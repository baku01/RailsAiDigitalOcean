<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>concurrent-ruby@1.3.5.rbi - RDoc Documentation</title>

  <meta name="keywords" content="ruby,documentation,concurrent-ruby@1.3.5.rbi">
  <meta name="description" content="concurrent-ruby@1.3.5.rbi: true # DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the `concurrent-ruby` gem. tapioca gem concurrent-ruby`.">


<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../Dockerfile.html">Dockerfile</a>
    <li><a href="../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../README_md.html">README</a>
    <li><a href="../../../Rakefile.html">Rakefile</a>
    <li><details><summary>app</summary>
    <ul class="link-list">
      <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
      <li><a href="../../../app/views/pwa/service-worker_js.html">service-worker.js</a>
    </ul></details>
    <li><a href="../../../bin/docker-entrypoint.html">docker-entrypoint</a>
    <li><a href="../../../config_ru.html">config.ru</a>
    <li><details><summary>config</summary>
    <ul class="link-list">
      <li><a href="../../../config/credentials_yml_enc.html">credentials.yml.enc</a>
      <li><a href="../../../config/master_key.html">master.key</a>
    </ul></details>
    <li><details><summary>log</summary>
    <ul class="link-list">
      <li><a href="../../../log/development_log.html">development.log</a>
      <li><a href="../../../log/test_log.html">test.log</a>
    </ul></details>
    <li><details><summary>public</summary>
    <ul class="link-list">
      <li><a href="../../../public/400_html.html">400.html</a>
      <li><a href="../../../public/404_html.html">404.html</a>
      <li><a href="../../../public/406-unsupported-browser_html.html">406-unsupported-browser.html</a>
      <li><a href="../../../public/422_html.html">422.html</a>
      <li><a href="../../../public/500_html.html">500.html</a>
      <li><a href="../../../public/robots_txt.html">robots</a>
    </ul></details>
    <li><details open><summary>sorbet</summary>
    <ul class="link-list">
      <li><a href="../../../sorbet/config.html">config</a>
      <li><a href="../../../sorbet/rbi/annotations/actionmailer_rbi.html">actionmailer.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionpack_rbi.html">actionpack.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionview_rbi.html">actionview.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activejob_rbi.html">activejob.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activemodel_rbi.html">activemodel.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activerecord_rbi.html">activerecord.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activesupport_rbi.html">activesupport.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/globalid_rbi.html">globalid.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/minitest_rbi.html">minitest.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/railties_rbi.html">railties.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/rainbow_rbi.html">rainbow.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching/fragments_rbi.html">fragments.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/conditional_get_rbi.html">conditional_get.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/content_security_policy_rbi.html">content_security_policy.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/data_streaming_rbi.html">data_streaming.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_flash_rbi.html">etag_with_flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_template_digest_rbi.html">etag_with_template_digest.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/flash_rbi.html">flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/form_builder_rbi.html">form_builder.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/params_wrapper_rbi.html">params_wrapper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/redirecting_rbi.html">redirecting.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers_rbi.html">renderers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers/all_rbi.html">all.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/request_forgery_protection_rbi.html">request_forgery_protection.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/rescue_rbi.html">rescue.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/test_case/behavior_rbi.html">behavior.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/assertions_rbi.html">assertions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/integration_test_rbi.html">integration_test.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/route_set/mounted_helpers_rbi.html">mounted_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_helper_rbi.html">form_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_tag_helper_rbi.html">form_tag_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/text_helper_rbi.html">text_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/layouts_rbi.html">layouts.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/enqueuing_rbi.html">enqueuing.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/exceptions_rbi.html">exceptions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/execution_rbi.html">execution.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/logging_rbi.html">logging.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_adapter_rbi.html">queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_name_rbi.html">queue_name.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_priority_rbi.html">queue_priority.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/test_helper/test_queue_adapter_rbi.html">test_queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attribute_methods_rbi.html">attribute_methods.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attributes_rbi.html">attributes.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/serializers/json_rbi.html">json.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations_rbi.html">validations.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/actionable_error_rbi.html">actionable_error.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/rescuable_rbi.html">rescuable.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/testing/file_fixtures_rbi.html">file_fixtures.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/application_controller_rbi.html">application_controller.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/base_generator_rbi.html">base_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/form_generator_rbi.html">form_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_path_helpers_module_rbi.html">generated_path_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_rbi.html">generated_url_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_module_rbi.html">generated_url_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/policy_generator_rbi.html">policy_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/poro_generator_rbi.html">poro_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/service_generator_rbi.html">service_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/time_rbi.html">time.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/action_broadcast_job_rbi.html">action_broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_job_rbi.html">broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_stream_job_rbi.html">broadcast_stream_job.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actioncable@8_0_2_rbi.html">actioncable@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailbox@8_0_2_rbi.html">actionmailbox@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailer@8_0_2_rbi.html">actionmailer@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionpack@8_0_2_rbi.html">actionpack@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actiontext@8_0_2_rbi.html">actiontext@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionview@8_0_2_rbi.html">actionview@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activejob@8_0_2_rbi.html">activejob@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activemodel@8_0_2_rbi.html">activemodel@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activerecord@8_0_2_rbi.html">activerecord@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activestorage@8_0_2_rbi.html">activestorage@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activesupport@8_0_2_rbi.html">activesupport@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ast@2_4_3_rbi.html">ast@2.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/backport@1_2_0_rbi.html">backport@1.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/base64@0_3_0_rbi.html">base64@0.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bcrypt_pbkdf@1_1_1_rbi.html">bcrypt_pbkdf@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/benchmark@0_4_1_rbi.html">benchmark@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bigdecimal@3_2_2_rbi.html">bigdecimal@3.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bindex@0_8_1_rbi.html">bindex@0.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/brakeman@7_0_2_rbi.html">brakeman@7.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/commander@5_0_0_rbi.html">commander@5.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/concurrent-ruby@1_3_5_rbi.html">concurrent-ruby@1.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/connection_pool@2_5_3_rbi.html">connection_pool@2.5.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/crass@1_0_6_rbi.html">crass@1.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/csv@3_3_5_rbi.html">csv@3.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/date@3_4_1_rbi.html">date@3.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/diff-lcs@1_6_2_rbi.html">diff-lcs@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/dotenv@3_1_8_rbi.html">dotenv@3.1.8.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/drb@2_2_3_rbi.html">drb@2.2.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/e2mmap@0_1_0_rbi.html">e2mmap@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ed25519@1_4_0_rbi.html">ed25519@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erb@5_0_1_rbi.html">erb@5.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erubi@1_13_1_rbi.html">erubi@1.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/globalid@1_2_1_rbi.html">globalid@1.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/highline@3_0_1_rbi.html">highline@3.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/httparty@0_23_1_rbi.html">httparty@0.23.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/i18n@1_14_7_rbi.html">i18n@1.14.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/importmap-rails@2_1_0_rbi.html">importmap-rails@2.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/io-console@0_8_0_rbi.html">io-console@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/jaro_winkler@1_6_1_rbi.html">jaro_winkler@1.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/json@2_12_2_rbi.html">json@2.12.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kamal@2_7_0_rbi.html">kamal@2.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown-parser-gfm@1_1_0_rbi.html">kramdown-parser-gfm@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown@2_5_1_rbi.html">kramdown@2.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/language_server-protocol@3_17_0_5_rbi.html">language_server-protocol@3.17.0.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/lint_roller@1_1_0_rbi.html">lint_roller@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/logger@1_7_0_rbi.html">logger@1.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/loofah@2_24_1_rbi.html">loofah@2.24.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mail@2_8_1_rbi.html">mail@2.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/marcel@1_0_4_rbi.html">marcel@1.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/method_source@1_1_0_rbi.html">method_source@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mini_mime@1_1_5_rbi.html">mini_mime@1.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/minitest@5_25_5_rbi.html">minitest@5.25.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/multi_xml@0_7_2_rbi.html">multi_xml@0.7.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-imap@0_5_9_rbi.html">net-imap@0.5.9.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-pop@0_1_2_rbi.html">net-pop@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-protocol@0_2_2_rbi.html">net-protocol@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-scp@4_1_0_rbi.html">net-scp@4.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-sftp@4_0_0_rbi.html">net-sftp@4.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-smtp@0_5_1_rbi.html">net-smtp@0.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-ssh@7_3_0_rbi.html">net-ssh@7.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/netrc@0_11_0_rbi.html">netrc@0.11.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/nio4r@2_7_4_rbi.html">nio4r@2.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/observer@0_1_2_rbi.html">observer@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ostruct@0_6_2_rbi.html">ostruct@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parallel@1_27_0_rbi.html">parallel@1.27.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parlour@9_1_2_rbi.html">parlour@9.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parser@3_3_8_0_rbi.html">parser@3.3.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pattern_generator@0_1_0_rbi.html">pattern_generator@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/polyfill@1_9_0_rbi.html">polyfill@1.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pp@0_6_2_rbi.html">pp@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prettyprint@0_2_0_rbi.html">prettyprint@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prism@1_4_0_rbi.html">prism@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/propshaft@1_1_0_rbi.html">propshaft@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/psych@5_2_6_rbi.html">psych@5.2.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/puma@6_6_0_rbi.html">puma@6.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/racc@1_8_1_rbi.html">racc@1.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-session@2_1_1_rbi.html">rack-session@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-test@2_2_0_rbi.html">rack-test@2.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack@3_1_16_rbi.html">rack@3.1.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rackup@2_2_1_rbi.html">rackup@2.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-dom-testing@2_3_0_rbi.html">rails-dom-testing@2.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-html-sanitizer@1_6_2_rbi.html">rails-html-sanitizer@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails@8_0_2_rbi.html">rails@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/railties@8_0_2_rbi.html">railties@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rainbow@3_1_1_rbi.html">rainbow@3.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rake@13_3_0_rbi.html">rake@13.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbi@0_3_6_rbi.html">rbi@0.3.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbs@4_0_0_dev_4_rbi.html">rbs@4.0.0.dev.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rdoc@6_14_2_rbi.html">rdoc@6.14.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/redcarpet@3_6_1_rbi.html">redcarpet@3.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/regexp_parser@2_10_0_rbi.html">regexp_parser@2.10.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reline@0_6_1_rbi.html">reline@0.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/require-hooks@0_2_2_rbi.html">require-hooks@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reverse_markdown@2_1_1_rbi.html">reverse_markdown@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-core@3_13_5_rbi.html">rspec-core@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-expectations@3_13_5_rbi.html">rspec-expectations@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-mocks@3_13_5_rbi.html">rspec-mocks@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-rails@8_0_1_rbi.html">rspec-rails@8.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-support@3_13_4_rbi.html">rspec-support@3.13.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec@3_13_1_rbi.html">rspec@3.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-ast@1_45_1_rbi.html">rubocop-ast@1.45.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-performance@1_25_0_rbi.html">rubocop-performance@1.25.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails-omakase@1_1_0_rbi.html">rubocop-rails-omakase@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails@2_32_0_rbi.html">rubocop-rails@2.32.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop@1_78_0_rbi.html">rubocop@1.78.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp-rails@0_4_6_rbi.html">ruby-lsp-rails@0.4.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp@0_24_2_rbi.html">ruby-lsp@0.24.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-progressbar@1_13_0_rbi.html">ruby-progressbar@1.13.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/safe_type@1_1_1_rbi.html">safe_type@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/securerandom@0_4_1_rbi.html">securerandom@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph-rails@1_1_2_rbi.html">solargraph-rails@1.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph@0_48_0_rbi.html">solargraph@0.48.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-coerce@0_7_0_rbi.html">sorbet-coerce@0.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-rails@0_7_34_rbi.html">sorbet-rails@0.7.34.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-runtime-stub@0_2_0_rbi.html">sorbet-runtime-stub@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/spoom@1_7_4_rbi.html">spoom@1.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sshkit@1_24_0_rbi.html">sshkit@1.24.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stimulus-rails@1_3_4_rbi.html">stimulus-rails@1.3.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stringio@3_1_7_rbi.html">stringio@3.1.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tapioca@0_17_6_rbi.html">tapioca@0.17.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thor@1_3_2_rbi.html">thor@1.3.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thruster@0_1_14_rbi.html">thruster@0.1.14.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tilt@2_6_1_rbi.html">tilt@2.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/timeout@0_4_3_rbi.html">timeout@0.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/turbo-rails@2_0_16_rbi.html">turbo-rails@2.0.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tzinfo@2_0_6_rbi.html">tzinfo@2.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-display_width@3_1_4_rbi.html">unicode-display_width@3.1.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-emoji@4_0_4_rbi.html">unicode-emoji@4.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/uri@1_0_3_rbi.html">uri@1.0.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/useragent@0_16_11_rbi.html">useragent@0.16.11.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/web-console@4_2_1_rbi.html">web-console@4.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-driver@0_8_0_rbi.html">websocket-driver@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-extensions@0_1_5_rbi.html">websocket-extensions@0.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-kramdown@0_0_1_rbi.html">yard-kramdown@0.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-solargraph@0_1_0_rbi.html">yard-solargraph@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-sorbet@0_9_0_rbi.html">yard-sorbet@0.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard@0_9_37_rbi.html">yard@0.9.37.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/zeitwerk@2_7_3_rbi.html">zeitwerk@2.7.3.rbi</a>
      <li><a href="../../../sorbet/rbi/todo_rbi.html">todo.rbi</a>
    </ul></details>
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  </ul>
</div>


  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-label="Page sorbet/rbi/gems/concurrent-ruby@1.3.5.rbi">

<p># typed: true</p>

<p># DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the ‘concurrent-ruby` gem. # Please instead update this file by running `bin/tapioca gem concurrent-ruby`.</p>

<p># {include:file:README.md} # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#1 module Concurrent</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Utility</span><span class="ruby-operator">::</span><span class="ruby-constant">EngineDetector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Utility</span><span class="ruby-operator">::</span><span class="ruby-constant">NativeExtensionLoader</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Deprecation</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Abort a currently running transaction - see `Concurrent::atomically`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Transaction::AbortError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">abort_transaction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Run a block that reads and writes `TVar`s as a single atomic transaction.</span>
<span class="ruby-comment"># With respect to the value of `TVar` objects, the transaction is atomic, in</span>
<span class="ruby-comment"># that it either happens or it does not, consistent, in that the `TVar`</span>
<span class="ruby-comment"># objects involved will never enter an illegal state, and isolated, in that</span>
<span class="ruby-comment"># transactions never interfere with each other. You may recognise these</span>
<span class="ruby-comment"># properties from database transactions.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># There are some very important and unusual semantics that you must be aware of:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * Most importantly, the block that you pass to atomically may be executed</span>
<span class="ruby-comment">#     more than once. In most cases your code should be free of</span>
<span class="ruby-comment">#     side-effects, except for via TVar.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * If an exception escapes an atomically block it will abort the transaction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * It is undefined behaviour to use callcc or Fiber with atomically.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * If you create a new thread within an atomically, it will not be part of</span>
<span class="ruby-comment">#     the transaction. Creating a thread counts as a side-effect.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Transactions within transactions are flattened to a single transaction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   a = new TVar(100_000)</span>
<span class="ruby-comment">#   b = new TVar(100)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   Concurrent::atomically do</span>
<span class="ruby-comment">#   a.value -= 10</span>
<span class="ruby-comment">#   b.value += 10</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">atomically</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_dataflow</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dataflow allows you to create a task that will be scheduled when all of its data dependencies are available.</span>
<span class="ruby-comment"># {include:file:docs-source/dataflow.md}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param inputs [Future] zero or more `Future` operations that this dataflow depends upon</span>
<span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
<span class="ruby-comment"># @raise [ArgumentError] if any of the inputs are not `IVar`s</span>
<span class="ruby-comment"># @return [Object] the result of all the operations</span>
<span class="ruby-comment"># @yield The operation to perform once all the dependencies are met</span>
<span class="ruby-comment"># @yieldparam inputs [Future] each of the `Future` inputs to the dataflow</span>
<span class="ruby-comment"># @yieldreturn [Object] the result of the block operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow_with</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow_with!</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Leave a transaction without committing or aborting - see `Concurrent::atomically`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Transaction::LeaveError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leave_transaction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the current time as tracked by the application monotonic clock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param unit [Symbol] the time unit to be returned, can be either</span>
<span class="ruby-comment">#   :float_second, :float_millisecond, :float_microsecond, :second,</span>
<span class="ruby-comment">#   :millisecond, :microsecond, or :nanosecond default to :float_second.</span>
<span class="ruby-comment"># @return [Float] The current monotonic time since some unspecified</span>
<span class="ruby-comment">#   starting point</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/monotonic_time.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">monotonic_time</span>(<span class="ruby-identifier">unit</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Abort a currently running transaction - see `Concurrent::atomically`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @raise [Transaction::AbortError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#148</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">abort_transaction</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Run a block that reads and writes `TVar`s as a single atomic transaction.</span>
  <span class="ruby-comment"># With respect to the value of `TVar` objects, the transaction is atomic, in</span>
  <span class="ruby-comment"># that it either happens or it does not, consistent, in that the `TVar`</span>
  <span class="ruby-comment"># objects involved will never enter an illegal state, and isolated, in that</span>
  <span class="ruby-comment"># transactions never interfere with each other. You may recognise these</span>
  <span class="ruby-comment"># properties from database transactions.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># There are some very important and unusual semantics that you must be aware of:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Most importantly, the block that you pass to atomically may be executed</span>
  <span class="ruby-comment">#     more than once. In most cases your code should be free of</span>
  <span class="ruby-comment">#     side-effects, except for via TVar.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * If an exception escapes an atomically block it will abort the transaction.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * It is undefined behaviour to use callcc or Fiber with atomically.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * If you create a new thread within an atomically, it will not be part of</span>
  <span class="ruby-comment">#     the transaction. Creating a thread counts as a side-effect.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Transactions within transactions are flattened to a single transaction.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example</span>
  <span class="ruby-comment">#   a = new TVar(100_000)</span>
  <span class="ruby-comment">#   b = new TVar(100)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   Concurrent::atomically do</span>
  <span class="ruby-comment">#   a.value -= 10</span>
  <span class="ruby-comment">#   b.value += 10</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment"># @raise [ArgumentError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#148</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">atomically</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Number of processors cores available for process scheduling.</span>
  <span class="ruby-comment"># This method takes in account the CPU quota if the process is inside a cgroup with a</span>
  <span class="ruby-comment"># dedicated CPU quota (typically Docker).</span>
  <span class="ruby-comment"># Otherwise it returns the same value as #processor_count but as a Float.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># For performance reasons the calculated value will be memoized on the first</span>
  <span class="ruby-comment"># call.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Float] number of available processors</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#194</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available_processor_count</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @raise [ArgumentError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#80</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_dataflow</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The maximum number of processors cores available for process scheduling.</span>
  <span class="ruby-comment"># Returns `nil` if there is no enforced limit, or a `Float` if the</span>
  <span class="ruby-comment"># process is inside a cgroup with a dedicated CPU quota (typically Docker).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Note that nothing prevents setting a CPU quota higher than the actual number of</span>
  <span class="ruby-comment"># cores on the system.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># For performance reasons the calculated value will be memoized on the first</span>
  <span class="ruby-comment"># call.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [nil, Float] Maximum number of available processors as set by a cgroup CPU quota, or nil if none set</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#209</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cpu_quota</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The CPU shares requested by the process. For performance reasons the calculated</span>
  <span class="ruby-comment"># value will be memoized on the first call.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Float, nil] CPU shares requested by the process, or nil if not set</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#217</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cpu_shares</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a simple logger with provided level and output.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#38</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_simple_logger</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">output</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a stdlib logger with provided level and output.</span>
  <span class="ruby-comment"># If you use this deprecated method you might need to add logger to your Gemfile to avoid warnings from Ruby 3.3.5+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @deprecated</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#73</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_stdlib_logger</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">output</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Dataflow allows you to create a task that will be scheduled when all of its data dependencies are available.</span>
  <span class="ruby-comment"># {include:file:docs-source/dataflow.md}</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param inputs [Future] zero or more `Future` operations that this dataflow depends upon</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @raise [ArgumentError] if any of the inputs are not `IVar`s</span>
  <span class="ruby-comment"># @return [Object] the result of all the operations</span>
  <span class="ruby-comment"># @yield The operation to perform once all the dependencies are met</span>
  <span class="ruby-comment"># @yieldparam inputs [Future] each of the `Future` inputs to the dataflow</span>
  <span class="ruby-comment"># @yieldreturn [Object] the result of the block operation</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow_with</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dataflow_with!</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">inputs</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Disables AtExit handlers including pool auto-termination handlers.</span>
  <span class="ruby-comment"># When disabled it will be the application programmer&#39;s responsibility</span>
  <span class="ruby-comment"># to ensure that the handlers are shutdown properly prior to application</span>
  <span class="ruby-comment"># exit by calling `AtExit.run` method.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @deprecated Has no effect since it is no longer needed, see https://github.com/ruby-concurrency/concurrent-ruby/pull/841.</span>
  <span class="ruby-comment"># @note this option should be needed only because of `at_exit` ordering</span>
  <span class="ruby-comment">#   issues which may arise when running some of the testing frameworks.</span>
  <span class="ruby-comment">#   E.g. Minitest&#39;s test-suite runs itself in `at_exit` callback which</span>
  <span class="ruby-comment">#   executes after the pools are already terminated. Then auto termination</span>
  <span class="ruby-comment">#   needs to be disabled and called manually after test-suite ends.</span>
  <span class="ruby-comment"># @note This method should *never* be called</span>
  <span class="ruby-comment">#   from within a gem. It should *only* be used from within the main</span>
  <span class="ruby-comment">#   application and even then it should be used only when necessary.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_at_exit_handlers!</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># General access point to global executors.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param executor_identifier [Symbol, Executor] symbols:</span>
  <span class="ruby-comment">#   - :fast - {Concurrent.global_fast_executor}</span>
  <span class="ruby-comment">#   - :io - {Concurrent.global_io_executor}</span>
  <span class="ruby-comment">#   - :immediate - {Concurrent.global_immediate_executor}</span>
  <span class="ruby-comment"># @return [Executor]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#83</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>(<span class="ruby-identifier">executor_identifier</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Global thread pool optimized for short, fast *operations*.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [ThreadPoolExecutor] the thread pool</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#55</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_fast_executor</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#66</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_immediate_executor</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Global thread pool optimized for long, blocking (IO) *tasks*.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [ThreadPoolExecutor] the thread pool</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_io_executor</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#114</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_logger</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#118</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_logger=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Global thread pool user for global *timers*.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Concurrent::TimerSet] the thread pool</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#73</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_timer_set</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Leave a transaction without committing or aborting - see `Concurrent::atomically`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @raise [Transaction::LeaveError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#148</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leave_transaction</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the current time as tracked by the application monotonic clock.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param unit [Symbol] the time unit to be returned, can be either</span>
  <span class="ruby-comment">#   :float_second, :float_millisecond, :float_microsecond, :second,</span>
  <span class="ruby-comment">#   :millisecond, :microsecond, or :nanosecond default to :float_second.</span>
  <span class="ruby-comment"># @return [Float] The current monotonic time since some unspecified</span>
  <span class="ruby-comment">#   starting point</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/monotonic_time.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">monotonic_time</span>(<span class="ruby-identifier">unit</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/lock_local_var.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mutex_owned_per_thread?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#87</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_fast_executor</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#98</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_io_executor</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Number of physical processor cores on the current system. For performance</span>
  <span class="ruby-comment"># reasons the calculated value will be memoized on the first call.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># On Windows the Win32 API will be queried for the `NumberOfCores from</span>
  <span class="ruby-comment"># Win32_Processor`. This will return the total number &quot;of cores for the</span>
  <span class="ruby-comment"># current instance of the processor.&quot; On Unix-like operating systems either</span>
  <span class="ruby-comment"># the `hwprefs` or `sysctl` utility will be called in a subshell and the</span>
  <span class="ruby-comment"># returned value will be used. In the rare case where none of these methods</span>
  <span class="ruby-comment"># work or an exception is raised the function will simply return 1.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Integer] number physical processor cores on the current system</span>
  <span class="ruby-comment"># @see https://github.com/grosser/parallel/blob/4fc8b89d08c7091fe0419ca8fba1ec3ce5a8d185/lib/parallel.rb</span>
  <span class="ruby-comment"># @see http://msdn.microsoft.com/en-us/library/aa394373(v=vs.85).aspx</span>
  <span class="ruby-comment"># @see http://www.unix.com/man-page/osx/1/HWPREFS/</span>
  <span class="ruby-comment"># @see http://linux.die.net/man/8/sysctl</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#181</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">physical_processor_count</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Number of processors seen by the OS and used for process scheduling. For</span>
  <span class="ruby-comment"># performance reasons the calculated value will be memoized on the first</span>
  <span class="ruby-comment"># call.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># When running under JRuby the Java runtime call</span>
  <span class="ruby-comment"># `java.lang.Runtime.getRuntime.availableProcessors` will be used. According</span>
  <span class="ruby-comment"># to the Java documentation this &quot;value may change during a particular</span>
  <span class="ruby-comment"># invocation of the virtual machine... [applications] should therefore</span>
  <span class="ruby-comment"># occasionally poll this property.&quot; We still memoize this value once under</span>
  <span class="ruby-comment"># JRuby.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Otherwise Ruby&#39;s Etc.nprocessors will be used.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Integer] number of processors seen by the OS or Java runtime</span>
  <span class="ruby-comment"># @see http://docs.oracle.com/javase/6/docs/api/java/lang/Runtime.html#availableProcessors()</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#160</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processor_count</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#142</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processor_counter</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Use logger created by #create_simple_logger to log concurrent-ruby messages.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#66</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_simple_logger</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">output</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Use logger created by #create_stdlib_logger to log concurrent-ruby messages.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @deprecated</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#101</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_stdlib_logger</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">output</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#38 class Concurrent::AbstractExchanger &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-comment"># @return [AbstractExchanger] a new instance of AbstractExchanger</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Waits for another thread to arrive at this exchange point (unless the</span>
<span class="ruby-comment"># current thread is interrupted), and then transfers the given object to</span>
<span class="ruby-comment"># it, receiving its object in return. The timeout value indicates the</span>
<span class="ruby-comment"># approximate number of seconds the method should block while waiting</span>
<span class="ruby-comment"># for the exchange. When the timeout value is `nil` the method will</span>
<span class="ruby-comment"># block indefinitely.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In some edge cases when a `timeout` is given a return value of `nil` may be</span>
<span class="ruby-comment"># ambiguous. Specifically, if `nil` is a valid value in the exchange it will</span>
<span class="ruby-comment"># be impossible to tell whether `nil` is the actual return value or if it</span>
<span class="ruby-comment"># signifies timeout. When `nil` is a valid value in the exchange consider</span>
<span class="ruby-comment"># using {#exchange!} or {#try_exchange} instead.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to exchange with another thread</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` blocks indefinitely</span>
<span class="ruby-comment"># @return [Object] the value exchanged by the other thread or `nil` on timeout</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exchange</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Waits for another thread to arrive at this exchange point (unless the</span>
<span class="ruby-comment"># current thread is interrupted), and then transfers the given object to</span>
<span class="ruby-comment"># it, receiving its object in return. The timeout value indicates the</span>
<span class="ruby-comment"># approximate number of seconds the method should block while waiting</span>
<span class="ruby-comment"># for the exchange. When the timeout value is `nil` the method will</span>
<span class="ruby-comment"># block indefinitely.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># On timeout a {Concurrent::TimeoutError} exception will be raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to exchange with another thread</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` blocks indefinitely</span>
<span class="ruby-comment"># @raise [Concurrent::TimeoutError] on timeout</span>
<span class="ruby-comment"># @return [Object] the value exchanged by the other thread</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exchange!</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Waits for another thread to arrive at this exchange point (unless the</span>
<span class="ruby-comment"># current thread is interrupted), and then transfers the given object to</span>
<span class="ruby-comment"># it, receiving its object in return. The timeout value indicates the</span>
<span class="ruby-comment"># approximate number of seconds the method should block while waiting</span>
<span class="ruby-comment"># for the exchange. When the timeout value is `nil` the method will</span>
<span class="ruby-comment"># block indefinitely.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The return value will be a {Concurrent::Maybe} set to `Just` on success or</span>
<span class="ruby-comment"># `Nothing` on timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   exchanger = Concurrent::Exchanger.new</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   result = exchanger.exchange(:foo, 0.5)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   if result.just?</span>
<span class="ruby-comment">#   puts result.value #=&gt; :bar</span>
<span class="ruby-comment">#   else</span>
<span class="ruby-comment">#   puts &#39;timeout&#39;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># @param value [Object] the value to exchange with another thread</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` blocks indefinitely</span>
<span class="ruby-comment"># @return [Concurrent::Maybe] on success a `Just` maybe will be returned with</span>
<span class="ruby-comment">#   the item exchanged by the other thread as `#value`; on timeout a</span>
<span class="ruby-comment">#   `Nothing` maybe will be returned with {Concurrent::TimeoutError} as `#reason`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_exchange</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Waits for another thread to arrive at this exchange point (unless the</span>
<span class="ruby-comment"># current thread is interrupted), and then transfers the given object to</span>
<span class="ruby-comment"># it, receiving its object in return. The timeout value indicates the</span>
<span class="ruby-comment"># approximate number of seconds the method should block while waiting</span>
<span class="ruby-comment"># for the exchange. When the timeout value is `nil` the method will</span>
<span class="ruby-comment"># block indefinitely.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to exchange with another thread</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` blocks indefinitely</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Object, CANCEL] the value exchanged by the other thread; {CANCEL} on timeout</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_exchange</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#41 Concurrent::AbstractExchanger::CANCEL = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#10 class Concurrent::AbstractExecutorService &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">ExecutorService</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Deprecation</span>

<span class="ruby-comment"># Create a new thread pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [AbstractExecutorService] a new instance of AbstractExecutorService</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">auto_terminate=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">auto_terminate?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute fallback_policy.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fallback_policy</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuttingdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_termination</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns an action which executes the `fallback_policy` once the queue</span>
<span class="ruby-comment"># size reaches `max_queue`. The reason for the indirection of an action</span>
<span class="ruby-comment"># is so that the work can be deferred outside of synchronization.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] the arguments to the task which is being handled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fallback_action</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_auto_terminate?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_execute</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Callback method called when the executor has been killed.</span>
<span class="ruby-comment"># The default behavior is to do nothing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_kill_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Callback method called when an orderly shutdown has completed.</span>
<span class="ruby-comment"># The default behavior is to signal all waiting threads.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown_execution</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The set of possible fallback policies that may be set at thread pool creation. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#15 Concurrent::AbstractExecutorService::FALLBACK_POLICIES = T.let(T.unsafe(nil), Array)</p>

<p># An abstract implementation of local storage, with sub-classes for # per-thread and per-fiber locals. # # Each execution context (EC, thread or fiber) has a lazily initialized array # of local variable values. Each time a new local variable is created, we # allocate an “index” for it. # # For example, if the allocated index is 1, that means slot #1 in EVERY EC’s # locals array will be used for the value of that variable. # # The good thing about using a per-EC structure to hold values, rather than # a global, is that no synchronization is needed when reading and writing # those values (since the structure is only ever accessed by a single # thread). # # Of course, when a local variable is GC’d, 1) we need to recover its index # for use by other new local variables (otherwise the locals arrays could # get bigger and bigger with time), and 2) we need to null out all the # references held in the now-unused slots (both to avoid blocking GC of those # objects, and also to prevent “stale” values from being passed on to a new # local when the index is reused). # # Because we need to null out freed slots, we need to keep references to # ALL the locals arrays, so we can null out the appropriate slots in all of # them. This is why we need to use a finalizer to clean up the locals array # when the EC goes out of scope. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#35 class Concurrent::AbstractLocals</p>

<pre class="ruby"><span class="ruby-comment"># @return [AbstractLocals] a new instance of AbstractLocals</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch</span>(<span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">free_index</span>(<span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_index</span>(<span class="ruby-identifier">local</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">index</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">weak_synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># When the local goes out of scope, clean up that slot across all locals currently assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_finalizer</span>(<span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the locals for the current scope, or nil if none exist.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the locals for the current scope, creating them if necessary.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When a thread/fiber goes out of scope, remove the array from @all_arrays.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">thread_fiber_finalizer</span>(<span class="ruby-identifier">array_object_id</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># ‘Agent` is inspired by Clojure’s [agent](<a href="http://clojure.org/agents">clojure.org/agents</a>) # function. An agent is a shared, mutable variable providing independent, # uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when # the value will undergo frequent, complex updates. Suitable when the result # of an update does not need to be known immediately. ‘Agent` is (mostly) # functionally equivalent to Clojure’s agent, except where the runtime # prevents parity. # # Agents are reactive, not autonomous - there is no imperative message loop # and no blocking receive. The state of an Agent should be itself immutable # and the ‘#value` of an Agent is always immediately available for reading by # any thread without any messages, i.e. observation does not require # cooperation or coordination. # # Agent action dispatches are made using the various `#send` methods. These # methods always return immediately. At some point later, in another thread, # the following will happen: # # 1. The given `action` will be applied to the state of the Agent and the #    `args`, if any were supplied. # 2. The return value of `action` will be passed to the validator lambda, #    if one has been set on the Agent. # 3. If the validator succeeds or if no validator was given, the return value #    of the given `action` will become the new `#value` of the Agent. See #    `#initialize` for details. # 4. If any observers were added to the Agent, they will be notified. See #    `#add_observer` for details. # 5. If during the `action` execution any other dispatches are made (directly #    or indirectly), they will be held until after the `#value` of the Agent #    has been changed. # # If any exceptions are thrown by an action function, no nested dispatches # will occur, and the exception will be cached in the Agent itself. When an # Agent has errors cached, any subsequent interactions will immediately throw # an exception, until the agent’s errors are cleared. Agent errors can be # examined with ‘#error` and the agent restarted with `#restart`. # # The actions of all Agents get interleaved amongst threads in a thread pool. # At any point in time, at most one action for each Agent is being executed. # Actions dispatched to an agent from another single agent or thread will # occur in the order they were sent, potentially interleaved with actions # dispatched to the same agent from other sources. The `#send` method should # be used for actions that are CPU limited, while the `#send_off` method is # appropriate for actions that may block on IO. # # Unlike in Clojure, `Agent` cannot participate in `Concurrent::TVar` transactions. # # ## Example # # “` # def next_fibonacci(set = nil) #   return [0, 1] if set.nil? #   set + [<a href="-2..-1">set</a>.reduce{|sum,x| sum + x }] # end # # # create an agent with an initial value # agent = Concurrent::Agent.new(next_fibonacci) # # # send a few update requests # 5.times do #   agent.send{|set| next_fibonacci(set) } # end # # # wait for them to complete # agent.await # # # get the current value # agent.value #=&gt; [0, 1, 1, 2, 3, 5, 8] # “` # # ## Observation # # Agents support observers through the {Concurrent::Observable} mixin module. # Notification of observers occurs every time an action dispatch returns and # the new value is successfully validated. Observation will <strong>not</strong> occur if the # action raises an exception, if validation fails, or when a {#restart} occurs. # # When notified the observer will receive three arguments: `time`, `old_value`, # and `new_value`. The `time` argument is the time at which the value change # occurred. The `old_value` is the value of the Agent when the action began # processing. The `new_value` is the value to which the Agent was set when the # action completed. Note that `old_value` and `new_value` may be the same. # This is not an error. It simply means that the action returned the same # value. # # ## Nested Actions # # It is possible for an Agent action to post further actions back to itself. # The nested actions will be enqueued normally then processed <strong>after</strong> the # outer action completes, in the order they were sent, possibly interleaved # with action dispatches from other threads. Nested actions never deadlock # with one another and a failure in a nested action will never affect the # outer action. # # Nested actions can be called using the Agent reference from the enclosing # scope or by passing the reference in as a “send” argument. Nested actions # cannot be post using `self` from within the action block/proc/lambda; `self` # in this context will not reference the Agent. The preferred method for # dispatching nested actions is to pass the Agent as an argument. This allows # Ruby to more effectively manage the closing scope. # # Prefer this: # # “` # agent = Concurrent::Agent.new(0) # agent.send(agent) do |value, this| #   this.send {|v| v + 42 } #   3.14 # end # agent.value #=&gt; 45.14 # “` # # Over this: # # “` # agent = Concurrent::Agent.new(0) # agent.send do |value| #   agent.send {|v| v + 42 } #   3.14 # end # “` # # # <strong>NOTE</strong> Never, *under any circumstances*, call any of the “await” methods # ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action # block/proc/lambda. The call will block the Agent and will always fail. # Calling either {#await} or {#wait} (with a timeout of `nil`) will # hopelessly deadlock the Agent with no possibility of recovery. # # @see <a href="http://clojure.org/Agents">clojure.org/Agents</a> Clojure Agents # @see <a href="http://clojure.org/state">clojure.org/state</a> Values and Change - Clojure’s approach to Identity and State # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#145 class Concurrent::Agent &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Observable</span>

<span class="ruby-comment"># Create a new `Agent` with the given initial value and options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The `:validator` option must be `nil` or a side-effect free proc/lambda</span>
<span class="ruby-comment"># which takes one argument. On any intended value change the validator, if</span>
<span class="ruby-comment"># provided, will be called. If the new value is invalid the validator should</span>
<span class="ruby-comment"># return `false` or raise an error.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The `:error_handler` option must be `nil` or a proc/lambda which takes two</span>
<span class="ruby-comment"># arguments. When an action raises an error or validation fails, either by</span>
<span class="ruby-comment"># returning false or raising an error, the error handler will be called. The</span>
<span class="ruby-comment"># arguments to the error handler will be a reference to the agent itself and</span>
<span class="ruby-comment"># the error object which was raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The `:error_mode` may be either `:continue` (the default if an error</span>
<span class="ruby-comment"># handler is given) or `:fail` (the default if error handler nil or not</span>
<span class="ruby-comment"># given).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If an action being run by the agent throws an error or doesn&#39;t pass</span>
<span class="ruby-comment"># validation the error handler, if present, will be called. After the</span>
<span class="ruby-comment"># handler executes if the error mode is `:continue` the Agent will continue</span>
<span class="ruby-comment"># as if neither the action that caused the error nor the error itself ever</span>
<span class="ruby-comment"># happened.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the mode is `:fail` the Agent will become {#failed?} and will stop</span>
<span class="ruby-comment"># accepting new action dispatches. Any previously queued actions will be</span>
<span class="ruby-comment"># held until {#restart} is called. The {#value} method will still work,</span>
<span class="ruby-comment"># returning the value of the Agent before the error.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param initial [Object] the initial value</span>
<span class="ruby-comment"># @param opts [Hash] the configuration options</span>
<span class="ruby-comment"># @return [Agent] a new instance of Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">initial</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Appropriate for actions that may block on IO.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @return [Concurrent::Agent] self</span>
<span class="ruby-comment"># @see #send_off</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks the current thread (indefinitely!) until all actions dispatched</span>
<span class="ruby-comment"># thus far, from this thread or nested by the Agent, have occurred. Will</span>
<span class="ruby-comment"># block when {#failed?}. Will never return if a failed Agent is {#restart}</span>
<span class="ruby-comment"># with `:clear_actions` true.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a reference to `self` to support method chaining:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment"># current_value = agent.await.value</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
<span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
<span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
<span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
<span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks the current thread until all actions dispatched thus far, from this</span>
<span class="ruby-comment"># thread or nested by the Agent, have occurred, or the timeout (in seconds)</span>
<span class="ruby-comment"># has elapsed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
<span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
<span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
<span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
<span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Float] the maximum number of seconds to wait</span>
<span class="ruby-comment"># @return [Boolean] true if all actions complete before timeout else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await_for</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks the current thread until all actions dispatched thus far, from this</span>
<span class="ruby-comment"># thread or nested by the Agent, have occurred, or the timeout (in seconds)</span>
<span class="ruby-comment"># has elapsed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
<span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
<span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
<span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
<span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Float] the maximum number of seconds to wait</span>
<span class="ruby-comment"># @raise [Concurrent::TimeoutError] when timeout is reached</span>
<span class="ruby-comment"># @return [Boolean] true if all actions complete before timeout</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await_for!</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value (state) of the Agent, irrespective of any pending or</span>
<span class="ruby-comment"># in-progress actions. The value is always available and is non-blocking.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deref</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When {#failed?} and {#error_mode} is `:fail`, returns the error object</span>
<span class="ruby-comment"># which caused the failure, else `nil`. When {#error_mode} is `:continue`</span>
<span class="ruby-comment"># will *always* return `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [nil, Error] the error which caused the failure when {#failed?}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">error</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The error mode this Agent is operating in. See {#initialize} for details.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">error_mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the Agent in a failed state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment"># @see #restart</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#402</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">failed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued, false if</span>
<span class="ruby-comment">#   the Agent is {#failed?}</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#298</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When {#failed?} and {#error_mode} is `:fail`, returns the error object</span>
<span class="ruby-comment"># which caused the failure, else `nil`. When {#error_mode} is `:continue`</span>
<span class="ruby-comment"># will *always* return `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [nil, Error] the error which caused the failure when {#failed?}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When an Agent is {#failed?}, changes the Agent {#value} to `new_value`</span>
<span class="ruby-comment"># then un-fails the Agent so that action dispatches are allowed again. If</span>
<span class="ruby-comment"># the `:clear_actions` option is give and true, any actions queued on the</span>
<span class="ruby-comment"># Agent that were being held while it was failed will be discarded,</span>
<span class="ruby-comment"># otherwise those held actions will proceed. The `new_value` must pass the</span>
<span class="ruby-comment"># validator if any, or `restart` will raise an exception and the Agent will</span>
<span class="ruby-comment"># remain failed with its old {#value} and {#error}. Observers, if any, will</span>
<span class="ruby-comment"># not be notified of the new state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param new_value [Object] the new value for the Agent once restarted</span>
<span class="ruby-comment"># @param opts [Hash] the configuration options</span>
<span class="ruby-comment"># @raise [Concurrent:AgentError] when not failed</span>
<span class="ruby-comment"># @return [Boolean] true</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restart</span>(<span class="ruby-identifier">new_value</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued, false if</span>
<span class="ruby-comment">#   the Agent is {#failed?}</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @raise [Concurrent::Agent::Error] if the Agent is {#failed?}</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued, false if</span>
<span class="ruby-comment">#   the Agent is {#failed?}</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#294</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_off</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @raise [Concurrent::Agent::Error] if the Agent is {#failed?}</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_off!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @param executor [Concurrent::ExecutorService] the executor on which the</span>
<span class="ruby-comment">#   action is to be dispatched</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued, false if</span>
<span class="ruby-comment">#   the Agent is {#failed?}</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#311</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_via</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dispatches an action to the Agent and returns immediately. Subsequently,</span>
<span class="ruby-comment"># in a thread from a thread pool, the {#value} will be set to the return</span>
<span class="ruby-comment"># value of the action. Action dispatches are only allowed when the Agent</span>
<span class="ruby-comment"># is not {#failed?}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The action must be a block/proc/lambda which takes 1 or more arguments.</span>
<span class="ruby-comment"># The first argument is the current {#value} of the Agent. Any arguments</span>
<span class="ruby-comment"># passed to the send method via the `args` parameter will be passed to the</span>
<span class="ruby-comment"># action as the remaining arguments. The action must return the new value</span>
<span class="ruby-comment"># of the Agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * {#send} and {#send!} should be used for actions that are CPU limited</span>
<span class="ruby-comment"># * {#send_off}, {#send_off!}, and {#&lt;&lt;} are appropriate for actions that</span>
<span class="ruby-comment">#   may block on IO</span>
<span class="ruby-comment"># * {#send_via} and {#send_via!} are used when a specific executor is to</span>
<span class="ruby-comment">#   be used for the action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] zero or more arguments to be passed to</span>
<span class="ruby-comment">#   the action</span>
<span class="ruby-comment"># @param action [Proc] the action dispatch to be enqueued</span>
<span class="ruby-comment"># @param executor [Concurrent::ExecutorService] the executor on which the</span>
<span class="ruby-comment">#   action is to be dispatched</span>
<span class="ruby-comment"># @raise [Concurrent::Agent::Error] if the Agent is {#failed?}</span>
<span class="ruby-comment"># @return [Boolean] true if the action is successfully enqueued</span>
<span class="ruby-comment"># @yield [agent, value, *args] process the old value and return the new</span>
<span class="ruby-comment"># @yieldparam value [Object] the current {#value} of the Agent</span>
<span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] zero or more arguments to pass to the</span>
<span class="ruby-comment">#   action</span>
<span class="ruby-comment"># @yieldreturn [Object] the new value of the Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_via!</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">action</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the Agent in a failed state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment"># @see #restart</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stopped?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value (state) of the Agent, irrespective of any pending or</span>
<span class="ruby-comment"># in-progress actions. The value is always available and is non-blocking.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks the current thread until all actions dispatched thus far, from this</span>
<span class="ruby-comment"># thread or nested by the Agent, have occurred, or the timeout (in seconds)</span>
<span class="ruby-comment"># has elapsed. Will block indefinitely when timeout is nil or not given.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Provided mainly for consistency with other classes in this library. Prefer</span>
<span class="ruby-comment"># the various `await` methods instead.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
<span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
<span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
<span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
<span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Float] the maximum number of seconds to wait</span>
<span class="ruby-comment"># @return [Boolean] true if all actions complete before timeout else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#393</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#510</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue_action_job</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#516</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue_await_job</span>(<span class="ruby-identifier">latch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#543</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_next_job</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#576</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_error</span>(<span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#529</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_enqueue_job</span>(<span class="ruby-identifier">job</span>, <span class="ruby-identifier">index</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#584</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_find_last_job_for_thread</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#490</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">initial</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#539</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_post_next_job</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#570</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_validate</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Blocks the current thread (indefinitely!) until all actions dispatched</span>
  <span class="ruby-comment"># thus far to all the given Agents, from this thread or nested by the</span>
  <span class="ruby-comment"># given Agents, have occurred. Will block when any of the agents are</span>
  <span class="ruby-comment"># failed. Will never return if a failed Agent is restart with</span>
  <span class="ruby-comment"># `:clear_actions` true.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
  <span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
  <span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
  <span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
  <span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param agents [Array&lt;Concurrent::Agent&gt;] the Agents on which to wait</span>
  <span class="ruby-comment"># @return [Boolean] true</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#449</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Blocks the current thread until all actions dispatched thus far to all</span>
  <span class="ruby-comment"># the given Agents, from this thread or nested by the given Agents, have</span>
  <span class="ruby-comment"># occurred, or the timeout (in seconds) has elapsed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
  <span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
  <span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
  <span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
  <span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param timeout [Float] the maximum number of seconds to wait</span>
  <span class="ruby-comment"># @param agents [Array&lt;Concurrent::Agent&gt;] the Agents on which to wait</span>
  <span class="ruby-comment"># @return [Boolean] true if all actions complete before timeout else false</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#463</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await_for</span>(<span class="ruby-identifier">timeout</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Blocks the current thread until all actions dispatched thus far to all</span>
  <span class="ruby-comment"># the given Agents, from this thread or nested by the given Agents, have</span>
  <span class="ruby-comment"># occurred, or the timeout (in seconds) has elapsed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># **NOTE** Never, *under any circumstances*, call any of the &quot;await&quot; methods</span>
  <span class="ruby-comment"># ({#await}, {#await_for}, {#await_for!}, and {#wait}) from within an action</span>
  <span class="ruby-comment"># block/proc/lambda. The call will block the Agent and will always fail.</span>
  <span class="ruby-comment"># Calling either {#await} or {#wait} (with a timeout of `nil`) will</span>
  <span class="ruby-comment"># hopelessly deadlock the Agent with no possibility of recovery.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param timeout [Float] the maximum number of seconds to wait</span>
  <span class="ruby-comment"># @param agents [Array&lt;Concurrent::Agent&gt;] the Agents on which to wait</span>
  <span class="ruby-comment"># @raise [Concurrent::TimeoutError] when timeout is reached</span>
  <span class="ruby-comment"># @return [Boolean] true if all actions complete before timeout</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#482</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await_for!</span>(<span class="ruby-identifier">timeout</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">agents</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#154 Concurrent::Agent::AWAIT_ACTION = T.let(T.unsafe(nil), Proc)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#151 Concurrent::Agent::AWAIT_FLAG = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#157 Concurrent::Agent::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#160 Concurrent::Agent::DEFAULT_VALIDATOR = T.let(T.unsafe(nil), Proc)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#148 Concurrent::Agent::ERROR_MODES = T.let(T.unsafe(nil), Array)</p>

<p># Raised during action processing or any other time in an Agent’s lifecycle. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#167 class Concurrent::Agent::Error &lt; ::StandardError</p>

<pre class="ruby"><span class="ruby-comment"># @return [Error] a new instance of Error</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163 class Concurrent::Agent::Job &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">action</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute action</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute action to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">action=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute args to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute caller</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of caller</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">caller</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute caller</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute caller to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">caller=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute executor to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when a new value obtained during action processing or at ‘#restart` # fails validation. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#176 class Concurrent::Agent::ValidationError &lt; ::Concurrent::Agent::Error</p>

<pre class="ruby"><span class="ruby-comment"># @return [ValidationError] a new instance of ValidationError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread-safe subclass of Array. This version locks against the object # itself for every method call, ensuring only one thread can be reading # or writing at a time. This includes iteration methods like ‘#each`. # # @note `a += b` is <strong>not</strong> a <strong>thread-safe</strong> operation on #   `Concurrent::Array`. It reads array `a`, then it creates new `Concurrent::Array` #   which is concatenation of `a` and `b`, then it writes the concatenation to `a`. #   The read and write are independent operations they do not form a single atomic #   operation therefore when two `+=` operations are executed concurrently updates #   may be lost. Use `#concat` instead. # @see <a href="http://ruby-doc.org/core/Array.html">ruby-doc.org/core/Array.html</a> Ruby standard library `Array` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/array.rb#53 class Concurrent::Array &lt; ::Array; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/array.rb#22 Concurrent::ArrayImplementation = Array</p>

<p># A mixin module that provides simple asynchronous behavior to a class, # turning it into a simple actor. Loosely based on Erlang’s # [gen_server](<a href="http://www.erlang.org/doc/man/gen_server.html">www.erlang.org/doc/man/gen_server.html</a>), but without # supervision or linking. # # A more feature-rich {Concurrent::Actor} is also available when the # capabilities of ‘Async` are too limited. # # “`cucumber # Feature: #   As a stateful, plain old Ruby class #   I want safe, asynchronous behavior #   So my long-running methods don’t block the main thread # “‘ # # The `Async` module is a way to mix simple yet powerful asynchronous # capabilities into any plain old Ruby object or class, turning each object # into a simple Actor. Method calls are processed on a background thread. The # caller is free to perform other actions while processing occurs in the # background. # # Method calls to the asynchronous object are made via two proxy methods: # `async` (alias `cast`) and `await` (alias `call`). These proxy methods post # the method call to the object’s background thread and return a “future” # which will eventually contain the result of the method call. # # This behavior is loosely patterned after Erlang’s ‘gen_server` behavior. # When an Erlang module implements the `gen_server` behavior it becomes # inherently asynchronous. The `start` or `start_link` function spawns a # process (similar to a thread but much more lightweight and efficient) and # returns the ID of the process. Using the process ID, other processes can # send messages to the `gen_server` via the `cast` and `call` methods. Unlike # Erlang’s ‘gen_server`, however, `Async` classes do not support linking or # supervision trees. # # ## Basic Usage # # When this module is mixed into a class, objects of the class become inherently # asynchronous. Each object gets its own background thread on which to post # asynchronous method calls. Asynchronous method calls are executed in the # background one at a time in the order they are received. # # To create an asynchronous class, simply mix in the `Concurrent::Async` module: # # “` # class Hello #   include Concurrent::Async # #   def hello(name) #     “Hello, #{name}!” #   end # end # “` # # Mixing this module into a class provides each object two proxy methods: # `async` and `await`. These methods are thread safe with respect to the # enclosing object. The former proxy allows methods to be called # asynchronously by posting to the object’s internal thread. The latter proxy # allows a method to be called synchronously but does so safely with respect # to any pending asynchronous method calls and ensures proper ordering. Both # methods return a {Concurrent::IVar} which can be inspected for the result # of the proxied method call. Calling a method with ‘async` will return a # `:pending` `IVar` whereas `await` will return a `:complete` `IVar`. # # “` # class Echo #   include Concurrent::Async # #   def echo(msg) #     print “#{msg}n” #   end # end # # horn = Echo.new # horn.echo(’zero’)      # synchronous, not thread-safe #                        # returns the actual return value of the method # # horn.async.echo(‘one’) # asynchronous, non-blocking, thread-safe #                        # returns an IVar in the :pending state # # horn.await.echo(‘two’) # synchronous, blocking, thread-safe #                        # returns an IVar in the :complete state # “‘ # # ## Let It Fail # # The `async` and `await` proxy methods have built-in error protection based # on Erlang’s famous “let it fail” philosophy. Instance methods should not be # programmed defensively. When an exception is raised by a delegated method # the proxy will rescue the exception, expose it to the caller as the ‘reason` # attribute of the returned future, then process the next method call. # # ## Calling Methods Internally # # External method calls should <strong>always</strong> use the `async` and `await` proxy # methods. When one method calls another method, the `async` proxy should # rarely be used and the `await` proxy should <strong>never</strong> be used. # # When an object calls one of its own methods using the `await` proxy the # second call will be enqueued <strong>behind</strong> the currently running method call. # Any attempt to wait on the result will fail as the second call will never # run until after the current call completes. # # Calling a method using the `await` proxy from within a method that was # itself called using `async` or `await` will irreversibly deadlock the # object. Do <strong>not</strong> do this, ever. # # ## Instance Variables and Attribute Accessors # # Instance variables do not need to be thread-safe so long as they are private. # Asynchronous method calls are processed in the order they are received and # are processed one at a time. Therefore private instance variables can only # be accessed by one thread at a time. This is inherently thread-safe. # # When using private instance variables within asynchronous methods, the best # practice is to read the instance variable into a local variable at the start # of the method then update the instance variable at the <strong>end</strong> of the method. # This way, should an exception be raised during method execution the internal # state of the object will not have been changed. # # ### Reader Attributes # # The use of `attr_reader` is discouraged. Internal state exposed externally, # when necessary, should be done through accessor methods. The instance # variables exposed by these methods <strong>must</strong> be thread-safe, or they must be # called using the `async` and `await` proxy methods. These two approaches are # subtly different. # # When internal state is accessed via the `async` and `await` proxy methods, # the returned value represents the object’s state *at the time the call is # processed*, which may <strong>not</strong> be the state of the object at the time the call # is made. # # To get the state *at the current* time, irrespective of an enqueued method # calls, a reader method must be called directly. This is inherently unsafe # unless the instance variable is itself thread-safe, preferably using one # of the thread-safe classes within this library. Because the thread-safe # classes within this library are internally-locking or non-locking, they can # be safely used from within asynchronous methods without causing deadlocks. # # Generally speaking, the best practice is to <strong>not</strong> expose internal state via # reader methods. The best practice is to simply use the method’s return value. # # ### Writer Attributes # # Writer attributes should never be used with asynchronous classes. Changing # the state externally, even when done in the thread-safe way, is not logically # consistent. Changes to state need to be timed with respect to all asynchronous # method calls which my be in-process or enqueued. The only safe practice is to # pass all necessary data to each method as arguments and let the method update # the internal state as necessary. # # ## Class Constants, Variables, and Methods # # ### Class Constants # # Class constants do not need to be thread-safe. Since they are read-only and # immutable they may be safely read both externally and from within # asynchronous methods. # # ### Class Variables # # Class variables should be avoided. Class variables represent shared state. # Shared state is anathema to concurrency. Should there be a need to share # state using class variables they <strong>must</strong> be thread-safe, preferably # using the thread-safe classes within this library. When updating class # variables, never assign a new value/object to the variable itself. Assignment # is not thread-safe in Ruby. Instead, use the thread-safe update functions # of the variable itself to change the value. # # The best practice is to <strong>never</strong> use class variables with ‘Async` classes. # # ### Class Methods # # Class methods which are pure functions are safe. Class methods which modify # class variables should be avoided, for all the reasons listed above. # # ## An Important Note About Thread Safe Guarantees # # &gt; Thread safe guarantees can only be made when asynchronous method calls # &gt; are not mixed with direct method calls. Use only direct method calls # &gt; when the object is used exclusively on a single thread. Use only # &gt; `async` and `await` when the object is shared between threads. Once you # &gt; call a method using `async` or `await`, you should no longer call methods # &gt; directly on the object. Use `async` and `await` exclusively from then on. # # @example # #   class Echo #   include Concurrent::Async # #   def echo(msg) #   print “#{msg}n” #   end #   end # #   horn = Echo.new #   horn.echo(’zero’)      # synchronous, not thread-safe #   # returns the actual return value of the method # #   horn.async.echo(‘one’) # asynchronous, non-blocking, thread-safe #   # returns an IVar in the :pending state # #   horn.await.echo(‘two’) # synchronous, blocking, thread-safe #   # returns an IVar in the :complete state # @see Concurrent::Actor # @see <a href="https://en.wikipedia.org/wiki/Actor_model">en.wikipedia.org/wiki/Actor_model</a> “Actor Model” at Wikipedia # @see <a href="http://www.erlang.org/doc/man/gen_server.html">www.erlang.org/doc/man/gen_server.html</a> Erlang gen_server # @see <a href="http://c2.com/cgi/wiki?LetItCrash">c2.com/cgi/wiki?LetItCrash</a> “Let It Crash” at <a href="http://c2.com">c2.com</a>/ # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#217 module Concurrent::Async</p>

<pre class="ruby"><span class="ruby-identifier">mixes_in_class_methods</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Async</span><span class="ruby-operator">::</span><span class="ruby-constant">ClassMethods</span>

<span class="ruby-comment"># Causes the chained method call to be performed asynchronously on the</span>
<span class="ruby-comment"># object&#39;s thread. The delegated method will return a future in the</span>
<span class="ruby-comment"># `:pending` state and the method call will have been scheduled on the</span>
<span class="ruby-comment"># object&#39;s thread. The final disposition of the method call can be obtained</span>
<span class="ruby-comment"># by inspecting the returned future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The method call is guaranteed to be thread safe with respect to</span>
<span class="ruby-comment">#   all other method calls against the same object that are called with</span>
<span class="ruby-comment">#   either `async` or `await`. The mutable nature of Ruby references</span>
<span class="ruby-comment">#   (and object orientation in general) prevent any other thread safety</span>
<span class="ruby-comment">#   guarantees. Do NOT mix direct method calls with delegated method calls.</span>
<span class="ruby-comment">#   Use *only* delegated method calls when sharing the object between threads.</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to the requested method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of</span>
<span class="ruby-comment">#   the requested method</span>
<span class="ruby-comment"># @return [Concurrent::IVar] the pending result of the asynchronous operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#412</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Causes the chained method call to be performed synchronously on the</span>
<span class="ruby-comment"># current thread. The delegated will return a future in either the</span>
<span class="ruby-comment"># `:fulfilled` or `:rejected` state and the delegated method will have</span>
<span class="ruby-comment"># completed. The final disposition of the delegated method can be obtained</span>
<span class="ruby-comment"># by inspecting the returned future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The method call is guaranteed to be thread safe with respect to</span>
<span class="ruby-comment">#   all other method calls against the same object that are called with</span>
<span class="ruby-comment">#   either `async` or `await`. The mutable nature of Ruby references</span>
<span class="ruby-comment">#   (and object orientation in general) prevent any other thread safety</span>
<span class="ruby-comment">#   guarantees. Do NOT mix direct method calls with delegated method calls.</span>
<span class="ruby-comment">#   Use *only* delegated method calls when sharing the object between threads.</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to the requested method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of the</span>
<span class="ruby-comment">#   requested method</span>
<span class="ruby-comment"># @return [Concurrent::IVar] the completed result of the synchronous operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#430</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">await</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Causes the chained method call to be performed synchronously on the</span>
<span class="ruby-comment"># current thread. The delegated will return a future in either the</span>
<span class="ruby-comment"># `:fulfilled` or `:rejected` state and the delegated method will have</span>
<span class="ruby-comment"># completed. The final disposition of the delegated method can be obtained</span>
<span class="ruby-comment"># by inspecting the returned future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The method call is guaranteed to be thread safe with respect to</span>
<span class="ruby-comment">#   all other method calls against the same object that are called with</span>
<span class="ruby-comment">#   either `async` or `await`. The mutable nature of Ruby references</span>
<span class="ruby-comment">#   (and object orientation in general) prevent any other thread safety</span>
<span class="ruby-comment">#   guarantees. Do NOT mix direct method calls with delegated method calls.</span>
<span class="ruby-comment">#   Use *only* delegated method calls when sharing the object between threads.</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to the requested method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of the</span>
<span class="ruby-comment">#   requested method</span>
<span class="ruby-comment"># @return [Concurrent::IVar] the completed result of the synchronous operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#433</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Causes the chained method call to be performed asynchronously on the</span>
<span class="ruby-comment"># object&#39;s thread. The delegated method will return a future in the</span>
<span class="ruby-comment"># `:pending` state and the method call will have been scheduled on the</span>
<span class="ruby-comment"># object&#39;s thread. The final disposition of the method call can be obtained</span>
<span class="ruby-comment"># by inspecting the returned future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The method call is guaranteed to be thread safe with respect to</span>
<span class="ruby-comment">#   all other method calls against the same object that are called with</span>
<span class="ruby-comment">#   either `async` or `await`. The mutable nature of Ruby references</span>
<span class="ruby-comment">#   (and object orientation in general) prevent any other thread safety</span>
<span class="ruby-comment">#   guarantees. Do NOT mix direct method calls with delegated method calls.</span>
<span class="ruby-comment">#   Use *only* delegated method calls when sharing the object between threads.</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to the requested method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of</span>
<span class="ruby-comment">#   the requested method</span>
<span class="ruby-comment"># @return [Concurrent::IVar] the pending result of the asynchronous operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Initialize the internal serializer and other stnchronization mechanisms.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This method *must* be called immediately upon object construction.</span>
<span class="ruby-comment">#   This is the only way thread-safe initialization can be guaranteed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#441</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">init_synchronization</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#262</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Check for the presence of a method on an object and determine if a given</span>
  <span class="ruby-comment"># set of arguments matches the required arity.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @note This check is imperfect because of the way Ruby reports the arity of</span>
  <span class="ruby-comment">#   methods with a variable number of arguments. It is possible to determine</span>
  <span class="ruby-comment">#   if too few arguments are given but impossible to determine if too many</span>
  <span class="ruby-comment">#   arguments are given. This check may also fail to recognize dynamic behavior</span>
  <span class="ruby-comment">#   of the object, such as methods simulated with `method_missing`.</span>
  <span class="ruby-comment"># @param obj [Object] the object to check against</span>
  <span class="ruby-comment"># @param method [Symbol] the method to check the object for</span>
  <span class="ruby-comment"># @param args [Array] zero or more arguments for the arity check</span>
  <span class="ruby-comment"># @raise [NameError] the object does not respond to `method` method</span>
  <span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of `method`</span>
  <span class="ruby-comment"># @see http://www.ruby-doc.org/core-2.1.1/Method.html#method-i-arity Method#arity</span>
  <span class="ruby-comment"># @see http://ruby-doc.org/core-2.1.0/Object.html#method-i-respond_to-3F Object#respond_to?</span>
  <span class="ruby-comment"># @see http://www.ruby-doc.org/core-2.1.0/BasicObject.html#method-i-method_missing BasicObject#method_missing</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#250</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_argc</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Delegates asynchronous, thread-safe method calls to the wrapped object. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#282 class Concurrent::Async::AsyncDelegator &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># Create a new delegator object wrapping the given delegate.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delegate [Object] the object to wrap and delegate method calls to</span>
<span class="ruby-comment"># @return [AsyncDelegator] a new instance of AsyncDelegator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#288</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delegate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Delegates method calls to the wrapped object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param method [Symbol] the method being called</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to the method</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to `method` method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of `method`</span>
<span class="ruby-comment"># @return [IVar] the result of the method call</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_missing</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Perform all enqueued tasks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This method must be called from within the executor. It must not be</span>
<span class="ruby-comment"># called while already running. It will loop until the queue is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#330</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">perform</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_if_forked</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Check whether the method is responsive</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param method [Symbol] the method being called</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#322</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">respond_to_missing?</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">include_private</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Delegates synchronous, thread-safe method calls to the wrapped object. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#360 class Concurrent::Async::AwaitDelegator</p>

<pre class="ruby"><span class="ruby-comment"># Create a new delegator object wrapping the given delegate.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delegate [AsyncDelegator] the object to wrap and delegate method calls to</span>
<span class="ruby-comment"># @return [AwaitDelegator] a new instance of AwaitDelegator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delegate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Delegates method calls to the wrapped object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param method [Symbol] the method being called</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to the method</span>
<span class="ruby-comment"># @raise [NameError] the object does not respond to `method` method</span>
<span class="ruby-comment"># @raise [ArgumentError] the given `args` do not match the arity of `method`</span>
<span class="ruby-comment"># @return [IVar] the result of the method call</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#378</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_missing</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Check whether the method is responsive</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param method [Symbol] the method being called</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#387</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">respond_to_missing?</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">include_private</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#269 module Concurrent::Async::ClassMethods</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Atoms provide a way to manage shared, synchronous, independent state. # # An atom is initialized with an initial value and an optional validation # proc. At any time the value of the atom can be synchronously and safely # changed. If a validator is given at construction then any new value # will be checked against the validator and will be rejected if the # validator returns false or raises an exception. # # There are two ways to change the value of an atom: {#compare_and_set} and # {#swap}. The former will set the new value if and only if it validates and # the current value matches the new value. The latter will atomically set the # new value to the result of running the given block if and only if that # value validates. # # ## Example # # “‘ # def next_fibonacci(set = nil) #   return [0, 1] if set.nil? #   set + [<a href="-2..-1">set</a>.reduce{|sum,x| sum + x }] # end # # # create an atom with an initial value # atom = Concurrent::Atom.new(next_fibonacci) # # # send a few update requests # 5.times do #   atom.swap{|set| next_fibonacci(set) } # end # # # get the current value # atom.value #=&gt; [0, 1, 1, 2, 3, 5, 8] # “` # # ## Observation # # Atoms support observers through the {Concurrent::Observable} mixin module. # Notification of observers occurs every time the value of the Atom changes. # When notified the observer will receive three arguments: `time`, `old_value`, # and `new_value`. The `time` argument is the time at which the value change # occurred. The `old_value` is the value of the Atom when the change began # The `new_value` is the value to which the Atom was set when the change # completed. Note that `old_value` and `new_value` may be the same. This is # not an error. It simply means that the change operation returned the same # value. # # Unlike in Clojure, `Atom` cannot participate in {Concurrent::TVar} transactions. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # # @see <a href="http://clojure.org/atoms">clojure.org/atoms</a> Clojure Atoms # @see <a href="http://clojure.org/state">clojure.org/state</a> Values and Change - Clojure’s approach to Identity and State # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#95 class Concurrent::Atom &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Observable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new atom with the given initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param value [Object] The initial value</span>
<span class="ruby-comment"># @param opts [Hash] The options used to configure the atom</span>
<span class="ruby-comment"># @raise [ArgumentError] if the validator is not a `Proc` (when given)</span>
<span class="ruby-comment"># @return [Atom] a new instance of Atom</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value of atom to the new value if and only if the</span>
<span class="ruby-comment"># current value of the atom is identical to the old value and the new</span>
<span class="ruby-comment"># value successfully validates against the (optional) validator given</span>
<span class="ruby-comment"># at construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param old_value [Object] The expected current value.</span>
<span class="ruby-comment"># @param new_value [Object] The intended new value.</span>
<span class="ruby-comment"># @return [Boolean] True if the value is changed else false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set</span>(<span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deref</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value of atom to the new value without regard for the</span>
<span class="ruby-comment"># current value so long as the new value successfully validates against the</span>
<span class="ruby-comment"># (optional) validator given at construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] The intended new value.</span>
<span class="ruby-comment"># @return [Object] The final value of the atom after all operations and</span>
<span class="ruby-comment">#   validations are complete.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically swaps the value of atom using the given block. The current</span>
<span class="ruby-comment"># value will be passed to the block, as will any arguments passed as</span>
<span class="ruby-comment"># arguments to the function. The new value will be validated against the</span>
<span class="ruby-comment"># (optional) validator proc given at construction. If validation fails the</span>
<span class="ruby-comment"># value will not be changed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Internally, {#swap} reads the current value, applies the block to it, and</span>
<span class="ruby-comment"># attempts to compare-and-set it in. Since another thread may have changed</span>
<span class="ruby-comment"># the value in the intervening time, it may have to retry, and does so in a</span>
<span class="ruby-comment"># spin loop. The net effect is that the value will always be the result of</span>
<span class="ruby-comment"># the application of the supplied block to a current value, atomically.</span>
<span class="ruby-comment"># However, because the block might be called multiple times, it must be free</span>
<span class="ruby-comment"># of side effects.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The given block may be called multiple times, and thus should be free</span>
<span class="ruby-comment">#   of side effects.</span>
<span class="ruby-comment"># @param args [Object] Zero or more arguments passed to the block.</span>
<span class="ruby-comment"># @raise [ArgumentError] When no block is given.</span>
<span class="ruby-comment"># @return [Object] The final value of the atom after all operations and</span>
<span class="ruby-comment">#   validations are complete.</span>
<span class="ruby-comment"># @yield [value, args] Calculates a new value for the atom based on the</span>
<span class="ruby-comment">#   current value and any supplied arguments.</span>
<span class="ruby-comment"># @yieldparam value [Object] The current value of the atom.</span>
<span class="ruby-comment"># @yieldparam args [Object] All arguments passed to the function, in order.</span>
<span class="ruby-comment"># @yieldreturn [Object] The intended new value of the atom.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value of the atom.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] The current value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_value</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_value</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_value</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the new value valid?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] The intended new value.</span>
<span class="ruby-comment"># @return [Boolean] false if the validator function returns false or raises</span>
<span class="ruby-comment">#   an exception else true</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid?</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A boolean value that can be updated atomically. Reads and writes to an atomic # boolean and thread-safe and guaranteed to succeed. Reads and writes may block # briefly but no explicit locking is required. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # Performance: # # “‘ # Testing with ruby 2.1.2 # Testing with Concurrent::MutexAtomicBoolean… #   2.790000   0.000000   2.790000 (  2.791454) # Testing with Concurrent::CAtomicBoolean… #   0.740000   0.000000   0.740000 (  0.740206) # # Testing with jruby 1.9.3 # Testing with Concurrent::MutexAtomicBoolean… #   5.240000   2.520000   7.760000 (  3.683000) # Testing with Concurrent::JavaAtomicBoolean… #   3.340000   0.010000   3.350000 (  0.855000) # “` # # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicBoolean.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicBoolean.html</a> java.util.concurrent.atomic.AtomicBoolean # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#119 class Concurrent::AtomicBoolean &lt; ::Concurrent::MutexAtomicBoolean</p>

<pre class="ruby"><span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#82 Concurrent::AtomicBooleanImplementation = Concurrent::MutexAtomicBoolean</p>

<p># Define update methods that use direct paths # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#9 module Concurrent::AtomicDirectUpdate</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_update</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_update!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A numeric value that can be updated atomically. Reads and writes to an atomic # fixnum and thread-safe and guaranteed to succeed. Reads and writes may block # briefly but no explicit locking is required. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # Performance: # # “‘ # Testing with ruby 2.1.2 # Testing with Concurrent::MutexAtomicFixnum… #   3.130000   0.000000   3.130000 (  3.136505) # Testing with Concurrent::CAtomicFixnum… #   0.790000   0.000000   0.790000 (  0.785550) # # Testing with jruby 1.9.3 # Testing with Concurrent::MutexAtomicFixnum… #   5.460000   2.460000   7.920000 (  3.715000) # Testing with Concurrent::JavaAtomicFixnum… #   4.520000   0.030000   4.550000 (  1.187000) # “` # # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html</a> java.util.concurrent.atomic.AtomicLong # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#136 class Concurrent::AtomicFixnum &lt; ::Concurrent::MutexAtomicFixnum</p>

<pre class="ruby"><span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#99 Concurrent::AtomicFixnumImplementation = Concurrent::MutexAtomicFixnum</p>

<p># An atomic reference which maintains an object reference along with a mark bit # that can be updated atomically. # # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html</a> java.util.concurrent.atomic.AtomicMarkableReference # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#10 class Concurrent::AtomicMarkableReference &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [AtomicMarkableReference] a new instance of AtomicMarkableReference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">mark</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value and mark to the given updated value and</span>
<span class="ruby-comment"># mark given both:</span>
<span class="ruby-comment">#   - the current value == the expected value &amp;&amp;</span>
<span class="ruby-comment">#   - the current mark == the expected mark</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># that the actual value was not equal to the expected value or the</span>
<span class="ruby-comment"># actual mark was not equal to the expected mark</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param expected_val [Object] the expected value</span>
<span class="ruby-comment"># @param new_val [Object] the new value</span>
<span class="ruby-comment"># @param expected_mark [Boolean] the expected mark</span>
<span class="ruby-comment"># @param new_mark [Boolean] the new mark</span>
<span class="ruby-comment"># @return [Boolean] `true` if successful. A `false` return indicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set</span>(<span class="ruby-identifier">expected_val</span>, <span class="ruby-identifier">new_val</span>, <span class="ruby-identifier">expected_mark</span>, <span class="ruby-identifier">new_mark</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value and mark to the given updated value and</span>
<span class="ruby-comment"># mark given both:</span>
<span class="ruby-comment">#   - the current value == the expected value &amp;&amp;</span>
<span class="ruby-comment">#   - the current mark == the expected mark</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># that the actual value was not equal to the expected value or the</span>
<span class="ruby-comment"># actual mark was not equal to the expected mark</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param expected_val [Object] the expected value</span>
<span class="ruby-comment"># @param new_val [Object] the new value</span>
<span class="ruby-comment"># @param expected_mark [Boolean] the expected mark</span>
<span class="ruby-comment"># @param new_mark [Boolean] the new mark</span>
<span class="ruby-comment"># @return [Boolean] `true` if successful. A `false` return indicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_swap</span>(<span class="ruby-identifier">expected_val</span>, <span class="ruby-identifier">new_val</span>, <span class="ruby-identifier">expected_mark</span>, <span class="ruby-identifier">new_mark</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current reference and marked values.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the current reference and marked values</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current marked value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] the current marked value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mark</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current marked value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] the current marked value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marked?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># _Unconditionally_ sets to the given value of both the reference and</span>
<span class="ruby-comment"># the mark.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_val [Object] the new value</span>
<span class="ruby-comment"># @param new_mark [Boolean] the new mark</span>
<span class="ruby-comment"># @return [Array] both the new value and the new mark</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">new_val</span>, <span class="ruby-identifier">new_mark</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Pass the current value to the given block, replacing it with the</span>
<span class="ruby-comment"># block&#39;s result. Simply return nil if update fails.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># the update failed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the new value and marked state, or nil if</span>
<span class="ruby-comment"># @yield [Object] Calculate a new value and marked state for the atomic</span>
<span class="ruby-comment">#   reference using given (old) value and (old) marked</span>
<span class="ruby-comment"># @yieldparam old_val [Object] the starting value of the atomic reference</span>
<span class="ruby-comment"># @yieldparam old_mark [Boolean] the starting state of marked</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_update</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Pass the current value to the given block, replacing it</span>
<span class="ruby-comment"># with the block&#39;s result. Raise an exception if the update</span>
<span class="ruby-comment"># fails.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Concurrent::ConcurrentUpdateError] if the update fails</span>
<span class="ruby-comment"># @return [Array] the new value and marked state</span>
<span class="ruby-comment"># @yield [Object] Calculate a new value and marked state for the atomic</span>
<span class="ruby-comment">#   reference using given (old) value and (old) marked</span>
<span class="ruby-comment"># @yieldparam old_val [Object] the starting value of the atomic reference</span>
<span class="ruby-comment"># @yieldparam old_mark [Boolean] the starting state of marked</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_update!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Pass the current value and marked state to the given block, replacing it</span>
<span class="ruby-comment"># with the block&#39;s results. May retry if the value changes during the</span>
<span class="ruby-comment"># block&#39;s execution.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the new value and new mark</span>
<span class="ruby-comment"># @yield [Object] Calculate a new value and marked state for the atomic</span>
<span class="ruby-comment">#   reference using given (old) value and (old) marked</span>
<span class="ruby-comment"># @yieldparam old_val [Object] the starting value of the atomic reference</span>
<span class="ruby-comment"># @yieldparam old_mark [Boolean] the starting state of marked</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current value of the reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of the reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_reference</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">immutable_array</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_reference</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_reference</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Special “compare and set” handling of numeric values. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#7 module Concurrent::AtomicNumericCompareAndSetWrapper</p>

<pre class="ruby"><span class="ruby-comment"># Atomically sets the value to the given updated value if</span>
<span class="ruby-comment"># the current value == the expected value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># that the actual value was not equal to the expected value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param old_value [Object] the expected value</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Boolean] `true` if successful. A `false` return indicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set</span>(<span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An object reference that may be updated atomically. All read and write # operations have java volatile semantic. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # # @see <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html">docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html</a> # @see <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#126 class Concurrent::AtomicReference &lt; ::Concurrent::MutexAtomicReference</p>

<pre class="ruby"><span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#18 Concurrent::AtomicReferenceImplementation = Concurrent::MutexAtomicReference</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#30 class Concurrent::CRubySet &lt; ::Set</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&amp;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">+</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">-</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">===</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&gt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&gt;=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">^</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classify</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_by_identity</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_by_identity?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_if</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">difference</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disjoint?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">divide</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eql?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten_merge</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">freeze</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">intersect?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">intersection</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">join</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_if</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">member?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pretty_print</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pretty_print_cycle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_subset?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_superset?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">subset?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">subtract</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">superset?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_set</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">union</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">|</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread pool that dynamically grows and shrinks to fit the current workload. # New threads are created as needed, existing threads are reused, and threads # that remain idle for too long are killed and removed from the pool. These # pools are particularly suited to applications that perform a high volume of # short-lived tasks. # # On creation a ‘CachedThreadPool` has zero running threads. New threads are # created on the pool as new operations are `#post`. The size of the pool # will grow until `#max_length` threads are in the pool or until the number # of threads exceeds the number of running and pending operations. When a new # operation is post to the pool the first available idle thread will be tasked # with the new operation. # # Should a thread crash for any reason the thread will immediately be removed # from the pool. Similarly, threads which remain idle for an extended period # of time will be killed and reclaimed. Thus these thread pools are very # efficient at reclaiming unused resources. # # The API and behavior of this class are based on Java’s ‘CachedThreadPool` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#27 class Concurrent::CachedThreadPool &lt; ::Concurrent::ThreadPoolExecutor</p>

<pre class="ruby"><span class="ruby-comment"># Create a new thread pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options defining pool behavior.</span>
<span class="ruby-comment"># @raise [ArgumentError] if `fallback_policy` is not a known policy</span>
<span class="ruby-comment"># @return [CachedThreadPool] a new instance of CachedThreadPool</span>
<span class="ruby-comment"># @see http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Create a new thread pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options defining pool behavior.</span>
<span class="ruby-comment"># @raise [ArgumentError] if `fallback_policy` is not a known policy</span>
<span class="ruby-comment"># @see http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when an asynchronous operation is cancelled before execution. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#9 class Concurrent::CancelledOperationError &lt; ::Concurrent::Error; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#7 module Concurrent::Collection; end</p>

<p># A thread safe observer set implemented using copy-on-read approach: # observers are added and removed from a thread safe collection; every time # a notification is required the internal data structure is copied to # prevent concurrency issues # # @api private # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#12 class Concurrent::Collection::CopyOnNotifyObserverSet &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [CopyOnNotifyObserverSet] a new instance of CopyOnNotifyObserverSet</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_observer</span>(<span class="ruby-identifier">observer</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">func</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observer</span>(<span class="ruby-identifier">observer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Notifies all registered observers with optional args and deletes them.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param args [Object] arguments to be passed to each observer</span>
<span class="ruby-comment"># @return [CopyOnWriteObserverSet] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_and_delete_observers</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Notifies all registered observers with optional args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param args [Object] arguments to be passed to each observer</span>
<span class="ruby-comment"># @return [CopyOnWriteObserverSet] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_observers</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicate_and_clear_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicate_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_to</span>(<span class="ruby-identifier">observers</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread safe observer set implemented using copy-on-write approach: # every time an observer is added or removed the whole internal data structure is # duplicated and replaced with a new one. # # @api private # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#11 class Concurrent::Collection::CopyOnWriteObserverSet &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [CopyOnWriteObserverSet] a new instance of CopyOnWriteObserverSet</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_observer</span>(<span class="ruby-identifier">observer</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">func</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observer</span>(<span class="ruby-identifier">observer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Notifies all registered observers with optional args and deletes them.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param args [Object] arguments to be passed to each observer</span>
<span class="ruby-comment"># @return [CopyOnWriteObserverSet] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_and_delete_observers</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Notifies all registered observers with optional args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param args [Object] arguments to be passed to each observer</span>
<span class="ruby-comment"># @return [CopyOnWriteObserverSet] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_observers</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_observers_and_return_old</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_to</span>(<span class="ruby-identifier">observers</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">observers=</span>(<span class="ruby-identifier">new_set</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#10 Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#10 class Concurrent::Collection::MriMapBackend &lt; ::Concurrent::Collection::NonConcurrentMapBackend</p>

<pre class="ruby"><span class="ruby-comment"># @return [MriMapBackend] a new instance of MriMapBackend</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">default_proc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_if_absent</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_if_present</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#9 class Concurrent::Collection::NonConcurrentMapBackend</p>

<pre class="ruby"><span class="ruby-comment"># WARNING: all public methods of the class must operate on the @backend</span>
<span class="ruby-comment"># directly without calling each other. This is important because of the</span>
<span class="ruby-comment"># SynchronizedMapBackend which uses a non-reentrant mutex for performance</span>
<span class="ruby-comment"># reasons.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [NonConcurrentMapBackend] a new instance of NonConcurrentMapBackend</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">default_proc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_if_absent</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_if_present</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_or_default</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">default_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key?</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dupped_backend</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pair?</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">expected_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_backend</span>(<span class="ruby-identifier">default_proc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">store_computed_value</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A queue collection in which the elements are sorted based on their # comparison (spaceship) operator ‘&lt;=&gt;`. Items are added to the queue # at a position relative to their priority. On removal the element # with the “highest” priority is removed. By default the sort order is # from highest to lowest, but a lowest-to-highest sort order can be # set on construction. # # The API is based on the `Queue` class from the Ruby standard library. # # The pure Ruby implementation, `RubyNonConcurrentPriorityQueue` uses a heap algorithm # stored in an array. The algorithm is based on the work of Robert Sedgewick # and Kevin Wayne. # # The JRuby native implementation is a thin wrapper around the standard # library `java.util.NonConcurrentPriorityQueue`. # # When running under JRuby the class `NonConcurrentPriorityQueue` extends `JavaNonConcurrentPriorityQueue`. # When running under all other interpreters it extends `RubyNonConcurrentPriorityQueue`. # # @note This implementation is <strong>not</strong> thread safe. # @see <a href="http://en.wikipedia.org/wiki/Priority_queue">en.wikipedia.org/wiki/Priority_queue</a> # @see <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/thread/rdoc/Queue.html">ruby-doc.org/stdlib-2.0.0/libdoc/thread/rdoc/Queue.html</a> # @see <a href="http://algs4.cs.princeton.edu/24pq/index.php#2.6">algs4.cs.princeton.edu/24pq/index.php#2.6</a> # @see <a href="http://algs4.cs.princeton.edu/24pq/MaxPQ.java.html">algs4.cs.princeton.edu/24pq/MaxPQ.java.html</a> # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html">docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#50 class Concurrent::Collection::NonConcurrentPriorityQueue &lt; ::Concurrent::Collection::RubyNonConcurrentPriorityQueue</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deq</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enq</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">has_priority?</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shift</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#10 Concurrent::Collection::NonConcurrentPriorityQueueImplementation = Concurrent::Collection::RubyNonConcurrentPriorityQueue</p>

<p># A queue collection in which the elements are sorted based on their # comparison (spaceship) operator ‘&lt;=&gt;`. Items are added to the queue # at a position relative to their priority. On removal the element # with the “highest” priority is removed. By default the sort order is # from highest to lowest, but a lowest-to-highest sort order can be # set on construction. # # The API is based on the `Queue` class from the Ruby standard library. # # The pure Ruby implementation, `RubyNonConcurrentPriorityQueue` uses a heap algorithm # stored in an array. The algorithm is based on the work of Robert Sedgewick # and Kevin Wayne. # # The JRuby native implementation is a thin wrapper around the standard # library `java.util.NonConcurrentPriorityQueue`. # # When running under JRuby the class `NonConcurrentPriorityQueue` extends `JavaNonConcurrentPriorityQueue`. # When running under all other interpreters it extends `RubyNonConcurrentPriorityQueue`. # # @note This implementation is <strong>not</strong> thread safe. # @see <a href="http://en.wikipedia.org/wiki/Priority_queue">en.wikipedia.org/wiki/Priority_queue</a> # @see <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/thread/rdoc/Queue.html">ruby-doc.org/stdlib-2.0.0/libdoc/thread/rdoc/Queue.html</a> # @see <a href="http://algs4.cs.princeton.edu/24pq/index.php#2.6">algs4.cs.princeton.edu/24pq/index.php#2.6</a> # @see <a href="http://algs4.cs.princeton.edu/24pq/MaxPQ.java.html">algs4.cs.princeton.edu/24pq/MaxPQ.java.html</a> # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html">docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#8 class Concurrent::Collection::RubyNonConcurrentPriorityQueue</p>

<pre class="ruby"><span class="ruby-comment"># Create a new priority queue with no items.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options for creating the queue</span>
<span class="ruby-comment"># @return [RubyNonConcurrentPriorityQueue] a new instance of RubyNonConcurrentPriorityQueue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Inserts the specified element into this priority queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to insert onto the queue</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes all of the elements from this priority queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Deletes all items from `self` that are equal to `item`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to be removed from the queue</span>
<span class="ruby-comment"># @return [Object] true if the item is found else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves and removes the head of this queue, or returns `nil` if this</span>
<span class="ruby-comment"># queue is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the head of the queue or `nil` when empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deq</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns `true` if `self` contains no elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if there are no items in the queue else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Inserts the specified element into this priority queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to insert onto the queue</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enq</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns `true` if the given item is present in `self` (that is, if any</span>
<span class="ruby-comment"># element == `item`), otherwise returns false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to search for</span>
<span class="ruby-comment"># @return [Boolean] true if the item is found else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">has_priority?</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns `true` if the given item is present in `self` (that is, if any</span>
<span class="ruby-comment"># element == `item`), otherwise returns false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to search for</span>
<span class="ruby-comment"># @return [Boolean] true if the item is found else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include?</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current length of the queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the number of items in the queue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves, but does not remove, the head of this queue, or returns `nil`</span>
<span class="ruby-comment"># if this queue is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the head of the queue or `nil` when empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">peek</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves and removes the head of this queue, or returns `nil` if this</span>
<span class="ruby-comment"># queue is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the head of the queue or `nil` when empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Inserts the specified element into this priority queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param item [Object] the item to insert onto the queue</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves and removes the head of this queue, or returns `nil` if this</span>
<span class="ruby-comment"># queue is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the head of the queue or `nil` when empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shift</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current length of the queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the number of items in the queue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Are the items at the given indexes ordered based on the priority</span>
<span class="ruby-comment"># order specified at construction?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param x [Integer] the first index from which to retrieve a comparable value</span>
<span class="ruby-comment"># @param y [Integer] the second index from which to retrieve a comparable value</span>
<span class="ruby-comment"># @return [Boolean] true if the two elements are in the correct priority order</span>
<span class="ruby-comment">#   else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ordered?</span>(<span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Percolate down to maintain heap invariant.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param k [Integer] the index at which to start the percolation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sink</span>(<span class="ruby-identifier">k</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Exchange the values at the given indexes within the internal array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param x [Integer] the first index to swap</span>
<span class="ruby-comment"># @param y [Integer] the second index to swap</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap</span>(<span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Percolate up to maintain heap invariant.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param k [Integer] the index at which to start the percolation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swim</span>(<span class="ruby-identifier">k</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @!macro priority_queue_method_from_list</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#89</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_list</span>(<span class="ruby-identifier">list</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#2 module Concurrent::Concern; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#8 module Concurrent::Concern::Deprecation</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Deprecation</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated</span>(<span class="ruby-identifier">message</span>, <span class="ruby-identifier">strip</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_method</span>(<span class="ruby-identifier">old_name</span>, <span class="ruby-identifier">new_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># <a href="../../../Object.html"><code>Object</code></a> references in Ruby are mutable. This can lead to serious problems when # the ‘#value` of a concurrent object is a mutable reference. Which is always the # case unless the value is a `Fixnum`, `Symbol`, or similar “primitive” data type. # Most classes in this library that expose a `#value` getter method do so using the # `Dereferenceable` mixin module. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#11 module Concurrent::Concern::Dereferenceable</p>

<pre class="ruby"><span class="ruby-comment"># Return the value this object represents after applying the options specified</span>
<span class="ruby-comment"># by the `#set_deref_options` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of the object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deref</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the value this object represents after applying the options specified</span>
<span class="ruby-comment"># by the `#set_deref_options` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of the object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_deref_options</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the options which define the operations #value performs before</span>
<span class="ruby-comment"># returning data to the caller (dereferencing).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Most classes that include this module will call `#set_deref_options`</span>
<span class="ruby-comment">#   from within the constructor, thus allowing these options to be set at</span>
<span class="ruby-comment">#   object creation.</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options defining dereference behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_set_deref_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the options which define the operations #value performs before</span>
<span class="ruby-comment"># returning data to the caller (dereferencing).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Most classes that include this module will call `#set_deref_options`</span>
<span class="ruby-comment">#   from within the constructor, thus allowing these options to be set at</span>
<span class="ruby-comment">#   object creation.</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options defining dereference behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_deref_options</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the internal value of this object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Include where logging is needed # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#9 module Concurrent::Concern::Logging</p>

<pre class="ruby"><span class="ruby-comment"># Logs through {Concurrent.global_logger}, it can be overridden by setting @logger</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param level [Integer] one of Concurrent::Concern::Logging constants</span>
<span class="ruby-comment"># @param progname [String] e.g. a path of an Actor</span>
<span class="ruby-comment"># @param message [String, nil] when nil block is used to generate the message</span>
<span class="ruby-comment"># @yieldreturn [String] a message</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">log</span>(<span class="ruby-identifier">level</span>, <span class="ruby-identifier">progname</span>, <span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::DEBUG = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::ERROR = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::FATAL = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::INFO = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#12 Concurrent::Concern::Logging::SEV_LABEL = T.let(T.unsafe(nil), Array)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::UNKNOWN = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#11 Concurrent::Concern::Logging::WARN = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#10 module Concurrent::Concern::Obligation</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Dereferenceable</span>

<span class="ruby-comment"># Has the obligation completed processing?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @example allows Obligation to be risen</span>
<span class="ruby-comment">#   rejected_ivar = Ivar.new.fail</span>
<span class="ruby-comment">#   raise rejected_ivar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Has the obligation been fulfilled?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the obligation still awaiting completion of processing?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incomplete?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait until obligation is complete or the timeout is reached. Will re-raise</span>
<span class="ruby-comment"># any exceptions raised during processing (but will not raise an exception</span>
<span class="ruby-comment"># on timeout).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @raise [Exception] raises the reason when rejected</span>
<span class="ruby-comment"># @return [Obligation] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_error!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is obligation completion still pending?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Has the obligation been fulfilled?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">realized?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If an exception was raised during processing this will return the</span>
<span class="ruby-comment"># exception object. Will return `nil` when the state is pending or if</span>
<span class="ruby-comment"># the obligation has been successfully fulfilled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Exception] the exception raised during processing or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Has the obligation been rejected?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current state of the obligation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the current state</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the obligation still unscheduled?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unscheduled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value of the obligation. Will be `nil` while the state is</span>
<span class="ruby-comment"># pending or the operation has been rejected.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @return [Object] see Dereferenceable#deref</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value of the obligation. Will be `nil` while the state is</span>
<span class="ruby-comment"># pending or the operation has been rejected. Will re-raise any exceptions</span>
<span class="ruby-comment"># raised during processing (but will not raise an exception on timeout).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @raise [Exception] raises the reason when rejected</span>
<span class="ruby-comment"># @return [Object] see Dereferenceable#deref</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait until obligation is complete or the timeout has been reached.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @return [Obligation] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait until obligation is complete or the timeout is reached. Will re-raise</span>
<span class="ruby-comment"># any exceptions raised during processing (but will not raise an exception</span>
<span class="ruby-comment"># on timeout).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @raise [Exception] raises the reason when rejected</span>
<span class="ruby-comment"># @return [Obligation] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Atomic compare and set operation</span>
<span class="ruby-comment"># State is set to `next_state` only if `current state == expected_current`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param next_state [Symbol]</span>
<span class="ruby-comment"># @param expected_current [Symbol]</span>
<span class="ruby-comment"># @return [Boolean] true is state is changed, false otherwise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_state</span>(<span class="ruby-identifier">next_state</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">expected_current</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_arguments_from</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Executes the block within mutex if current state is included in expected_states</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return block value if executed, false otherwise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_state</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">expected_states</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">init_obligation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Am I in the current state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param expected [Symbol] The state to check against</span>
<span class="ruby-comment"># @return [Boolean] true if in the expected state else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_check_state?</span>(<span class="ruby-identifier">expected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_set_state</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_state</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The [observer pattern](<a href="http://en.wikipedia.org/wiki/Observer_pattern">en.wikipedia.org/wiki/Observer_pattern</a>) is one # of the most useful design patterns. # # The workflow is very simple: # - an ‘observer` can register itself to a `subject` via a callback # - many `observers` can be registered to the same `subject` # - the `subject` notifies all registered observers when its status changes # - an `observer` can deregister itself when is no more interested to receive #     event notifications # # In a single threaded environment the whole pattern is very easy: the # `subject` can use a simple data structure to manage all its subscribed # `observer`s and every `observer` can react directly to every event without # caring about synchronization. # # In a multi threaded environment things are more complex. The `subject` must # synchronize the access to its data structure and to do so currently we’re # using two specialized ObserverSet: {Concurrent::Concern::CopyOnWriteObserverSet} # and {Concurrent::Concern::CopyOnNotifyObserverSet}. # # When implementing and ‘observer` there’s a very important rule to remember: # **there are no guarantees about the thread that will execute the callback** # # Let’s take this example # “‘ # class Observer #   def initialize #     @count = 0 #   end # #   def update #     @count += 1 #   end # end # # obs = Observer.new # [obj1, obj2, obj3, obj4].each { |o| o.add_observer(obs) } # # execute [obj1, obj2, obj3, obj4] # “` # # `obs` is wrong because the variable `@count` can be accessed by different # threads at the same time, so it should be synchronized (using either a Mutex # or an AtomicFixum) # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#50 module Concurrent::Concern::Observable</p>

<pre class="ruby"><span class="ruby-comment"># Adds an observer to this set. If a block is passed, the observer will be</span>
<span class="ruby-comment"># created by this method and no other params should be passed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param observer [Object] the observer to add</span>
<span class="ruby-comment"># @param func [Symbol] the function to call on the observer during notification.</span>
<span class="ruby-comment">#   Default is :update</span>
<span class="ruby-comment"># @return [Object] the added observer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_observer</span>(<span class="ruby-identifier">observer</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">func</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the number of observers associated with this object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] the observers count</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Remove `observer` as an observer on this object so that it will no</span>
<span class="ruby-comment"># longer receive notifications.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param observer [Object] the observer to remove</span>
<span class="ruby-comment"># @return [Object] the deleted observer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observer</span>(<span class="ruby-identifier">observer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Remove all observers associated with this object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Observable] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># As `#add_observer` but can be used for chaining.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param observer [Object] the observer to add</span>
<span class="ruby-comment"># @param func [Symbol] the function to call on the observer during notification.</span>
<span class="ruby-comment"># @return [Observable] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_observer</span>(<span class="ruby-identifier">observer</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">func</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Returns the value of attribute observers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">observers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute observers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute observers to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">observers=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#70 class Concurrent::ConcurrentUpdateError &lt; ::ThreadError; end</p>

<p># frozen pre-allocated backtrace to speed ConcurrentUpdateError # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#72 Concurrent::ConcurrentUpdateError::CONC_UP_ERR_BACKTRACE = T.let(T.unsafe(nil), Array)</p>

<p># Raised when errors occur during configuration. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#6 class Concurrent::ConfigurationError &lt; ::Concurrent::Error; end</p>

<p># A synchronization object that allows one thread to wait on multiple other threads. # The thread that will wait creates a ‘CountDownLatch` and sets the initial value # (normally equal to the number of other threads). The initiating thread passes the # latch to the other threads then waits for the other threads by calling the `#wait` # method. Each of the other threads calls `#count_down` when done with its work. # When the latch counter reaches zero the waiting thread is unblocked and continues # with its work. A `CountDownLatch` can be used only once. Its value cannot be reset. # # @example Waiter and Decrementer #   latch = Concurrent::CountDownLatch.new(3) # #   waiter = Thread.new do #   latch.wait() #   puts (“Waiter released”) #   end # #   decrementer = Thread.new do #   sleep(1) #   latch.count_down #   puts latch.count # #   sleep(1) #   latch.count_down #   puts latch.count # #   sleep(1) #   latch.count_down #   puts latch.count #   end # #   [waiter, decrementer].each(&amp;:join) # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/count_down_latch.rb#98 class Concurrent::CountDownLatch &lt; ::Concurrent::MutexCountDownLatch; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/count_down_latch.rb#56 Concurrent::CountDownLatchImplementation = Concurrent::MutexCountDownLatch</p>

<p># A synchronization aid that allows a set of threads to all wait for each # other to reach a common barrier point. # # @example #   barrier = Concurrent::CyclicBarrier.new(3) #   jobs    = Array.new(3) { |i| -&gt; { sleep i; p done: i } } #   process = -&gt; (i) do #   # waiting to start at the same time #   barrier.wait #   # execute job #   <a href="i">jobs</a>.call #   # wait for others to finish #   barrier.wait #   end #   threads = 2.times.map do |i| #   Thread.new(i, &amp;process) #   end # #   # use main as well #   process.call 2 # #   # here we can be sure that all jobs are processed # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#27 class Concurrent::CyclicBarrier &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># Create a new `CyclicBarrier` that waits for `parties` threads</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param parties [Fixnum] the number of parties</span>
<span class="ruby-comment"># @raise [ArgumentError] if `parties` is not an integer or is less than zero</span>
<span class="ruby-comment"># @return [CyclicBarrier] a new instance of CyclicBarrier</span>
<span class="ruby-comment"># @yield an optional block that will be executed that will be executed after</span>
<span class="ruby-comment">#   the last thread arrives and before the others are released</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">parties</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A barrier can be broken when:</span>
<span class="ruby-comment"># - a thread called the `reset` method while at least one other thread was waiting</span>
<span class="ruby-comment"># - at least one thread timed out on `wait` method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A broken barrier can be restored using `reset` it&#39;s safer to create a new one</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the barrier is broken otherwise false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">broken?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] the number of threads currently waiting on the barrier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">number_waiting</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] the number of threads needed to pass the barrier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parties</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># resets the barrier to its initial state</span>
<span class="ruby-comment"># If there is at least one waiting thread, it will be woken up, the `wait`</span>
<span class="ruby-comment"># method will return false and the barrier will be broken</span>
<span class="ruby-comment"># If the barrier is broken, this method restores it to the original state</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks on the barrier until the number of waiting threads is equal to</span>
<span class="ruby-comment"># `parties` or until `timeout` is reached or `reset` is called</span>
<span class="ruby-comment"># If a block has been passed to the constructor, it will be executed once by</span>
<span class="ruby-comment">#  the last arrived thread before releasing the others</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Fixnum] the number of seconds to wait for the counter or</span>
<span class="ruby-comment">#   `nil` to block indefinitely</span>
<span class="ruby-comment"># @return [Boolean] `true` if the `count` reaches zero else false on</span>
<span class="ruby-comment">#   `timeout` or on `reset` or if the barrier is broken</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_generation_done</span>(<span class="ruby-identifier">generation</span>, <span class="ruby-identifier">status</span>, <span class="ruby-identifier">continue</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">parties</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_next_generation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30 class Concurrent::CyclicBarrier::Generation &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">status</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute status to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">status=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Lazy evaluation of a block yielding an immutable result. Useful for # expensive operations that may never be needed. It may be non-blocking, # supports the ‘Concern::Obligation` interface, and accepts the injection of # custom executor upon which to execute the block. Processing of # block will be deferred until the first time `#value` is called. # At that time the caller can choose to return immediately and let # the block execute asynchronously, block indefinitely, or block # with a timeout. # # When a `Delay` is created its state is set to `pending`. The value and # reason are both `nil`. The first time the `#value` method is called the # enclosed operation will be run and the calling thread will block. Other # threads attempting to call `#value` will block as well. Once the operation # is complete the <strong>value</strong> will be set to the result of the operation or the # <strong>reason</strong> will be set to the raised exception, as appropriate. All threads # blocked on `#value` will return. Subsequent calls to `#value` will immediately # return the cached value. The operation will only be run once. This means that # any side effects created by the operation will only happen once as well. # # `Delay` includes the `Concurrent::Concern::Dereferenceable` mixin to support thread # safety of the reference returned by `#value`. # # @note The default behavior of `Delay` is to block indefinitely when #   calling either `value` or `wait`, executing the delayed operation on #   the current thread. This makes the `timeout` value completely #   irrelevant. To enable non-blocking behavior, use the `executor` #   constructor option. This will cause the delayed operation to be #   execute on the given executor, allowing the call to timeout. # @see Concurrent::Concern::Dereferenceable # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#44 class Concurrent::Delay &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Dereferenceable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Obligation</span>

<span class="ruby-comment"># Create a new `Delay` in the `:pending` state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
<span class="ruby-comment"># @return [Delay] a new instance of Delay</span>
<span class="ruby-comment"># @yield the delayed operation to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reconfigures the block returning the value if still `#incomplete?`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true, false] if success</span>
<span class="ruby-comment"># @yield the delayed operation to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reconfigure</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the value this object represents after applying the options</span>
<span class="ruby-comment"># specified by the `#set_deref_options` method. If the delayed operation</span>
<span class="ruby-comment"># raised an exception this method will return nil. The exception object</span>
<span class="ruby-comment"># can be accessed via the `#reason` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The default behavior of `Delay` is to block indefinitely when</span>
<span class="ruby-comment">#   calling either `value` or `wait`, executing the delayed operation on</span>
<span class="ruby-comment">#   the current thread. This makes the `timeout` value completely</span>
<span class="ruby-comment">#   irrelevant. To enable non-blocking behavior, use the `executor`</span>
<span class="ruby-comment">#   constructor option. This will cause the delayed operation to be</span>
<span class="ruby-comment">#   execute on the given executor, allowing the call to timeout.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum number of seconds to wait</span>
<span class="ruby-comment"># @return [Object] the current value of the object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the value this object represents after applying the options</span>
<span class="ruby-comment"># specified by the `#set_deref_options` method. If the delayed operation</span>
<span class="ruby-comment"># raised an exception, this method will raise that exception (even when)</span>
<span class="ruby-comment"># the operation has already been executed).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The default behavior of `Delay` is to block indefinitely when</span>
<span class="ruby-comment">#   calling either `value` or `wait`, executing the delayed operation on</span>
<span class="ruby-comment">#   the current thread. This makes the `timeout` value completely</span>
<span class="ruby-comment">#   irrelevant. To enable non-blocking behavior, use the `executor`</span>
<span class="ruby-comment">#   constructor option. This will cause the delayed operation to be</span>
<span class="ruby-comment">#   execute on the given executor, allowing the call to timeout.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum number of seconds to wait</span>
<span class="ruby-comment"># @raise [Exception] when `#rejected?` raises `#reason`</span>
<span class="ruby-comment"># @return [Object] the current value of the object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the value this object represents after applying the options</span>
<span class="ruby-comment"># specified by the `#set_deref_options` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The default behavior of `Delay` is to block indefinitely when</span>
<span class="ruby-comment">#   calling either `value` or `wait`, executing the delayed operation on</span>
<span class="ruby-comment">#   the current thread. This makes the `timeout` value completely</span>
<span class="ruby-comment">#   irrelevant. To enable non-blocking behavior, use the `executor`</span>
<span class="ruby-comment">#   constructor option. This will cause the delayed operation to be</span>
<span class="ruby-comment">#   execute on the given executor, allowing the call to timeout.</span>
<span class="ruby-comment"># @param timeout [Integer] (nil) the maximum number of seconds to wait for</span>
<span class="ruby-comment">#   the value to be computed. When `nil` the caller will block indefinitely.</span>
<span class="ruby-comment"># @return [Object] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_task_once</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#7 class Concurrent::DependencyCounter</p>

<pre class="ruby"><span class="ruby-comment"># @return [DependencyCounter] a new instance of DependencyCounter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">count</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>(<span class="ruby-identifier">time</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#3 class Concurrent::Error &lt; ::StandardError; end</p>

<p># Old school kernel-style event reminiscent of Win32 programming in C++. # # When an ‘Event` is created it is in the `unset` state. Threads can choose to # `#wait` on the event, blocking until released by another thread. When one # thread wants to alert all blocking threads it calls the `#set` method which # will then wake up all listeners. Once an `Event` has been set it remains set. # New threads calling `#wait` will return immediately. An `Event` may be # `#reset` at any time once it has been set. # # @example #   event = Concurrent::Event.new # #   t1 = Thread.new do #   puts “t1 is waiting” #   event.wait(1) #   puts “event occurred” #   end # #   t2 = Thread.new do #   puts “t2 calling set” #   event.set #   end # #   [t1, t2].each(&amp;:join) # #   # prints: #   # t1 is waiting #   # t2 calling set #   # event occurred # @see <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682655.aspx">msdn.microsoft.com/en-us/library/windows/desktop/ms682655.aspx</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#36 class Concurrent::Event &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new `Event` in the unset state. Threads calling `#wait` on the</span>
<span class="ruby-comment"># `Event` will block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event] a new instance of Event</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reset a previously set event back to the `unset` state.</span>
<span class="ruby-comment"># Has no effect if the `Event` has not yet been set.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] should always return `true`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Trigger the event, setting the state to `set` and releasing all threads</span>
<span class="ruby-comment"># waiting on the event. Has no effect if the `Event` has already been set.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] should always return `true`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the object in the set state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] indicating whether or not the `Event` has been set</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait a given number of seconds for the `Event` to be set by another</span>
<span class="ruby-comment"># thread. Will wait forever when no `timeout` value is given. Returns</span>
<span class="ruby-comment"># immediately if the `Event` has already been set.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the `Event` was set before timeout else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_set</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A synchronization point at which threads can pair and swap elements within # pairs. Each thread presents some object on entry to the exchange method, # matches with a partner thread, and receives its partner’s object on return. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # This implementation is very simple, using only a single slot for each # exchanger (unlike more advanced implementations which use an “arena”). # This approach will work perfectly fine when there are only a few threads # accessing a single ‘Exchanger`. Beyond a handful of threads the performance # will degrade rapidly due to contention on the single slot, but the algorithm # will remain correct. # # @example # #   exchanger = Concurrent::Exchanger.new # #   threads = [ #   Thread.new { puts “first: ” &lt;&lt; exchanger.exchange(’foo’, 1) }, #=&gt; “first: bar” #   Thread.new { puts “second: ” &lt;&lt; exchanger.exchange(‘bar’, 1) } #=&gt; “second: foo” #   ] #   threads.each {|t| t.join(2) } # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/Exchanger.html</a> java.util.concurrent.Exchanger # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#336 class Concurrent::Exchanger &lt; ::Concurrent::RubyExchanger; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#327 Concurrent::ExchangerImplementation = Concurrent::RubyExchanger</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#157 module Concurrent::ExecutorService</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param task [Proc] the asynchronous task to perform</span>
<span class="ruby-comment"># @return [self] returns itself</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does the task queue have a maximum size?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Always returns `false`</span>
<span class="ruby-comment"># @return [Boolean] True if the task queue has a maximum size else false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_overflow?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does this executor guarantee serialization of its operations?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Always returns `false`</span>
<span class="ruby-comment"># @return [Boolean] True if the executor guarantees that all operations</span>
<span class="ruby-comment">#   will be post in the order they are received and no two operations may</span>
<span class="ruby-comment">#   occur simultaneously. Else false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serialized?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A ‘FiberLocalVar` is a variable where the value is different for each fiber. # Each variable may have a default value, but when you modify the variable only # the current fiber will ever see that change. # # This is similar to Ruby’s built-in fiber-local variables (‘<a href=":name">Thread.current</a>`), # but with these major advantages: # * `FiberLocalVar` has its own identity, it doesn’t need a Symbol. # * Each Ruby’s built-in fiber-local variable leaks some memory forever (it’s a Symbol held forever on the fiber), #   so it’s only OK to create a small amount of them. #   ‘FiberLocalVar` has no such issue and it is fine to create many of them. # * Ruby’s built-in fiber-local variables leak forever the value set on each fiber (unless set to nil explicitly). #   ‘FiberLocalVar` automatically removes the mapping for each fiber once the `FiberLocalVar` instance is GC’d. # # @example #   v = FiberLocalVar.new(14) #   v.value #=&gt; 14 #   v.value = 2 #   v.value #=&gt; 2 # @example #   v = FiberLocalVar.new(14) # #   Fiber.new do #   v.value #=&gt; 14 #   v.value = 1 #   v.value #=&gt; 1 #   end.resume # #   Fiber.new do #   v.value #=&gt; 14 #   v.value = 2 #   v.value #=&gt; 2 #   end.resume # #   v.value #=&gt; 14 # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#41 class Concurrent::FiberLocalVar</p>

<pre class="ruby"><span class="ruby-comment"># Creates a fiber local variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default [Object] the default value when otherwise unset</span>
<span class="ruby-comment"># @param default_block [Proc] Optional block that gets called to obtain the</span>
<span class="ruby-comment">#   default value for each fiber</span>
<span class="ruby-comment"># @return [FiberLocalVar] a new instance of FiberLocalVar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">default_block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Bind the given value to fiber local storage during</span>
<span class="ruby-comment"># execution of the given block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to bind</span>
<span class="ruby-comment"># @return [Object] the value</span>
<span class="ruby-comment"># @yield the operation to be performed with the bound variable</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bind</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value in the current fiber&#39;s copy of this fiber-local variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the current fiber&#39;s copy of this fiber-local variable to the specified value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#42 Concurrent::FiberLocalVar::LOCALS = T.let(T.unsafe(nil), Concurrent::FiberLocals)</p>

<p># An array-backed storage of indexed variables per fiber. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#166 class Concurrent::FiberLocals &lt; ::Concurrent::AbstractLocals</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals!</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread pool that reuses a fixed number of threads operating off an unbounded queue. # At any point, at most ‘num_threads` will be active processing tasks. When all threads are busy new # tasks `#post` to the thread pool are enqueued until a thread becomes available. # Should a thread crash for any reason the thread will immediately be removed # from the pool and replaced. # # The API and behavior of this class are based on Java’s ‘FixedThreadPool` # # **Thread Pool Options** # # Thread pools support several configuration options: # # * `idletime`: The number of seconds that a thread may be idle before being reclaimed. # * `name`: The name of the executor (optional). Printed in the executor’s ‘#to_s` output and #   a `&lt;name&gt;-worker-&lt;id&gt;` name is given to its threads if supported by used Ruby #   implementation. `&lt;id&gt;` is uniq for each thread. # * `max_queue`: The maximum number of tasks that may be waiting in the work queue at #   any one time. When the queue size reaches `max_queue` and no new threads can be created, #   subsequent tasks will be rejected in accordance with the configured `fallback_policy`. # * `auto_terminate`: When true (default), the threads started will be marked as daemon. # * `fallback_policy`: The policy defining how rejected tasks are handled. # # Three fallback policies are supported: # # * `:abort`: Raise a `RejectedExecutionError` exception and discard the task. # * `:discard`: Discard the task and return false. # * `:caller_runs`: Execute the task on the calling thread. # # **Shutting Down Thread Pools** # # Killing a thread pool while tasks are still being processed, either by calling # the `#kill` method or at application exit, will have unpredictable results. There # is no way for the thread pool to know what resources are being used by the # in-progress tasks. When those tasks are killed the impact on those resources # cannot be predicted. The <strong>best</strong> practice is to explicitly shutdown all thread # pools using the provided methods: # # * Call `#shutdown` to initiate an orderly termination of all in-progress tasks # * Call `#wait_for_termination` with an appropriate timeout interval an allow #   the orderly shutdown to complete # * Call `#kill` *only when* the thread pool fails to shutdown in the allotted time # # On some runtime platforms (most notably the JVM) the application will not # exit until all thread pools have been shutdown. To prevent applications from # “hanging” on exit, all threads can be marked as daemon according to the # `:auto_terminate` option. # # “`ruby # pool1 = Concurrent::FixedThreadPool.new(5) # threads will be marked as daemon # pool2 = Concurrent::FixedThreadPool.new(5, auto_terminate: false) # mark threads as non-daemon # “` # # @note Failure to properly shutdown a thread pool can lead to unpredictable results. #   Please read *Shutting Down Thread Pools* for more information. # @see <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">docs.oracle.com/javase/tutorial/essential/concurrency/pools.html</a> Java Tutorials: Thread Pools # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html</a> Java Executors class # @see <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</a> Java ExecutorService interface # @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean">docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean</a>- # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/fixed_thread_pool.rb#201 class Concurrent::FixedThreadPool &lt; ::Concurrent::ThreadPoolExecutor</p>

<pre class="ruby"><span class="ruby-comment"># Create a new thread pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param num_threads [Integer] the number of threads to allocate</span>
<span class="ruby-comment"># @param opts [Hash] the options defining pool behavior.</span>
<span class="ruby-comment"># @raise [ArgumentError] if `num_threads` is less than or equal to zero</span>
<span class="ruby-comment"># @raise [ArgumentError] if `fallback_policy` is not a known policy</span>
<span class="ruby-comment"># @return [FixedThreadPool] a new instance of FixedThreadPool</span>
<span class="ruby-comment"># @see http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/fixed_thread_pool.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">num_threads</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># {include:file:docs-source/future.md} # # @see <a href="http://ruby-doc.org/stdlib-2.1.1/libdoc/observer/rdoc/Observable.html">ruby-doc.org/stdlib-2.1.1/libdoc/observer/rdoc/Observable.html</a> Ruby Observable module # @see <a href="http://clojuredocs.org/clojure_core/clojure.core/future">clojuredocs.org/clojure_core/clojure.core/future</a> Clojure’s future function # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html</a> java.util.concurrent.Future # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#21 class Concurrent::Future &lt; ::Concurrent::IVar</p>

<pre class="ruby"><span class="ruby-comment"># Create a new `Future` in the `:unscheduled` state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
<span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
<span class="ruby-comment"># @return [Future] a new instance of Future</span>
<span class="ruby-comment"># @yield the asynchronous operation to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attempt to cancel the operation if it has not already processed.</span>
<span class="ruby-comment"># The operation can only be cancelled while still `pending`. It cannot</span>
<span class="ruby-comment"># be cancelled once it has begun processing or has completed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] was the operation successfully cancelled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancel</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Has the operation been successfully cancelled?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancelled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute an `:unscheduled` `Future`. Immediately sets the state to `:pending` and</span>
<span class="ruby-comment"># passes the block to a new thread/thread pool for eventual execution.</span>
<span class="ruby-comment"># Does nothing if the `Future` is in any state other than `:unscheduled`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example Instance and execute in separate steps</span>
<span class="ruby-comment">#   future = Concurrent::Future.new{ sleep(1); 42 }</span>
<span class="ruby-comment">#   future.state #=&gt; :unscheduled</span>
<span class="ruby-comment">#   future.execute</span>
<span class="ruby-comment">#   future.state #=&gt; :pending</span>
<span class="ruby-comment"># @example Instance and execute in one line</span>
<span class="ruby-comment">#   future = Concurrent::Future.new{ sleep(1); 42 }.execute</span>
<span class="ruby-comment">#   future.state #=&gt; :pending</span>
<span class="ruby-comment"># @return [Future] a reference to `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait the given number of seconds for the operation to complete.</span>
<span class="ruby-comment"># On timeout attempt to cancel the operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in seconds to wait.</span>
<span class="ruby-comment"># @return [Boolean] true if the operation completed before the timeout</span>
<span class="ruby-comment">#   else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_or_cancel</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Create a new `Future` object with the given block, execute it, and return the</span>
  <span class="ruby-comment"># `:pending` object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example</span>
  <span class="ruby-comment">#   future = Concurrent::Future.execute{ sleep(1); 42 }</span>
  <span class="ruby-comment">#   future.state #=&gt; :pending</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @return [Future] the newly created `Future` in the `:pending` state</span>
  <span class="ruby-comment"># @yield the asynchronous operation to perform</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#77</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#18 Concurrent::GLOBAL_FAST_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#30 Concurrent::GLOBAL_IMMEDIATE_EXECUTOR = T.let(T.unsafe(nil), Concurrent::ImmediateExecutor)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#22 Concurrent::GLOBAL_IO_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#111 Concurrent::GLOBAL_LOGGER = T.let(T.unsafe(nil), Concurrent::AtomicReference)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#26 Concurrent::GLOBAL_TIMER_SET = T.let(T.unsafe(nil), Concurrent::Delay)</p>

<p># A thread-safe subclass of Hash. This version locks against the object # itself for every method call, ensuring only one thread can be reading # or writing at a time. This includes iteration methods like ‘#each`, # which takes the lock repeatedly when reading an item. # # @see <a href="http://ruby-doc.org/core/Hash.html">ruby-doc.org/core/Hash.html</a> Ruby standard library `Hash` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/hash.rb#49 class Concurrent::Hash &lt; ::Hash; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/hash.rb#16 Concurrent::HashImplementation = Hash</p>

<p># An ‘IVar` is like a future that you can assign. As a future is a value that # is being computed that you can wait on, an `IVar` is a value that is waiting # to be assigned, that you can wait on. `IVars` are single assignment and # deterministic. # # Then, express futures as an asynchronous computation that assigns an `IVar`. # The `IVar` becomes the primitive on which [futures](Future) and # [dataflow](Dataflow) are built. # # An `IVar` is a single-element container that is normally created empty, and # can only be set once. The I in `IVar` stands for immutable. Reading an # `IVar` normally blocks until it is set. It is safe to set and read an `IVar` # from different threads. # # If you want to have some parallel task set the value in an `IVar`, you want # a `Future`. If you want to create a graph of parallel tasks all executed # when the values they depend on are ready you want `dataflow`. `IVar` is # generally a low-level primitive. # # ## Examples # # Create, set and get an `IVar` # # “`ruby # ivar = Concurrent::IVar.new # ivar.set 14 # ivar.value #=&gt; 14 # ivar.set 2 # would now be an error # “` # # ## See Also # # 1. For the theory: Arvind, R. Nikhil, and K. Pingali. #    [I-Structures: Data structures for parallel computing](<a href="http://dl.acm.org/citation.cfm?id=69562">dl.acm.org/citation.cfm?id=69562</a>). #    In Proceedings of Workshop on Graph Reduction, 1986. # 2. For recent application: #    [DataDrivenFuture in Habanero Java from Rice](<a href="http://www.cs.rice.edu/~vs3/hjlib/doc/edu/rice/hj/api/HjDataDrivenFuture.html">www.cs.rice.edu/~vs3/hjlib/doc/edu/rice/hj/api/HjDataDrivenFuture.html</a>). # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#48 class Concurrent::IVar &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Dereferenceable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Obligation</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Observable</span>

<span class="ruby-comment"># Create a new `IVar` in the `:pending` state with the (optional) initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param value [Object] the initial value</span>
<span class="ruby-comment"># @param opts [Hash] the options to create a message with</span>
<span class="ruby-comment"># @return [IVar] a new instance of IVar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add an observer on this object that will receive notification on update.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Upon completion the `IVar` will notify all observers in a thread-safe way.</span>
<span class="ruby-comment"># The `func` method of the observer will be called with three arguments: the</span>
<span class="ruby-comment"># `Time` at which the `Future` completed the asynchronous operation, the</span>
<span class="ruby-comment"># final `value` (or `nil` on rejection), and the final `reason` (or `nil` on</span>
<span class="ruby-comment"># fulfillment).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param observer [Object] the object that will be notified of changes</span>
<span class="ruby-comment"># @param func [Symbol] symbol naming the method to call when this</span>
<span class="ruby-comment">#   `Observable` has changes`</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_observer</span>(<span class="ruby-identifier">observer</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">func</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the `IVar` to failed due to some error and wake or notify all threads waiting on it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param reason [Object] for the failure</span>
<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already</span>
<span class="ruby-comment">#   been set or otherwise completed</span>
<span class="ruby-comment"># @return [IVar] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fail</span>(<span class="ruby-identifier">reason</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the `IVar` to a value and wake or notify all threads waiting on it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to store in the `IVar`</span>
<span class="ruby-comment"># @raise [ArgumentError] if both a value and a block are given</span>
<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already</span>
<span class="ruby-comment">#   been set or otherwise completed</span>
<span class="ruby-comment"># @return [IVar] self</span>
<span class="ruby-comment"># @yield A block operation to use for setting the value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attempt to set the `IVar` with the given value or block. Return a</span>
<span class="ruby-comment"># boolean indicating the success or failure of the set operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to store in the `IVar`</span>
<span class="ruby-comment"># @raise [ArgumentError] if both a value and a block are given</span>
<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already</span>
<span class="ruby-comment">#   been set or otherwise completed</span>
<span class="ruby-comment"># @return [Boolean] true if the value was set else false</span>
<span class="ruby-comment"># @yield A block operation to use for setting the value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_block_or_value!</span>(<span class="ruby-identifier">block_given</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete_without_notification</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_observers</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [MultipleAssignmentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_complete_without_notification</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_execute</span>(<span class="ruby-identifier">task</span>, <span class="ruby-identifier">args</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when an operation is attempted which is not legal given the # receiver’s current state # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#20 class Concurrent::IllegalOperationError &lt; ::Concurrent::Error; end</p>

<p># An executor service which runs all operations on the current thread, # blocking as necessary. Operations are performed in the order they are # received and no two operations can be performed simultaneously. # # This executor service exists mainly for testing an debugging. When used # it immediately runs every ‘#post` operation on the current thread, blocking # that thread until the operation is complete. This can be very beneficial # during testing because it makes all operations deterministic. # # @note Intended for use primarily in testing and debugging. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#17 class Concurrent::ImmediateExecutor &lt; ::Concurrent::AbstractExecutorService</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">SerialExecutorService</span>

<span class="ruby-comment"># Creates a new executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ImmediateExecutor] a new instance of ImmediateExecutor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param task [Proc] the asynchronous task to perform</span>
<span class="ruby-comment"># @return [self] returns itself</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an orderly shutdown. Tasks already in the queue will be executed,</span>
<span class="ruby-comment"># but no new tasks will be accepted. Has no additional effect if the</span>
<span class="ruby-comment"># thread pool is not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor running?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when running, `false` when shutting down or shutdown</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an orderly shutdown. Tasks already in the queue will be executed,</span>
<span class="ruby-comment"># but no new tasks will be accepted. Has no additional effect if the</span>
<span class="ruby-comment"># thread pool is not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor shutdown?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when shutdown, `false` when shutting down or running</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor shuttingdown?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when not running and not shutdown, else `false`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuttingdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Block until executor shutdown is complete or until `timeout` seconds have</span>
<span class="ruby-comment"># passed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Does not initiate shutdown or termination. Either `shutdown` or `kill`</span>
<span class="ruby-comment">#   must be called before this method (or on another thread).</span>
<span class="ruby-comment"># @param timeout [Integer] the maximum number of seconds to wait for shutdown to complete</span>
<span class="ruby-comment"># @return [Boolean] `true` if shutdown complete or false on `timeout`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_termination</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when an attempt is made to violate an immutability guarantee. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#16 class Concurrent::ImmutabilityError &lt; ::Concurrent::Error; end</p>

<p># A thread-safe, immutable variation of Ruby’s standard ‘Struct`. # # @see <a href="http://ruby-doc.org/core/Struct.html">ruby-doc.org/core/Struct.html</a> Ruby standard library `Struct` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#9 module Concurrent::ImmutableStruct</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">AbstractStruct</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">member</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">other</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indexes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">original</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#92 Concurrent::ImmutableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)</p>

<p># An executor service which runs all operations on a new thread, blocking # until it completes. Operations are performed in the order they are received # and no two operations can be performed simultaneously. # # This executor service exists mainly for testing an debugging. When used it # immediately runs every ‘#post` operation on a new thread, blocking the # current thread until the operation is complete. This is similar to how the # ImmediateExecutor works, but the operation has the full stack of the new # thread at its disposal. This can be helpful when the operations will spawn # more operations on the same executor and so on - such a situation might # overflow the single stack in case of an ImmediateExecutor, which is # inconsistent with how it would behave for a threaded executor. # # @note Intended for use primarily in testing and debugging. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#19 class Concurrent::IndirectImmediateExecutor &lt; ::Concurrent::ImmediateExecutor</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [IndirectImmediateExecutor] a new instance of IndirectImmediateExecutor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when an object’s methods are called when it has not been # properly initialized. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#24 class Concurrent::InitializationError &lt; ::Concurrent::Error; end</p>

<p># Raised when a lifecycle method (such as ‘stop`) is called in an improper # sequence or when the object is in an inappropriate state. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#13 class Concurrent::LifecycleError &lt; ::Concurrent::Error; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#6 class Concurrent::LockFreeStack &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [LockFreeStack] a new instance of LockFreeStack</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">head</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield over the cleared stack</span>
<span class="ruby-comment"># @yieldparam value [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_if</span>(<span class="ruby-identifier">head</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_clear</span>(<span class="ruby-identifier">head</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_pop</span>(<span class="ruby-identifier">head</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_push</span>(<span class="ruby-identifier">head</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-identifier">head</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>(<span class="ruby-identifier">head</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">peek</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param head [Node]</span>
<span class="ruby-comment"># @param new_head [Node]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_if</span>(<span class="ruby-identifier">head</span>, <span class="ruby-identifier">new_head</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_head</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">head=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_head</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_head</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#41</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">of1</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#46</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">of2</span>(<span class="ruby-identifier">value1</span>, <span class="ruby-identifier">value2</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The singleton for empty node # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#32 Concurrent::LockFreeStack::EMPTY = T.let(T.unsafe(nil), Concurrent::LockFreeStack::Node)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#10 class Concurrent::LockFreeStack::Node</p>

<pre class="ruby"><span class="ruby-comment"># @return [Node] a new instance of Node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">next_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># allow to nil-ify to free GC when the entry is no longer relevant, not synchronised</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Either {FiberLocalVar} or {ThreadLocalVar} depending on whether Mutex (and Monitor) # are held, respectively, per Fiber or per Thread. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/lock_local_var.rb#21 Concurrent::LockLocalVar = Concurrent::FiberLocalVar</p>

<p># An ‘MVar` is a synchronized single element container. They are empty or # contain one item. Taking a value from an empty `MVar` blocks, as does # putting a value into a full one. You can either think of them as blocking # queue of length one, or a special kind of mutable variable. # # On top of the fundamental `#put` and `#take` operations, we also provide a # `#mutate` that is atomic with respect to operations on the same instance. # These operations all support timeouts. # # We also support non-blocking operations `#try_put!` and `#try_take!`, a # `#set!` that ignores existing values, a `#value` that returns the value # without removing it or returns `MVar::EMPTY`, and a `#modify!` that yields # `MVar::EMPTY` if the `MVar` is empty and can be used to set `MVar::EMPTY`. # You shouldn’t use these operations in the first instance. # # ‘MVar` is a [Dereferenceable](Dereferenceable). # # `MVar` is related to M-structures in Id, `MVar` in Haskell and `SyncVar` in Scala. # # Note that unlike the original Haskell paper, our `#take` is blocking. This is how # Haskell and Scala do it today. # # ## See Also # # 1. P. Barth, R. Nikhil, and Arvind. [M-Structures: Extending a parallel, non- strict, functional language with state](<a href="http://dl.acm.org/citation.cfm?id=652538">dl.acm.org/citation.cfm?id=652538</a>). In Proceedings of the 5th #    ACM Conference on Functional Programming Languages and Computer Architecture (FPCA), 1991. # # 2. S. Peyton Jones, A. Gordon, and S. Finne. [Concurrent Haskell](<a href="http://dl.acm.org/citation.cfm?id=237794">dl.acm.org/citation.cfm?id=237794</a>). #    In Proceedings of the 23rd Symposium on Principles of Programming Languages #    (PoPL), 1996. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#38 class Concurrent::MVar &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Dereferenceable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new `MVar`, either empty or with an initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param opts [Hash] the options controlling how the future will be processed</span>
<span class="ruby-comment"># @return [MVar] a new instance of MVar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># acquires lock on the from an `MVAR`, yields the value to provided block,</span>
<span class="ruby-comment"># and release lock. A timeout can be set to limit the time spent blocked,</span>
<span class="ruby-comment"># in which case it returns `TIMEOUT` if the time is exceeded.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the value returned by the block, or `TIMEOUT`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">borrow</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns if the `MVar` is currently empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns if the `MVar` currently contains a value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">full?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically `take`, yield the value to a block for transformation, and then</span>
<span class="ruby-comment"># `put` the transformed value. Returns the transformed value. A timeout can</span>
<span class="ruby-comment"># be set to limit the time spent blocked, in which case it returns `TIMEOUT`</span>
<span class="ruby-comment"># if the time is exceeded.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [Object] the transformed value, or `TIMEOUT`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modify</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Non-blocking version of `modify` that will yield with `EMPTY` if there is no value yet.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modify!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Put a value into an `MVar`, blocking if there is already a value until</span>
<span class="ruby-comment"># it is empty. A timeout can be set to limit the time spent blocked, in</span>
<span class="ruby-comment"># which case it returns `TIMEOUT` if the time is exceeded.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the value that was put, or `TIMEOUT`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">put</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Non-blocking version of `put` that will overwrite an existing value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set!</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Remove the value from an `MVar`, leaving it empty, and blocking if there</span>
<span class="ruby-comment"># isn&#39;t a value. A timeout can be set to limit the time spent blocked, in</span>
<span class="ruby-comment"># which case it returns `TIMEOUT` if the time is exceeded.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the value that was taken, or `TIMEOUT`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">take</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Non-blocking version of `put`, that returns whether or not it was successful.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_put!</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Non-blocking version of `take`, that returns `EMPTY` instead of blocking.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_take!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unlocked_empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unlocked_full?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_empty</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_full</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_while</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Unique value that represents that an ‘MVar` was empty # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#43 Concurrent::MVar::EMPTY = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># Unique value that represents that an ‘MVar` timed out before it was able # to produce a value. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#47 Concurrent::MVar::TIMEOUT = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># ‘Concurrent::Map` is a hash-like object and should have much better performance # characteristics, especially under high concurrency, than `Concurrent::Hash`. # However, `Concurrent::Map `is not strictly semantically equivalent to a ruby `Hash` # – for instance, it does not necessarily retain ordering by insertion time as `Hash` # does. For most uses it should do fine though, and we recommend you consider # `Concurrent::Map` instead of `Concurrent::Hash` for your concurrency-safe hash needs. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#39 class Concurrent::Map &lt; ::Concurrent::Collection::MriMapBackend</p>

<pre class="ruby"><span class="ruby-comment"># Iterates over each key value pair.</span>
<span class="ruby-comment"># This method is atomic.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Atomic methods taking a block do not allow the `self` instance</span>
<span class="ruby-comment">#   to be used within the block. Doing so will cause a deadlock.</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield for each key value pair in the map</span>
<span class="ruby-comment"># @yieldparam key [Object]</span>
<span class="ruby-comment"># @yieldparam value [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Iterates over each key.</span>
<span class="ruby-comment"># This method is atomic.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Atomic methods taking a block do not allow the `self` instance</span>
<span class="ruby-comment">#   to be used within the block. Doing so will cause a deadlock.</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield for each key in the map</span>
<span class="ruby-comment"># @yieldparam key [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Iterates over each key value pair.</span>
<span class="ruby-comment"># This method is atomic.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Atomic methods taking a block do not allow the `self` instance</span>
<span class="ruby-comment">#   to be used within the block. Doing so will cause a deadlock.</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield for each key value pair in the map</span>
<span class="ruby-comment"># @yieldparam key [Object]</span>
<span class="ruby-comment"># @yieldparam value [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Iterates over each value.</span>
<span class="ruby-comment"># This method is atomic.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Atomic methods taking a block do not allow the `self` instance</span>
<span class="ruby-comment">#   to be used within the block. Doing so will cause a deadlock.</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield for each value in the map</span>
<span class="ruby-comment"># @yieldparam value [Object]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is map empty?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#291</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Get a value with key, or default_value when key is absent,</span>
<span class="ruby-comment"># or fail when no default_value is given.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note The &quot;fetch-then-act&quot; methods of `Map` are not atomic. `Map` is intended</span>
<span class="ruby-comment">#   to be use as a concurrency primitive with strong happens-before</span>
<span class="ruby-comment">#   guarantees. It is not intended to be used as a high-level abstraction</span>
<span class="ruby-comment">#   supporting complex operations. All read and write operations are</span>
<span class="ruby-comment">#   thread safe, but no guarantees are made regarding race conditions</span>
<span class="ruby-comment">#   between the fetch operation and yielding to the block. Additionally,</span>
<span class="ruby-comment">#   this method does not support recursion. This is due to internal</span>
<span class="ruby-comment">#   constraints that are very unlikely to change in the near future.</span>
<span class="ruby-comment"># @param key [Object]</span>
<span class="ruby-comment"># @param default_value [Object]</span>
<span class="ruby-comment"># @raise [KeyError] when key is missing and no default_value is provided</span>
<span class="ruby-comment"># @return [Object] the value or default value</span>
<span class="ruby-comment"># @yield default value for a key</span>
<span class="ruby-comment"># @yieldparam key [Object]</span>
<span class="ruby-comment"># @yieldreturn [Object] default value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">default_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Fetch value with key, or store default value when key is absent,</span>
<span class="ruby-comment"># or fail when no default_value is given. This is a two step operation,</span>
<span class="ruby-comment"># therefore not atomic. The store can overwrite other concurrently</span>
<span class="ruby-comment"># stored value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param key [Object]</span>
<span class="ruby-comment"># @param default_value [Object]</span>
<span class="ruby-comment"># @return [Object] the value or default value</span>
<span class="ruby-comment"># @yield default value for a key</span>
<span class="ruby-comment"># @yieldparam key [Object]</span>
<span class="ruby-comment"># @yieldreturn [Object] default value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch_or_store</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">default_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Get a value with key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param key [Object]</span>
<span class="ruby-comment"># @return [Object] the value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#321</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Find key of a value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [Object, nil] key or nil when not found</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># All keys</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [::Array&lt;Object&gt;] keys</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [TypeError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marshal_dump</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marshal_load</span>(<span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set a value with key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param key [Object]</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">put</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Insert value into map with key if key is absent in one atomic step.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param key [Object]</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [Object, nil] the previous value when key was present or nil when there was no key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">put_if_absent</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the value stored in the map. Iterates over all values.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># All values</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [::Array&lt;Object&gt;] values</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">populate_from</span>(<span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [KeyError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raise_fetch_no_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_options_hash!</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when an object with a start/stop lifecycle has been started an # excessive number of times. Often used in conjunction with a restart # policy or strategy. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#29 class Concurrent::MaxRestartFrequencyError &lt; ::Concurrent::Error; end</p>

<p># A ‘Maybe` encapsulates an optional value. A `Maybe` either contains a value # of (represented as `Just`), or it is empty (represented as `Nothing`). Using # `Maybe` is a good way to deal with errors or exceptional cases without # resorting to drastic measures such as exceptions. # # `Maybe` is a replacement for the use of `nil` with better type checking. # # For compatibility with {Concurrent::Concern::Obligation} the predicate and # accessor methods are aliased as `fulfilled?`, `rejected?`, `value`, and # `reason`. # # ## Motivation # # A common pattern in languages with pattern matching, such as Erlang and # Haskell, is to return <strong>either</strong> a value <strong>or</strong> an error from a function # Consider this Erlang code: # # “`erlang # case file:consult(“data.dat”) of #   {ok, Terms} -&gt; do_something_useful(Terms); #   {error, Reason} -&gt; lager:error(Reason) # end. # “` # # In this example the standard library function `file:consult` returns a # [tuple](<a href="http://erlang.org/doc/reference_manual/data_types.html#id69044">erlang.org/doc/reference_manual/data_types.html#id69044</a>) # with two elements: an [atom](<a href="http://erlang.org/doc/reference_manual/data_types.html#id64134">erlang.org/doc/reference_manual/data_types.html#id64134</a>) # (similar to a ruby symbol) and a variable containing ancillary data. On # success it returns the atom `ok` and the data from the file. On failure it # returns `error` and a string with an explanation of the problem. With this # pattern there is no ambiguity regarding success or failure. If the file is # empty the return value cannot be misinterpreted as an error. And when an # error occurs the return value provides useful information. # # In Ruby we tend to return `nil` when an error occurs or else we raise an # exception. Both of these idioms are problematic. Returning `nil` is # ambiguous because `nil` may also be a valid value. It also lacks # information pertaining to the nature of the error. Raising an exception # is both expensive and usurps the normal flow of control. All of these # problems can be solved with the use of a `Maybe`. # # A `Maybe` is unambiguous with regard to whether or not it contains a value. # When `Just` it contains a value, when `Nothing` it does not. When `Just` # the value it contains may be `nil`, which is perfectly valid. When # `Nothing` the reason for the lack of a value is contained as well. The # previous Erlang example can be duplicated in Ruby in a principled way by # having functions return `Maybe` objects: # # “`ruby # result = MyFileUtils.consult(“data.dat”) # returns a Maybe # if result.just? #   do_something_useful(result.value)      # or result.just # else #   logger.error(result.reason)            # or result.nothing # end # “` # # @example Returning a Maybe from a Function #   module MyFileUtils #   def self.consult(path) #   file = File.open(path, ’r’) #   Concurrent::Maybe.just(file.read) #   rescue =&gt; ex #   return Concurrent::Maybe.nothing(ex) #   ensure #   file.close if file #   end #   end # #   maybe = MyFileUtils.consult(‘bogus.file’) #   maybe.just?    #=&gt; false #   maybe.nothing? #=&gt; true #   maybe.reason   #=&gt; #<Errno::ENOENT: No such file or directory @ rb_sysopen - bogus.file&gt; # #   maybe = MyFileUtils.consult(&#39;README.md&#39;) #   maybe.just?    #=&gt; true #   maybe.nothing? #=&gt; false #   maybe.value    #=&gt; &quot;# Concurrent Ruby\n[![Gem Version...&quot; # @example Using Maybe with a Block #   result = Concurrent::Maybe.from do #   Client.find(10) # Client is an ActiveRecord model #   end # #   # -- if the record was found #   result.just? #=&gt; true #   result.value #=&gt; #<Client id: 10, first_name: &quot;Ryan&quot;&gt; # #   # -- if the record was not found #   result.just?  #=&gt; false #   result.reason #=&gt; ActiveRecord::RecordNotFound # @example Using Maybe with the Null <a href="../../../Object.html"><code>Object</code></a> Pattern #   # In a Rails controller… #   result = ClientService.new(10).find    # returns a Maybe #   render json: result.or(NullClient.new) # @see <a href="https://hackage.haskell.org/package/base-4.2.0.1/docs/Data-Maybe.html">hackage.haskell.org/package/base-4.2.0.1/docs/Data-Maybe.html</a> Haskell Data.Maybe # @see <a href="https://github.com/purescript/purescript-maybe/blob/master/docs/Data.Maybe.md">github.com/purescript/purescript-maybe/blob/master/docs/Data.Maybe.md</a> PureScript Data.Maybe # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#104 class Concurrent::Maybe &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new `Maybe` with the given attributes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param just [Object] The value when `Just` else `NONE`.</span>
<span class="ruby-comment"># @param nothing [Exception, Object] The exception when `Nothing` else `NONE`.</span>
<span class="ruby-comment"># @return [Maybe] The new `Maybe`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">just</span>, <span class="ruby-identifier">nothing</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Comparison operator.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] 0 if self and other are both `Nothing`;</span>
<span class="ruby-comment">#   -1 if self is `Nothing` and other is `Just`;</span>
<span class="ruby-comment">#   1 if self is `Just` and other is nothing;</span>
<span class="ruby-comment">#   `self.just &lt;=&gt; other.just` if both self and other are `Just`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is this `Maybe` a `Just` (successfully fulfilled with a value)?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] True if `Just` or false if `Nothing`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The value of a `Maybe` when `Just`. Will be `NONE` when `Nothing`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">just</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is this `Maybe` a `Just` (successfully fulfilled with a value)?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] True if `Just` or false if `Nothing`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">just?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The reason for the `Maybe` when `Nothing`. Will be `NONE` when `Just`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nothing</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is this `Maybe` a `nothing` (rejected with an exception upon fulfillment)?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] True if `Nothing` or false if `Just`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nothing?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return either the value of self or the given default value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] The value of self when `Just`; else the given default.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">or</span>(<span class="ruby-identifier ruby-title">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The reason for the `Maybe` when `Nothing`. Will be `NONE` when `Just`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is this `Maybe` a `nothing` (rejected with an exception upon fulfillment)?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] True if `Nothing` or false if `Just`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The value of a `Maybe` when `Just`. Will be `NONE` when `Nothing`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Create a new `Maybe` using the given block.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Runs the given block passing all function arguments to the block as block</span>
  <span class="ruby-comment"># arguments. If the block runs to completion without raising an exception</span>
  <span class="ruby-comment"># a new `Just` is created with the value set to the return value of the</span>
  <span class="ruby-comment"># block. If the block raises an exception a new `Nothing` is created with</span>
  <span class="ruby-comment"># the reason being set to the raised exception.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param args [Array&lt;Object&gt;] Zero or more arguments to pass to the block.</span>
  <span class="ruby-comment"># @raise [ArgumentError] when no block given.</span>
  <span class="ruby-comment"># @return [Maybe] The newly created object.</span>
  <span class="ruby-comment"># @yield The block from which to create a new `Maybe`.</span>
  <span class="ruby-comment"># @yieldparam args [Array&lt;Object&gt;] Zero or more block arguments passed as</span>
  <span class="ruby-comment">#   arguments to the function.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#137</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a new `Just` with the given value.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value [Object] The value to set for the new `Maybe` object.</span>
  <span class="ruby-comment"># @return [Maybe] The newly created object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#152</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">just</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a new `Nothing` with the given (optional) reason.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param error [Exception] The reason to set for the new `Maybe` object.</span>
  <span class="ruby-comment">#   When given a string a new `StandardError` will be created with the</span>
  <span class="ruby-comment">#   argument as the message. When no argument is given a new</span>
  <span class="ruby-comment">#   `StandardError` with an empty message will be created.</span>
  <span class="ruby-comment"># @return [Maybe] The newly created object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#164</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nothing</span>(<span class="ruby-identifier">error</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#119</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Indicates that the given attribute has not been set. # When ‘Just` the {#nothing} getter will return `NONE`. # When `Nothing` the {#just} getter will return `NONE`. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#111 Concurrent::Maybe::NONE = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># Raised when an attempt is made to modify an immutable object # (such as an ‘IVar`) after its final state has been set. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#33 class Concurrent::MultipleAssignmentError &lt; ::Concurrent::Error</p>

<pre class="ruby"><span class="ruby-comment"># @return [MultipleAssignmentError] a new instance of MultipleAssignmentError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">inspection_data</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute inspection_data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspection_data</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Aggregates multiple exceptions. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#58 class Concurrent::MultipleErrors &lt; ::Concurrent::Error</p>

<pre class="ruby"><span class="ruby-comment"># @return [MultipleErrors] a new instance of MultipleErrors</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">errors</span>, <span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute errors.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An thread-safe variation of Ruby’s standard ‘Struct`. Values can be set at # construction or safely changed at any time during the object’s lifecycle. # # @see <a href="http://ruby-doc.org/core/Struct.html">ruby-doc.org/core/Struct.html</a> Ruby standard library ‘Struct` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#10 module Concurrent::MutableStruct</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">AbstractStruct</span>

<span class="ruby-comment"># Equality</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if other has the same struct subclass and has</span>
<span class="ruby-comment">#   equal member values (according to `Object#==`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attribute Reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param member [Symbol, String, Integer] the string or symbol name of the member</span>
<span class="ruby-comment">#   for which to obtain the value or the member&#39;s index</span>
<span class="ruby-comment"># @raise [NameError] if the member does not exist</span>
<span class="ruby-comment"># @raise [IndexError] if the index is out of range.</span>
<span class="ruby-comment"># @return [Object] the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">member</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attribute Assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Sets the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param member [Symbol, String, Integer] the string or symbol name of the member</span>
<span class="ruby-comment">#   for which to obtain the value or the member&#39;s index</span>
<span class="ruby-comment"># @raise [NameError] if the name does not exist</span>
<span class="ruby-comment"># @raise [IndexError] if the index is out of range.</span>
<span class="ruby-comment"># @return [Object] the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">member</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the value of each struct member in order. If no block is given</span>
<span class="ruby-comment"># an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the name and value of each struct member in order. If no block is</span>
<span class="ruby-comment"># given an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member/value pair</span>
<span class="ruby-comment"># @yieldparam member [Object] each struct member (in order)</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Describe the contents of this struct in a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the contents of this struct in a string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a new struct containing the contents of `other` and the contents</span>
<span class="ruby-comment"># of `self`. If no block is specified, the value for entries with duplicate</span>
<span class="ruby-comment"># keys will be that of `other`. Otherwise the value for each duplicate key</span>
<span class="ruby-comment"># is determined by calling the block with the key, its value in `self` and</span>
<span class="ruby-comment"># its value in `other`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param other [Hash] the hash from which to set the new values</span>
<span class="ruby-comment"># @raise [ArgumentError] of given a member that is not defined in the struct</span>
<span class="ruby-comment"># @return [Synchronization::AbstractStruct] a new struct with the new values</span>
<span class="ruby-comment"># @yield an options block for resolving duplicate keys</span>
<span class="ruby-comment"># @yieldparam member [String, Symbol] the name of the member which is duplicated</span>
<span class="ruby-comment"># @yieldparam selfvalue [Object] the value of the member in `self`</span>
<span class="ruby-comment"># @yieldparam othervalue [Object] the value of the member in `other`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">other</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields each member value from the struct to the block and returns an Array</span>
<span class="ruby-comment"># containing the member values from the struct for which the given block</span>
<span class="ruby-comment"># returns a true value (equivalent to `Enumerable#select`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] an array containing each value for which the block returns true</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the values for this struct as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the values for this struct</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a hash containing the names and values for the struct’s members.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Hash] the names and values for the struct’s members</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Describe the contents of this struct in a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the contents of this struct in a string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the values for this struct as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the values for this struct</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the struct member values for each selector as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A selector may be either an Integer offset or a Range of offsets (as in `Array#values_at`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param indexes [Fixnum, Range] the index(es) from which to obatin the values (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indexes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">original</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Factory for creating new struct classes.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ```</span>
  <span class="ruby-comment"># new([class_name] [, member_name]+&gt;) -&gt; StructClass click to toggle source</span>
  <span class="ruby-comment"># new([class_name] [, member_name]+&gt;) {|StructClass| block } -&gt; StructClass</span>
  <span class="ruby-comment"># new(value, ...) -&gt; obj</span>
  <span class="ruby-comment"># StructClass[value, ...] -&gt; obj</span>
  <span class="ruby-comment"># ```</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The first two forms are used to create a new struct subclass `class_name`</span>
  <span class="ruby-comment"># that can contain a value for each   member_name . This subclass can be</span>
  <span class="ruby-comment"># used to create instances of the structure like any other  Class .</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If the `class_name` is omitted an anonymous struct class will be created.</span>
  <span class="ruby-comment"># Otherwise, the name of this struct will appear as a constant in the struct class,</span>
  <span class="ruby-comment"># so it must be unique for all structs under this base class and must start with a</span>
  <span class="ruby-comment"># capital letter. Assigning a struct class to a constant also gives the class</span>
  <span class="ruby-comment"># the name of the constant.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If a block is given it will be evaluated in the context of `StructClass`, passing</span>
  <span class="ruby-comment"># the created class as a parameter. This is the recommended way to customize a struct.</span>
  <span class="ruby-comment"># Subclassing an anonymous struct creates an extra anonymous class that will never be used.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The last two forms create a new instance of a struct subclass. The number of value</span>
  <span class="ruby-comment"># parameters must be less than or equal to the number of attributes defined for the</span>
  <span class="ruby-comment"># struct. Unset parameters default to nil. Passing more parameters than number of attributes</span>
  <span class="ruby-comment"># will raise an `ArgumentError`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see http://ruby-doc.org/core/Struct.html#method-c-new Ruby standard library `Struct#new`</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#210</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#220 Concurrent::MutableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)</p>

<p># A boolean value that can be updated atomically. Reads and writes to an atomic # boolean and thread-safe and guaranteed to succeed. Reads and writes may block # briefly but no explicit locking is required. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # Performance: # # “‘ # Testing with ruby 2.1.2 # Testing with Concurrent::MutexAtomicBoolean… #   2.790000   0.000000   2.790000 (  2.791454) # Testing with Concurrent::CAtomicBoolean… #   0.740000   0.000000   0.740000 (  0.740206) # # Testing with jruby 1.9.3 # Testing with Concurrent::MutexAtomicBoolean… #   5.240000   2.520000   7.760000 (  3.683000) # Testing with Concurrent::JavaAtomicBoolean… #   3.340000   0.010000   3.350000 (  0.855000) # “` # # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicBoolean.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicBoolean.html</a> java.util.concurrent.atomic.AtomicBoolean # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#8 class Concurrent::MutexAtomicBoolean</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Creates a new `AtomicBoolean` with the given initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param initial [Boolean] the initial value</span>
<span class="ruby-comment"># @return [MutexAtomicBoolean] a new instance of MutexAtomicBoolean</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">initial</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the current value `false`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the current value is `false`, else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">false?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Explicitly sets the value to false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if value has changed, otherwise false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_false</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Explicitly sets the value to true.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if value has changed, otherwise false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_true</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the current value `true`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the current value is `true`, else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">true?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves the current `Boolean` value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Explicitly sets the value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Boolean] the new value to be set</span>
<span class="ruby-comment"># @return [Boolean] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_make_value</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A numeric value that can be updated atomically. Reads and writes to an atomic # fixnum and thread-safe and guaranteed to succeed. Reads and writes may block # briefly but no explicit locking is required. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # Performance: # # “‘ # Testing with ruby 2.1.2 # Testing with Concurrent::MutexAtomicFixnum… #   3.130000   0.000000   3.130000 (  3.136505) # Testing with Concurrent::CAtomicFixnum… #   0.790000   0.000000   0.790000 (  0.785550) # # Testing with jruby 1.9.3 # Testing with Concurrent::MutexAtomicFixnum… #   5.460000   2.460000   7.920000 (  3.715000) # Testing with Concurrent::JavaAtomicFixnum… #   4.520000   0.030000   4.550000 (  1.187000) # “` # # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLong.html</a> java.util.concurrent.atomic.AtomicLong # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#9 class Concurrent::MutexAtomicFixnum</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Creates a new `AtomicFixnum` with the given initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param initial [Fixnum] the initial value</span>
<span class="ruby-comment"># @raise [ArgumentError] if the initial value is not a `Fixnum`</span>
<span class="ruby-comment"># @return [MutexAtomicFixnum] a new instance of MutexAtomicFixnum</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">initial</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value to the given updated value if the current</span>
<span class="ruby-comment"># value == the expected value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param expect [Fixnum] the expected value</span>
<span class="ruby-comment"># @param update [Fixnum] the new value</span>
<span class="ruby-comment"># @return [Boolean] true if the value was updated else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set</span>(<span class="ruby-identifier">expect</span>, <span class="ruby-identifier">update</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Decreases the current value by the given amount (defaults to 1).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delta [Fixnum] the amount by which to decrease the current value</span>
<span class="ruby-comment"># @return [Fixnum] the current value after decrementation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decrement</span>(<span class="ruby-identifier">delta</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Decreases the current value by the given amount (defaults to 1).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delta [Fixnum] the amount by which to decrease the current value</span>
<span class="ruby-comment"># @return [Fixnum] the current value after decrementation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">down</span>(<span class="ruby-identifier">delta</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Increases the current value by the given amount (defaults to 1).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delta [Fixnum] the amount by which to increase the current value</span>
<span class="ruby-comment"># @return [Fixnum] the current value after incrementation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">increment</span>(<span class="ruby-identifier">delta</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Increases the current value by the given amount (defaults to 1).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delta [Fixnum] the amount by which to increase the current value</span>
<span class="ruby-comment"># @return [Fixnum] the current value after incrementation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">up</span>(<span class="ruby-identifier">delta</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Pass the current value to the given block, replacing it</span>
<span class="ruby-comment"># with the block&#39;s result. May retry if the value changes</span>
<span class="ruby-comment"># during the block&#39;s execution.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment"># @yield [Object] Calculate a new value for the atomic reference using</span>
<span class="ruby-comment">#   given (old) value</span>
<span class="ruby-comment"># @yieldparam old_value [Object] the starting value of the atomic reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves the current `Fixnum` value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Explicitly sets the value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Fixnum] the new value to be set</span>
<span class="ruby-comment"># @raise [ArgumentError] if the new value is not a `Fixnum`</span>
<span class="ruby-comment"># @return [Fixnum] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_set</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#9 class Concurrent::MutexAtomicReference</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">AtomicDirectUpdate</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">AtomicNumericCompareAndSetWrapper</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @param value [Object] The initial value.</span>
<span class="ruby-comment"># @return [MutexAtomicReference] a new instance of MutexAtomicReference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets the value to the given updated value if</span>
<span class="ruby-comment"># the current value == the expected value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># that the actual value was not equal to the expected value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param old_value [Object] the expected value</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Boolean] `true` if successful. A `false` return indicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_compare_and_set</span>(<span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_swap</span>(<span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets to the given value and returns the old value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Object] the old value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_and_set</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets to the given value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Atomically sets to the given value and returns the old value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Object] the old value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets the current value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets to the given value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param new_value [Object] the new value</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A synchronization object that allows one thread to wait on multiple other threads. # The thread that will wait creates a ‘CountDownLatch` and sets the initial value # (normally equal to the number of other threads). The initiating thread passes the # latch to the other threads then waits for the other threads by calling the `#wait` # method. Each of the other threads calls `#count_down` when done with its work. # When the latch counter reaches zero the waiting thread is unblocked and continues # with its work. A `CountDownLatch` can be used only once. Its value cannot be reset. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#9 class Concurrent::MutexCountDownLatch &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># Create a new `CountDownLatch` with the initial `count`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param count [new] the initial count</span>
<span class="ruby-comment"># @raise [ArgumentError] if `count` is not an integer or is less than zero</span>
<span class="ruby-comment"># @return [MutexCountDownLatch] a new instance of MutexCountDownLatch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">count</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current value of the counter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the current value of the counter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Signal the latch to decrement the counter. Will signal all blocked threads when</span>
<span class="ruby-comment"># the `count` reaches zero.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_down</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Block on the latch until the counter reaches zero or until `timeout` is reached.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param timeout [Fixnum] the number of seconds to wait for the counter or `nil`</span>
<span class="ruby-comment">#   to block indefinitely</span>
<span class="ruby-comment"># @return [Boolean] `true` if the `count` reaches zero else false on `timeout`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#9 class Concurrent::MutexSemaphore &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># @return [MutexSemaphore] a new instance of MutexSemaphore</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acquire</span>(<span class="ruby-identifier">permits</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available_permits</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Acquires and returns all permits that are immediately available.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">drain_permits</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shrinks the number of available permits by the indicated reduction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param reduction [Fixnum] Number of permits to remove.</span>
<span class="ruby-comment"># @raise [ArgumentError] if `reduction` is not an integer or is negative</span>
<span class="ruby-comment"># @raise [ArgumentError] if `@free` - `@reduction` is less than zero</span>
<span class="ruby-comment"># @return [nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reduce_permits</span>(<span class="ruby-identifier">reduction</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">release</span>(<span class="ruby-identifier">permits</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_acquire</span>(<span class="ruby-identifier">permits</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_acquire_now</span>(<span class="ruby-identifier">permits</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_acquire_timed</span>(<span class="ruby-identifier">permits</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Various classes within allows for <code>nil</code> values to be stored, # so a special <code>NULL</code> token is required to indicate the “nil-ness”. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#6 Concurrent::NULL = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># Suppresses all output when used for logging. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#108 Concurrent::NULL_LOGGER = T.let(T.unsafe(nil), Proc)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#6 module Concurrent::Options</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>(<span class="ruby-identifier">executor_identifier</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Get the requested `Executor` based on the values set in the options hash.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] the options defining the requested executor</span>
  <span class="ruby-comment"># @return [Executor, nil] the requested thread pool, or nil when no option specified</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor_from_options</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Promises are inspired by the JavaScript [Promises/A](<a href="http://wiki.commonjs.org/wiki/Promises/A">wiki.commonjs.org/wiki/Promises/A</a>) # and [Promises/A+](<a href="http://promises-aplus.github.io/promises-spec">promises-aplus.github.io/promises-spec</a>/) specifications. # # &gt; A promise represents the eventual value returned from the single # &gt; completion of an operation. # # Promises are similar to futures and share many of the same behaviours. # Promises are far more robust, however. Promises can be chained in a tree # structure where each promise may have zero or more children. Promises are # chained using the ‘then` method. The result of a call to `then` is always # another promise. Promises are resolved asynchronously (with respect to the # main thread) but in a strict order: parents are guaranteed to be resolved # before their children, children before their younger siblings. The `then` # method takes two parameters: an optional block to be executed upon parent # resolution and an optional callable to be executed upon parent failure. The # result of each promise is passed to each of its children upon resolution. # When a promise is rejected all its children will be summarily rejected and # will receive the reason. # # Promises have several possible states: <strong>:unscheduled</strong>, <strong>:pending</strong>, # <strong>:processing</strong>, <strong>:rejected</strong>, or <strong>:fulfilled</strong>. These are also aggregated as # `#incomplete?` and `#complete?`. When a Promise is created it is set to # <strong>:unscheduled</strong>. Once the `#execute` method is called the state becomes # <strong>:pending</strong>. Once a job is pulled from the thread pool’s queue and is given # to a thread for processing (often immediately upon ‘#post`) the state # becomes <strong>:processing</strong>. The future will remain in this state until processing # is complete. A future that is in the <strong>:unscheduled</strong>, <strong>:pending</strong>, or # <strong>:processing</strong> is considered `#incomplete?`. A `#complete?` Promise is either # <strong>:rejected</strong>, indicating that an exception was thrown during processing, or # <strong>:fulfilled</strong>, indicating success. If a Promise is <strong>:fulfilled</strong> its `#value` # will be updated to reflect the result of the operation. If <strong>:rejected</strong> the # `reason` will be updated with a reference to the thrown exception. The # predicate methods `#unscheduled?`, `#pending?`, `#rejected?`, and # `#fulfilled?` can be called at any time to obtain the state of the Promise, # as can the `#state` method, which returns a symbol. # # Retrieving the value of a promise is done through the `value` (alias: # `deref`) method. Obtaining the value of a promise is a potentially blocking # operation. When a promise is <strong>rejected</strong> a call to `value` will return `nil` # immediately. When a promise is <strong>fulfilled</strong> a call to `value` will # immediately return the current value. When a promise is <strong>pending</strong> a call to # `value` will block until the promise is either <strong>rejected</strong> or <strong>fulfilled</strong>. A # <strong>timeout</strong> value can be passed to `value` to limit how long the call will # block. If `nil` the call will block indefinitely. If `0` the call will not # block. Any other integer or float value will indicate the maximum number of # seconds to block. # # Promises run on the global thread pool. # # ### Examples # # Start by requiring promises # # “`ruby # require ’concurrent/promise’ # “‘ # # Then create one # # “`ruby # p = Concurrent::Promise.execute do #       # do something #       42 #     end # “` # # Promises can be chained using the `then` method. The `then` method accepts a # block and an executor, to be executed on fulfillment, and a callable argument to be executed # on rejection. The result of the each promise is passed as the block argument # to chained promises. # # “`ruby # p = Concurrent::Promise.new{10}.then{|x| x * 2}.then{|result| result - 10 }.execute # “` # # And so on, and so on, and so on… # # “`ruby # p = Concurrent::Promise.fulfill(20). #     then{|result| result - 10 }. #     then{|result| result * 3 }. #     then(executor: different_executor){|result| result % 5 }.execute # “` # # The initial state of a newly created Promise depends on the state of its parent: # - if parent is <strong>unscheduled</strong> the child will be <strong>unscheduled</strong> # - if parent is <strong>pending</strong> the child will be <strong>pending</strong> # - if parent is <strong>fulfilled</strong> the child will be <strong>pending</strong> # - if parent is <strong>rejected</strong> the child will be <strong>pending</strong> (but will ultimately be <strong>rejected</strong>) # # Promises are executed asynchronously from the main thread. By the time a # child Promise finishes initialization it may be in a different state than its # parent (by the time a child is created its parent may have completed # execution and changed state). Despite being asynchronous, however, the order # of execution of Promise objects in a chain (or tree) is strictly defined. # # There are multiple ways to create and execute a new `Promise`. Both ways # provide identical behavior: # # “`ruby # # create, operate, then execute # p1 = Concurrent::Promise.new{ “Hello World!” } # p1.state #=&gt; :unscheduled # p1.execute # # # create and immediately execute # p2 = Concurrent::Promise.new{ “Hello World!” }.execute # # # execute during creation # p3 = Concurrent::Promise.execute{ “Hello World!” } # “` # # Once the `execute` method is called a `Promise` becomes `pending`: # # “`ruby # p = Concurrent::Promise.execute{ “Hello, world!” } # p.state    #=&gt; :pending # p.pending? #=&gt; true # “` # # Wait a little bit, and the promise will resolve and provide a value: # # “`ruby # p = Concurrent::Promise.execute{ “Hello, world!” } # sleep(0.1) # # p.state      #=&gt; :fulfilled # p.fulfilled? #=&gt; true # p.value      #=&gt; “Hello, world!” # “` # # If an exception occurs, the promise will be rejected and will provide # a reason for the rejection: # # “`ruby # p = Concurrent::Promise.execute{ raise StandardError.new(“Here comes the Boom!”) } # sleep(0.1) # # p.state     #=&gt; :rejected # p.rejected? #=&gt; true # p.reason    #=&gt; “#&lt;StandardError: Here comes the Boom!&gt;” # “` # # #### Rejection # # When a promise is rejected all its children will be rejected and will # receive the rejection `reason` as the rejection callable parameter: # # “`ruby # p = Concurrent::Promise.execute { Thread.pass; raise StandardError } # # c1 = p.then(-&gt; reason { 42 }) # c2 = p.then(-&gt; reason { raise ’Boom!‘ }) # # c1.wait.state  #=&gt; :fulfilled # c1.value       #=&gt; 45 # c2.wait.state  #=&gt; :rejected # c2.reason      #=&gt; #<RuntimeError: Boom!&gt; # “` # # Once a promise is rejected it will continue to accept children that will # receive immediately rejection (they will be executed asynchronously). # # #### Aliases # # The `then` method is the most generic alias: it accepts a block to be # executed upon parent fulfillment and a callable to be executed upon parent # rejection. At least one of them should be passed. The default block is `{ # |result| result }` that fulfills the child with the parent value. The # default callable is `{ |reason| raise reason }` that rejects the child with # the parent reason. # # - `on_success { |result| … }` is the same as `then {|result| … }` # - `rescue { |reason| … }` is the same as `then(Proc.new { |reason| … } )` # - `rescue` is aliased by `catch` and `on_error` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#190 class Concurrent::Promise &lt; ::Concurrent::IVar</p>

<pre class="ruby"><span class="ruby-comment"># Initialize a new Promise with the provided options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
<span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
<span class="ruby-comment"># @return [Promise] a new instance of Promise</span>
<span class="ruby-comment"># @see http://wiki.commonjs.org/wiki/Promises/A</span>
<span class="ruby-comment"># @see http://promises-aplus.github.io/promises-spec/</span>
<span class="ruby-comment"># @yield The block operation to be performed asynchronously.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chain onto this promise an action to be undertaken on failure</span>
<span class="ruby-comment"># (rejection).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Promise] self</span>
<span class="ruby-comment"># @yield The block to execute</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">catch</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute an `:unscheduled` `Promise`. Immediately sets the state to `:pending` and</span>
<span class="ruby-comment"># passes the block to a new thread/thread pool for eventual execution.</span>
<span class="ruby-comment"># Does nothing if the `Promise` is in any state other than `:unscheduled`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Promise] a reference to `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the `IVar` to failed due to some error and wake or notify all threads waiting on it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param reason [Object] for the failure</span>
<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already</span>
<span class="ruby-comment">#   been set or otherwise completed</span>
<span class="ruby-comment"># @raise [Concurrent::PromiseExecutionError] if not the root promise</span>
<span class="ruby-comment"># @return [IVar] self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fail</span>(<span class="ruby-identifier">reason</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yield the successful result to the block that returns a promise. If that</span>
<span class="ruby-comment"># promise is also successful the result is the result of the yielded promise.</span>
<span class="ruby-comment"># If either part fails the whole also fails.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   Promise.execute { 1 }.flat_map { |v| Promise.execute { v + 2 } }.value! #=&gt; 3</span>
<span class="ruby-comment"># @return [Promise]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chain onto this promise an action to be undertaken on failure</span>
<span class="ruby-comment"># (rejection).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Promise] self</span>
<span class="ruby-comment"># @yield The block to execute</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_error</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chain onto this promise an action to be undertaken on success</span>
<span class="ruby-comment"># (fulfillment).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [Promise] self</span>
<span class="ruby-comment"># @yield The block to execute</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_success</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chain onto this promise an action to be undertaken on failure</span>
<span class="ruby-comment"># (rejection).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Promise] self</span>
<span class="ruby-comment"># @yield The block to execute</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">rescue</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier ruby-title">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the `IVar` to a value and wake or notify all threads waiting on it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to store in the `IVar`</span>
<span class="ruby-comment"># @raise [ArgumentError] if both a value and a block are given</span>
<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already</span>
<span class="ruby-comment">#   been set or otherwise completed</span>
<span class="ruby-comment"># @raise [Concurrent::PromiseExecutionError] if not the root promise</span>
<span class="ruby-comment"># @return [IVar] self</span>
<span class="ruby-comment"># @yield A block operation to use for setting the value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chain a new promise off the current promise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload then</span>
<span class="ruby-comment"># @overload then</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [Promise] the new promise</span>
<span class="ruby-comment"># @yield The block operation to be performed asynchronously.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#314</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">then</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Builds a promise that produces the result of self and others in an Array</span>
<span class="ruby-comment"># and fails if any of them fails.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload zip</span>
<span class="ruby-comment"># @overload zip</span>
<span class="ruby-comment"># @return [Promise&lt;Array&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#440</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">others</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#551</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#545</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notify_child</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#533</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfill</span>(<span class="ruby-identifier">result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#539</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_reject</span>(<span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#562</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">realize</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#528</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_pending</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#570</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#576</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronized_set_state!</span>(<span class="ruby-identifier">success</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Aggregate a collection of zero or more promises under a composite promise,</span>
  <span class="ruby-comment"># execute the aggregated promises and collect them into a standard Ruby array,</span>
  <span class="ruby-comment"># call the given Ruby `Ennnumerable` predicate (such as `any?`, `all?`, `none?`,</span>
  <span class="ruby-comment"># or `one?`) on the collection checking for the success or failure of each,</span>
  <span class="ruby-comment"># then executing the composite&#39;s `#then` handlers if the predicate returns</span>
  <span class="ruby-comment"># `true` or executing the composite&#39;s `#rescue` handlers if the predicate</span>
  <span class="ruby-comment"># returns false.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The returned promise will not yet have been executed. Additional `#then`</span>
  <span class="ruby-comment"># and `#rescue` handlers may still be provided. Once the returned promise</span>
  <span class="ruby-comment"># is execute the aggregate promises will be also be executed (if they have</span>
  <span class="ruby-comment"># not been executed already). The results of the aggregate promises will</span>
  <span class="ruby-comment"># be checked upon completion. The necessary `#then` and `#rescue` blocks</span>
  <span class="ruby-comment"># on the aggregating promise will then be executed as appropriate. If the</span>
  <span class="ruby-comment"># `#rescue` handlers are executed the raises exception will be</span>
  <span class="ruby-comment"># `Concurrent::PromiseExecutionError`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param promises [Array] Zero or more promises to aggregate</span>
  <span class="ruby-comment"># @return [Promise] an unscheduled (not executed) promise that aggregates</span>
  <span class="ruby-comment">#   the promises given as arguments</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#505</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aggregate</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Aggregates a collection of promises and executes the `then` condition</span>
  <span class="ruby-comment"># if all aggregated promises succeed. Executes the `rescue` handler with</span>
  <span class="ruby-comment"># a `Concurrent::PromiseExecutionError` if any of the aggregated promises</span>
  <span class="ruby-comment"># fail. Upon execution will execute any of the aggregate promises that</span>
  <span class="ruby-comment"># were not already executed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#464</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Aggregates a collection of promises and executes the `then` condition</span>
  <span class="ruby-comment"># if any aggregated promises succeed. Executes the `rescue` handler with</span>
  <span class="ruby-comment"># a `Concurrent::PromiseExecutionError` if any of the aggregated promises</span>
  <span class="ruby-comment"># fail. Upon execution will execute any of the aggregate promises that</span>
  <span class="ruby-comment"># were not already executed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The returned promise will not yet have been executed. Additional `#then`</span>
  <span class="ruby-comment"># and `#rescue` handlers may still be provided. Once the returned promise</span>
  <span class="ruby-comment"># is execute the aggregate promises will be also be executed (if they have</span>
  <span class="ruby-comment"># not been executed already). The results of the aggregate promises will</span>
  <span class="ruby-comment"># be checked upon completion. The necessary `#then` and `#rescue` blocks</span>
  <span class="ruby-comment"># on the aggregating promise will then be executed as appropriate. If the</span>
  <span class="ruby-comment"># `#rescue` handlers are executed the raises exception will be</span>
  <span class="ruby-comment"># `Concurrent::PromiseExecutionError`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param promises [Array] Zero or more promises to aggregate</span>
  <span class="ruby-comment"># @return [Promise] an unscheduled (not executed) promise that aggregates</span>
  <span class="ruby-comment">#   the promises given as arguments</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#475</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a new `Promise` object with the given block, execute it, and return the</span>
  <span class="ruby-comment"># `:pending` object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example</span>
  <span class="ruby-comment">#   promise = Concurrent::Promise.execute{ sleep(1); 42 }</span>
  <span class="ruby-comment">#   promise.state #=&gt; :pending</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @return [Promise] the newly created `Promise` in the `:pending` state</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#296</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a new `Promise` and fulfill it immediately.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @return [Promise] the newly created `Promise`</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#224</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfill</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create a new `Promise` and reject it immediately.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @return [Promise] the newly created `Promise`</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#237</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject</span>(<span class="ruby-identifier">reason</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Builds a promise that produces the result of promises in an Array</span>
  <span class="ruby-comment"># and fails if any of them fails.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @overload zip</span>
  <span class="ruby-comment"># @overload zip</span>
  <span class="ruby-comment"># @return [Promise&lt;Array&gt;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#409</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">promises</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#11 class Concurrent::PromiseExecutionError &lt; ::StandardError; end</p>

<p># {include:file:docs-source/promises-main.md} # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#13 module Concurrent::Promises</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">FactoryMethods</span><span class="ruby-operator">::</span><span class="ruby-constant">Configuration</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">FactoryMethods</span>
</pre>

<p>end</p>

<p># @abstract # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2047 class Concurrent::Promises::AbstractAnyPromise &lt; ::Concurrent::Promises::BlockedPromise; end</p>

<p># Common ancestor of {Event} and {Future} classes, many shared methods are defined here. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#513 class Concurrent::Promises::AbstractEventFuture &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">InternalStates</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [AbstractEventFuture] a new instance of AbstractEventFuture</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#522</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">promise</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#738</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_callback_clear_delayed_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#733</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_callback_notify_blocked</span>(<span class="ruby-identifier">promise</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;AbstractPromise&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#702</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blocks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#710</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callbacks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#chain_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #chain_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#596</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chain</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chains the task to be executed asynchronously on executor after it is resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload an_event.chain_on</span>
<span class="ruby-comment"># @overload a_future.chain_on</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @yieldreturn will become result of the returned Future.</span>
<span class="ruby-comment">#   Its returned value becomes {Future#value} fulfilling it,</span>
<span class="ruby-comment">#   raised exception becomes {Future#reason} rejecting it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#614</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chain_on</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Resolves the resolvable when receiver is resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolvable [Resolvable]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#629</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chain_resolvable</span>(<span class="ruby-identifier">resolvable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns default executor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Executor] default executor</span>
<span class="ruby-comment"># @see #with_default_executor</span>
<span class="ruby-comment"># @see FactoryMethods#future_on</span>
<span class="ruby-comment"># @see FactoryMethods#resolvable_future</span>
<span class="ruby-comment"># @see FactoryMethods#any_fulfilled_future_on</span>
<span class="ruby-comment"># @see similar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#590</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_executor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#623</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal_state</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#on_resolution_using} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @see #on_resolution_using</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#637</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolution</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed synchronously on resolving thread after it is</span>
<span class="ruby-comment"># resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload an_event.on_resolution!</span>
<span class="ruby-comment"># @overload a_future.on_resolution!</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#655</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolution!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed asynchronously on executor after it is resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload an_event.on_resolution_using</span>
<span class="ruby-comment"># @overload a_future.on_resolution_using</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#673</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolution_using</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is it in pending state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#549</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#716</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">promise</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#688</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_with</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reserved</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is it in resolved state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#555</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns its state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload an_event.state</span>
<span class="ruby-comment"># @overload a_future.state</span>
<span class="ruby-comment"># @return [Symbol]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#543</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Resolves the resolvable when receiver is resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolvable [Resolvable]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#633</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tangle</span>(<span class="ruby-identifier">resolvable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#619</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Propagates touch. Requests all the delayed futures, which it depends on, to be</span>
<span class="ruby-comment"># executed. This method is called by any other method requiring resolved state, like {#wait}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#562</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#722</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touched?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait (block the Thread) until receiver is {#resolved?}.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @return [self, true, false] self implies timeout was not used, true implies timeout was used</span>
<span class="ruby-comment">#   and it was resolved, false implies it was not resolved within timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#578</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#728</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">waiting_threads</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Crates new object with same class with the executor set as its new default executor.</span>
<span class="ruby-comment"># Any futures depending on it will use the new default executor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @abstract</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [AbstractEventFuture]</span>
<span class="ruby-comment"># @see Event#with_default_executor</span>
<span class="ruby-comment"># @see Future#with_default_executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#683</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_default_executor</span>(<span class="ruby-identifier">executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#743</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_hidden_resolvable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#750</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_callback</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#812</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async_callback_on_resolution</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#796</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_callback</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#800</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_callbacks</span>(<span class="ruby-identifier">state</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#763</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_clear_delayed_node</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#818</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_notify_blocked</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">promise</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_internal_state</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal_state=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_internal_state</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_internal_state</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#768</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until_resolved</span>(<span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#808</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_async</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1796 class Concurrent::Promises::AbstractFlatPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [AbstractFlatPromise] a new instance of AbstractFlatPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1798</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed_because</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">event_or_future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1808</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1828</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_delayed_of</span>(<span class="ruby-identifier">future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1820</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1824</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable?</span>(<span class="ruby-identifier">countdown</span>, <span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1816</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touched?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @abstract # @private # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1549 class Concurrent::Promises::AbstractPromise &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">InternalStates</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [AbstractPromise] a new instance of AbstractPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1553</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1564</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_executor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1581</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delayed_because</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1562</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1558</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">future</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1579</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1568</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1575</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1572</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1592</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_to</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1587</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_with</span>(<span class="ruby-identifier">new_state</span>, <span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2084 class Concurrent::Promises::AnyFulfilledFuturePromise &lt; ::Concurrent::Promises::AnyResolvedFuturePromise</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2088</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable?</span>(<span class="ruby-identifier">countdown</span>, <span class="ruby-identifier">event_or_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2050 class Concurrent::Promises::AnyResolvedEventPromise &lt; ::Concurrent::Promises::AbstractAnyPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [AnyResolvedEventPromise] a new instance of AnyResolvedEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2054</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2062</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2058</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable?</span>(<span class="ruby-identifier">countdown</span>, <span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2067 class Concurrent::Promises::AnyResolvedFuturePromise &lt; ::Concurrent::Promises::AbstractAnyPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [AnyResolvedFuturePromise] a new instance of AnyResolvedFuturePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2071</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2079</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2075</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable?</span>(<span class="ruby-identifier">countdown</span>, <span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @abstract # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1619 class Concurrent::Promises::BlockedPromise &lt; ::Concurrent::Promises::InnerPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [BlockedPromise] a new instance of BlockedPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1661</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># for inspection only</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1683</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blocked_by</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1674</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delayed_because</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1667</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1678</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1691</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_and_propagate_touch</span>(<span class="ruby-identifier">stack_or_element</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1710</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1706</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [true, false] if resolvable</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1702</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable?</span>(<span class="ruby-identifier">countdown</span>, <span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1652</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_delayed</span>(<span class="ruby-identifier">delayed1</span>, <span class="ruby-identifier">delayed2</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1645</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_blocked_by</span>(<span class="ruby-identifier">blockers</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1623</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_blocked_by1</span>(<span class="ruby-identifier">blocker</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1630</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_blocked_by2</span>(<span class="ruby-identifier">blocker1</span>, <span class="ruby-identifier">blocker2</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1621</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @abstract # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1716 class Concurrent::Promises::BlockedTaskPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [BlockedTaskPromise] a new instance of BlockedTaskPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1717</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1725</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1766 class Concurrent::Promises::ChainPromise &lt; ::Concurrent::Promises::BlockedTaskPromise</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1769</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2095 class Concurrent::Promises::DelayPromise &lt; ::Concurrent::Promises::InnerPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [DelayPromise] a new instance of DelayPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2097</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delayed_because</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">touch</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Represents an event which will happen in future (will be resolved). The event is either # pending or resolved. It should be always resolved. Use {Future} to communicate rejections and # cancellation. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#826 class Concurrent::Promises::Event &lt; ::Concurrent::Promises::AbstractEventFuture</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new event or a future which will be resolved when receiver and other are.</span>
<span class="ruby-comment"># Returns an event if receiver and other are events, otherwise returns a future.</span>
<span class="ruby-comment"># If just one of the parties is Future then the result</span>
<span class="ruby-comment"># of the returned future is equal to the result of the supplied future. If both are futures</span>
<span class="ruby-comment"># then the result is as described in {FactoryMethods#zip_futures_on}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future, Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#847</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&amp;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which will be resolved when the first of receiver, `event_or_future`</span>
<span class="ruby-comment"># resolves.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#853</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any</span>(<span class="ruby-identifier">event_or_future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new event dependent on receiver which will not evaluate until touched, see {#touch}.</span>
<span class="ruby-comment"># In other words, it inserts delay into the chain of Futures making rest of it lazy evaluated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#863</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delay</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new event dependent on receiver scheduled to execute on/in intended_time.</span>
<span class="ruby-comment"># In time is interpreted from the moment the receiver is resolved, therefore it inserts</span>
<span class="ruby-comment"># delay into the chain.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param intended_time [Numeric, Time] `Numeric` means to run in `intended_time` seconds.</span>
<span class="ruby-comment">#   `Time` means to run on `intended_time`.</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#875</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule</span>(<span class="ruby-identifier">intended_time</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#828</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">then</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns self, since this is event</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#893</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts event to a future. The future is fulfilled when the event is resolved, the future may never fail.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#885</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_future</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Crates new object with same class with the executor set as its new default executor.</span>
<span class="ruby-comment"># Any futures depending on it will use the new default executor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#899</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_default_executor</span>(<span class="ruby-identifier">executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event or a future which will be resolved when receiver and other are.</span>
<span class="ruby-comment"># Returns an event if receiver and other are events, otherwise returns a future.</span>
<span class="ruby-comment"># If just one of the parties is Future then the result</span>
<span class="ruby-comment"># of the returned future is equal to the result of the supplied future. If both are futures</span>
<span class="ruby-comment"># then the result is as described in {FactoryMethods#zip_futures_on}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future, Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#839</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which will be resolved when the first of receiver, `event_or_future`</span>
<span class="ruby-comment"># resolves.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#857</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">|</span>(<span class="ruby-identifier">event_or_future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#910</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_resolution</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [Concurrent::MultipleAssignmentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#905</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected_resolution</span>(<span class="ruby-identifier">raise_on_reassign</span>, <span class="ruby-identifier">state</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1972 class Concurrent::Promises::EventWrapperPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [EventWrapperPromise] a new instance of EventWrapperPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1973</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1979</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Container of all {Future}, {Event} factory methods. They are never constructed directly with # new. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#46 module Concurrent::Promises::FactoryMethods</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">FactoryMethods</span><span class="ruby-operator">::</span><span class="ruby-constant">Configuration</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">ReInclude</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">FactoryMethods</span><span class="ruby-operator">::</span><span class="ruby-constant">Configuration</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">FactoryMethods</span>

<span class="ruby-comment"># Shortcut of {#any_resolved_future_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #any_resolved_future_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#any_event_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment"># @see #any_event_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_event</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which becomes resolved after the first futures_and_or_events resolves.</span>
<span class="ruby-comment"># If resolved it does not propagate {Concurrent::AbstractEventFuture#touch}, leaving delayed</span>
<span class="ruby-comment"># futures un-executed if they are not required any more.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param futures_and_or_events [AbstractEventFuture]</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_event_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#any_fulfilled_future_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #any_fulfilled_future_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#300</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_fulfilled_future</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new future which is resolved after the first futures_and_or_events is fulfilled.</span>
<span class="ruby-comment"># Its result equals the result of the first resolved future or if all futures_and_or_events reject,</span>
<span class="ruby-comment"># it has reason of the last rejected future.</span>
<span class="ruby-comment"># If resolved it does not propagate {Concurrent::AbstractEventFuture#touch}, leaving delayed</span>
<span class="ruby-comment"># futures un-executed if they are not required any more.</span>
<span class="ruby-comment"># If event is supplied, which does not have value and can be only resolved, it&#39;s</span>
<span class="ruby-comment"># represented as `:fulfilled` with value `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param futures_and_or_events [AbstractEventFuture]</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_fulfilled_future_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#any_resolved_future_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #any_resolved_future_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_resolved_future</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new future which is resolved after the first futures_and_or_events is resolved.</span>
<span class="ruby-comment"># Its result equals the result of the first resolved future.</span>
<span class="ruby-comment"># If resolved it does not propagate {Concurrent::AbstractEventFuture#touch}, leaving delayed</span>
<span class="ruby-comment"># futures un-executed if they are not required any more.</span>
<span class="ruby-comment"># If event is supplied, which does not have value and can be only resolved, it&#39;s</span>
<span class="ruby-comment"># represented as `:fulfilled` with value `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param futures_and_or_events [AbstractEventFuture]</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#294</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_resolved_future_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#delay_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future, Event]</span>
<span class="ruby-comment"># @see #delay_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delay</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event or future which is resolved only after it is touched,</span>
<span class="ruby-comment"># see {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload delay_on</span>
<span class="ruby-comment"># @overload delay_on</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delay_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a resolved future which will be fulfilled with the given value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled_future</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#future_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #future_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">future</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Constructs a new Future which will be resolved after block is evaluated on default executor.</span>
<span class="ruby-comment"># Evaluation begins immediately.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @yield [*args] to the task.</span>
<span class="ruby-comment"># @yieldreturn will become result of the returned Future.</span>
<span class="ruby-comment">#   Its returned value becomes {Future#value} fulfilling it,</span>
<span class="ruby-comment">#   raised exception becomes {Future#reason} rejecting it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">future_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># General constructor. Behaves differently based on the argument&#39;s type. It&#39;s provided for convenience</span>
<span class="ruby-comment"># but it&#39;s better to be explicit.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload make_future</span>
<span class="ruby-comment"># @overload make_future</span>
<span class="ruby-comment"># @overload make_future</span>
<span class="ruby-comment"># @overload make_future</span>
<span class="ruby-comment"># @overload make_future</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @return [Event, Future]</span>
<span class="ruby-comment"># @see rejected_future, resolved_event, fulfilled_future</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_future</span>(<span class="ruby-identifier">argument</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a resolved future which will be rejected with the given reason.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param reason [Object]</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected_future</span>(<span class="ruby-identifier">reason</span>, <span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#resolvable_event_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ResolvableEvent]</span>
<span class="ruby-comment"># @see #resolvable_event_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable_event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a resolvable event, user is responsible for resolving the event once</span>
<span class="ruby-comment"># by calling {Promises::ResolvableEvent#resolve}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @return [ResolvableEvent]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable_event_on</span>(<span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#resolvable_future_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ResolvableFuture]</span>
<span class="ruby-comment"># @see #resolvable_future_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable_future</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates resolvable future, user is responsible for resolving the future once by</span>
<span class="ruby-comment"># {Promises::ResolvableFuture#resolve}, {Promises::ResolvableFuture#fulfill},</span>
<span class="ruby-comment"># or {Promises::ResolvableFuture#reject}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @return [ResolvableFuture]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolvable_future_on</span>(<span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates resolved event.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved_event</span>(<span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a resolved future with will be either fulfilled with the given value or rejected with</span>
<span class="ruby-comment"># the given reason.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param fulfilled [true, false]</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @param reason [Object]</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved_future</span>(<span class="ruby-identifier">fulfilled</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>, <span class="ruby-identifier">default_executor</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#schedule_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future, Event]</span>
<span class="ruby-comment"># @see #schedule_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule</span>(<span class="ruby-identifier">intended_time</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event or future which is resolved in intended_time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload schedule_on</span>
<span class="ruby-comment"># @overload schedule_on</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param intended_time [Numeric, Time] `Numeric` means to run in `intended_time` seconds.</span>
<span class="ruby-comment">#   `Time` means to run on `intended_time`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">intended_time</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#zip_futures_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #zip_futures_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#zip_events_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment"># @see #zip_events_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip_events</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which is resolved after all futures_and_or_events are resolved.</span>
<span class="ruby-comment"># (Future is resolved when fulfilled or rejected.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param futures_and_or_events [AbstractEventFuture]</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip_events_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#zip_futures_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #zip_futures_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip_futures</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new future which is resolved after all futures_and_or_events are resolved.</span>
<span class="ruby-comment"># Its value is an array of zipped future values. Its reason is an array of reasons for rejection.</span>
<span class="ruby-comment"># If there is an error it rejects.</span>
<span class="ruby-comment"># If event is supplied, which does not have value and can be only resolved, it&#39;s</span>
<span class="ruby-comment"># represented as `:fulfilled` with value `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default_executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. Default executor propagates to chained futures unless overridden with</span>
<span class="ruby-comment">#   executor parameter or changed with {AbstractEventFuture#with_default_executor}.</span>
<span class="ruby-comment"># @param futures_and_or_events [AbstractEventFuture]</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip_futures_on</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">futures_and_or_events</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#50 module Concurrent::Promises::FactoryMethods::Configuration</p>

<pre class="ruby"><span class="ruby-comment"># @return [Executor, :io, :fast] the executor which is used when none is supplied</span>
<span class="ruby-comment">#   to a factory method. The method can be overridden in the receivers of</span>
<span class="ruby-comment">#   `include FactoryMethod`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_executor</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1840 class Concurrent::Promises::FlatEventPromise &lt; ::Concurrent::Promises::AbstractFlatPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [FlatEventPromise] a new instance of FlatEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1844</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1848</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1873 class Concurrent::Promises::FlatFuturePromise &lt; ::Concurrent::Promises::AbstractFlatPromise</p>

<pre class="ruby"><span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [FlatFuturePromise] a new instance of FlatFuturePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1877</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">levels</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1884</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Represents a value which will become available in future. May reject with a reason instead, # e.g. when the tasks raises an exception. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#917 class Concurrent::Promises::Future &lt; ::Concurrent::Promises::AbstractEventFuture</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new event or a future which will be resolved when receiver and other are.</span>
<span class="ruby-comment"># Returns an event if receiver and other are events, otherwise returns a future.</span>
<span class="ruby-comment"># If just one of the parties is Future then the result</span>
<span class="ruby-comment"># of the returned future is equal to the result of the supplied future. If both are futures</span>
<span class="ruby-comment"># then the result is as described in {FactoryMethods#zip_futures_on}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1078</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&amp;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which will be resolved when the first of receiver, `event_or_future`</span>
<span class="ruby-comment"># resolves. Returning future will have value nil if event_or_future is event and resolves</span>
<span class="ruby-comment"># first.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1085</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any</span>(<span class="ruby-identifier">event_or_future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new future dependent on receiver which will not evaluate until touched, see {#touch}.</span>
<span class="ruby-comment"># In other words, it inserts delay into the chain of Futures making rest of it lazy evaluated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1095</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delay</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Allows rejected Future to be risen with `raise` method.</span>
<span class="ruby-comment"># If the reason is not an exception `Runtime.new(reason)` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   raise Promises.rejected_future(StandardError.new(&quot;boom&quot;))</span>
<span class="ruby-comment">#   raise Promises.rejected_future(&quot;or just boom&quot;)</span>
<span class="ruby-comment"># @raise [Concurrent::Error] when raising not rejected future</span>
<span class="ruby-comment"># @return [Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1013</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new future which will have result of the future returned by receiver. If receiver</span>
<span class="ruby-comment"># rejects it will have its rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param level [Integer] how many levels of futures should flatten</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new event which will be resolved when the returned event by receiver is.</span>
<span class="ruby-comment"># Be careful if the receiver rejects it will just resolve since Event does not hold reason.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new future which will have result of the future returned by receiver. If receiver</span>
<span class="ruby-comment"># rejects it will have its rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param level [Integer] how many levels of futures should flatten</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_future</span>(<span class="ruby-identifier">level</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is it in fulfilled state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#921</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#on_fulfillment_using} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @see #on_fulfillment_using</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed synchronously on resolving thread after it is</span>
<span class="ruby-comment"># fulfilled. Does nothing on rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [value, *args] to the callback.</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed asynchronously on executor after it is</span>
<span class="ruby-comment"># fulfilled. Does nothing on rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [value, *args] to the callback.</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_fulfillment_using</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#on_rejection_using} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @see #on_rejection_using</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed synchronously on resolving thread after it is</span>
<span class="ruby-comment"># rejected. Does nothing on fulfillment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [reason, *args] to the callback.</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Stores the callback to be executed asynchronously on executor after it is</span>
<span class="ruby-comment"># rejected. Does nothing on fulfillment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [reason, *args] to the callback.</span>
<span class="ruby-comment"># @yieldreturn is forgotten.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rejection_using</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns reason of future&#39;s rejection.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @note Make sure returned `nil` is not confused with timeout, no value when rejected,</span>
<span class="ruby-comment">#   no reason when fulfilled, etc.</span>
<span class="ruby-comment">#   Use more exact methods if needed, like {#wait}, {#value!}, {#result}, etc.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @param timeout_value [Object] a value returned by the method when it times out</span>
<span class="ruby-comment"># @return [Object, timeout_value] the reason, or timeout_value on timeout, or nil on fulfillment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#966</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is it in rejected state?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#928</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#rescue_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #rescue_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1052</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">rescue</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chains the task to be executed asynchronously on executor after it rejects. Does not run</span>
<span class="ruby-comment"># the task if it fulfills. It will resolve though, triggering any dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @yield [reason, *args] to the task.</span>
<span class="ruby-comment"># @yieldreturn will become result of the returned Future.</span>
<span class="ruby-comment">#   Its returned value becomes {Future#value} fulfilling it,</span>
<span class="ruby-comment">#   raised exception becomes {Future#reason} rejecting it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1064</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_on</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns triplet fulfilled?, value, reason.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @return [Array(Boolean, Object, Object), nil] triplet of fulfilled?, value, reason, or nil</span>
<span class="ruby-comment">#   on timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#981</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">result</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Allows to use futures as green threads. The receiver has to evaluate to a future which</span>
<span class="ruby-comment"># represents what should be done next. It basically flattens indefinitely until non Future</span>
<span class="ruby-comment"># values is returned which becomes result of the returned future. Any encountered exception</span>
<span class="ruby-comment"># will become reason of the returned future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   body = lambda do |v|</span>
<span class="ruby-comment">#   v += 1</span>
<span class="ruby-comment">#   v &lt; 5 ? Promises.future(v, &amp;body) : v</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   Promises.future(0, &amp;body).run.value! # =&gt; 5</span>
<span class="ruby-comment"># @param run_test [#call(value)] an object which when called returns either Future to keep running with</span>
<span class="ruby-comment">#   or nil, then the run completes with the value.</span>
<span class="ruby-comment">#   The run_test can be used to extract the Future from deeper structure,</span>
<span class="ruby-comment">#   or to distinguish Future which is a resulting value from a future</span>
<span class="ruby-comment">#   which is suppose to continue running.</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">run_test</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new event dependent on receiver scheduled to execute on/in intended_time.</span>
<span class="ruby-comment"># In time is interpreted from the moment the receiver is resolved, therefore it inserts</span>
<span class="ruby-comment"># delay into the chain.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param intended_time [Numeric, Time] `Numeric` means to run in `intended_time` seconds.</span>
<span class="ruby-comment">#   `Time` means to run on `intended_time`.</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule</span>(<span class="ruby-identifier">intended_time</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut of {#then_on} with default `:io` executor supplied.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @see #then_on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1034</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">then</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Chains the task to be executed asynchronously on executor after it fulfills. Does not run</span>
<span class="ruby-comment"># the task if it rejects. It will resolve though, triggering any dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param executor [Executor, :io, :fast] Instance of an executor or a name of the</span>
<span class="ruby-comment">#   global executor. The task is executed on it, default executor remains unchanged.</span>
<span class="ruby-comment"># @param args [Object] arguments which are passed to the task when it&#39;s executed.</span>
<span class="ruby-comment">#   (It might be prepended with other arguments, see the @yield section).</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment"># @yield [value, *args] to the task.</span>
<span class="ruby-comment"># @yieldreturn will become result of the returned Future.</span>
<span class="ruby-comment">#   Its returned value becomes {Future#value} fulfilling it,</span>
<span class="ruby-comment">#   raised exception becomes {Future#reason} rejecting it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1046</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then_on</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts future to event which is resolved when future is resolved by fulfillment or rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns self, since this is a future</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_future</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] Short string representation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return value of the future.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @note Make sure returned `nil` is not confused with timeout, no value when rejected,</span>
<span class="ruby-comment">#   no reason when fulfilled, etc.</span>
<span class="ruby-comment">#   Use more exact methods if needed, like {#wait}, {#value!}, {#result}, etc.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @param timeout_value [Object] a value returned by the method when it times out</span>
<span class="ruby-comment"># @return [Object, nil, timeout_value] the value of the Future when fulfilled,</span>
<span class="ruby-comment">#   timeout_value on timeout,</span>
<span class="ruby-comment">#   nil on rejection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#950</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return value of the future.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @note Make sure returned `nil` is not confused with timeout, no value when rejected,</span>
<span class="ruby-comment">#   no reason when fulfilled, etc.</span>
<span class="ruby-comment">#   Use more exact methods if needed, like {#wait}, {#value!}, {#result}, etc.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @param timeout_value [Object] a value returned by the method when it times out</span>
<span class="ruby-comment"># @raise [Exception] {#reason} on rejection</span>
<span class="ruby-comment"># @return [Object, nil, timeout_value] the value of the Future when fulfilled,</span>
<span class="ruby-comment">#   or nil on rejection,</span>
<span class="ruby-comment">#   or timeout_value on timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#997</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait (block the Thread) until receiver is {#resolved?}.</span>
<span class="ruby-comment"># Calls {Concurrent::AbstractEventFuture#touch}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This function potentially blocks current thread until the Future is resolved.</span>
<span class="ruby-comment">#   Be careful it can deadlock. Try to chain instead.</span>
<span class="ruby-comment"># @param timeout [Numeric] the maximum time in second to wait.</span>
<span class="ruby-comment"># @raise [Exception] {#reason} on rejection</span>
<span class="ruby-comment"># @return [self, true, false] self implies timeout was not used, true implies timeout was used</span>
<span class="ruby-comment">#   and it was resolved, false implies it was not resolved within timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#987</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Crates new object with same class with the executor set as its new default executor.</span>
<span class="ruby-comment"># Any futures depending on it will use the new default executor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_default_executor</span>(<span class="ruby-identifier">executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event or a future which will be resolved when receiver and other are.</span>
<span class="ruby-comment"># Returns an event if receiver and other are events, otherwise returns a future.</span>
<span class="ruby-comment"># If just one of the parties is Future then the result</span>
<span class="ruby-comment"># of the returned future is equal to the result of the supplied future. If both are futures</span>
<span class="ruby-comment"># then the result is as described in {FactoryMethods#zip_futures_on}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1070</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new event which will be resolved when the first of receiver, `event_or_future`</span>
<span class="ruby-comment"># resolves. Returning future will have value nil if event_or_future is event and resolves</span>
<span class="ruby-comment"># first.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1089</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">|</span>(<span class="ruby-identifier">event_or_future</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async_callback_on_fulfillment</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">async_callback_on_rejection</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_fulfillment</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1288</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_rejection</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_on_resolution</span>(<span class="ruby-identifier">state</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rejected_resolution</span>(<span class="ruby-identifier">raise_on_reassign</span>, <span class="ruby-identifier">state</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_test</span>(<span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until_resolved!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1984 class Concurrent::Promises::FutureWrapperPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [FutureWrapperPromise] a new instance of FutureWrapperPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1985</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1991</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># will be immediately resolved # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1783 class Concurrent::Promises::ImmediateEventPromise &lt; ::Concurrent::Promises::InnerPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ImmediateEventPromise] a new instance of ImmediateEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1784</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1789 class Concurrent::Promises::ImmediateFuturePromise &lt; ::Concurrent::Promises::InnerPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ImmediateFuturePromise] a new instance of ImmediateFuturePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1790</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">fulfilled</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @abstract # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1615 class Concurrent::Promises::InnerPromise &lt; ::Concurrent::Promises::AbstractPromise; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#338 module Concurrent::Promises::InternalStates; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#397 class Concurrent::Promises::InternalStates::Fulfilled &lt; ::Concurrent::Promises::InternalStates::ResolvedWithResult</p>

<pre class="ruby"><span class="ruby-comment"># @return [Fulfilled] a new instance of Fulfilled</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#399</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#407</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#419</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#411</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#425 class Concurrent::Promises::InternalStates::FulfilledArray &lt; ::Concurrent::Promises::InternalStates::Fulfilled</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#426</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#488 Concurrent::Promises::InternalStates::PENDING = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Pending)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#459 class Concurrent::Promises::InternalStates::PartiallyRejected &lt; ::Concurrent::Promises::InternalStates::ResolvedWithResult</p>

<pre class="ruby"><span class="ruby-comment"># @return [PartiallyRejected] a new instance of PartiallyRejected</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#460</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#482</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#466</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#478</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#470</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#474</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#351 class Concurrent::Promises::InternalStates::Pending &lt; ::Concurrent::Promises::InternalStates::State</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#352</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#356</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#490 Concurrent::Promises::InternalStates::RESERVED = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Reserved)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#492 Concurrent::Promises::InternalStates::RESOLVED = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Fulfilled)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#432 class Concurrent::Promises::InternalStates::Rejected &lt; ::Concurrent::Promises::InternalStates::ResolvedWithResult</p>

<pre class="ruby"><span class="ruby-comment"># @return [Rejected] a new instance of Rejected</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#433</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#453</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#437</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#445</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#441</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#362 class Concurrent::Promises::InternalStates::Reserved &lt; ::Concurrent::Promises::InternalStates::Pending; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#366 class Concurrent::Promises::InternalStates::ResolvedWithResult &lt; ::Concurrent::Promises::InternalStates::State</p>

<pre class="ruby"><span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#391</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#379</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfilled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#387</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#367</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">result</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#371</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#383</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#340 class Concurrent::Promises::InternalStates::State</p>

<pre class="ruby"><span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolved?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sym</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1748 class Concurrent::Promises::RescuePromise &lt; ::Concurrent::Promises::BlockedTaskPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [RescuePromise] a new instance of RescuePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1751</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1755</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Marker module of Future, Event resolved manually. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1299 module Concurrent::Promises::Resolvable</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">InternalStates</span>
</pre>

<p>end</p>

<p># A Event which can be resolved by user. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1304 class Concurrent::Promises::ResolvableEvent &lt; ::Concurrent::Promises::Event</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">Resolvable</span>

<span class="ruby-comment"># Makes the event resolved, which triggers all dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param raise_on_reassign [Boolean] should method raise exception if already resolved</span>
<span class="ruby-comment"># @param reserved [true, false] Set to true if the resolvable is {#reserve}d by you,</span>
<span class="ruby-comment">#   marks resolution of reserved resolvable events and futures explicitly.</span>
<span class="ruby-comment">#   Advanced feature, ignore unless you use {Resolvable#reserve} from edge.</span>
<span class="ruby-comment"># @return [self, false] false is returned when raise_on_reassign is false and the receiver</span>
<span class="ruby-comment">#   is already resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve</span>(<span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reserved</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {AbstractEventFuture#wait} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [true, false] If it times out and the argument is true it will also resolve the event.</span>
<span class="ruby-comment"># @return [self, true, false]</span>
<span class="ruby-comment"># @see AbstractEventFuture#wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1342</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new event wrapping receiver, effectively hiding the resolve method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Event]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_hidden_resolvable</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1600 class Concurrent::Promises::ResolvableEventPromise &lt; ::Concurrent::Promises::AbstractPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ResolvableEventPromise] a new instance of ResolvableEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1601</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A Future which can be resolved by user. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1354 class Concurrent::Promises::ResolvableFuture &lt; ::Concurrent::Promises::Future</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Promises</span><span class="ruby-operator">::</span><span class="ruby-constant">Resolvable</span>

<span class="ruby-comment"># Evaluates the block and sets its result as future&#39;s value fulfilling, if the block raises</span>
<span class="ruby-comment"># an exception the future rejects with it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [*args] to the block.</span>
<span class="ruby-comment"># @yieldreturn [Object] value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_to</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Evaluates the block and sets its result as future&#39;s value fulfilling, if the block raises</span>
<span class="ruby-comment"># an exception the future rejects with it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Exception] also raise reason on rejection.</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment"># @yield [*args] to the block.</span>
<span class="ruby-comment"># @yieldreturn [Object] value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_to!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Makes the future fulfilled with `value`,</span>
<span class="ruby-comment"># which triggers all dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @param raise_on_reassign [Boolean] should method raise exception if already resolved</span>
<span class="ruby-comment"># @param reserved [true, false] Set to true if the resolvable is {#reserve}d by you,</span>
<span class="ruby-comment">#   marks resolution of reserved resolvable events and futures explicitly.</span>
<span class="ruby-comment">#   Advanced feature, ignore unless you use {Resolvable#reserve} from edge.</span>
<span class="ruby-comment"># @return [self, false] false is returned when raise_on_reassign is false and the receiver</span>
<span class="ruby-comment">#   is already resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fulfill</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reserved</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {Future#reason} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @return [Exception, timeout_value, nil]</span>
<span class="ruby-comment"># @see Future#reason</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1503</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Makes the future rejected with `reason`,</span>
<span class="ruby-comment"># which triggers all dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param reason [Object]</span>
<span class="ruby-comment"># @param raise_on_reassign [Boolean] should method raise exception if already resolved</span>
<span class="ruby-comment"># @param reserved [true, false] Set to true if the resolvable is {#reserve}d by you,</span>
<span class="ruby-comment">#   marks resolution of reserved resolvable events and futures explicitly.</span>
<span class="ruby-comment">#   Advanced feature, ignore unless you use {Resolvable#reserve} from edge.</span>
<span class="ruby-comment"># @return [self, false] false is returned when raise_on_reassign is false and the receiver</span>
<span class="ruby-comment">#   is already resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject</span>(<span class="ruby-identifier">reason</span>, <span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reserved</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Makes the future resolved with result of triplet `fulfilled?`, `value`, `reason`,</span>
<span class="ruby-comment"># which triggers all dependent futures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param fulfilled [true, false]</span>
<span class="ruby-comment"># @param value [Object]</span>
<span class="ruby-comment"># @param reason [Object]</span>
<span class="ruby-comment"># @param raise_on_reassign [Boolean] should method raise exception if already resolved</span>
<span class="ruby-comment"># @param reserved [true, false] Set to true if the resolvable is {#reserve}d by you,</span>
<span class="ruby-comment">#   marks resolution of reserved resolvable events and futures explicitly.</span>
<span class="ruby-comment">#   Advanced feature, ignore unless you use {Resolvable#reserve} from edge.</span>
<span class="ruby-comment"># @return [self, false] false is returned when raise_on_reassign is false and the receiver</span>
<span class="ruby-comment">#   is already resolved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve</span>(<span class="ruby-identifier">fulfilled</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reason</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">raise_on_reassign</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">reserved</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {Future#result} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @return [::Array(Boolean, Object, Exception), nil]</span>
<span class="ruby-comment"># @see Future#result</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1524</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">result</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {Future#value} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @return [Object, timeout_value, nil]</span>
<span class="ruby-comment"># @see Future#value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1459</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {Future#value!} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @raise [Exception] {#reason} on rejection</span>
<span class="ruby-comment"># @return [Object, timeout_value, nil]</span>
<span class="ruby-comment"># @see Future#value!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout_value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {AbstractEventFuture#wait} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @return [self, true, false]</span>
<span class="ruby-comment"># @see AbstractEventFuture#wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1421</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Behaves as {Future#wait!} but has one additional optional argument</span>
<span class="ruby-comment"># resolve_on_timeout.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param resolve_on_timeout [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] If it times out and the argument is not nil it will also resolve the future</span>
<span class="ruby-comment">#   to the provided resolution.</span>
<span class="ruby-comment"># @raise [Exception] {#reason} on rejection</span>
<span class="ruby-comment"># @return [self, true, false]</span>
<span class="ruby-comment"># @see Future#wait!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1438</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait!</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">resolve_on_timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates new future wrapping receiver, effectively hiding the resolve method and similar.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Future]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1542</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_hidden_resolvable</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1606 class Concurrent::Promises::ResolvableFuturePromise &lt; ::Concurrent::Promises::AbstractPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ResolvableFuturePromise] a new instance of ResolvableFuturePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1611</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_to</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1909 class Concurrent::Promises::RunFuturePromise &lt; ::Concurrent::Promises::AbstractFlatPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [RunFuturePromise] a new instance of RunFuturePromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1913</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">run_test</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1918</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2114 class Concurrent::Promises::ScheduledPromise &lt; ::Concurrent::Promises::InnerPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ScheduledPromise] a new instance of ScheduledPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">intended_time</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">intended_time</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1730 class Concurrent::Promises::ThenPromise &lt; ::Concurrent::Promises::BlockedTaskPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ThenPromise] a new instance of ThenPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1733</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>, <span class="ruby-identifier">executor</span>, <span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1737</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1940 class Concurrent::Promises::ZipEventEventPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ZipEventEventPromise] a new instance of ZipEventEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1941</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1947</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2031 class Concurrent::Promises::ZipEventsPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ZipEventsPromise] a new instance of ZipEventsPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2035</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2041</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1952 class Concurrent::Promises::ZipFutureEventPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ZipFutureEventPromise] a new instance of ZipFutureEventPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1953</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1967</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1960</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1996 class Concurrent::Promises::ZipFuturesPromise &lt; ::Concurrent::Promises::BlockedPromise</p>

<pre class="ruby"><span class="ruby-comment"># @return [ZipFuturesPromise] a new instance of ZipFuturesPromise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2000</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delayed</span>, <span class="ruby-identifier">blockers_count</span>, <span class="ruby-identifier">default_executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2013</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resolvable</span>(<span class="ruby-identifier">resolved_future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2007</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_on_blocker_resolution</span>(<span class="ruby-identifier">future</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Methods form module A included to a module B, which is already included into class C, # will not be visible in the C class. If this module is extended to B then A’s methods # are correctly made visible to C. # # @example #   module A #   def a #   :a #   end #   end # #   module B1 #   end # #   class C1 #   include B1 #   end # #   module B2 #   extend Concurrent::ReInclude #   end # #   class C2 #   include B2 #   end # #   B1.send :include, A #   B2.send :include, A # #   C1.new.respond_to? :a # =&gt; false #   C2.new.respond_to? :a # =&gt; true # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#36 module Concurrent::ReInclude</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">modules</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Ruby read-write lock implementation # # Allows any number of concurrent readers, but only one concurrent writer # (And if the “write” lock is taken, any readers who come along will have to wait) # # If readers are already active when a writer comes along, the writer will wait for # all the readers to finish before going ahead. # Any additional readers that come when the writer is already waiting, will also # wait (so writers are not starved). # # This implementation is based on ‘java.util.concurrent.ReentrantReadWriteLock`. # # @example #   lock = Concurrent::ReadWriteLock.new #   lock.with_read_lock  { data.retrieve } #   lock.with_write_lock { data.modify! } # @note Do <strong>not</strong> try to acquire the write lock while already holding a read lock #   <strong>or</strong> try to acquire the write lock while you already have it. #   This will lead to deadlock # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a> java.util.concurrent.ReentrantReadWriteLock # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#31 class Concurrent::ReadWriteLock &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new `ReadWriteLock` in the unlocked state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ReadWriteLock] a new instance of ReadWriteLock</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Acquire a read lock. If a write lock has been acquired will block until</span>
<span class="ruby-comment"># it is released. Will not block if other read locks have been acquired.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acquire_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Acquire a write lock. Will block and wait for all active readers and writers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of writers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acquire_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Queries whether any threads are waiting to acquire the read or write lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if any threads are waiting for a lock else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">has_waiters?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Release a previously acquired read lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully released</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">release_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Release a previously acquired write lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully released</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">release_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute a block operation within a read lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError] when no block is given.</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Object] the result of the block operation.</span>
<span class="ruby-comment"># @yield the task to be performed within the lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute a block operation within a write lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError] when no block is given.</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Object] the result of the block operation.</span>
<span class="ruby-comment"># @yield the task to be performed within the lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Queries if the write lock is held by any thread.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the write lock is held else false`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_locked?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_writers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_readers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">waiting_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">waiting_writers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#40 Concurrent::ReadWriteLock::MAX_READERS = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#43 Concurrent::ReadWriteLock::MAX_WRITERS = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#37 Concurrent::ReadWriteLock::RUNNING_WRITER = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#34 Concurrent::ReadWriteLock::WAITING_WRITER = T.let(T.unsafe(nil), Integer)</p>

<p># Re-entrant read-write lock implementation # # Allows any number of concurrent readers, but only one concurrent writer # (And while the “write” lock is taken, no read locks can be obtained either. # Hence, the write lock can also be called an “exclusive” lock.) # # If another thread has taken a read lock, any thread which wants a write lock # will block until all the readers release their locks. However, once a thread # starts waiting to obtain a write lock, any additional readers that come along # will also wait (so writers are not starved). # # A thread can acquire both a read and write lock at the same time. A thread can # also acquire a read lock OR a write lock more than once. Only when the read (or # write) lock is released as many times as it was acquired, will the thread # actually let it go, allowing other threads which might have been waiting # to proceed. Therefore the lock can be upgraded by first acquiring # read lock and then write lock and that the lock can be downgraded by first # having both read and write lock a releasing just the write lock. # # If both read and write locks are acquired by the same thread, it is not strictly # necessary to release them in the same order they were acquired. In other words, # the following code is legal: # # This implementation was inspired by ‘java.util.concurrent.ReentrantReadWriteLock`. # # @example #   lock = Concurrent::ReentrantReadWriteLock.new #   lock.acquire_write_lock #   lock.acquire_read_lock #   lock.release_write_lock #   # At this point, the current thread is holding only a read lock, not a write #   # lock. So other threads can take read locks, but not a write lock. #   lock.release_read_lock #   # Now the current thread is not holding either a read or write lock, so #   # another thread could potentially acquire a write lock. # @example #   lock = Concurrent::ReentrantReadWriteLock.new #   lock.with_read_lock  { data.retrieve } #   lock.with_write_lock { data.modify! } # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a> java.util.concurrent.ReentrantReadWriteLock # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#53 class Concurrent::ReentrantReadWriteLock &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new `ReentrantReadWriteLock` in the unlocked state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ReentrantReadWriteLock] a new instance of ReentrantReadWriteLock</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Acquire a read lock. If a write lock is held by another thread, will block</span>
<span class="ruby-comment"># until it is released.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acquire_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Acquire a write lock. Will block and wait for all active readers and writers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of writers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acquire_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Release a previously acquired read lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully released</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">release_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Release a previously acquired write lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully released</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">release_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Try to acquire a read lock and return true if we succeed. If it cannot be</span>
<span class="ruby-comment"># acquired immediately, return false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Try to acquire a write lock and return true if we succeed. If it cannot be</span>
<span class="ruby-comment"># acquired immediately, return false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the lock is successfully acquired</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute a block operation within a read lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError] when no block is given.</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Object] the result of the block operation.</span>
<span class="ruby-comment"># @yield the task to be performed within the lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_read_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute a block operation within a write lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError] when no block is given.</span>
<span class="ruby-comment"># @raise [Concurrent::ResourceLimitError] if the maximum number of readers</span>
<span class="ruby-comment">#   is exceeded.</span>
<span class="ruby-comment"># @return [Object] the result of the block operation.</span>
<span class="ruby-comment"># @yield the task to be performed within the lock.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_write_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_writers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_readers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_readers?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#355</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">waiting_or_running_writer?</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">waiting_writers</span>(<span class="ruby-identifier">c</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#94 Concurrent::ReentrantReadWriteLock::MAX_READERS = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#96 Concurrent::ReentrantReadWriteLock::MAX_WRITERS = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#84 Concurrent::ReentrantReadWriteLock::READER_BITS = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#102 Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#92 Concurrent::ReentrantReadWriteLock::RUNNING_WRITER = T.let(T.unsafe(nil), Integer)</p>

<p># Used with @Counter: # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#90 Concurrent::ReentrantReadWriteLock::WAITING_WRITER = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#86 Concurrent::ReentrantReadWriteLock::WRITER_BITS = T.let(T.unsafe(nil), Integer)</p>

<p># Used with @HeldCount: # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#100 Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#104 Concurrent::ReentrantReadWriteLock::WRITE_LOCK_MASK = T.let(T.unsafe(nil), Integer)</p>

<p># Raised by an ‘Executor` when it is unable to process a given task, # possibly because of a reject policy or other internal error. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#48 class Concurrent::RejectedExecutionError &lt; ::Concurrent::Error; end</p>

<p># Raised when any finite resource, such as a lock counter, exceeds its # maximum limit/threshold. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#52 class Concurrent::ResourceLimitError &lt; ::Concurrent::Error; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#129 class Concurrent::RubyExchanger &lt; ::Concurrent::AbstractExchanger</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [RubyExchanger] a new instance of RubyExchanger</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_slot</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slot</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slot=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_slot</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_slot</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Waits for another thread to arrive at this exchange point (unless the</span>
<span class="ruby-comment"># current thread is interrupted), and then transfers the given object to</span>
<span class="ruby-comment"># it, receiving its object in return. The timeout value indicates the</span>
<span class="ruby-comment"># approximate number of seconds the method should block while waiting</span>
<span class="ruby-comment"># for the exchange. When the timeout value is `nil` the method will</span>
<span class="ruby-comment"># block indefinitely.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to exchange with another thread</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` blocks indefinitely</span>
<span class="ruby-comment"># @return [Object, CANCEL] the value exchanged by the other thread; {CANCEL} on timeout</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_exchange</span>(<span class="ruby-identifier">value</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#138 class Concurrent::RubyExchanger::Node &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [Node] a new instance of Node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set_value</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">item</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">latch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_value</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_value</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#8 class Concurrent::RubyExecutorService &lt; ::Concurrent::AbstractExecutorService</p>

<pre class="ruby"><span class="ruby-comment"># @return [RubyExecutorService] a new instance of RubyExecutorService</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an immediate shutdown. In-progress tasks will be allowed to</span>
<span class="ruby-comment"># complete but enqueued tasks will be dismissed and no new tasks</span>
<span class="ruby-comment"># will be accepted. Has no additional effect if the thread pool is</span>
<span class="ruby-comment"># not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an orderly shutdown. Tasks already in the queue will be executed,</span>
<span class="ruby-comment"># but no new tasks will be accepted. Has no additional effect if the</span>
<span class="ruby-comment"># thread pool is not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Block until executor shutdown is complete or until `timeout` seconds have</span>
<span class="ruby-comment"># passed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Does not initiate shutdown or termination. Either `shutdown` or `kill`</span>
<span class="ruby-comment">#   must be called before this method (or on another thread).</span>
<span class="ruby-comment"># @param timeout [Integer] the maximum number of seconds to wait for shutdown to complete</span>
<span class="ruby-comment"># @return [Boolean] `true` if shutdown complete or false on `timeout`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_termination</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_running?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shuttingdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stop_event</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stopped_event</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_single_thread_executor.rb#8 class Concurrent::RubySingleThreadExecutor &lt; ::Concurrent::RubyThreadPoolExecutor</p>

<pre class="ruby"><span class="ruby-comment"># @return [RubySingleThreadExecutor] a new instance of RubySingleThreadExecutor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_single_thread_executor.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># **Thread Pool Options** # # Thread pools support several configuration options: # # * ‘idletime`: The number of seconds that a thread may be idle before being reclaimed. # * `name`: The name of the executor (optional). Printed in the executor’s ‘#to_s` output and #   a `&lt;name&gt;-worker-&lt;id&gt;` name is given to its threads if supported by used Ruby #   implementation. `&lt;id&gt;` is uniq for each thread. # * `max_queue`: The maximum number of tasks that may be waiting in the work queue at #   any one time. When the queue size reaches `max_queue` and no new threads can be created, #   subsequent tasks will be rejected in accordance with the configured `fallback_policy`. # * `auto_terminate`: When true (default), the threads started will be marked as daemon. # * `fallback_policy`: The policy defining how rejected tasks are handled. # # Three fallback policies are supported: # # * `:abort`: Raise a `RejectedExecutionError` exception and discard the task. # * `:discard`: Discard the task and return false. # * `:caller_runs`: Execute the task on the calling thread. # # **Shutting Down Thread Pools** # # Killing a thread pool while tasks are still being processed, either by calling # the `#kill` method or at application exit, will have unpredictable results. There # is no way for the thread pool to know what resources are being used by the # in-progress tasks. When those tasks are killed the impact on those resources # cannot be predicted. The <strong>best</strong> practice is to explicitly shutdown all thread # pools using the provided methods: # # * Call `#shutdown` to initiate an orderly termination of all in-progress tasks # * Call `#wait_for_termination` with an appropriate timeout interval an allow #   the orderly shutdown to complete # * Call `#kill` *only when* the thread pool fails to shutdown in the allotted time # # On some runtime platforms (most notably the JVM) the application will not # exit until all thread pools have been shutdown. To prevent applications from # “hanging” on exit, all threads can be marked as daemon according to the # `:auto_terminate` option. # # “`ruby # pool1 = Concurrent::FixedThreadPool.new(5) # threads will be marked as daemon # pool2 = Concurrent::FixedThreadPool.new(5, auto_terminate: false) # mark threads as non-daemon # “` # # @note Failure to properly shutdown a thread pool can lead to unpredictable results. #   Please read *Shutting Down Thread Pools* for more information. # @see <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">docs.oracle.com/javase/tutorial/essential/concurrency/pools.html</a> Java Tutorials: Thread Pools # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html</a> Java Executors class # @see <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</a> Java ExecutorService interface # @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean">docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean</a>- # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#12 class Concurrent::RubyThreadPoolExecutor &lt; ::Concurrent::RubyExecutorService</p>

<pre class="ruby"><span class="ruby-comment"># @return [RubyThreadPoolExecutor] a new instance of RubyThreadPoolExecutor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of threads that are actively executing tasks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of threads that are actively executing tasks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does the task queue have a maximum size?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] True if the task queue has a maximum size else false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_overflow?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of tasks that have been completed by the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of tasks that have been completed by the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">completed_task_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of seconds that a thread may be idle before being reclaimed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of seconds that a thread may be idle before being reclaimed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">idletime</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The largest number of threads that have been created in the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The largest number of threads that have been created in the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of threads currently in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of threads currently in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of threads that may be created in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The maximum number of threads that may be created in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of tasks that may be waiting in the work queue at any one time.</span>
<span class="ruby-comment"># When the queue size reaches `max_queue` subsequent tasks will be rejected in</span>
<span class="ruby-comment"># accordance with the configured `fallback_policy`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The maximum number of tasks that may be waiting in the work queue at any one time.</span>
<span class="ruby-comment">#   When the queue size reaches `max_queue` subsequent tasks will be rejected in</span>
<span class="ruby-comment">#   accordance with the configured `fallback_policy`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_queue</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The minimum number of threads that may be retained in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The minimum number of threads that may be retained in the pool.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Prune the thread pool of unneeded threads</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># What is being pruned is controlled by the min_threads and idletime</span>
<span class="ruby-comment"># parameters passed at pool creation time</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This is a no-op on some pool implementation (e.g. the Java one).  The Ruby</span>
<span class="ruby-comment"># pool will auto-prune each time a new job is posted. You will need to call</span>
<span class="ruby-comment"># this method explicitly in case your application post jobs in bursts (a</span>
<span class="ruby-comment"># lot of jobs and then nothing for long periods)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prune_pool</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of tasks in the queue awaiting execution.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of tasks in the queue awaiting execution.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">queue_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ready_worker</span>(<span class="ruby-identifier">worker</span>, <span class="ruby-identifier">last_message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Number of tasks that may be enqueued before reaching `max_queue` and rejecting</span>
<span class="ruby-comment"># new tasks. A value of -1 indicates that the queue may grow without bound.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] Number of tasks that may be enqueued before reaching `max_queue` and rejecting</span>
<span class="ruby-comment">#   new tasks. A value of -1 indicates that the queue may grow without bound.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remaining_capacity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_busy_worker</span>(<span class="ruby-identifier">worker</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of tasks that have been scheduled for execution on the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] The number of tasks that have been scheduled for execution on the pool since construction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scheduled_task_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Whether or not a value of 0 for :max_queue option means the queue must perform direct hand-off or rather unbounded queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronous</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">worker_died</span>(<span class="ruby-identifier">worker</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">worker_task_completed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># creates new worker which has to receive work to do after it&#39;s added</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [nil, Worker] nil of max capacity is reached</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_add_busy_worker</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># tries to assign task to a worker, tries to get one from @ready or to create new one</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true, false] if task is assigned to a worker</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_assign_worker</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># tries to enqueue task</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true, false] if enqueued</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_enqueue</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_execute</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_kill_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_limited_queue?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># try oldest worker if it is idle for enough time, it&#39;s returned back at the start</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_prune_pool</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># handle ready worker, giving it new job or assigning back to @ready</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_ready_worker</span>(<span class="ruby-identifier">worker</span>, <span class="ruby-identifier">last_message</span>, <span class="ruby-identifier">success</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># removes a worker which is not in not tracked in @ready</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_remove_busy_worker</span>(<span class="ruby-identifier">worker</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_reset_if_forked</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_worker_died</span>(<span class="ruby-identifier">worker</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Default maximum number of threads that will be created in the pool. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#15 Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_POOL_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># Default maximum number of tasks that may be added to the task queue. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#21 Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># Default minimum number of threads that will be retained in the pool. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#18 Concurrent::RubyThreadPoolExecutor::DEFAULT_MIN_POOL_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># Default value of the :synchronous option. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#27 Concurrent::RubyThreadPoolExecutor::DEFAULT_SYNCHRONOUS = T.let(T.unsafe(nil), FalseClass)</p>

<p># Default maximum number of seconds a thread in the pool may remain idle # before being reclaimed. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#24 Concurrent::RubyThreadPoolExecutor::DEFAULT_THREAD_IDLETIMEOUT = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#310 class Concurrent::RubyThreadPoolExecutor::Worker</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>

<span class="ruby-comment"># @return [Worker] a new instance of Worker</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">pool</span>, <span class="ruby-identifier">id</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#332</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#328</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_worker</span>(<span class="ruby-identifier">queue</span>, <span class="ruby-identifier">pool</span>, <span class="ruby-identifier">idletime</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_task</span>(<span class="ruby-identifier">pool</span>, <span class="ruby-identifier">task</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A simple utility class that executes a callable and returns and array of three elements: # success - indicating if the callable has been executed without errors # value - filled by the callable result if it has been executed without errors, nil otherwise # reason - the error risen by the callable if it has been executed with errors, nil otherwise # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#9 class Concurrent::SafeTaskExecutor &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># @return [SafeTaskExecutor] a new instance of SafeTaskExecutor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">task</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># ‘ScheduledTask` is a close relative of `Concurrent::Future` but with one # important difference: A `Future` is set to execute as soon as possible # whereas a `ScheduledTask` is set to execute after a specified delay. This # implementation is loosely based on Java’s # [ScheduledExecutorService](<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html</a>). # It is a more feature-rich variant of {Concurrent.timer}. # # The <strong>intended</strong> schedule time of task execution is set on object construction # with the ‘delay` argument. The delay is a numeric (floating point or integer) # representing a number of seconds in the future. Any other value or a numeric # equal to or less than zero will result in an exception. The <strong>actual</strong> schedule # time of task execution is set when the `execute` method is called. # # The constructor can also be given zero or more processing options. Currently # the only supported options are those recognized by the # [Dereferenceable](Dereferenceable) module. # # The final constructor argument is a block representing the task to be performed. # If no block is given an `ArgumentError` will be raised. # # <strong>States</strong> # # `ScheduledTask` mixes in the  [Obligation](Obligation) module thus giving it # “future” behavior. This includes the expected lifecycle states. `ScheduledTask` # has one additional state, however. While the task (block) is being executed the # state of the object will be `:processing`. This additional state is necessary # because it has implications for task cancellation. # # <strong>Cancellation</strong> # # A `:pending` task can be cancelled using the `#cancel` method. A task in any # other state, including `:processing`, cannot be cancelled. The `#cancel` # method returns a boolean indicating the success of the cancellation attempt. # A cancelled `ScheduledTask` cannot be restarted. It is immutable. # # **Obligation and Observation** # # The result of a `ScheduledTask` can be obtained either synchronously or # asynchronously. `ScheduledTask` mixes in both the [Obligation](Obligation) # module and the # [Observable](<a href="http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html">ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html</a>) # module from the Ruby standard library. With one exception `ScheduledTask` # behaves identically to [Future](Observable) with regard to these modules. # # @example Basic usage # #   require ’concurrent/scheduled_task’ #   require ‘csv’ #   require ‘open-uri’ # #   class Ticker #   def get_year_end_closing(symbol, year, api_key) #   uri = “<a href="https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY&amp;symbol">www.alphavantage.co/query?function=TIME_SERIES_MONTHLY&amp;symbol</a>=#{symbol}&amp;apikey=#{api_key}&amp;datatype=csv” #   data = [] #   csv = URI.parse(uri).read #   if csv.include?(‘call frequency’) #   return :rate_limit_exceeded #   end #   CSV.parse(csv, headers: true) do |row| #   data &lt;&lt; <a href="&#39;close&#39;">row</a>.to_f if <a href="&#39;timestamp&#39;">row</a>.include?(year.to_s) #   end #   year_end = data.first #   year_end #   rescue =&gt; e #   p e #   end #   end # #   api_key = <a href="&#39;ALPHAVANTAGE_KEY&#39;">ENV</a> #   abort(error_message) unless api_key # #   # Future #   price = Concurrent::Future.execute{ Ticker.new.get_year_end_closing(‘TWTR’, 2013, api_key) } #   price.state #=&gt; :pending #   price.pending? #=&gt; true #   price.value(0) #=&gt; nil (does not block) # #   sleep(1)    # do other stuff # #   price.value #=&gt; 63.65 (after blocking if necessary) #   price.state #=&gt; :fulfilled #   price.fulfilled? #=&gt; true #   price.value #=&gt; 63.65 # @example Successful task execution # #   task = Concurrent::ScheduledTask.new(2){ ‘What does the fox say?’ } #   task.state         #=&gt; :unscheduled #   task.execute #   task.state         #=&gt; pending # #   # wait for it… #   sleep(3) # #   task.unscheduled? #=&gt; false #   task.pending?     #=&gt; false #   task.fulfilled?   #=&gt; true #   task.rejected?    #=&gt; false #   task.value        #=&gt; ‘What does the fox say?’ # @example One line creation and execution # #   task = Concurrent::ScheduledTask.new(2){ ‘What does the fox say?’ }.execute #   task.state         #=&gt; pending # #   task = Concurrent::ScheduledTask.execute(2){ ‘What do you get when you multiply 6 by 9?’ } #   task.state         #=&gt; pending # @example Failed task execution # #   task = Concurrent::ScheduledTask.execute(2){ raise StandardError.new(‘Call me maybe?’) } #   task.pending?      #=&gt; true # #   # wait for it… #   sleep(3) # #   task.unscheduled? #=&gt; false #   task.pending?     #=&gt; false #   task.fulfilled?   #=&gt; false #   task.rejected?    #=&gt; true #   task.value        #=&gt; nil #   task.reason       #=&gt; #<StandardError: Call me maybe?&gt; # @example Task execution with observation # #   observer = Class.new{ #   def update(time, value, reason) #   puts &quot;The task completed at #{time} with value &#39;#{value}&#39;&quot; #   end #   }.new # #   task = Concurrent::ScheduledTask.new(2){ &#39;What does the fox say?&#39; } #   task.add_observer(observer) #   task.execute #   task.pending?      #=&gt; true # #   # wait for it... #   sleep(3) # #   #>> The task completed at 2013-11-07 12:26:09 -0500 with value ‘What does the fox say?’ # @see Concurrent.timer # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#158 class Concurrent::ScheduledTask &lt; ::Concurrent::IVar</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>

<span class="ruby-comment"># Schedule a task for execution at a specified future time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task</span>
<span class="ruby-comment"># @param opts [Hash] a customizable set of options</span>
<span class="ruby-comment"># @raise [ArgumentError] When no block is given</span>
<span class="ruby-comment"># @raise [ArgumentError] When given a time that is in the past</span>
<span class="ruby-comment"># @return [ScheduledTask] a new instance of ScheduledTask</span>
<span class="ruby-comment"># @yield the task to be performed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">delay</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Comparator which orders by schedule time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Cancel this task and prevent it from executing. A task can only be</span>
<span class="ruby-comment"># cancelled if it is pending or unscheduled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if successfully cancelled else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancel</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Has the task been cancelled?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the task is in the given state else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancelled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute an `:unscheduled` `ScheduledTask`. Immediately sets the state to `:pending`</span>
<span class="ruby-comment"># and starts counting down toward execution. Does nothing if the `ScheduledTask` is</span>
<span class="ruby-comment"># in any state other than `:unscheduled`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ScheduledTask] a reference to `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#273</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The executor on which to execute the task.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The `delay` value given at instantiation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Float] the initial delay.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initial_delay</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute the task.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_task</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># In the task execution in progress?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if the task is in the given state else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processing?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reschedule the task using the given delay and the current time.</span>
<span class="ruby-comment"># A task can only be reset while it is `:pending`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task</span>
<span class="ruby-comment"># @raise [ArgumentError] When given a time that is in the past</span>
<span class="ruby-comment"># @return [Boolean] true if successfully rescheduled else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reschedule</span>(<span class="ruby-identifier">delay</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reschedule the task using the original delay and the current time.</span>
<span class="ruby-comment"># A task can only be reset while it is `:pending`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if successfully rescheduled else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The monotonic time at which the the task is scheduled to be executed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Float] the schedule time or nil if `unscheduled`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule_time</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fail</span>(<span class="ruby-identifier">reason</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reschedule the task using the given delay and the current time.</span>
<span class="ruby-comment"># A task can only be reset while it is `:pending`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task</span>
<span class="ruby-comment"># @return [Boolean] true if successfully rescheduled else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#326</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_reschedule</span>(<span class="ruby-identifier">delay</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Schedule the task using the given delay and the current time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task</span>
<span class="ruby-comment"># @return [Boolean] true if successfully rescheduled else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_schedule</span>(<span class="ruby-identifier">delay</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_set</span>(<span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Create a new `ScheduledTask` object with the given block, execute it, and return the</span>
  <span class="ruby-comment"># `:pending` object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no block is given</span>
  <span class="ruby-comment"># @return [ScheduledTask] the newly created `ScheduledTask` in the `:pending` state</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#290</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>(<span class="ruby-identifier">delay</span>, <span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A counting semaphore. Conceptually, a semaphore maintains a set of # permits. Each {#acquire} blocks if necessary until a permit is # available, and then takes it. Each {#release} adds a permit, potentially # releasing a blocking acquirer. # However, no actual permit objects are used; the Semaphore just keeps a # count of the number available and acts accordingly. # Alternatively, permits may be acquired within a block, and automatically # released after the block finishes executing. # # @example #   semaphore = Concurrent::Semaphore.new(2) # #   t1 = Thread.new do #   semaphore.acquire #   puts “Thread 1 acquired semaphore” #   end # #   t2 = Thread.new do #   semaphore.acquire #   puts “Thread 2 acquired semaphore” #   end # #   t3 = Thread.new do #   semaphore.acquire #   puts “Thread 3 acquired semaphore” #   end # #   t4 = Thread.new do #   sleep(2) #   puts “Thread 4 releasing semaphore” #   semaphore.release #   end # #   [t1, t2, t3, t4].each(&amp;:join) # #   # prints: #   # Thread 3 acquired semaphore #   # Thread 2 acquired semaphore #   # Thread 4 releasing semaphore #   # Thread 1 acquired semaphore # @example #   semaphore = Concurrent::Semaphore.new(1) # #   puts semaphore.available_permits #   semaphore.acquire do #   puts semaphore.available_permits #   end #   puts semaphore.available_permits # #   # prints: #   # 1 #   # 0 #   # 1 # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/semaphore.rb#161 class Concurrent::Semaphore &lt; ::Concurrent::MutexSemaphore; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/semaphore.rb#96 Concurrent::SemaphoreImplementation = Concurrent::MutexSemaphore</p>

<p># Indicates that the including ‘ExecutorService` guarantees # that all operations will occur in the order they are post and that no # two operations may occur simultaneously. This module provides no # functionality and provides no guarantees. That is the responsibility # of the including class. This module exists solely to allow the including # object to be interrogated for its serialization status. # # @example #   class Foo #   include Concurrent::SerialExecutor #   end # #   foo = Foo.new # #   foo.is_a? Concurrent::ExecutorService #=&gt; true #   foo.is_a? Concurrent::SerialExecutor  #=&gt; true #   foo.serialized?                       #=&gt; true # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serial_executor_service.rb#24 module Concurrent::SerialExecutorService</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">ExecutorService</span>

<span class="ruby-comment"># Does this executor guarantee serialization of its operations?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Always returns `true`</span>
<span class="ruby-comment"># @return [Boolean] True if the executor guarantees that all operations</span>
<span class="ruby-comment">#   will be post in the order they are received and no two operations may</span>
<span class="ruby-comment">#   occur simultaneously. Else false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serial_executor_service.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serialized?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Ensures passed jobs in a serialized order never running at the same time. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#8 class Concurrent::SerializedExecution &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>

<span class="ruby-comment"># @return [SerializedExecution] a new instance of SerializedExecution</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param executor [Executor] to be used for this job</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-identifier">executor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># As {#post} but allows to submit multiple tasks at once, it&#39;s guaranteed that they will not</span>
<span class="ruby-comment"># be interleaved by other tasks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param posts [Array&lt;Array(ExecutorService, Array&lt;Object&gt;, Proc)&gt;] array of triplets where</span>
<span class="ruby-comment">#   first is a {ExecutorService}, second is array of args for task, third is a task (Proc)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">posts</span>(<span class="ruby-identifier">posts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_job</span>(<span class="ruby-identifier">job</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># ensures next job is executed if any is stashed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">work</span>(<span class="ruby-identifier">job</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16 class Concurrent::SerializedExecution::Job &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute args</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute args to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute block</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of block</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute block</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute block to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute executor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute executor to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executor=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A wrapper/delegator for any ‘ExecutorService` that # guarantees serialized execution of tasks. # # @see [SimpleDelegator](<a href="http://www.ruby-doc.org/stdlib-2.1.2/libdoc/delegate/rdoc/SimpleDelegator.html">www.ruby-doc.org/stdlib-2.1.2/libdoc/delegate/rdoc/SimpleDelegator.html</a>) # @see Concurrent::SerializedExecution # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#12 class Concurrent::SerializedExecutionDelegator &lt; ::SimpleDelegator</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Logging</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">ExecutorService</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">SerialExecutorService</span>

<span class="ruby-comment"># @return [SerializedExecutionDelegator] a new instance of SerializedExecutionDelegator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">executor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread-safe subclass of Set. This version locks against the object # itself for every method call, ensuring only one thread can be reading # or writing at a time. This includes iteration methods like ‘#each`. # # @note `a += b` is <strong>not</strong> a <strong>thread-safe</strong> operation on #   `Concurrent::Set`. It reads Set `a`, then it creates new `Concurrent::Set` #   which is union of `a` and `b`, then it writes the union to `a`. #   The read and write are independent operations they do not form a single atomic #   operation therefore when two `+=` operations are executed concurrently updates #   may be lost. Use `#merge` instead. # @see <a href="http://ruby-doc.org/stdlib-2.4.0/libdoc/set/rdoc/Set.html">ruby-doc.org/stdlib-2.4.0/libdoc/set/rdoc/Set.html</a> Ruby standard library `Set` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#61 class Concurrent::Set &lt; ::Concurrent::CRubySet; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#23 Concurrent::SetImplementation = Concurrent::CRubySet</p>

<p># An thread-safe, write-once variation of Ruby’s standard ‘Struct`. # Each member can have its value set at most once, either at construction # or any time thereafter. Attempting to assign a value to a member # that has already been set will result in a `Concurrent::ImmutabilityError`. # # @see <a href="http://ruby-doc.org/core/Struct.html">ruby-doc.org/core/Struct.html</a> Ruby standard library `Struct` # @see <a href="http://en.wikipedia.org/wiki/Final_(Java">en.wikipedia.org/wiki/Final_(Java</a>) Java `final` keyword # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#14 module Concurrent::SettableStruct</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">AbstractStruct</span>

<span class="ruby-comment"># Equality</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if other has the same struct subclass and has</span>
<span class="ruby-comment">#   equal member values (according to `Object#==`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attribute Reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param member [Symbol, String, Integer] the string or symbol name of the member</span>
<span class="ruby-comment">#   for which to obtain the value or the member&#39;s index</span>
<span class="ruby-comment"># @raise [NameError] if the member does not exist</span>
<span class="ruby-comment"># @raise [IndexError] if the index is out of range.</span>
<span class="ruby-comment"># @return [Object] the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">member</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attribute Assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Sets the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param member [Symbol, String, Integer] the string or symbol name of the member</span>
<span class="ruby-comment">#   for which to obtain the value or the member&#39;s index</span>
<span class="ruby-comment"># @raise [NameError] if the name does not exist</span>
<span class="ruby-comment"># @raise [IndexError] if the index is out of range.</span>
<span class="ruby-comment"># @raise [Concurrent::ImmutabilityError] if the given member has already been set</span>
<span class="ruby-comment"># @return [Object] the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">member</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the value of each struct member in order. If no block is given</span>
<span class="ruby-comment"># an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the name and value of each struct member in order. If no block is</span>
<span class="ruby-comment"># given an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member/value pair</span>
<span class="ruby-comment"># @yieldparam member [Object] each struct member (in order)</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Describe the contents of this struct in a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the contents of this struct in a string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a new struct containing the contents of `other` and the contents</span>
<span class="ruby-comment"># of `self`. If no block is specified, the value for entries with duplicate</span>
<span class="ruby-comment"># keys will be that of `other`. Otherwise the value for each duplicate key</span>
<span class="ruby-comment"># is determined by calling the block with the key, its value in `self` and</span>
<span class="ruby-comment"># its value in `other`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param other [Hash] the hash from which to set the new values</span>
<span class="ruby-comment"># @raise [ArgumentError] of given a member that is not defined in the struct</span>
<span class="ruby-comment"># @return [Synchronization::AbstractStruct] a new struct with the new values</span>
<span class="ruby-comment"># @yield an options block for resolving duplicate keys</span>
<span class="ruby-comment"># @yieldparam member [String, Symbol] the name of the member which is duplicated</span>
<span class="ruby-comment"># @yieldparam selfvalue [Object] the value of the member in `self`</span>
<span class="ruby-comment"># @yieldparam othervalue [Object] the value of the member in `other`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">other</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields each member value from the struct to the block and returns an Array</span>
<span class="ruby-comment"># containing the member values from the struct for which the given block</span>
<span class="ruby-comment"># returns a true value (equivalent to `Enumerable#select`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] an array containing each value for which the block returns true</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the values for this struct as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the values for this struct</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a hash containing the names and values for the struct’s members.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Hash] the names and values for the struct’s members</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Describe the contents of this struct in a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the contents of this struct in a string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the values for this struct as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the values for this struct</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the struct member values for each selector as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A selector may be either an Integer offset or a Range of offsets (as in `Array#values_at`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param indexes [Fixnum, Range] the index(es) from which to obatin the values (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indexes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">original</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Factory for creating new struct classes.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ```</span>
  <span class="ruby-comment"># new([class_name] [, member_name]+&gt;) -&gt; StructClass click to toggle source</span>
  <span class="ruby-comment"># new([class_name] [, member_name]+&gt;) {|StructClass| block } -&gt; StructClass</span>
  <span class="ruby-comment"># new(value, ...) -&gt; obj</span>
  <span class="ruby-comment"># StructClass[value, ...] -&gt; obj</span>
  <span class="ruby-comment"># ```</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The first two forms are used to create a new struct subclass `class_name`</span>
  <span class="ruby-comment"># that can contain a value for each   member_name . This subclass can be</span>
  <span class="ruby-comment"># used to create instances of the structure like any other  Class .</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If the `class_name` is omitted an anonymous struct class will be created.</span>
  <span class="ruby-comment"># Otherwise, the name of this struct will appear as a constant in the struct class,</span>
  <span class="ruby-comment"># so it must be unique for all structs under this base class and must start with a</span>
  <span class="ruby-comment"># capital letter. Assigning a struct class to a constant also gives the class</span>
  <span class="ruby-comment"># the name of the constant.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If a block is given it will be evaluated in the context of `StructClass`, passing</span>
  <span class="ruby-comment"># the created class as a parameter. This is the recommended way to customize a struct.</span>
  <span class="ruby-comment"># Subclassing an anonymous struct creates an extra anonymous class that will never be used.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The last two forms create a new instance of a struct subclass. The number of value</span>
  <span class="ruby-comment"># parameters must be less than or equal to the number of attributes defined for the</span>
  <span class="ruby-comment"># struct. Unset parameters default to nil. Passing more parameters than number of attributes</span>
  <span class="ruby-comment"># will raise an `ArgumentError`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @see http://ruby-doc.org/core/Struct.html#method-c-new Ruby standard library `Struct#new`</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#105</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#115 Concurrent::SettableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)</p>

<p># An executor service in which every operation spawns a new, # independently operating thread. # # This is perhaps the most inefficient executor service in this # library. It exists mainly for testing an debugging. Thread creation # and management is expensive in Ruby and this executor performs no # resource pooling. This can be very beneficial during testing and # debugging because it decouples the using code from the underlying # executor implementation. In production this executor will likely # lead to suboptimal performance. # # @note Intended for use primarily in testing and debugging. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#21 class Concurrent::SimpleExecutorService &lt; ::Concurrent::RubyExecutorService</p>

<pre class="ruby"><span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param task [Proc] the asynchronous task to perform</span>
<span class="ruby-comment"># @return [self] returns itself</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an immediate shutdown. In-progress tasks will be allowed to</span>
<span class="ruby-comment"># complete but enqueued tasks will be dismissed and no new tasks</span>
<span class="ruby-comment"># will be accepted. Has no additional effect if the thread pool is</span>
<span class="ruby-comment"># not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
<span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
<span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
<span class="ruby-comment">#   is not running</span>
<span class="ruby-comment"># @yield the asynchronous task to perform</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor running?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when running, `false` when shutting down or shutdown</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an orderly shutdown. Tasks already in the queue will be executed,</span>
<span class="ruby-comment"># but no new tasks will be accepted. Has no additional effect if the</span>
<span class="ruby-comment"># thread pool is not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor shutdown?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when shutdown, `false` when shutting down or running</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor shuttingdown?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when not running and not shutdown, else `false`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuttingdown?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Block until executor shutdown is complete or until `timeout` seconds have</span>
<span class="ruby-comment"># passed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Does not initiate shutdown or termination. Either `shutdown` or `kill`</span>
<span class="ruby-comment">#   must be called before this method (or on another thread).</span>
<span class="ruby-comment"># @param timeout [Integer] the maximum number of seconds to wait for shutdown to complete</span>
<span class="ruby-comment"># @return [Boolean] `true` if shutdown complete or false on `timeout`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_termination</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param task [Proc] the asynchronous task to perform</span>
  <span class="ruby-comment"># @return [self] returns itself</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Submit a task to the executor for asynchronous processing.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param args [Array] zero or more arguments to be passed to the task</span>
  <span class="ruby-comment"># @raise [ArgumentError] if no task is given</span>
  <span class="ruby-comment"># @return [Boolean] `true` if the task is queued, `false` if the executor</span>
  <span class="ruby-comment">#   is not running</span>
  <span class="ruby-comment"># @yield the asynchronous task to perform</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A thread pool with a single thread an unlimited queue. Should the thread # die for any reason it will be removed and replaced, thus ensuring that # the executor will always remain viable and available to process jobs. # # A common pattern for background processing is to create a single thread # on which an infinite loop is run. The thread’s loop blocks on an input # source (perhaps blocking I/O or a queue) and processes each input as it # is received. This pattern has several issues. The thread itself is highly # susceptible to errors during processing. Also, the thread itself must be # constantly monitored and restarted should it die. ‘SingleThreadExecutor` # encapsulates all these behaviors. The task processor is highly resilient # to errors from within tasks. Also, should the thread die it will # automatically be restarted. # # The API and behavior of this class are based on Java’s ‘SingleThreadExecutor`. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/single_thread_executor.rb#37 class Concurrent::SingleThreadExecutor &lt; ::Concurrent::RubySingleThreadExecutor; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/single_thread_executor.rb#10 Concurrent::SingleThreadExecutorImplementation = Concurrent::RubySingleThreadExecutor</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#2 module Concurrent::Synchronization</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/full_memory_barrier.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">full_memory_barrier</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#9 class Concurrent::Synchronization::AbstractLockableObject &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Broadcast to all waiting threads.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note only to be used inside synchronized block</span>
<span class="ruby-comment"># @note to provide direct access to this method in a descendant add method</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment">#   def broadcast</span>
<span class="ruby-comment">#   synchronize { ns_broadcast }</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Signal one waiting thread.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note only to be used inside synchronized block</span>
<span class="ruby-comment"># @note to provide direct access to this method in a descendant add method</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment">#   def signal</span>
<span class="ruby-comment">#   synchronize { ns_signal }</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_signal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait until another thread calls #signal or #broadcast,</span>
<span class="ruby-comment"># spurious wake-ups can happen.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note only to be used inside synchronized block</span>
<span class="ruby-comment"># @note to provide direct access to this method in a descendant add method</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment">#   def wait(timeout = nil)</span>
<span class="ruby-comment">#   synchronize { ns_wait(timeout) }</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` means no timeout</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [self]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Wait until condition is met or timeout passes,</span>
<span class="ruby-comment"># protects against spurious wake-ups.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note only to be used inside synchronized block</span>
<span class="ruby-comment"># @note to provide direct access to this method in a descendant add method</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment">#   def wait_until(timeout = nil, &amp;condition)</span>
<span class="ruby-comment">#   synchronize { ns_wait_until(timeout, &amp;condition) }</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   ```</span>
<span class="ruby-comment"># @param timeout [Numeric, nil] in seconds, `nil` means no timeout</span>
<span class="ruby-comment"># @return [true, false] if condition met</span>
<span class="ruby-comment"># @yield condition to be met</span>
<span class="ruby-comment"># @yieldreturn [true, false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait_until</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @note can by made public in descendants if required by `public :synchronize`</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @yield runs the block synchronized against this object,</span>
<span class="ruby-comment">#   equivalent of java&#39;s `synchronize(this) {}`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#6 class Concurrent::Synchronization::AbstractObject</p>

<pre class="ruby"><span class="ruby-comment"># @return [AbstractObject] a new instance of AbstractObject</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">full_memory_barrier</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @raise [NotImplementedError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attr_volatile</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#6 module Concurrent::Synchronization::AbstractStruct</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the number of struct members.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the number of struct members</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the struct members as an array of symbols.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the struct members as an array of symbols</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the number of struct members.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Fixnum] the number of struct members</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Yields the value of each struct member in order. If no block is given</span>
<span class="ruby-comment"># an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_each</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the name and value of each struct member in order. If no block is</span>
<span class="ruby-comment"># given an enumerator is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member/value pair</span>
<span class="ruby-comment"># @yieldparam member [Object] each struct member (in order)</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_each_pair</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Equality</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] true if other has the same struct subclass and has</span>
<span class="ruby-comment">#   equal member values (according to `Object#==`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_equality</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attribute Reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param member [Symbol, String, Integer] the string or symbol name of the member</span>
<span class="ruby-comment">#   for which to obtain the value or the member&#39;s index</span>
<span class="ruby-comment"># @raise [NameError] if the member does not exist</span>
<span class="ruby-comment"># @raise [IndexError] if the index is out of range.</span>
<span class="ruby-comment"># @return [Object] the value of the given struct member or the member at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_get</span>(<span class="ruby-identifier">member</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize_copy</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Describe the contents of this struct in a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the contents of this struct in a string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a new struct containing the contents of `other` and the contents</span>
<span class="ruby-comment"># of `self`. If no block is specified, the value for entries with duplicate</span>
<span class="ruby-comment"># keys will be that of `other`. Otherwise the value for each duplicate key</span>
<span class="ruby-comment"># is determined by calling the block with the key, its value in `self` and</span>
<span class="ruby-comment"># its value in `other`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param other [Hash] the hash from which to set the new values</span>
<span class="ruby-comment"># @raise [ArgumentError] of given a member that is not defined in the struct</span>
<span class="ruby-comment"># @return [Synchronization::AbstractStruct] a new struct with the new values</span>
<span class="ruby-comment"># @yield an options block for resolving duplicate keys</span>
<span class="ruby-comment"># @yieldparam member [String, Symbol] the name of the member which is duplicated</span>
<span class="ruby-comment"># @yieldparam selfvalue [Object] the value of the member in `self`</span>
<span class="ruby-comment"># @yieldparam othervalue [Object] the value of the member in `other`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_merge</span>(<span class="ruby-identifier">other</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields each member value from the struct to the block and returns an Array</span>
<span class="ruby-comment"># containing the member values from the struct for which the given block</span>
<span class="ruby-comment"># returns a true value (equivalent to `Enumerable#select`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] an array containing each value for which the block returns true</span>
<span class="ruby-comment"># @yield the operation to be performed on each struct member</span>
<span class="ruby-comment"># @yieldparam value [Object] each struct value (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_select</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a hash containing the names and values for the struct’s members.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Hash] the names and values for the struct’s members</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the values for this struct as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the values for this struct</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the struct member values for each selector as an Array.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A selector may be either an Integer offset or a Range of offsets (as in `Array#values_at`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param indexes [Fixnum, Range] the index(es) from which to obatin the values (in order)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_values_at</span>(<span class="ruby-identifier">indexes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pr_underscore</span>(<span class="ruby-identifier">clazz</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#141</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_struct_class</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">members</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># TODO (pitr-ch 04-Dec-2016): should be in edge # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#8 class Concurrent::Synchronization::Condition &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># @return [Condition] a new instance of Condition</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">lock</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_signal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait_until</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#8 module Concurrent::Synchronization::ConditionSignalling</p>

<pre class="ruby"><span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_signal</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># TODO (pitr-ch 04-Dec-2016): should be in edge # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#8 class Concurrent::Synchronization::Lock &lt; ::Concurrent::Synchronization::LockableObject</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_broadcast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_signal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait_until</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Safe synchronization under any Ruby implementation. #   It provides methods like {#synchronize}, {#wait}, {#signal} and {#broadcast}. #   Provides a single layer which can improve its implementation over time without changes needed to #   the classes using it. Use {Synchronization::Object} not this abstract class. # #   @note this object does not support usage together with #     [‘Thread#wakeup`](<a href="http://ruby-doc.org/core/Thread.html#method-i-wakeup">ruby-doc.org/core/Thread.html#method-i-wakeup</a>) #     and [`Thread#raise`](<a href="http://ruby-doc.org/core/Thread.html#method-i-raise">ruby-doc.org/core/Thread.html#method-i-raise</a>). #     `Thread#sleep` and `Thread#wakeup` will work as expected but mixing `Synchronization::Object#wait` and #     `Thread#wakeup` will not work on all platforms. # #   @see Event implementation as an example of this class use # #   @example simple #     class AnClass &lt; Synchronization::Object #       def initialize #         super #         synchronize { @value = ’asd’ } #       end # #       def value #         synchronize { @value } #       end #     end # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lockable_object.rb#50 class Concurrent::Synchronization::LockableObject &lt; ::Concurrent::Synchronization::MutexLockableObject</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_condition</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lockable_object.rb#11 Concurrent::Synchronization::LockableObjectImplementation = Concurrent::Synchronization::MutexLockableObject</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#60 class Concurrent::Synchronization::MonitorLockableObject &lt; ::Concurrent::Synchronization::AbstractLockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionSignalling</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [MonitorLockableObject] a new instance of MonitorLockableObject</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># TODO may be a problem with lock.synchronize { lock.wait }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#25 class Concurrent::Synchronization::MutexLockableObject &lt; ::Concurrent::Synchronization::AbstractLockableObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionSignalling</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># @return [MutexLockableObject] a new instance of MutexLockableObject</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_wait</span>(<span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synchronize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Abstract object providing final, volatile, ans CAS extensions to build other concurrent abstractions. # - final instance variables see {Object.safe_initialization!} # - volatile instance variables see {Object.attr_volatile} # - volatile instance variables see {Object.attr_atomic} # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#15 class Concurrent::Synchronization::Object &lt; ::Concurrent::Synchronization::AbstractObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Volatile</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Volatile</span><span class="ruby-operator">::</span><span class="ruby-constant">ClassMethods</span>

<span class="ruby-comment"># Has to be called by children.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] a new instance of Object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__initialize_atomic_fields__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @return [true, false] is the attribute with name atomic?</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#125</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">atomic_attribute?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @param inherited [true, false] should inherited volatile with CAS fields be returned?</span>
  <span class="ruby-comment"># @return [::Array&lt;Symbol&gt;] Returns defined volatile with CAS fields on this class.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#119</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">atomic_attributes</span>(<span class="ruby-identifier">inherited</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Creates methods for reading and writing to a instance variable with</span>
  <span class="ruby-comment"># volatile (Java) semantic as {.attr_volatile} does.</span>
  <span class="ruby-comment"># The instance variable should be accessed only through generated methods.</span>
  <span class="ruby-comment"># This method generates following methods: `value`, `value=(new_value) #=&gt; new_value`,</span>
  <span class="ruby-comment"># `swap_value(new_value) #=&gt; old_value`,</span>
  <span class="ruby-comment"># `compare_and_set_value(expected, value) #=&gt; true || false`, `update_value(&amp;block)`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param names [::Array&lt;Symbol&gt;] of the instance variables to be volatile with CAS.</span>
  <span class="ruby-comment"># @return [::Array&lt;Symbol&gt;] names of defined method names.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#84</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attr_atomic</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># For testing purposes, quite slow. Injects assert code to new method which will raise if class instance contains</span>
  <span class="ruby-comment"># any instance variables with CamelCase names and isn&#39;t {.safe_initialization?}.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @raise when offend found</span>
  <span class="ruby-comment"># @return [true]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#45</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_safe_initialization_when_final_fields_are_present</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#33</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_initialization!</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_initialization?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#131</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_initialize_atomic_fields</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># By extending this module, a class and all its children are marked to be constructed safely. Meaning that # all writes (ivar initializations) are made visible to all readers of newly constructed object. It ensures # same behaviour as Java’s final fields. # # Due to using Kernel#extend, the module is not included again if already present in the ancestors, # which avoids extra overhead. # # @example #   class AClass &lt; Concurrent::Synchronization::Object #   extend Concurrent::Synchronization::SafeInitialization # #   def initialize #   @AFinalValue = ‘value’ # published safely, #foo will never return nil #   end # #   def foo #   @AFinalValue #   end #   end # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#28 module Concurrent::Synchronization::SafeInitialization</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Volatile adds the attr_volatile class method when included. # #  foo = Foo.new #  foo.bar #  =&gt; 1 #  foo.bar = 2 #  =&gt; 2 # # @example #   class Foo #   include Concurrent::Synchronization::Volatile # #   attr_volatile :bar # #   def initialize #   self.bar = 1 #   end #   end # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#28 module Concurrent::Synchronization::Volatile</p>

<pre class="ruby"><span class="ruby-identifier">mixes_in_class_methods</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">Volatile</span><span class="ruby-operator">::</span><span class="ruby-constant">ClassMethods</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">full_memory_barrier</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#29</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#37 module Concurrent::Synchronization::Volatile::ClassMethods</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attr_volatile</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class provides a trivial way to synchronize all calls to a given object # by wrapping it with a ‘Delegator` that performs `Monitor#enter/exit` calls # around the delegated `#send`. Example: # #   array = [] # not thread-safe on many impls #   array = SynchronizedDelegator.new([]) # thread-safe # # A simple `Monitor` provides a very coarse-grained way to synchronize a given # object, in that it will cause synchronization for methods that have no need # for it, but this is a trivial way to get thread-safety where none may exist # currently on some implementations. # # This class is currently being considered for inclusion into stdlib, via # <a href="https://bugs.ruby-lang.org/issues/8556">bugs.ruby-lang.org/issues/8556</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#21 class Concurrent::SynchronizedDelegator &lt; ::SimpleDelegator</p>

<pre class="ruby"><span class="ruby-comment"># @return [SynchronizedDelegator] a new instance of SynchronizedDelegator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">obj</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_missing</span>(<span class="ruby-identifier">method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setup</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">teardown</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A ‘TVar` is a transactional variable - a single-element container that # is used as part of a transaction - see `Concurrent::atomically`. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # {include:file:docs-source/tvar.md} # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#12 class Concurrent::TVar &lt; ::Concurrent::Synchronization::Object</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Synchronization</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeInitialization</span>

<span class="ruby-comment"># Create a new `TVar` with an initial value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [TVar] a new instance of TVar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_lock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Get the value of a `TVar`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the value of a `TVar`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A ‘ThreadLocalVar` is a variable where the value is different for each thread. # Each variable may have a default value, but when you modify the variable only # the current thread will ever see that change. # # This is similar to Ruby’s built-in thread-local variables (‘Thread#thread_variable_get`), # but with these major advantages: # * `ThreadLocalVar` has its own identity, it doesn’t need a Symbol. # * Each Ruby’s built-in thread-local variable leaks some memory forever (it’s a Symbol held forever on the thread), #   so it’s only OK to create a small amount of them. #   ‘ThreadLocalVar` has no such issue and it is fine to create many of them. # * Ruby’s built-in thread-local variables leak forever the value set on each thread (unless set to nil explicitly). #   ‘ThreadLocalVar` automatically removes the mapping for each thread once the `ThreadLocalVar` instance is GC’d. # # # ## Thread-safe Variable Classes # # Each of the thread-safe variable classes is designed to solve a different # problem. In general: # # * *{Concurrent::Agent}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>asynchronous</strong> change of individual values. Best used when #   the value will undergo frequent, complex updates. Suitable when the result #   of an update does not need to be known immediately. # * *{Concurrent::Atom}:* Shared, mutable variable providing independent, #   uncoordinated, <strong>synchronous</strong> change of individual values. Best used when #   the value will undergo frequent reads but only occasional, though complex, #   updates. Suitable when the result of an update must be known immediately. # * *{Concurrent::AtomicReference}:* A simple object reference that can be updated #   atomically. Updates are synchronous but fast. Best used when updates a #   simple set operations. Not suitable when updates are complex. #   {Concurrent::AtomicBoolean} and {Concurrent::AtomicFixnum} are similar #   but optimized for the given data type. # * *{Concurrent::Exchanger}:* Shared, stateless synchronization point. Used #   when two or more threads need to exchange data. The threads will pair then #   block on each other until the exchange is complete. # * *{Concurrent::MVar}:* Shared synchronization point. Used when one thread #   must give a value to another, which must take the value. The threads will #   block on each other until the exchange is complete. # * *{Concurrent::ThreadLocalVar}:* Shared, mutable, isolated variable which #   holds a different value for each thread which has access. Often used as #   an instance variable in objects which must maintain different state #   for different threads. # * *{Concurrent::TVar}:* Shared, mutable variables which provide #   <strong>coordinated</strong>, <strong>synchronous</strong>, change of <strong>many</strong> stated. Used when multiple #   value must change together, in an all-or-nothing transaction. # # @example #   v = ThreadLocalVar.new(14) #   v.value #=&gt; 14 #   v.value = 2 #   v.value #=&gt; 2 # @example #   v = ThreadLocalVar.new(14) # #   t1 = Thread.new do #   v.value #=&gt; 14 #   v.value = 1 #   v.value #=&gt; 1 #   end # #   t2 = Thread.new do #   v.value #=&gt; 14 #   v.value = 2 #   v.value #=&gt; 2 #   end # #   v.value #=&gt; 14 # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#43 class Concurrent::ThreadLocalVar</p>

<pre class="ruby"><span class="ruby-comment"># Creates a thread local variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param default [Object] the default value when otherwise unset</span>
<span class="ruby-comment"># @param default_block [Proc] Optional block that gets called to obtain the</span>
<span class="ruby-comment">#   default value for each thread</span>
<span class="ruby-comment"># @return [ThreadLocalVar] a new instance of ThreadLocalVar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">default</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">default_block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Bind the given value to thread local storage during</span>
<span class="ruby-comment"># execution of the given block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to bind</span>
<span class="ruby-comment"># @return [Object] the value</span>
<span class="ruby-comment"># @yield the operation to be performed with the bound variable</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bind</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value in the current thread&#39;s copy of this thread-local variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the current thread&#39;s copy of this thread-local variable to the specified value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set</span>
<span class="ruby-comment"># @return [Object] the new value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#44 Concurrent::ThreadLocalVar::LOCALS = T.let(T.unsafe(nil), Concurrent::ThreadLocals)</p>

<p># An array-backed storage of indexed variables per thread. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#141 class Concurrent::ThreadLocals &lt; ::Concurrent::AbstractLocals</p>

<pre class="ruby"><span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">locals!</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An abstraction composed of one or more threads and a task queue. Tasks # (blocks or ‘proc` objects) are submitted to the pool and added to the queue. # The threads in the pool remove the tasks and execute them in the order # they were received. # # A `ThreadPoolExecutor` will automatically adjust the pool size according # to the bounds set by `min-threads` and `max-threads`. When a new task is # submitted and fewer than `min-threads` threads are running, a new thread # is created to handle the request, even if other worker threads are idle. # If there are more than `min-threads` but less than `max-threads` threads # running, a new thread will be created only if the queue is full. # # Threads that are idle for too long will be garbage collected, down to the # configured minimum options. Should a thread crash it, too, will be garbage collected. # # `ThreadPoolExecutor` is based on the Java class of the same name. From # the official Java documentation; # # &gt; Thread pools address two different problems: they usually provide # &gt; improved performance when executing large numbers of asynchronous tasks, # &gt; due to reduced per-task invocation overhead, and they provide a means # &gt; of bounding and managing the resources, including threads, consumed # &gt; when executing a collection of tasks. Each ThreadPoolExecutor also # &gt; maintains some basic statistics, such as the number of completed tasks. # &gt; # &gt; To be useful across a wide range of contexts, this class provides many # &gt; adjustable parameters and extensibility hooks. However, programmers are # &gt; urged to use the more convenient Executors factory methods # &gt; [CachedThreadPool] (unbounded thread pool, with automatic thread reclamation), # &gt; [FixedThreadPool] (fixed size thread pool) and [SingleThreadExecutor] (single # &gt; background thread), that preconfigure settings for the most common usage # &gt; scenarios. # # **Thread Pool Options** # # Thread pools support several configuration options: # # * `idletime`: The number of seconds that a thread may be idle before being reclaimed. # * `name`: The name of the executor (optional). Printed in the executor’s ‘#to_s` output and #   a `&lt;name&gt;-worker-&lt;id&gt;` name is given to its threads if supported by used Ruby #   implementation. `&lt;id&gt;` is uniq for each thread. # * `max_queue`: The maximum number of tasks that may be waiting in the work queue at #   any one time. When the queue size reaches `max_queue` and no new threads can be created, #   subsequent tasks will be rejected in accordance with the configured `fallback_policy`. # * `auto_terminate`: When true (default), the threads started will be marked as daemon. # * `fallback_policy`: The policy defining how rejected tasks are handled. # # Three fallback policies are supported: # # * `:abort`: Raise a `RejectedExecutionError` exception and discard the task. # * `:discard`: Discard the task and return false. # * `:caller_runs`: Execute the task on the calling thread. # # **Shutting Down Thread Pools** # # Killing a thread pool while tasks are still being processed, either by calling # the `#kill` method or at application exit, will have unpredictable results. There # is no way for the thread pool to know what resources are being used by the # in-progress tasks. When those tasks are killed the impact on those resources # cannot be predicted. The <strong>best</strong> practice is to explicitly shutdown all thread # pools using the provided methods: # # * Call `#shutdown` to initiate an orderly termination of all in-progress tasks # * Call `#wait_for_termination` with an appropriate timeout interval an allow #   the orderly shutdown to complete # * Call `#kill` *only when* the thread pool fails to shutdown in the allotted time # # On some runtime platforms (most notably the JVM) the application will not # exit until all thread pools have been shutdown. To prevent applications from # “hanging” on exit, all threads can be marked as daemon according to the # `:auto_terminate` option. # # “`ruby # pool1 = Concurrent::FixedThreadPool.new(5) # threads will be marked as daemon # pool2 = Concurrent::FixedThreadPool.new(5, auto_terminate: false) # mark threads as non-daemon # “` # # @note Failure to properly shutdown a thread pool can lead to unpredictable results. #   Please read *Shutting Down Thread Pools* for more information. # @see <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">docs.oracle.com/javase/tutorial/essential/concurrency/pools.html</a> Java Tutorials: Thread Pools # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html</a> Java Executors class # @see <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</a> Java ExecutorService interface # @see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean">docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDaemon-boolean</a>- # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/thread_pool_executor.rb#56 class Concurrent::ThreadPoolExecutor &lt; ::Concurrent::RubyThreadPoolExecutor; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/thread_pool_executor.rb#10 Concurrent::ThreadPoolExecutorImplementation = Concurrent::RubyThreadPoolExecutor</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#4 module Concurrent::ThreadSafe; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#7 module Concurrent::ThreadSafe::Util</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_synchronized_on_cruby</span>(<span class="ruby-identifier">klass</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#41</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_synchronized_on_truffleruby</span>(<span class="ruby-identifier">klass</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># TODO (pitr-ch 15-Oct-2016): migrate to Utility::ProcessorCounter # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#13 Concurrent::ThreadSafe::Util::CPU_COUNT = T.let(T.unsafe(nil), Integer)</p>

<p># TODO (pitr-ch 15-Oct-2016): migrate to Utility::NativeInteger # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#10 Concurrent::ThreadSafe::Util::FIXNUM_BIT_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#11 Concurrent::ThreadSafe::Util::MAX_INT = T.let(T.unsafe(nil), Integer)</p>

<p># Raised when an operation times out. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#55 class Concurrent::TimeoutError &lt; ::Concurrent::Error; end</p>

<p># Executes a collection of tasks, each after a given delay. A master task # monitors the set and schedules each task for execution at the appropriate # time. Tasks are run on the global thread pool or on the supplied executor. # Each task is represented as a ‘ScheduledTask`. # # @see Concurrent::ScheduledTask # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#19 class Concurrent::TimerSet &lt; ::Concurrent::RubyExecutorService</p>

<pre class="ruby"><span class="ruby-comment"># Create a new set of timed tasks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options used to specify the executor on which to perform actions</span>
<span class="ruby-comment"># @return [TimerSet] a new instance of TimerSet</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Begin an immediate shutdown. In-progress tasks will be allowed to</span>
<span class="ruby-comment"># complete but enqueued tasks will be dismissed and no new tasks</span>
<span class="ruby-comment"># will be accepted. Has no additional effect if the thread pool is</span>
<span class="ruby-comment"># not running.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kill</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Post a task to be execute run after a given delay (in seconds). If the</span>
<span class="ruby-comment"># delay is less than 1/100th of a second the task will be immediately post</span>
<span class="ruby-comment"># to the executor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param delay [Float] the number of seconds to wait for before executing the task.</span>
<span class="ruby-comment"># @param args [Array&lt;Object&gt;] the arguments passed to the task on execution.</span>
<span class="ruby-comment"># @raise [ArgumentError] if the intended execution time is not in the future.</span>
<span class="ruby-comment"># @raise [ArgumentError] if no block is given.</span>
<span class="ruby-comment"># @return [Concurrent::ScheduledTask, false] IVar representing the task if the post</span>
<span class="ruby-comment">#   is successful; false after shutdown.</span>
<span class="ruby-comment"># @yield the task to be performed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-identifier">delay</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Initialize the object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param opts [Hash] the options to create the object with.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_post_task</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_reset_if_forked</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># `ExecutorService` callback called during shutdown.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Post the task to the internal queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This is intended as a callback method from ScheduledTask</span>
<span class="ruby-comment">#   only. It is not intended to be used directly. Post a task</span>
<span class="ruby-comment">#   by using the `SchedulesTask#execute` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post_task</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Run a loop and execute tasks in the scheduled order and at the approximate</span>
<span class="ruby-comment"># scheduled time. If no tasks remain the thread will exit gracefully so that</span>
<span class="ruby-comment"># garbage collection can occur. If there are no ready tasks it will sleep</span>
<span class="ruby-comment"># for up to 60 seconds waiting for the next scheduled task.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_tasks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Remove the given task from the queue.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This is intended as a callback method from `ScheduledTask`</span>
<span class="ruby-comment">#   only. It is not intended to be used directly. Cancel a task</span>
<span class="ruby-comment">#   by using the `ScheduledTask#cancel` method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_task</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A very common concurrency pattern is to run a thread that performs a task at # regular intervals. The thread that performs the task sleeps for the given # interval then wakes up and performs the task. Lather, rinse, repeat… This # pattern causes two problems. First, it is difficult to test the business # logic of the task because the task itself is tightly coupled with the # concurrency logic. Second, an exception raised while performing the task can # cause the entire thread to abend. In a long-running application where the # task thread is intended to run for days/weeks/years a crashed task thread # can pose a significant problem. ‘TimerTask` alleviates both problems. # # When a `TimerTask` is launched it starts a thread for monitoring the # execution interval. The `TimerTask` thread does not perform the task, # however. Instead, the TimerTask launches the task on a separate thread. # Should the task experience an unrecoverable crash only the task thread will # crash. This makes the `TimerTask` very fault tolerant. Additionally, the # `TimerTask` thread can respond to the success or failure of the task, # performing logging or ancillary operations. # # One other advantage of `TimerTask` is that it forces the business logic to # be completely decoupled from the concurrency logic. The business logic can # be tested separately then passed to the `TimerTask` for scheduling and # running. # # A `TimerTask` supports two different types of interval calculations. # A fixed delay will always wait the same amount of time between the # completion of one task and the start of the next. A fixed rate will # attempt to maintain a constant rate of execution regardless of the # duration of the task. For example, if a fixed rate task is scheduled # to run every 60 seconds but the task itself takes 10 seconds to # complete, the next task will be scheduled to run 50 seconds after # the start of the previous task. If the task takes 70 seconds to # complete, the next task will be start immediately after the previous # task completes. Tasks will not be executed concurrently. # # In some cases it may be necessary for a `TimerTask` to affect its own # execution cycle. To facilitate this, a reference to the TimerTask instance # is passed as an argument to the provided block every time the task is # executed. # # The `TimerTask` class includes the `Dereferenceable` mixin module so the # result of the last execution is always available via the `#value` method. # Dereferencing options can be passed to the `TimerTask` during construction or # at any later time using the `#set_deref_options` method. # # `TimerTask` supports notification through the Ruby standard library # {<a href="http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html">ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html</a> # Observable} module. On execution the `TimerTask` will notify the observers # with three arguments: time of execution, the result of the block (or nil on # failure), and any raised exceptions (or nil on success). # # @example Basic usage #   task = Concurrent::TimerTask.new{ puts ’Boom!‘ } #   task.execute # #   task.execution_interval #=&gt; 60 (default) # #   # wait 60 seconds… #   #=&gt; ’Boom!‘ # #   task.shutdown #=&gt; true # @example Configuring `:execution_interval` #   task = Concurrent::TimerTask.new(execution_interval: 5) do #   puts ’Boom!‘ #   end # #   task.execution_interval #=&gt; 5 # @example Immediate execution with `:run_now` #   task = Concurrent::TimerTask.new(run_now: true){ puts ’Boom!‘ } #   task.execute # #   #=&gt; ’Boom!‘ # @example Configuring `:interval_type` with either :fixed_delay or :fixed_rate, default is :fixed_delay #   task = Concurrent::TimerTask.new(execution_interval: 5, interval_type: :fixed_rate) do #   puts ’Boom!‘ #   end #   task.interval_type #=&gt; :fixed_rate # @example Last `#value` and `Dereferenceable` mixin #   task = Concurrent::TimerTask.new( #   dup_on_deref: true, #   execution_interval: 5 #   ){ Time.now } # #   task.execute #   Time.now   #=&gt; 2013-11-07 18:06:50 -0500 #   sleep(10) #   task.value #=&gt; 2013-11-07 18:06:55 -0500 # @example Controlling execution from within the block #   timer_task = Concurrent::TimerTask.new(execution_interval: 1) do |task| #   task.execution_interval.to_i.times{ print ’Boom! ‘ } #   print “n” #   task.execution_interval += 1 #   if task.execution_interval &gt; 5 #   puts ’Stopping…‘ #   task.shutdown #   end #   end # #   timer_task.execute #   #=&gt; Boom! #   #=&gt; Boom! Boom! #   #=&gt; Boom! Boom! Boom! #   #=&gt; Boom! Boom! Boom! Boom! #   #=&gt; Boom! Boom! Boom! Boom! Boom! #   #=&gt; Stopping… # @example Observation #   class TaskObserver #   def update(time, result, ex) #   if result #   print “(#{time}) Execution successfully returned #{result}n” #   else #   print “(#{time}) Execution failed with error #{ex}n” #   end #   end #   end # #   task = Concurrent::TimerTask.new(execution_interval: 1){ 42 } #   task.add_observer(TaskObserver.new) #   task.execute #   sleep 4 # #   #=&gt; (2013-10-13 19:08:58 -0400) Execution successfully returned 42 #   #=&gt; (2013-10-13 19:08:59 -0400) Execution successfully returned 42 #   #=&gt; (2013-10-13 19:09:00 -0400) Execution successfully returned 42 #   task.shutdown # #   task = Concurrent::TimerTask.new(execution_interval: 1){ sleep } #   task.add_observer(TaskObserver.new) #   task.execute # #   #=&gt; (2013-10-13 19:07:25 -0400) Execution timed out #   #=&gt; (2013-10-13 19:07:27 -0400) Execution timed out #   #=&gt; (2013-10-13 19:07:29 -0400) Execution timed out #   task.shutdown # #   task = Concurrent::TimerTask.new(execution_interval: 1){ raise StandardError } #   task.add_observer(TaskObserver.new) #   task.execute # #   #=&gt; (2013-10-13 19:09:37 -0400) Execution failed with error StandardError #   #=&gt; (2013-10-13 19:09:38 -0400) Execution failed with error StandardError #   #=&gt; (2013-10-13 19:09:39 -0400) Execution failed with error StandardError #   task.shutdown # @see <a href="http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html">ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html</a> # @see <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html">docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#165 class Concurrent::TimerTask &lt; ::Concurrent::RubyExecutorService</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Dereferenceable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Concern</span><span class="ruby-operator">::</span><span class="ruby-constant">Observable</span>

<span class="ruby-comment"># Create a new TimerTask with the given task and configuration.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @option opts</span>
<span class="ruby-comment"># @param opts [Hash] the options defining task execution.</span>
<span class="ruby-comment"># @raise ArgumentError when no block is given.</span>
<span class="ruby-comment"># @return [TimerTask] the new `TimerTask`</span>
<span class="ruby-comment"># @yield to the block after :execution_interval seconds have passed since</span>
<span class="ruby-comment">#   the last yield</span>
<span class="ruby-comment"># @yieldparam task a reference to the `TimerTask` instance so that the</span>
<span class="ruby-comment">#   block can control its own lifecycle. Necessary since `self` will</span>
<span class="ruby-comment">#   refer to the execution context of the block rather than the running</span>
<span class="ruby-comment">#   `TimerTask`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Execute a previously created `TimerTask`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example Instance and execute in separate steps</span>
<span class="ruby-comment">#   task = Concurrent::TimerTask.new(execution_interval: 10){ print &quot;Hello World\n&quot; }</span>
<span class="ruby-comment">#   task.running? #=&gt; false</span>
<span class="ruby-comment">#   task.execute</span>
<span class="ruby-comment">#   task.running? #=&gt; true</span>
<span class="ruby-comment"># @example Instance and execute in one line</span>
<span class="ruby-comment">#   task = Concurrent::TimerTask.new(execution_interval: 10){ print &quot;Hello World\n&quot; }.execute</span>
<span class="ruby-comment">#   task.running? #=&gt; true</span>
<span class="ruby-comment"># @return [TimerTask] a reference to `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] Number of seconds after the task completes before the</span>
<span class="ruby-comment">#   task is performed again.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execution_interval</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] Number of seconds after the task completes before the</span>
<span class="ruby-comment">#   task is performed again.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execution_interval=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Symbol] method to calculate the interval between executions</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interval_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Is the executor running?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] `true` when running, `false` when shutting down or shutdown</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">running?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] Number of seconds the task can run before it is</span>
<span class="ruby-comment">#   considered to have failed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">timeout_interval</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Fixnum] Number of seconds the task can run before it is</span>
<span class="ruby-comment">#   considered to have failed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#288</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">timeout_interval=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#352</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate_next_interval</span>(<span class="ruby-identifier">start_time</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_task</span>(<span class="ruby-identifier">completion</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_initialize</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_kill_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ns_shutdown_execution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#330</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">schedule_next_task</span>(<span class="ruby-identifier">interval</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Create and execute a new `TimerTask`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @example</span>
  <span class="ruby-comment">#   task = Concurrent::TimerTask.execute(execution_interval: 10){ print &quot;Hello World\n&quot; }</span>
  <span class="ruby-comment">#   task.running? #=&gt; true</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @option opts</span>
  <span class="ruby-comment"># @param opts [Hash] the options defining task execution.</span>
  <span class="ruby-comment"># @raise ArgumentError when no block is given.</span>
  <span class="ruby-comment"># @return [TimerTask] the new `TimerTask`</span>
  <span class="ruby-comment"># @yield to the block after :execution_interval seconds have passed since</span>
  <span class="ruby-comment">#   the last yield</span>
  <span class="ruby-comment"># @yieldparam task a reference to the `TimerTask` instance so that the</span>
  <span class="ruby-comment">#   block can control its own lifecycle. Necessary since `self` will</span>
  <span class="ruby-comment">#   refer to the execution context of the block rather than the running</span>
  <span class="ruby-comment">#   `TimerTask`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#252</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">task</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Default ‘:interval_type` # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#181 Concurrent::TimerTask::DEFAULT_INTERVAL_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># Default ‘:execution_interval` in seconds. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#170 Concurrent::TimerTask::EXECUTION_INTERVAL = T.let(T.unsafe(nil), Integer)</p>

<p># Maintain the interval between the end of one execution and the start of the next execution. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#173 Concurrent::TimerTask::FIXED_DELAY = T.let(T.unsafe(nil), Symbol)</p>

<p># Maintain the interval between the start of one execution and the start of the next. # If execution time exceeds the interval, the next execution will start immediately # after the previous execution finishes. Executions will not run concurrently. # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#178 Concurrent::TimerTask::FIXED_RATE = T.let(T.unsafe(nil), Symbol)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#153 class Concurrent::Transaction</p>

<pre class="ruby"><span class="ruby-comment"># @return [Transaction] a new instance of Transaction</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">abort</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">commit</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">tvar</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">tvar</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unlock</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write</span>(<span class="ruby-identifier">tvar</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#212</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#216</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current=</span>(<span class="ruby-identifier">transaction</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#155 Concurrent::Transaction::ABORTED = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#159 class Concurrent::Transaction::AbortError &lt; ::StandardError; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#160 class Concurrent::Transaction::LeaveError &lt; ::StandardError; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157 class Concurrent::Transaction::OpenEntry &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute modified</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of modified</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modified</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute modified</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute modified to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modified=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute value to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A fixed size array with volatile (synchronized, thread safe) getters/setters. # Mixes in Ruby’s ‘Enumerable` module for enhanced search, sort, and traversal. # # @example #   tuple = Concurrent::Tuple.new(16) # #   tuple.set(0, :foo)                   #=&gt; :foo  | volatile write #   tuple.get(0)                         #=&gt; :foo  | volatile read #   tuple.compare_and_set(0, :foo, :bar) #=&gt; true  | strong CAS #   tuple.cas(0, :foo, :baz)             #=&gt; false | strong CAS #   tuple.get(0)                         #=&gt; :bar  | volatile read # @see <a href="https://en.wikipedia.org/wiki/Tuple">en.wikipedia.org/wiki/Tuple</a> Tuple entry at Wikipedia # @see <a href="http://www.erlang.org/doc/reference_manual/data_types.html#id70396">www.erlang.org/doc/reference_manual/data_types.html#id70396</a> Erlang Tuple # @see <a href="http://ruby-doc.org/core-2.2.2/Enumerable.html">ruby-doc.org/core-2.2.2/Enumerable.html</a> Enumerable # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#20 class Concurrent::Tuple</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>

<span class="ruby-comment"># Create a new tuple of the given size.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param size [Integer] the number of elements in the tuple</span>
<span class="ruby-comment"># @return [Tuple] a new instance of Tuple</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the value at the given index to the new value if and only if the current</span>
<span class="ruby-comment"># value matches the given old value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index for the element to set</span>
<span class="ruby-comment"># @param old_value [Object] the value to compare against the current value</span>
<span class="ruby-comment"># @param new_value [Object] the value to set at the given index</span>
<span class="ruby-comment"># @return [Boolean] true if the value at the given element was set else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cas</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the value at the given index to the new value if and only if the current</span>
<span class="ruby-comment"># value matches the given old value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index for the element to set</span>
<span class="ruby-comment"># @param old_value [Object] the value to compare against the current value</span>
<span class="ruby-comment"># @param new_value [Object] the value to set at the given index</span>
<span class="ruby-comment"># @return [Boolean] true if the value at the given element was set else false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_and_set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block once for each element in self, passing that element as a parameter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yieldparam ref [Object] the `Concurrent::AtomicReference` object at the current index</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Get the value of the element at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index from which to retrieve the value</span>
<span class="ruby-comment"># @return [Object] the value at the given index or nil if the index is out of bounds</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>(<span class="ruby-identifier">i</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the element at the given index to the given value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index for the element to set</span>
<span class="ruby-comment"># @param value [Object] the value to set at the given index</span>
<span class="ruby-comment"># @return [Object] the new value of the element at the given index or nil if the index is out of bounds</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The (fixed) size of the tuple.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Get the value of the element at the given index.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index from which to retrieve the value</span>
<span class="ruby-comment"># @return [Object] the value at the given index or nil if the index is out of bounds</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">volatile_get</span>(<span class="ruby-identifier">i</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set the element at the given index to the given value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param i [Integer] the index for the element to set</span>
<span class="ruby-comment"># @param value [Object] the value to set at the given index</span>
<span class="ruby-comment"># @return [Object] the new value of the element at the given index or nil if the index is out of bounds</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">volatile_set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#3 module Concurrent::Utility; end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#6 module Concurrent::Utility::EngineDetector</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cruby?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_jruby?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_linux?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_osx?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_truffleruby?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_windows?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_version</span>(<span class="ruby-identifier">version</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">comparison</span>, <span class="ruby-identifier">major</span>, <span class="ruby-identifier">minor</span>, <span class="ruby-identifier">patch</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#9 module Concurrent::Utility::NativeExtensionLoader</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_c_extensions?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">c_extensions_loaded?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_native_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">java_extensions_loaded?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_error_path</span>(<span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_c_extensions_loaded</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_java_extensions_loaded</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">try_load_c_extension</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @private # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#5 module Concurrent::Utility::NativeInteger</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Concurrent</span><span class="ruby-operator">::</span><span class="ruby-constant">Utility</span><span class="ruby-operator">::</span><span class="ruby-constant">NativeInteger</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_integer</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_integer_and_bounds</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_lower_bound</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_positive</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_positive_and_no_zero</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_upper_bound</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#8 Concurrent::Utility::NativeInteger::MAX_VALUE = T.let(T.unsafe(nil), Integer)</p>

<p># <a href="http://stackoverflow.com/questions/535721/ruby-max-integer">stackoverflow.com/questions/535721/ruby-max-integer</a> # # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#7 Concurrent::Utility::NativeInteger::MIN_VALUE = T.let(T.unsafe(nil), Integer)</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#10 class Concurrent::Utility::ProcessorCounter</p>

<pre class="ruby"><span class="ruby-comment"># @return [ProcessorCounter] a new instance of ProcessorCounter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available_processor_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cpu_quota</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cpu_shares</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">physical_processor_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processor_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_cpu_quota</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_cpu_shares</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_physical_processor_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_processor_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">command</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://concurrent-ruby//lib/concurrent-ruby/concurrent/version.rb#2 Concurrent::VERSION = T.let(T.unsafe(nil), String)</p>

</main>

