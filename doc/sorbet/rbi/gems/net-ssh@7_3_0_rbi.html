<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>net-ssh@7.3.0.rbi - RDoc Documentation</title>

  <meta name="keywords" content="ruby,documentation,net-ssh@7.3.0.rbi">
  <meta name="description" content="net-ssh@7.3.0.rbi: true # DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the `net-ssh` gem. tapioca gem net-ssh`.">


<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../Dockerfile.html">Dockerfile</a>
    <li><a href="../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../README_md.html">README</a>
    <li><a href="../../../Rakefile.html">Rakefile</a>
    <li><details><summary>app</summary>
    <ul class="link-list">
      <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
      <li><a href="../../../app/views/pwa/service-worker_js.html">service-worker.js</a>
    </ul></details>
    <li><a href="../../../bin/docker-entrypoint.html">docker-entrypoint</a>
    <li><a href="../../../config_ru.html">config.ru</a>
    <li><details><summary>config</summary>
    <ul class="link-list">
      <li><a href="../../../config/credentials_yml_enc.html">credentials.yml.enc</a>
      <li><a href="../../../config/master_key.html">master.key</a>
    </ul></details>
    <li><details><summary>log</summary>
    <ul class="link-list">
      <li><a href="../../../log/development_log.html">development.log</a>
      <li><a href="../../../log/test_log.html">test.log</a>
    </ul></details>
    <li><details><summary>public</summary>
    <ul class="link-list">
      <li><a href="../../../public/400_html.html">400.html</a>
      <li><a href="../../../public/404_html.html">404.html</a>
      <li><a href="../../../public/406-unsupported-browser_html.html">406-unsupported-browser.html</a>
      <li><a href="../../../public/422_html.html">422.html</a>
      <li><a href="../../../public/500_html.html">500.html</a>
      <li><a href="../../../public/robots_txt.html">robots</a>
    </ul></details>
    <li><details open><summary>sorbet</summary>
    <ul class="link-list">
      <li><a href="../../../sorbet/config.html">config</a>
      <li><a href="../../../sorbet/rbi/annotations/actionmailer_rbi.html">actionmailer.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionpack_rbi.html">actionpack.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionview_rbi.html">actionview.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activejob_rbi.html">activejob.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activemodel_rbi.html">activemodel.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activerecord_rbi.html">activerecord.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activesupport_rbi.html">activesupport.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/globalid_rbi.html">globalid.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/minitest_rbi.html">minitest.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/railties_rbi.html">railties.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/rainbow_rbi.html">rainbow.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actioncable@8_0_2_rbi.html">actioncable@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailbox@8_0_2_rbi.html">actionmailbox@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailer@8_0_2_rbi.html">actionmailer@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionpack@8_0_2_rbi.html">actionpack@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actiontext@8_0_2_rbi.html">actiontext@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionview@8_0_2_rbi.html">actionview@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activejob@8_0_2_rbi.html">activejob@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activemodel@8_0_2_rbi.html">activemodel@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activerecord@8_0_2_rbi.html">activerecord@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activestorage@8_0_2_rbi.html">activestorage@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activesupport@8_0_2_rbi.html">activesupport@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ast@2_4_3_rbi.html">ast@2.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/backport@1_2_0_rbi.html">backport@1.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/base64@0_3_0_rbi.html">base64@0.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bcrypt_pbkdf@1_1_1_rbi.html">bcrypt_pbkdf@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/benchmark@0_4_1_rbi.html">benchmark@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bigdecimal@3_2_2_rbi.html">bigdecimal@3.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bindex@0_8_1_rbi.html">bindex@0.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/brakeman@7_0_2_rbi.html">brakeman@7.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/commander@5_0_0_rbi.html">commander@5.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/concurrent-ruby@1_3_5_rbi.html">concurrent-ruby@1.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/connection_pool@2_5_3_rbi.html">connection_pool@2.5.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/crass@1_0_6_rbi.html">crass@1.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/csv@3_3_5_rbi.html">csv@3.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/date@3_4_1_rbi.html">date@3.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/diff-lcs@1_6_2_rbi.html">diff-lcs@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/dotenv@3_1_8_rbi.html">dotenv@3.1.8.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/drb@2_2_3_rbi.html">drb@2.2.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/e2mmap@0_1_0_rbi.html">e2mmap@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ed25519@1_4_0_rbi.html">ed25519@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erb@5_0_1_rbi.html">erb@5.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erubi@1_13_1_rbi.html">erubi@1.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/globalid@1_2_1_rbi.html">globalid@1.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/highline@3_0_1_rbi.html">highline@3.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/httparty@0_23_1_rbi.html">httparty@0.23.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/i18n@1_14_7_rbi.html">i18n@1.14.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/importmap-rails@2_1_0_rbi.html">importmap-rails@2.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/io-console@0_8_0_rbi.html">io-console@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/jaro_winkler@1_6_1_rbi.html">jaro_winkler@1.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/json@2_12_2_rbi.html">json@2.12.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kamal@2_7_0_rbi.html">kamal@2.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown-parser-gfm@1_1_0_rbi.html">kramdown-parser-gfm@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown@2_5_1_rbi.html">kramdown@2.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/language_server-protocol@3_17_0_5_rbi.html">language_server-protocol@3.17.0.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/lint_roller@1_1_0_rbi.html">lint_roller@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/logger@1_7_0_rbi.html">logger@1.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/loofah@2_24_1_rbi.html">loofah@2.24.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mail@2_8_1_rbi.html">mail@2.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/marcel@1_0_4_rbi.html">marcel@1.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/method_source@1_1_0_rbi.html">method_source@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mini_mime@1_1_5_rbi.html">mini_mime@1.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/minitest@5_25_5_rbi.html">minitest@5.25.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/multi_xml@0_7_2_rbi.html">multi_xml@0.7.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-imap@0_5_9_rbi.html">net-imap@0.5.9.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-pop@0_1_2_rbi.html">net-pop@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-protocol@0_2_2_rbi.html">net-protocol@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-scp@4_1_0_rbi.html">net-scp@4.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-sftp@4_0_0_rbi.html">net-sftp@4.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-smtp@0_5_1_rbi.html">net-smtp@0.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-ssh@7_3_0_rbi.html">net-ssh@7.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/netrc@0_11_0_rbi.html">netrc@0.11.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/nio4r@2_7_4_rbi.html">nio4r@2.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/observer@0_1_2_rbi.html">observer@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ostruct@0_6_2_rbi.html">ostruct@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parallel@1_27_0_rbi.html">parallel@1.27.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parlour@9_1_2_rbi.html">parlour@9.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parser@3_3_8_0_rbi.html">parser@3.3.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pattern_generator@0_1_0_rbi.html">pattern_generator@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/polyfill@1_9_0_rbi.html">polyfill@1.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pp@0_6_2_rbi.html">pp@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prettyprint@0_2_0_rbi.html">prettyprint@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prism@1_4_0_rbi.html">prism@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/propshaft@1_1_0_rbi.html">propshaft@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/psych@5_2_6_rbi.html">psych@5.2.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/puma@6_6_0_rbi.html">puma@6.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/racc@1_8_1_rbi.html">racc@1.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-session@2_1_1_rbi.html">rack-session@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-test@2_2_0_rbi.html">rack-test@2.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack@3_1_16_rbi.html">rack@3.1.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rackup@2_2_1_rbi.html">rackup@2.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-dom-testing@2_3_0_rbi.html">rails-dom-testing@2.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-html-sanitizer@1_6_2_rbi.html">rails-html-sanitizer@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails@8_0_2_rbi.html">rails@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/railties@8_0_2_rbi.html">railties@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rainbow@3_1_1_rbi.html">rainbow@3.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rake@13_3_0_rbi.html">rake@13.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbi@0_3_6_rbi.html">rbi@0.3.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbs@4_0_0_dev_4_rbi.html">rbs@4.0.0.dev.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rdoc@6_14_2_rbi.html">rdoc@6.14.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/redcarpet@3_6_1_rbi.html">redcarpet@3.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/regexp_parser@2_10_0_rbi.html">regexp_parser@2.10.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reline@0_6_1_rbi.html">reline@0.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/require-hooks@0_2_2_rbi.html">require-hooks@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reverse_markdown@2_1_1_rbi.html">reverse_markdown@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-core@3_13_5_rbi.html">rspec-core@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-expectations@3_13_5_rbi.html">rspec-expectations@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-mocks@3_13_5_rbi.html">rspec-mocks@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-rails@8_0_1_rbi.html">rspec-rails@8.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-support@3_13_4_rbi.html">rspec-support@3.13.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec@3_13_1_rbi.html">rspec@3.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-ast@1_45_1_rbi.html">rubocop-ast@1.45.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-performance@1_25_0_rbi.html">rubocop-performance@1.25.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails-omakase@1_1_0_rbi.html">rubocop-rails-omakase@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails@2_32_0_rbi.html">rubocop-rails@2.32.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop@1_78_0_rbi.html">rubocop@1.78.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp-rails@0_4_6_rbi.html">ruby-lsp-rails@0.4.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp@0_24_2_rbi.html">ruby-lsp@0.24.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-progressbar@1_13_0_rbi.html">ruby-progressbar@1.13.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/safe_type@1_1_1_rbi.html">safe_type@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/securerandom@0_4_1_rbi.html">securerandom@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph-rails@1_1_2_rbi.html">solargraph-rails@1.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph@0_48_0_rbi.html">solargraph@0.48.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-coerce@0_7_0_rbi.html">sorbet-coerce@0.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-rails@0_7_34_rbi.html">sorbet-rails@0.7.34.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-runtime-stub@0_2_0_rbi.html">sorbet-runtime-stub@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/spoom@1_7_4_rbi.html">spoom@1.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sshkit@1_24_0_rbi.html">sshkit@1.24.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stimulus-rails@1_3_4_rbi.html">stimulus-rails@1.3.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stringio@3_1_7_rbi.html">stringio@3.1.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tapioca@0_17_6_rbi.html">tapioca@0.17.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thor@1_3_2_rbi.html">thor@1.3.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thruster@0_1_14_rbi.html">thruster@0.1.14.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tilt@2_6_1_rbi.html">tilt@2.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/timeout@0_4_3_rbi.html">timeout@0.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/turbo-rails@2_0_16_rbi.html">turbo-rails@2.0.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tzinfo@2_0_6_rbi.html">tzinfo@2.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-display_width@2_6_0_rbi.html">unicode-display_width@2.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/uri@1_0_3_rbi.html">uri@1.0.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/useragent@0_16_11_rbi.html">useragent@0.16.11.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/web-console@4_2_1_rbi.html">web-console@4.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-driver@0_8_0_rbi.html">websocket-driver@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-extensions@0_1_5_rbi.html">websocket-extensions@0.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-kramdown@0_0_1_rbi.html">yard-kramdown@0.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-solargraph@0_1_0_rbi.html">yard-solargraph@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-sorbet@0_9_0_rbi.html">yard-sorbet@0.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard@0_9_37_rbi.html">yard@0.9.37.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/zeitwerk@2_7_3_rbi.html">zeitwerk@2.7.3.rbi</a>
      <li><a href="../../../sorbet/rbi/todo_rbi.html">todo.rbi</a>
    </ul></details>
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  </ul>
</div>


  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-label="Page sorbet/rbi/gems/net-ssh@7.3.0.rbi">

<p># typed: true</p>

<p># DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the ‘net-ssh` gem. # Please instead update this file by running `bin/tapioca gem net-ssh`.</p>

<p># Net::SSH is a library for interacting, programmatically, with remote # processes via the SSH2 protocol. Sessions are always initiated via # Net::SSH.start. From there, a program interacts with the new SSH session # via the convenience methods on Net::SSH::Connection::Session, by opening # and interacting with new channels (Net::SSH::Connection:Session#open_channel # and Net::SSH::Connection::Channel), or by forwarding local and/or # remote ports through the connection (Net::SSH::Service::Forward). # # The SSH protocol is very event-oriented. Requests are sent from the client # to the server, and are answered asynchronously. This gives great flexibility # (since clients can have multiple requests pending at a time), but it also # adds complexity. Net::SSH tries to manage this complexity by providing # some simpler methods of synchronous communication (see Net::SSH::Connection::Session#exec!). # # In general, though, and if you want to do anything more complicated than # simply executing commands and capturing their output, you’ll need to use # channels (Net::SSH::Connection::Channel) to build state machines that are # executed while the event loop runs (Net::SSH::Connection::Session#loop). # # Net::SSH::Connection::Session and Net::SSH::Connection::Channel have more # information about this technique. # # = “Um, all I want to do is X, just show me how!” # # == X == “execute a command and capture the output” # #   Net::SSH.start(“host”, “user”, password: “password”) do |ssh| #     result = ssh.exec!(“ls -l”) #     puts result #   end # # == X == “forward connections on a local port to a remote host” # #   Net::SSH.start(“host”, “user”, password: “password”) do |ssh| #     ssh.forward.local(1234, “<a href="www.google.com">www.google.com</a>”, 80) #     ssh.loop { true } #   end # # == X == “forward connections on a remote port to the local host” # #   Net::SSH.start(“host”, “user”, password: “password”) do |ssh| #     ssh.forward.remote(80, “<a href="www.google.com">www.google.com</a>”, 1234) #     ssh.loop { true } #   end # # source://net-ssh//lib/net/ssh/errors.rb#2 module Net::SSH</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh.rb#298</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assign_defaults</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns a hash of the configuration options for the given host, as read</span>
  <span class="ruby-comment"># from the SSH configuration file(s). If +use_ssh_config+ is true (the</span>
  <span class="ruby-comment"># default), this will load configuration from both ~/.ssh/config and</span>
  <span class="ruby-comment"># /etc/ssh_config. If +use_ssh_config+ is nil or false, nothing will be</span>
  <span class="ruby-comment"># loaded (and an empty hash returned). Otherwise, +use_ssh_config+ may</span>
  <span class="ruby-comment"># be a file name (or array of file names) of SSH configuration file(s)</span>
  <span class="ruby-comment"># to read.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># See Net::SSH::Config for the full description of all supported options.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh.rb#288</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configuration_for</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">use_ssh_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The standard means of starting a new SSH connection. When used with a</span>
  <span class="ruby-comment"># block, the connection will be closed when the block terminates, otherwise</span>
  <span class="ruby-comment"># the connection will just be returned. The yielded (or returned) value</span>
  <span class="ruby-comment"># will be an instance of Net::SSH::Connection::Session (q.v.). (See also</span>
  <span class="ruby-comment"># Net::SSH::Connection::Channel and Net::SSH::Service::Forward.)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   Net::SSH.start(&quot;host&quot;, &quot;user&quot;) do |ssh|</span>
  <span class="ruby-comment">#     ssh.exec! &quot;cp /some/file /another/location&quot;</span>
  <span class="ruby-comment">#     hostname = ssh.exec!(&quot;hostname&quot;)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#     ssh.open_channel do |ch|</span>
  <span class="ruby-comment">#       ch.exec &quot;sudo -p &#39;sudo password: &#39; ls&quot; do |ch, success|</span>
  <span class="ruby-comment">#         abort &quot;could not execute sudo ls&quot; unless success</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#         ch.on_data do |ch, data|</span>
  <span class="ruby-comment">#           print data</span>
  <span class="ruby-comment">#           if data =~ /sudo password: /</span>
  <span class="ruby-comment">#             ch.send_data(&quot;password\n&quot;)</span>
  <span class="ruby-comment">#           end</span>
  <span class="ruby-comment">#         end</span>
  <span class="ruby-comment">#       end</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#     ssh.loop</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># This method accepts the following options (all are optional):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * :auth_methods =&gt; an array of authentication methods to try</span>
  <span class="ruby-comment"># * :bind_address =&gt; the IP address on the connecting machine to use in</span>
  <span class="ruby-comment">#   establishing connection. (:bind_address is discarded if :proxy</span>
  <span class="ruby-comment">#   is set.)</span>
  <span class="ruby-comment"># * :check_host_ip =&gt; Also ckeck IP address when connecting to remote host.</span>
  <span class="ruby-comment">#   Defaults to +true+.</span>
  <span class="ruby-comment"># * :compression =&gt; the compression algorithm to use, or +true+ to use</span>
  <span class="ruby-comment">#   whatever is supported.</span>
  <span class="ruby-comment"># * :compression_level =&gt; the compression level to use when sending data</span>
  <span class="ruby-comment"># * :config =&gt; set to +true+ to load the default OpenSSH config files</span>
  <span class="ruby-comment">#   (~/.ssh/config, /etc/ssh_config), or to +false+ to not load them, or to</span>
  <span class="ruby-comment">#   a file-name (or array of file-names) to load those specific configuration</span>
  <span class="ruby-comment">#   files. Defaults to +true+.</span>
  <span class="ruby-comment"># * :encryption =&gt; the encryption cipher (or ciphers) to use</span>
  <span class="ruby-comment"># * :forward_agent =&gt; set to true if you want the SSH agent connection to</span>
  <span class="ruby-comment">#   be forwarded</span>
  <span class="ruby-comment"># * :known_hosts =&gt; a custom object holding known hosts records.</span>
  <span class="ruby-comment">#   It must implement #search_for and `add` in a similiar manner as KnownHosts.</span>
  <span class="ruby-comment"># * :global_known_hosts_file =&gt; the location of the global known hosts</span>
  <span class="ruby-comment">#   file. Set to an array if you want to specify multiple global known</span>
  <span class="ruby-comment">#   hosts files. Defaults to %w(/etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2).</span>
  <span class="ruby-comment"># * :hmac =&gt; the hmac algorithm (or algorithms) to use</span>
  <span class="ruby-comment"># * :host_key =&gt; the host key algorithm (or algorithms) to use</span>
  <span class="ruby-comment"># * :host_key_alias =&gt; the host name to use when looking up or adding a</span>
  <span class="ruby-comment">#   host to a known_hosts dictionary file</span>
  <span class="ruby-comment"># * :host_name =&gt; the real host name or IP to log into. This is used</span>
  <span class="ruby-comment">#   instead of the +host+ parameter, and is primarily only useful when</span>
  <span class="ruby-comment">#   specified in an SSH configuration file. It lets you specify an</span>
  <span class="ruby-comment">#   &quot;alias&quot;, similarly to adding an entry in /etc/hosts but without needing</span>
  <span class="ruby-comment">#   to modify /etc/hosts.</span>
  <span class="ruby-comment"># * :keepalive =&gt; set to +true+ to send a keepalive packet to the SSH server</span>
  <span class="ruby-comment">#   when there&#39;s no traffic between the SSH server and Net::SSH client for</span>
  <span class="ruby-comment">#   the keepalive_interval seconds. Defaults to +false+.</span>
  <span class="ruby-comment"># * :keepalive_interval =&gt; the interval seconds for keepalive.</span>
  <span class="ruby-comment">#   Defaults to +300+ seconds.</span>
  <span class="ruby-comment"># * :keepalive_maxcount =&gt; the maximun number of keepalive packet miss allowed.</span>
  <span class="ruby-comment">#   Defaults to 3</span>
  <span class="ruby-comment"># * :kex =&gt; the key exchange algorithm (or algorithms) to use</span>
  <span class="ruby-comment"># * :keys =&gt; an array of file names of private keys to use for publickey</span>
  <span class="ruby-comment">#   and hostbased authentication</span>
  <span class="ruby-comment"># * :keycerts =&gt; an array of file names of key certificates to use</span>
  <span class="ruby-comment">#    with publickey authentication</span>
  <span class="ruby-comment"># * :keycert_data =&gt; an array of strings, which each element of the array</span>
  <span class="ruby-comment">#   being a key certificate to use with publickey authentication</span>
  <span class="ruby-comment"># * :key_data =&gt; an array of strings, with each element of the array being</span>
  <span class="ruby-comment">#   a raw private key in PEM format.</span>
  <span class="ruby-comment"># * :keys_only =&gt; set to +true+ to use only private keys from +keys+ and</span>
  <span class="ruby-comment">#   +key_data+ parameters, even if ssh-agent offers more identities. This</span>
  <span class="ruby-comment">#   option is intended for situations where ssh-agent offers many different</span>
  <span class="ruby-comment">#   identites.</span>
  <span class="ruby-comment"># * :logger =&gt; the logger instance to use when logging</span>
  <span class="ruby-comment"># * :max_pkt_size =&gt; maximum size we tell the other side that is supported per</span>
  <span class="ruby-comment">#   packet. Default is 0x8000 (32768 bytes). Increase to 0x10000 (65536 bytes)</span>
  <span class="ruby-comment">#   for better performance if your SSH server supports it (most do).</span>
  <span class="ruby-comment"># * :max_win_size =&gt; maximum size we tell the other side that is supported for</span>
  <span class="ruby-comment">#   the window.</span>
  <span class="ruby-comment"># * :non_interactive =&gt; set to true if your app is non interactive and prefers</span>
  <span class="ruby-comment">#   authentication failure vs password prompt. Non-interactive applications</span>
  <span class="ruby-comment">#   should set it to true to prefer failing a password/etc auth methods vs.</span>
  <span class="ruby-comment">#   asking for password.</span>
  <span class="ruby-comment"># * :paranoid =&gt; deprecated alias for :verify_host_key</span>
  <span class="ruby-comment"># * :passphrase =&gt; the passphrase to use when loading a private key (default</span>
  <span class="ruby-comment">#   is +nil+, for no passphrase)</span>
  <span class="ruby-comment"># * :password =&gt; the password to use to login</span>
  <span class="ruby-comment"># * :port =&gt; the port to use when connecting to the remote host</span>
  <span class="ruby-comment"># * :properties =&gt; a hash of key/value pairs to add to the new connection&#39;s</span>
  <span class="ruby-comment">#   properties (see Net::SSH::Connection::Session#properties)</span>
  <span class="ruby-comment"># * :proxy =&gt; a proxy instance (see Proxy) to use when connecting</span>
  <span class="ruby-comment"># * :pubkey_algorithms =&gt; the public key authentication algorithms to use for</span>
  <span class="ruby-comment">#   this connection. Valid values are &#39;rsa-sha2-256-cert-v01@openssh.com&#39;,</span>
  <span class="ruby-comment">#   &#39;ssh-rsa-cert-v01@openssh.com&#39;, &#39;rsa-sha2-256&#39;, &#39;ssh-rsa&#39;. Currently, this</span>
  <span class="ruby-comment">#   option is only used for RSA public key authentication and ignored for other</span>
  <span class="ruby-comment">#   types.</span>
  <span class="ruby-comment"># * :rekey_blocks_limit =&gt; the max number of blocks to process before rekeying</span>
  <span class="ruby-comment"># * :rekey_limit =&gt; the max number of bytes to process before rekeying</span>
  <span class="ruby-comment"># * :rekey_packet_limit =&gt; the max number of packets to process before rekeying</span>
  <span class="ruby-comment"># * :send_env =&gt; an array of local environment variable names to export to the</span>
  <span class="ruby-comment">#   remote environment. Names may be given as String or Regexp.</span>
  <span class="ruby-comment"># * :set_env =&gt; a hash of environment variable names and values to set to the</span>
  <span class="ruby-comment">#   remote environment. Override the ones if specified in +send_env+.</span>
  <span class="ruby-comment"># * :timeout =&gt; how long to wait for the initial connection to be made</span>
  <span class="ruby-comment"># * :user =&gt; the user name to log in as; this overrides the +user+</span>
  <span class="ruby-comment">#   parameter, and is primarily only useful when provided via an SSH</span>
  <span class="ruby-comment">#   configuration file.</span>
  <span class="ruby-comment"># * :remote_user =&gt; used for substitution into the &#39;%r&#39; part of a ProxyCommand</span>
  <span class="ruby-comment"># * :user_known_hosts_file =&gt; the location of the user known hosts file.</span>
  <span class="ruby-comment">#   Set to an array to specify multiple user known hosts files.</span>
  <span class="ruby-comment">#   Defaults to %w(~/.ssh/known_hosts ~/.ssh/known_hosts2).</span>
  <span class="ruby-comment"># * :use_agent =&gt; Set false to disable the use of ssh-agent. Defaults to</span>
  <span class="ruby-comment">#   true</span>
  <span class="ruby-comment"># * :identity_agent =&gt; the path to the ssh-agent&#39;s UNIX socket</span>
  <span class="ruby-comment"># * :verbose =&gt; how verbose to be (Logger verbosity constants, Logger::DEBUG</span>
  <span class="ruby-comment">#   is very verbose, Logger::FATAL is all but silent). Logger::FATAL is the</span>
  <span class="ruby-comment">#   default. The symbols :debug, :info, :warn, :error, and :fatal are also</span>
  <span class="ruby-comment">#   supported and are translated to the corresponding Logger constant.</span>
  <span class="ruby-comment"># * :append_all_supported_algorithms =&gt; set to +true+ to append all supported</span>
  <span class="ruby-comment">#   algorithms by net-ssh. Was the default behaviour until 2.10</span>
  <span class="ruby-comment"># * :number_of_password_prompts =&gt; Number of prompts for the password</span>
  <span class="ruby-comment">#   authentication method defaults to 3 set to 0 to disable prompt for</span>
  <span class="ruby-comment">#   password auth method</span>
  <span class="ruby-comment"># * :password_prompt =&gt; a custom prompt object with ask method. See Net::SSH::Prompt</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * :agent_socket_factory =&gt; enables the user to pass a lambda/block that will serve as the socket factory</span>
  <span class="ruby-comment">#    Net::SSH.start(host,user,agent_socket_factory: -&gt;{ UNIXSocket.open(&#39;/foo/bar&#39;) })</span>
  <span class="ruby-comment">#    example: -&gt;{ UNIXSocket.open(&#39;/foo/bar&#39;)}</span>
  <span class="ruby-comment"># * :verify_host_key =&gt; specify how strict host-key verification should be.</span>
  <span class="ruby-comment">#   In order of increasing strictness:</span>
  <span class="ruby-comment">#   * :never (very insecure) ::Net::SSH::Verifiers::Never</span>
  <span class="ruby-comment">#   * :accept_new_or_local_tunnel (insecure) ::Net::SSH::Verifiers::AcceptNewOrLocalTunnel</span>
  <span class="ruby-comment">#   * :accept_new (insecure) ::Net::SSH::Verifiers::AcceptNew</span>
  <span class="ruby-comment">#   * :always (secure) ::Net::SSH::Verifiers::Always</span>
  <span class="ruby-comment">#   You can also provide an own Object which responds to +verify+. The argument</span>
  <span class="ruby-comment">#   given to +verify+ is a hash consisting of the +:key+, the +:key_blob+,</span>
  <span class="ruby-comment">#   the +:fingerprint+ and the +:session+. Returning true accepts the host key,</span>
  <span class="ruby-comment">#   returning false declines it and closes the connection.</span>
  <span class="ruby-comment"># * :fingerprint_hash =&gt; &#39;MD5&#39; or &#39;SHA256&#39;, defaults to &#39;SHA256&#39;</span>
  <span class="ruby-comment"># If +user+ parameter is nil it defaults to USER from ssh_config, or</span>
  <span class="ruby-comment"># local username</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh.rb#225</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">user</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh.rb#311</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_sanitize_options</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh.rb#320</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_support_deprecated_option_paranoid</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#5 module Net::SSH::Authentication; end</p>

<p># This class implements a simple client for the ssh-agent protocol. It # does not implement any specific protocol, but instead copies the # behavior of the ssh-agent functions in the OpenSSH library (3.8). # # This means that although it behaves like a SSH1 client, it also has # some SSH2 functionality (like signing data). # # source://net-ssh//lib/net/ssh/authentication/agent.rb#26 class Net::SSH::Authentication::Agent</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># Creates a new Agent object, using the optional logger instance to</span>
<span class="ruby-comment"># report status.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Agent] a new instance of Agent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">logger</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds the private key with comment to the agent.</span>
<span class="ruby-comment"># If lifetime is given, the key will automatically be removed after lifetime</span>
<span class="ruby-comment"># seconds.</span>
<span class="ruby-comment"># If confirm is true, confirmation will be required for each agent signing</span>
<span class="ruby-comment"># operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_identity</span>(<span class="ruby-identifier">priv_key</span>, <span class="ruby-identifier">comment</span>, <span class="ruby-value">lifetime:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">confirm:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Closes this socket. This agent reference is no longer able to</span>
<span class="ruby-comment"># query the agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Connect to the agent process using the socket factory and socket name</span>
<span class="ruby-comment"># given by the attribute writers. If the agent on the other end of the</span>
<span class="ruby-comment"># socket reports that it is an SSH2-compatible agent, this will fail</span>
<span class="ruby-comment"># (it only supports the ssh-agent distributed by OpenSSH).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">connect!</span>(<span class="ruby-identifier">agent_socket_factory</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">identity_agent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return an array of all identities (public keys) known to the agent.</span>
<span class="ruby-comment"># Each key returned is augmented with a +comment+ property which is set</span>
<span class="ruby-comment"># to the comment returned by the agent for that key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identities</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># lock the ssh agent with password</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lock</span>(<span class="ruby-identifier">password</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attempts to negotiate the SSH agent protocol version. Raises an error</span>
<span class="ruby-comment"># if the version could not be negotiated successfully.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentNotAvailable]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negotiate!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes all identities from the agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_all_identities</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes key from the agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_identity</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Using the agent and the given public key, sign the given data. The</span>
<span class="ruby-comment"># signature is returned in SSH2 format.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">flags</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying socket being used to communicate with the SSH agent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">socket</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># unlock the ssh agent with password</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [AgentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unlock</span>(<span class="ruby-identifier">password</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns +true+ if the parameter indicates a &quot;failure&quot; response from</span>
<span class="ruby-comment"># the agent, and +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">agent_failed</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blob_for_add</span>(<span class="ruby-identifier">priv_key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read the next packet from the agent. This will return a two-part</span>
<span class="ruby-comment"># tuple consisting of the packet type, and the packet&#39;s body (which</span>
<span class="ruby-comment"># is returned as a Net::SSH::Buffer).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_packet</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Send the given packet and return the subsequent reply from the agent.</span>
<span class="ruby-comment"># (See #send_packet and #read_packet).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_and_wait</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Send a new packet of the given type, with the associated data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_packet</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unix_socket_class</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Instantiates a new agent object, connects to a running SSH agent,</span>
  <span class="ruby-comment"># negotiates the agent protocol version, and returns the agent object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">connect</span>(<span class="ruby-identifier">logger</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">agent_socket_factory</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">identity_agent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A simple module for extending keys, to allow comments to be specified # for them. # # source://net-ssh//lib/net/ssh/authentication/agent.rb#31 module Net::SSH::Authentication::Agent::Comment</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute comment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute comment to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/agent.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#40 Net::SSH::Authentication::Agent::SSH2_AGENT_ADD_IDENTITY = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#45 Net::SSH::Authentication::Agent::SSH2_AGENT_ADD_ID_CONSTRAINED = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#46 Net::SSH::Authentication::Agent::SSH2_AGENT_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#37 Net::SSH::Authentication::Agent::SSH2_AGENT_IDENTITIES_ANSWER = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#43 Net::SSH::Authentication::Agent::SSH2_AGENT_LOCK = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#42 Net::SSH::Authentication::Agent::SSH2_AGENT_REMOVE_ALL_IDENTITIES = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#41 Net::SSH::Authentication::Agent::SSH2_AGENT_REMOVE_IDENTITY = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#36 Net::SSH::Authentication::Agent::SSH2_AGENT_REQUEST_IDENTITIES = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#35 Net::SSH::Authentication::Agent::SSH2_AGENT_REQUEST_VERSION = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#38 Net::SSH::Authentication::Agent::SSH2_AGENT_SIGN_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#39 Net::SSH::Authentication::Agent::SSH2_AGENT_SIGN_RESPONSE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#44 Net::SSH::Authentication::Agent::SSH2_AGENT_UNLOCK = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#47 Net::SSH::Authentication::Agent::SSH2_AGENT_VERSION_RESPONSE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#58 Net::SSH::Authentication::Agent::SSH_AGENT_CONSTRAIN_CONFIRM = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#57 Net::SSH::Authentication::Agent::SSH_AGENT_CONSTRAIN_LIFETIME = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#54 Net::SSH::Authentication::Agent::SSH_AGENT_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#51 Net::SSH::Authentication::Agent::SSH_AGENT_REQUEST_RSA_IDENTITIES = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#52 Net::SSH::Authentication::Agent::SSH_AGENT_RSA_IDENTITIES_ANSWER1 = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#53 Net::SSH::Authentication::Agent::SSH_AGENT_RSA_IDENTITIES_ANSWER2 = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#60 Net::SSH::Authentication::Agent::SSH_AGENT_RSA_SHA2_256 = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#61 Net::SSH::Authentication::Agent::SSH_AGENT_RSA_SHA2_512 = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#55 Net::SSH::Authentication::Agent::SSH_AGENT_SUCCESS = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/agent.rb#49 Net::SSH::Authentication::Agent::SSH_COM_AGENT2_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># Class for representing agent-specific errors. # # source://net-ssh//lib/net/ssh/authentication/agent.rb#15 class Net::SSH::Authentication::AgentError &lt; ::Net::SSH::Exception; end</p>

<p># An exception for indicating that the SSH agent is not available. # # source://net-ssh//lib/net/ssh/authentication/agent.rb#18 class Net::SSH::Authentication::AgentNotAvailable &lt; ::Net::SSH::Authentication::AgentError; end</p>

<p># Class for representing an SSH certificate. # # <a href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.bin/ssh/PROTOCOL.certkeys?rev=1.10&amp;content-type=text/plain">cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.bin/ssh/PROTOCOL.certkeys?rev=1.10&amp;content-type=text/plain</a> # # source://net-ssh//lib/net/ssh/authentication/certificate.rb#9 class Net::SSH::Authentication::Certificate</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute critical_options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">critical_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute critical_options</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute critical_options to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">critical_options=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute extensions.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute extensions</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute extensions to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extensions=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fingerprint</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute key to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute key_id.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute key_id</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute key_id to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_id=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute nonce.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute nonce</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute nonce to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute reserved.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reserved</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute reserved</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute reserved to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reserved=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute serial.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serial</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute serial</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute serial to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serial=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">sign_nonce</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Signs the certificate with key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign!</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">sign_nonce</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute signature.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute signature</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute signature to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute signature_key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute signature_key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute signature_key to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature_key=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the certificate&#39;s signature was signed by signature key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature_valid?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_sign</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_verify</span>(<span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Serializes the certificate (and key).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_pem</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute type</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute type to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute valid_after.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_after</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute valid_after</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute valid_after to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_after=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute valid_before.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_before</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute valid_before</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute valid_before to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_before=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute valid_principals.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_principals</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute valid_principals</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute valid_principals to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_principals=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_without_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options_to_blob</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_time</span>(<span class="ruby-identifier">t</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob_without_signature</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type_value</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Read a certificate blob associated with a key of the given type.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_certblob</span>(<span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @raise [ArgumentError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#109</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_options</span>(<span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/certificate.rb#125</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type_symbol</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Describes the constants used by the Net::SSH::Authentication components # of the Net::SSH library. Individual authentication method implemenations # may define yet more constants that are specific to their implementation. # # source://net-ssh//lib/net/ssh/authentication/constants.rb#7 module Net::SSH::Authentication::Constants; end</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#11 Net::SSH::Authentication::Constants::USERAUTH_BANNER = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#9 Net::SSH::Authentication::Constants::USERAUTH_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#16 Net::SSH::Authentication::Constants::USERAUTH_METHOD_RANGE = T.let(T.unsafe(nil), Range)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#13 Net::SSH::Authentication::Constants::USERAUTH_PASSWD_CHANGEREQ = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#14 Net::SSH::Authentication::Constants::USERAUTH_PK_OK = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#8 Net::SSH::Authentication::Constants::USERAUTH_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/constants.rb#10 Net::SSH::Authentication::Constants::USERAUTH_SUCCESS = T.let(T.unsafe(nil), Integer)</p>

<p># Raised if the current authentication method is not allowed # # source://net-ssh//lib/net/ssh/authentication/session.rb#15 class Net::SSH::Authentication::DisallowedMethod &lt; ::Net::SSH::Exception; end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#13 module Net::SSH::Authentication::ED25519; end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#23 class Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @raise [ArgumentError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#41</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">datafull</span>, <span class="ruby-identifier">password</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#24 Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::CipherFactory = Net::SSH::Transport::CipherFactory</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#30 class Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::DecryptError &lt; ::ArgumentError</p>

<pre class="ruby"><span class="ruby-comment"># @return [DecryptError] a new instance of DecryptError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">message</span>, <span class="ruby-value">encrypted_key:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encrypted_key?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#28 Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::MAGIC = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#26 Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::MBEGIN = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#27 Net::SSH::Authentication::ED25519::OpenSSHPrivateKeyLoader::MEND = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#139 class Net::SSH::Authentication::ED25519::PrivKey</p>

<pre class="ruby"><span class="ruby-comment"># @return [PrivKey] a new instance of PrivKey</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">public_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute sign_key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_sign</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#177</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">password</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#140 Net::SSH::Authentication::ED25519::PrivKey::CipherFactory = Net::SSH::Transport::CipherFactory</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#144 Net::SSH::Authentication::ED25519::PrivKey::MAGIC = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#142 Net::SSH::Authentication::ED25519::PrivKey::MBEGIN = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#143 Net::SSH::Authentication::ED25519::PrivKey::MEND = T.let(T.unsafe(nil), String)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#104 class Net::SSH::Authentication::ED25519::PubKey</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Authentication</span><span class="ruby-operator">::</span><span class="ruby-constant">PubKeyFingerprint</span>

<span class="ruby-comment"># @return [PubKey] a new instance of PubKey</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_verify</span>(<span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_pem</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute verify_key.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#113</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_keyblob</span>(<span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#14 class Net::SSH::Authentication::ED25519::SigningKeyFromFile &lt; ::SimpleDelegator</p>

<pre class="ruby"><span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [SigningKeyFromFile] a new instance of SigningKeyFromFile</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">pk</span>, <span class="ruby-identifier">sk</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Loads ED25519 support which requires optinal dependecies like # ed25519, bcrypt_pbkdf # # source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#6 module Net::SSH::Authentication::ED25519Loader</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependenciesRequiredForED25519</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @raise [NotImplementedError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raiseUnlessLoaded</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#10 Net::SSH::Authentication::ED25519Loader::ERROR = T.let(T.unsafe(nil), T.untyped)</p>

<p># source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#9 Net::SSH::Authentication::ED25519Loader::LOADED = T.let(T.unsafe(nil), TrueClass)</p>

<p># This class encapsulates all operations done by clients on a user’s # private keys. In practice, the client should never need a reference # to a private key; instead, they grab a list of “identities” (public # keys) that are available from the KeyManager, and then use # the KeyManager to do various private key operations using those # identities. # # The KeyManager also uses the Agent class to encapsulate the # ssh-agent. Thus, from a client’s perspective it is completely # hidden whether an identity comes from the ssh-agent or from a file # on disk. # # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#23 class Net::SSH::Authentication::KeyManager</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># Create a new KeyManager. By default, the manager will</span>
<span class="ruby-comment"># use the ssh-agent if it is running and the `:use_agent` option</span>
<span class="ruby-comment"># is not false.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [KeyManager] a new instance of KeyManager</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">logger</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add the given key_file to the list of key files that will be used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add</span>(<span class="ruby-identifier">key_file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add the given key_file to the list of keys that will be used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_key_data</span>(<span class="ruby-identifier">key_data_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add the given keycert_file to the list of keycert files that will be used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_keycert</span>(<span class="ruby-identifier">keycert_file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add the given keycert_data to the list of keycerts that will be used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_keycert_data</span>(<span class="ruby-identifier">keycert_data_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an Agent instance to use for communicating with an SSH</span>
<span class="ruby-comment"># agent process. Returns nil if use of an SSH agent has been disabled,</span>
<span class="ruby-comment"># or if the agent is otherwise not available.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">agent</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Clear all knowledge of any loaded user keys. This also clears the list</span>
<span class="ruby-comment"># of default identity files that are to be loaded, thus making it</span>
<span class="ruby-comment"># appropriate to use if a client wishes to NOT use the default identity</span>
<span class="ruby-comment"># files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Iterates over all available identities (public keys) known to this</span>
<span class="ruby-comment"># manager. As it finds one, it will then yield it to the caller.</span>
<span class="ruby-comment"># The origin of the identities may be from files on disk or from an</span>
<span class="ruby-comment"># ssh-agent. Note that identities from an ssh-agent are always listed</span>
<span class="ruby-comment"># first in the array, with other identities coming after.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If key manager was created with :keys_only option, any identity</span>
<span class="ruby-comment"># from ssh-agent will be ignored unless it present in key_files or</span>
<span class="ruby-comment"># key_data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_identity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is used as a hint to the KeyManager indicating that the agent</span>
<span class="ruby-comment"># connection is no longer needed. Any other open resources may be closed</span>
<span class="ruby-comment"># at this time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calling this does NOT indicate that the KeyManager will no longer</span>
<span class="ruby-comment"># be used. Identities may still be requested and operations done on</span>
<span class="ruby-comment"># loaded identities, in which case, the agent will be automatically</span>
<span class="ruby-comment"># reconnected. This method simply allows the client connection to be</span>
<span class="ruby-comment"># closed when it will not be used in the immediate future.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finish</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of user key data that will be examined</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of user key files that will be examined</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of user key certificate data that will be examined</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keycert_data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of user key certificate files that will be examined</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keycert_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of loaded identities</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">known_identities</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_keys?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of options that were passed to the key-manager</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sign the given data, using the corresponding private key of the given</span>
<span class="ruby-comment"># identity. If the identity was originally obtained from an ssh-agent,</span>
<span class="ruby-comment"># then the ssh-agent will be used to sign the data, otherwise the</span>
<span class="ruby-comment"># private key for the identity will be loaded from disk (if it hasn&#39;t</span>
<span class="ruby-comment"># been loaded already) and will then be used to sign the data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Regardless of the identity&#39;s origin or who does the signing, this</span>
<span class="ruby-comment"># will always return the signature in an SSH2-specified &quot;signature</span>
<span class="ruby-comment"># blob&quot; format.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [KeyManagerError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Toggles whether the ssh-agent will be used or not. If true, an</span>
<span class="ruby-comment"># attempt will be made to use the ssh-agent. If false, any existing</span>
<span class="ruby-comment"># connection to an agent is closed and the agent will not be used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_agent=</span>(<span class="ruby-identifier">use_agent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Identifies whether the ssh-agent will be used or not.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_agent?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Load keycerts from files and data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keycerts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Load prepared identities. Private key decryption errors ignored if ignore_decryption_errors</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_identities</span>(<span class="ruby-identifier">identities</span>, <span class="ruby-identifier">ask_passphrase</span>, <span class="ruby-identifier">ignore_decryption_errors</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Prepared identities from user key_data, preserving their order and sources.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#273</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_identities_from_data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Prepares identities from user key_files for loading, preserving their order and sources.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_identities_from_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#314</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_identity_loading_error</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">e</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/key_manager.rb#268</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">readable_file?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A trivial exception class used to report errors in the key manager. # # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#10 class Net::SSH::Authentication::KeyManagerError &lt; ::Net::SSH::Exception; end</p>

<p># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#9 module Net::SSH::Authentication::Methods; end</p>

<p># The base class of all user authentication methods. It provides a few # bits of common functionality. # # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#12 class Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Authentication</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Instantiates a new authentication method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Abstract] a new instance of Abstract</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">session</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The key manager object. Not all authentication methods will require</span>
<span class="ruby-comment"># this.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_manager</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># So far only affects algorithms used for rsa keys, but can be</span>
<span class="ruby-comment"># extended to other keys, e.g after reading of</span>
<span class="ruby-comment"># PubkeyAcceptedAlgorithms option from ssh_config file is implemented.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pubkey_algorithms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends a message via the underlying transport layer abstraction. This</span>
<span class="ruby-comment"># will block until the message is completely sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_message</span>(<span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The authentication session object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">session</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the session-id, as generated during the first key exchange of</span>
<span class="ruby-comment"># an SSH connection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">session_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a new USERAUTH_REQUEST packet. The extra arguments on the end</span>
<span class="ruby-comment"># must be either boolean values or strings, and are tacked onto the end</span>
<span class="ruby-comment"># of the packet. The new packet is returned, ready for sending.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">userauth_request</span>(<span class="ruby-identifier">username</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">auth_method</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">others</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns the value of attribute prompt.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prompt</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements the host-based SSH authentication method. # # source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#8 class Net::SSH::Authentication::Methods::Hostbased &lt; ::Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># Attempts to perform host-based authorization of the user by trying</span>
<span class="ruby-comment"># all known keys.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Attempts to perform host-based authentication of the user, using</span>
<span class="ruby-comment"># the given host identity (key).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate_with</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">key_manager</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Build the &quot;core&quot; hostbased request string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_request</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">hostname</span>, <span class="ruby-identifier">client_username</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the hostname as reported by the underlying socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hostname</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements the “keyboard-interactive” SSH authentication method. # # source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#9 class Net::SSH::Authentication::Methods::KeyboardInteractive &lt; ::Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># Attempt to authenticate the given user for the given service.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interactive?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#10 Net::SSH::Authentication::Methods::KeyboardInteractive::USERAUTH_INFO_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#11 Net::SSH::Authentication::Methods::KeyboardInteractive::USERAUTH_INFO_RESPONSE = T.let(T.unsafe(nil), Integer)</p>

<p># Implements the “none” SSH authentication method. # # source://net-ssh//lib/net/ssh/authentication/methods/none.rb#9 class Net::SSH::Authentication::Methods::None &lt; ::Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># Attempt to authenticate as &quot;none&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/none.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">user</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements the “password” SSH authentication method. # # source://net-ssh//lib/net/ssh/authentication/methods/password.rb#10 class Net::SSH::Authentication::Methods::Password &lt; ::Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># Attempt to authenticate the given user for the given service. If</span>
<span class="ruby-comment"># the password parameter is nil, this will ask for password</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/password.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/password.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ask_password</span>(<span class="ruby-identifier">username</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/password.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_prompter!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/password.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_max_retries</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/authentication/methods/password.rb#53 Net::SSH::Authentication::Methods::Password::NUMBER_OF_PASSWORD_PROMPTS = T.let(T.unsafe(nil), Integer)</p>

<p># Implements the “publickey” SSH authentication method. # # source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#10 class Net::SSH::Authentication::Methods::Publickey &lt; ::Net::SSH::Authentication::Methods::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># Attempts to perform public-key authentication for the given</span>
<span class="ruby-comment"># username, trying each identity known to the key manager. If any of</span>
<span class="ruby-comment"># them succeed, returns +true+, otherwise returns +false+. This</span>
<span class="ruby-comment"># requires the presence of a key manager.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Attempts to perform public-key authentication for the given</span>
<span class="ruby-comment"># username, with the given identity (public key). Returns +true+ if</span>
<span class="ruby-comment"># successful, or +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate_with</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate_with_alg</span>(<span class="ruby-identifier">identity</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">alg</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Builds a packet that contains the request formatted for sending</span>
<span class="ruby-comment"># a public-key request to the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_request</span>(<span class="ruby-identifier">pub_key</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">alg</span>, <span class="ruby-identifier">has_sig</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Builds and sends a request formatted for a public-key</span>
<span class="ruby-comment"># authentication request.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_request</span>(<span class="ruby-identifier">pub_key</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">alg</span>, <span class="ruby-identifier">signature</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Public key fingerprinting utility module - internal not part of API. # This is included in pubkey classes and called from there. All RSA, DSA, and ECC keys # are supported. # #     require ‘net/ssh’ #     my_pubkey_text = File.read(‘/path/to/id_ed25519.pub’) #        #=&gt; “ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDB2NBh4GJPPUN1kXPMu8b633Xcv55WoKC3OkBjFAbzJ alice@example.com” #     my_pubkey = Net::SSH::KeyFactory.load_data_public_key(my_pubkey_text) #        #=&gt; #<Net::SSH::Authentication::ED25519::PubKey:0x00007fc8e91819b0 #     my_pubkey.fingerprint #        #=&gt; “2f:7f:97:21:76:a4:0f:38:c4:fe:d8:b4:6a:39:72:30” #     my_pubkey.fingerprint(‘SHA256’) #        #=&gt; “SHA256:u6mXnY8P1b0FODGp8mckqOB33u8+jvkSCtJbD5Q9klg” # # source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#19 module Net::SSH::Authentication::PubKeyFingerprint</p>

<pre class="ruby"><span class="ruby-comment"># Return the key&#39;s fingerprint.  Algorithm may be either +MD5+ (default),</span>
<span class="ruby-comment"># or +SHA256+. For +SHA256+, fingerprints are in the same format</span>
<span class="ruby-comment"># returned by OpenSSH&#39;s &lt;tt&gt;`ssh-add -l -E SHA256`&lt;/tt&gt;, i.e.,</span>
<span class="ruby-comment"># trailing base64 padding &#39;=&#39; characters are stripped and the</span>
<span class="ruby-comment"># literal string +SHA256:+ is prepended.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fingerprint</span>(<span class="ruby-identifier">algorithm</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fingerprint</span>(<span class="ruby-identifier">blob</span>, <span class="ruby-identifier">algorithm</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Represents an authentication session. It manages the authentication of # a user over an established connection (the “transport” object, see # Net::SSH::Transport::Session). # # The use of an authentication session to manage user authentication is # internal to Net::SSH (specifically Net::SSH.start). Consumers of the # Net::SSH library will never need to access this class directly. # # source://net-ssh//lib/net/ssh/authentication/session.rb#25 class Net::SSH::Authentication::Session</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Authentication</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Instantiates a new Authentication::Session object over the given</span>
<span class="ruby-comment"># transport layer abstraction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Session] a new instance of Session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">transport</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the list of authentication methods that are allowed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_auth_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the list of authentication methods to try</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">auth_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Attempts to authenticate the given user, in preparation for the next</span>
<span class="ruby-comment"># service request. Returns true if an authentication method succeeds in</span>
<span class="ruby-comment"># authenticating the user, and false otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">authenticate</span>(<span class="ruby-identifier">next_service</span>, <span class="ruby-identifier">username</span>, <span class="ruby-identifier">password</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks until a packet is received, and returns it if it is of the given</span>
<span class="ruby-comment"># type. If it is not, an exception is raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expect_message</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks until a packet is received. It silently handles USERAUTH_BANNER</span>
<span class="ruby-comment"># packets, and will raise an error if any packet is received that is not</span>
<span class="ruby-comment"># valid during user authentication.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># a hash of options, given at construction time</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># transport layer abstraction</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transport</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns an array of paths to the key files usually defined</span>
<span class="ruby-comment"># by system default.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of the key data that should be used when</span>
<span class="ruby-comment"># attempting any key-based authentication mechanism.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of the keycert data that should be used when</span>
<span class="ruby-comment"># attempting any key-based authentication mechanism.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keycert_data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of paths to the keycert files that should be used when</span>
<span class="ruby-comment"># attempting any key-based authentication mechanism.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keycerts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of paths to the key files that should be used when</span>
<span class="ruby-comment"># attempting any key-based authentication mechanism.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/authentication/session.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This exception is raised when authentication fails (whether it be # public key authentication, password authentication, or whatever). # # source://net-ssh//lib/net/ssh/errors.rb#9 class Net::SSH::AuthenticationFailed &lt; ::Net::SSH::Exception; end</p>

<p># Net::SSH::Buffer is a flexible class for building and parsing binary # data packets. It provides a stream-like interface for sequentially # reading data items from the buffer, as well as a useful helper method # for building binary packets given a signature. # # Writing to a buffer always appends to the end, regardless of where the # read cursor is. Reading, on the other hand, always begins at the first # byte of the buffer and increments the read cursor, with subsequent reads # taking up where the last left off. # # As a consumer of the Net::SSH library, you will rarely come into contact # with these buffer objects directly, but it could happen. Also, if you # are ever implementing a protocol on top of SSH (e.g. SFTP), this buffer # class can be quite handy. # # source://net-ssh//lib/net/ssh/buffer.rb#22 class Net::SSH::Buffer</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new buffer, initialized to the given content. The position</span>
<span class="ruby-comment"># is initialized to the beginning of the buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Buffer] a new instance of Buffer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">content</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compares the contents of the two buffers, returning +true+ only if they</span>
<span class="ruby-comment"># are identical in size and content.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Appends the given text to the end of the buffer. Does not alter the</span>
<span class="ruby-comment"># read position. Returns the buffer object itself.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">append</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the number of bytes available to be read (e.g., how many bytes</span>
<span class="ruby-comment"># remain between the current position and the end of the buffer).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Resets the buffer, making it empty. Also, resets the read position to</span>
<span class="ruby-comment"># 0.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Consumes n bytes from the buffer, where n is the current position</span>
<span class="ruby-comment"># unless otherwise specified. This is useful for removing data from the</span>
<span class="ruby-comment"># buffer that has previously been read, when you are expecting more data</span>
<span class="ruby-comment"># to be appended. It helps to keep the size of buffers down when they</span>
<span class="ruby-comment"># would otherwise tend to grow without bound.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the buffer object itself.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consume!</span>(<span class="ruby-identifier">n</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># exposes the raw content of the buffer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">content</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns +true+ if the buffer contains no data (e.g., it is of zero length).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the pointer is at the end of the buffer. Subsequent</span>
<span class="ruby-comment"># reads will return nil, in this case.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the length of the buffer&#39;s content.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the current position of the pointer in the buffer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">position</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the current position of the pointer in the buffer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">position=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reads and returns the next +count+ bytes from the buffer, starting from</span>
<span class="ruby-comment"># the read position. If +count+ is +nil+, this will return all remaining</span>
<span class="ruby-comment"># text in the buffer. This method will increment the pointer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">count</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reads (as #read) and returns the given number of bytes from the buffer,</span>
<span class="ruby-comment"># and then consumes (as #consume!) all data up to the new read position.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read!</span>(<span class="ruby-identifier">count</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls block(self) until the buffer is empty, and returns all results.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_all</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read a bignum (OpenSSL::BN) from the buffer, in SSH2 format. It is</span>
<span class="ruby-comment"># essentially just a string, which is reinterpreted to be a bignum in</span>
<span class="ruby-comment"># binary format.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_bignum</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read a single byte and convert it into a boolean, using &#39;C&#39; rules</span>
<span class="ruby-comment"># (i.e., zero is false, non-zero is true).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_bool</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reads the next string from the buffer, and returns a new Buffer</span>
<span class="ruby-comment"># object that wraps it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read and return the next byte in the buffer. Returns nil if called at</span>
<span class="ruby-comment"># the end of the buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_byte</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the next 8 bytes as a 64-bit integer (in network byte order).</span>
<span class="ruby-comment"># Returns nil if there are less than 8 bytes remaining to be read in the</span>
<span class="ruby-comment"># buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_int64</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read a key from the buffer. The key will start with a string</span>
<span class="ruby-comment"># describing its type. The remainder of the key is defined by the</span>
<span class="ruby-comment"># type that was read.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read a keyblob of the given type from the buffer, and return it as</span>
<span class="ruby-comment"># a key. Only RSA, DSA, and ECDSA keys are supported.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_keyblob</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return the next four bytes as a long integer (in network byte order).</span>
<span class="ruby-comment"># Returns nil if there are less than 4 bytes remaining to be read in the</span>
<span class="ruby-comment"># buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_long</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_private_keyblob</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read and return an SSH2-encoded string. The string starts with a long</span>
<span class="ruby-comment"># integer that describes the number of bytes remaining in the string.</span>
<span class="ruby-comment"># Returns nil if there are not enough bytes to satisfy the request.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_string</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reads all data up to and including the given pattern, which may be a</span>
<span class="ruby-comment"># String, Fixnum, or Regexp and is interpreted exactly as String#index</span>
<span class="ruby-comment"># does. Returns nil if nothing matches. Increments the position to point</span>
<span class="ruby-comment"># immediately after the pattern, if it does match. Returns all data up to</span>
<span class="ruby-comment"># and including the text that matched the pattern.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_to</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns all text from the current pointer to the end of the buffer as</span>
<span class="ruby-comment"># a new Net::SSH::Buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remainder_as_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Resets the pointer to the start of the buffer. Subsequent reads will</span>
<span class="ruby-comment"># begin at position 0.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a copy of the buffer&#39;s content.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes the given data literally into the string. Does not alter the</span>
<span class="ruby-comment"># read position. Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#356</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as a bignum (SSH2-style). No</span>
<span class="ruby-comment"># checking is done to ensure that the arguments are, in fact, bignums.</span>
<span class="ruby-comment"># Does not alter the read position. Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#436</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_bignum</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">n</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as a (C-style) boolean, with 1</span>
<span class="ruby-comment"># meaning true, and 0 meaning false. Does not alter the read position.</span>
<span class="ruby-comment"># Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#428</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_bool</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">b</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as a byte. Does not alter the read</span>
<span class="ruby-comment"># position. Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_byte</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">n</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as a network-byte-order-encoded</span>
<span class="ruby-comment"># 64-bit integer (8 bytes). Does not alter the read position. Returns the</span>
<span class="ruby-comment"># buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#376</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_int64</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">n</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes the given arguments to the buffer as SSH2-encoded keys. Does not</span>
<span class="ruby-comment"># alter the read position. Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#443</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_key</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as a network-byte-order-encoded</span>
<span class="ruby-comment"># long (4-byte) integer. Does not alter the read position. Returns the</span>
<span class="ruby-comment"># buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#388</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_long</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">n</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Optimized version of write where the caller gives up ownership of string</span>
<span class="ruby-comment"># to the method. This way we can mutate the string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_moved</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as an SSH2-encoded string. Each</span>
<span class="ruby-comment"># string is prefixed by its length, encoded as a 4-byte long integer.</span>
<span class="ruby-comment"># Does not alter the read position. Returns the buffer object.</span>
<span class="ruby-comment"># Might alter arguments see write_moved</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#416</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_mstring</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Writes each argument to the buffer as an SSH2-encoded string. Each</span>
<span class="ruby-comment"># string is prefixed by its length, encoded as a 4-byte long integer.</span>
<span class="ruby-comment"># Does not alter the read position. Returns the buffer object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_string</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># This is a convenience method for creating and populating a new buffer</span>
  <span class="ruby-comment"># from a single command. The arguments must be even in length, with the</span>
  <span class="ruby-comment"># first of each pair of arguments being a symbol naming the type of the</span>
  <span class="ruby-comment"># data that follows. If the type is :raw, the value is written directly</span>
  <span class="ruby-comment"># to the hash.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   b = Buffer.from(:byte, 1, :string, &quot;hello&quot;, :raw, &quot;\1\2\3\4&quot;)</span>
  <span class="ruby-comment">#   #-&gt; &quot;\1\0\0\0\5hello\1\2\3\4&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The supported data types are:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * :raw =&gt; write the next value verbatim (#write)</span>
  <span class="ruby-comment"># * :int64 =&gt; write an 8-byte integer (#write_int64)</span>
  <span class="ruby-comment"># * :long =&gt; write a 4-byte integer (#write_long)</span>
  <span class="ruby-comment"># * :byte =&gt; write a single byte (#write_byte)</span>
  <span class="ruby-comment"># * :string =&gt; write a 4-byte length followed by character data (#write_string)</span>
  <span class="ruby-comment"># * :mstring =&gt; same as string, but caller cannot resuse the string, avoids potential duplication (#write_moved)</span>
  <span class="ruby-comment"># * :bool =&gt; write a single byte, interpreted as a boolean (#write_bool)</span>
  <span class="ruby-comment"># * :bignum =&gt; write an SSH-encoded bignum (#write_bignum)</span>
  <span class="ruby-comment"># * :key =&gt; write an SSH-encoded key value (#write_key)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Any of these, except for :raw, accepts an Array argument, to make it</span>
  <span class="ruby-comment"># easier to write multiple values of the same type in a briefer manner.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @raise [ArgumentError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffer.rb#46</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module is used to extend sockets and other IO objects, to allow # them to be buffered for both read and write. This abstraction makes it # quite easy to write a select-based event loop # (see Net::SSH::Connection::Session#listen_to). # # The general idea is that instead of calling #read directly on an IO that # has been extended with this module, you call #fill (to add pending input # to the internal read buffer), and then #read_available (to read from that # buffer). Likewise, you don’t call #write directly, you call #enqueue to # add data to the write buffer, and then #send_pending or #wait_for_pending_sends # to actually send the data across the wire. # # In this way you can easily use the object as an argument to IO.select, # calling #fill when it is available for read, or #send_pending when it is # available for write, and then call #enqueue and #read_available during # the idle times. # #   socket = TCPSocket.new(address, port) #   socket.extend(Net::SSH::BufferedIo) # #   ssh.listen_to(socket) # #   ssh.loop do #     if socket.available &gt; 0 #       puts socket.read_available #       socket.enqueue(“responsen”) #     end #   end # # Note that this module must be used to extend an instance, and should not # be included in a class. If you do want to use it via an include, then you # must make sure to invoke the private #initialize_buffered_io method in # your class’ #initialize method: # #   class Foo &lt; IO #     include Net::SSH::BufferedIo # #     def initialize #       initialize_buffered_io #       # … #     end #   end # # source://net-ssh//lib/net/ssh/buffered_io.rb#48 module Net::SSH::BufferedIo</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># Returns the number of bytes available to be read from the input buffer.</span>
<span class="ruby-comment"># (See #read_available.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues data in the output buffer, to be written when #send_pending</span>
<span class="ruby-comment"># is called. Note that the data is _not_ sent immediately by this method!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tries to read up to +n+ bytes of data from the remote end, and appends</span>
<span class="ruby-comment"># the data to the input buffer. It returns the number of bytes read, or 0</span>
<span class="ruby-comment"># if no data was available to be read.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fill</span>(<span class="ruby-identifier">n</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns +true+ if there is data waiting in the output buffer, and</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending_write?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read up to +length+ bytes from the input buffer. If +length+ is nil,</span>
<span class="ruby-comment"># all available data is read from the buffer. (See #available.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_available</span>(<span class="ruby-identifier">length</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends as much of the pending output as possible. Returns +true+ if any</span>
<span class="ruby-comment"># data was sent, and +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_pending</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls #send_pending repeatedly, if necessary, blocking until the output</span>
<span class="ruby-comment"># buffer is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_for_pending_sends</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Initializes the intput and output buffers for this object. This method</span>
<span class="ruby-comment"># is called automatically when the module is mixed into an object via</span>
<span class="ruby-comment"># Object#extend (see Net::SSH::BufferedIo.extended), but must be called</span>
<span class="ruby-comment"># explicitly in the +initialize+ method of any class that uses</span>
<span class="ruby-comment"># Module#include to add this module.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_buffered_io</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># --</span>
<span class="ruby-comment"># Can&#39;t use attr_reader here (after +private+) without incurring the</span>
<span class="ruby-comment"># wrath of &quot;ruby -w&quot;. We hates it.</span>
<span class="ruby-comment"># ++</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">input</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Called when the #extend is called on an object, with this module as the</span>
  <span class="ruby-comment"># argument. It ensures that the modules instance variables are all properly</span>
  <span class="ruby-comment"># initialized.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended</span>(<span class="ruby-identifier">object</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This is exception is primarily used internally, but if you have a channel # open handler (see Net::SSH::Connection::Session#on_open_channel) and you # want to fail in such a way that the server knows it failed, you can # raise this exception in the handler and Net::SSH will translate that into # a “channel open failed” message. # # source://net-ssh//lib/net/ssh/errors.rb#34 class Net::SSH::ChannelOpenFailed &lt; ::Net::SSH::Exception</p>

<pre class="ruby"><span class="ruby-comment"># @return [ChannelOpenFailed] a new instance of ChannelOpenFailed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute code.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">code</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute reason.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This exception is primarily used internally, but if you have a channel # request handler (see Net::SSH::Connection::Channel#on_request) that you # want to fail in such a way that the server knows it failed, you can # raise this exception in the handler and Net::SSH will translate that into # a “channel failure” message. # # source://net-ssh//lib/net/ssh/errors.rb#27 class Net::SSH::ChannelRequestFailed &lt; ::Net::SSH::Exception; end</p>

<p># The Net::SSH::Config class is used to parse OpenSSH configuration files, # and translates that syntax into the configuration syntax that Net::SSH # understands. This lets Net::SSH scripts read their configuration (to # some extent) from OpenSSH configuration files (~/.ssh/config, /etc/ssh_config, # and so forth). # # Only a subset of OpenSSH configuration options are understood: # # * ChallengeResponseAuthentication =&gt; maps to the :auth_methods option challenge-response (then coleasced into keyboard-interactive) # * KbdInteractiveAuthentication =&gt; maps to the :auth_methods keyboard-interactive # * CertificateFile =&gt; maps to the :keycerts option # * Ciphers =&gt; maps to the :encryption option # * Compression =&gt; :compression # * CompressionLevel =&gt; :compression_level # * ConnectTimeout =&gt; maps to the :timeout option # * ForwardAgent =&gt; :forward_agent # * GlobalKnownHostsFile =&gt; :global_known_hosts_file # * HostBasedAuthentication =&gt; maps to the :auth_methods option # * HostKeyAlgorithms =&gt; maps to :host_key option # * HostKeyAlias =&gt; :host_key_alias # * HostName =&gt; :host_name # * IdentityFile =&gt; maps to the :keys option # * IdentityAgent =&gt; :identity_agent # * IdentitiesOnly =&gt; :keys_only # * CheckHostIP =&gt; :check_host_ip # * Macs =&gt; maps to the :hmac option # * PasswordAuthentication =&gt; maps to the :auth_methods option password # * Port =&gt; :port # * PreferredAuthentications =&gt; maps to the :auth_methods option # * ProxyCommand =&gt; maps to the :proxy option # * ProxyJump =&gt; maps to the :proxy option # * PubKeyAuthentication =&gt; maps to the :auth_methods option # * RekeyLimit =&gt; :rekey_limit # * StrictHostKeyChecking =&gt; :verify_host_key # * User =&gt; :user # * UserKnownHostsFile =&gt; :user_known_hosts_file # * NumberOfPasswordPrompts =&gt; :number_of_password_prompts # * FingerprintHash =&gt; :fingerprint_hash # # Note that you will never need to use this class directly–you can control # whether the OpenSSH configuration files are read by passing the :config # option to Net::SSH.start. (They are, by default.) # # source://net-ssh//lib/net/ssh/config.rb#45 class Net::SSH::Config</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#60</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_auth_methods</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns an array of locations of OpenSSH configuration files</span>
  <span class="ruby-comment"># to parse by default.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#56</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_files</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Filters default_files down to the files that are expandable.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#186</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expandable_default_files</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loads the configuration data for the given +host+ from all of the</span>
  <span class="ruby-comment"># given +files+ (defaulting to the list of files returned by</span>
  <span class="ruby-comment"># #default_files), translates the resulting hash into the options</span>
  <span class="ruby-comment"># recognized by Net::SSH, and returns them.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">for</span>(<span class="ruby-identifier ruby-title">host</span>, <span class="ruby-identifier">files</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Load the OpenSSH configuration settings in the given +file+ for the</span>
  <span class="ruby-comment"># given +host+. If +settings+ is given, the options are merged into</span>
  <span class="ruby-comment"># that hash, with existing values taking precedence over newly parsed</span>
  <span class="ruby-comment"># ones. Returns a hash containing the OpenSSH options. (See</span>
  <span class="ruby-comment"># #translate for how to convert the OpenSSH options into Net::SSH</span>
  <span class="ruby-comment"># options.)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#80</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">settings</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">base_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Given a hash of OpenSSH configuration options, converts them into</span>
  <span class="ruby-comment"># a hash of Net::SSH options. Unrecognized options are ignored. The</span>
  <span class="ruby-comment"># +settings+ hash must have Strings for keys, all downcased, and</span>
  <span class="ruby-comment"># the returned hash will have Symbols for keys.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#176</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">translate</span>(<span class="ruby-identifier">settings</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#365</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eval_match_conditions</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">settings</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#353</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included_file_paths</span>(<span class="ruby-identifier">base_dir</span>, <span class="ruby-identifier">config_paths</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Converts the given size into an integer number of bytes.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#336</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_size</span>(<span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#345</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_challenge_response_with_keyboard_interactive</span>(<span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Converts an ssh_config pattern into a regex for matching against</span>
  <span class="ruby-comment"># host names.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#316</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern2regex</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#301</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setup_proxy</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Tokenize string into tokens.</span>
  <span class="ruby-comment"># A token is a word or a quoted sequence of words, separated by whitespaces.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#361</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokenize_config_value</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#235</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">translate_config_key</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">settings</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#208</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">translate_keepalive</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#197</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">translate_verify_host_key</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/config.rb#400</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unquote</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#3 module Net::SSH::Connection; end</p>

<p># The channel abstraction. Multiple “channels” can be multiplexed onto a # single SSH channel, each operating independently and seemingly in parallel. # This class represents a single such channel. Most operations performed # with the Net::SSH library will involve using one or more channels. # # Channels are intended to be used asynchronously. You request that one be # opened (via Connection::Session#open_channel), and when it is opened, your # callback is invoked. Then, you set various other callbacks on the newly # opened channel, which are called in response to the corresponding events. # Programming with Net::SSH works best if you think of your programs as # state machines. Complex programs are best implemented as objects that # wrap a channel. See Net::SCP and Net::SFTP for examples of how complex # state machines can be built on top of the SSH protocol. # #   ssh.open_channel do |channel| #     channel.exec(“/invoke/some/command”) do |ch, success| #       abort “could not execute command” unless success # #       channel.on_data do |ch, data| #         puts “got stdout: #{data}” #         channel.send_data “something for stdinn” #       end # #       channel.on_extended_data do |ch, type, data| #         puts “got stderr: #{data}” #       end # #       channel.on_close do |ch| #         puts “channel is closing!” #       end #     end #   end # #   ssh.loop # # Channels also have a basic hash-like interface, that allows programs to # store arbitrary state information on a channel object. This helps simplify # the writing of state machines, especially when you may be juggling # multiple open channels at the same time. # # Note that data sent across SSH channels are governed by maximum packet # sizes and maximum window sizes. These details are managed internally # by Net::SSH::Connection::Channel, so you may remain blissfully ignorant # if you so desire, but you can always inspect the current maximums, as # well as the remaining window size, using the reader attributes for those # values. # # source://net-ssh//lib/net/ssh/connection/channel.rb#54 class Net::SSH::Connection::Channel</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Instantiates a new channel on the given connection, of the given type,</span>
<span class="ruby-comment"># and with the given id. If a block is given, it will be remembered until</span>
<span class="ruby-comment"># the channel is confirmed open by the server, and will be invoked at</span>
<span class="ruby-comment"># that time (see #do_open_confirmation).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This also sets the default maximum packet size and maximum window size.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Channel] a new instance of Channel</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">connection</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">local_id</span>, <span class="ruby-identifier">max_pkt_size</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">max_win_size</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">on_confirm_open</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shortcut for accessing properties of the channel (see #properties).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shortcut for setting properties of the channel (see #properties).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the channel exists in the channel list of the session,</span>
<span class="ruby-comment"># and false otherwise. This can be used to determine whether a channel has</span>
<span class="ruby-comment"># been closed or not.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.loop { channel.active? }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that the channel be closed. It only marks the channel to be closed</span>
<span class="ruby-comment"># the CHANNEL_CLOSE message will be sent from event loop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># True if close() has been called; NOTE: if the channel has data waiting to</span>
<span class="ruby-comment"># be sent then the channel will close after all the data is sent. See</span>
<span class="ruby-comment"># closed?() to determine if we have actually sent CHANNEL_CLOSE to server.</span>
<span class="ruby-comment"># This may be true for awhile before closed? returns true if we are still</span>
<span class="ruby-comment"># sending buffered output to server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying Net::SSH::Connection::Session instance that supports this channel.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">connection</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the #on_close callback when the server closes a channel.</span>
<span class="ruby-comment"># The channel is the only argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#613</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the #on_data callback when the server sends data to the</span>
<span class="ruby-comment"># channel. This will reduce the available window size on the local end,</span>
<span class="ruby-comment"># but does not actually throttle requests that come in illegally when</span>
<span class="ruby-comment"># the window size is too small. The callback is invoked with the channel</span>
<span class="ruby-comment"># as the first argument, and the data as the second.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#590</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_data</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the #on_eof callback when the server indicates that no</span>
<span class="ruby-comment"># further data is forthcoming. The callback is invoked with the channel</span>
<span class="ruby-comment"># as the argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_eof</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the #on_extended_data callback when the server sends</span>
<span class="ruby-comment"># extended data to the channel. This will reduce the available window</span>
<span class="ruby-comment"># size on the local end. The callback is invoked with the channel,</span>
<span class="ruby-comment"># type, and data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#599</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_extended_data</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the next pending request callback with +false+ as the second</span>
<span class="ruby-comment"># argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#619</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_failure</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked when the server confirms that a channel has been opened.</span>
<span class="ruby-comment"># The remote_id is the id of the channel as assigned by the remote host,</span>
<span class="ruby-comment"># and max_window and max_packet are the maximum window and maximum</span>
<span class="ruby-comment"># packet sizes, respectively. If an open-confirmation callback was</span>
<span class="ruby-comment"># given when the channel was created, it is invoked at this time with</span>
<span class="ruby-comment"># the channel itself as the sole argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#530</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_open_confirmation</span>(<span class="ruby-identifier">remote_id</span>, <span class="ruby-identifier">max_window</span>, <span class="ruby-identifier">max_packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked when the server failed to open the channel. If an #on_open_failed</span>
<span class="ruby-comment"># callback was specified, it will be invoked with the channel, reason code,</span>
<span class="ruby-comment"># and description as arguments. Otherwise, a ChannelOpenFailed exception</span>
<span class="ruby-comment"># will be raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#544</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_open_failed</span>(<span class="ruby-identifier">reason_code</span>, <span class="ruby-identifier">description</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked when the server sends a channel request. If any #on_request</span>
<span class="ruby-comment"># callback has been registered for the specific type of this request,</span>
<span class="ruby-comment"># it is invoked. If +want_reply+ is true, a packet will be sent of</span>
<span class="ruby-comment"># either CHANNEL_SUCCESS or CHANNEL_FAILURE type. If there was no callback</span>
<span class="ruby-comment"># to handle the request, CHANNEL_FAILURE will be sent. Otherwise,</span>
<span class="ruby-comment"># CHANNEL_SUCCESS, unless the callback raised ChannelRequestFailed. The</span>
<span class="ruby-comment"># callback should accept the channel as the first argument, and the</span>
<span class="ruby-comment"># request-specific data as the second.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#569</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_request</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">want_reply</span>, <span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the next pending request callback with +true+ as the second</span>
<span class="ruby-comment"># argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#629</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_success</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked when the server sends a CHANNEL_WINDOW_ADJUST packet, and</span>
<span class="ruby-comment"># causes the remote window size to be adjusted upwards by the given</span>
<span class="ruby-comment"># number of bytes. This has the effect of allowing more data to be sent</span>
<span class="ruby-comment"># from the local end to the remote end of the channel.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#556</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_window_adjust</span>(<span class="ruby-identifier">bytes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues pending output at the connection as CHANNEL_DATA packets. This</span>
<span class="ruby-comment"># does nothing if the channel has not yet been confirmed open (see</span>
<span class="ruby-comment"># #do_open_confirmation). This is called automatically by #process, which</span>
<span class="ruby-comment"># is called from the event loop (Connection::Session#process). You will</span>
<span class="ruby-comment"># generally not need to invoke it directly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#506</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue_pending_output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Syntactic sugar for setting an environment variable in the remote</span>
<span class="ruby-comment"># process&#39; environment. Note that for security reasons, the server may</span>
<span class="ruby-comment"># refuse to set certain environment variables, or all, at the server&#39;s</span>
<span class="ruby-comment"># discretion. If you are connecting to an OpenSSH server, you will</span>
<span class="ruby-comment"># need to update the AcceptEnv setting in the sshd_config to include the</span>
<span class="ruby-comment"># environment variables you want to send.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.env &quot;PATH&quot;, &quot;/usr/local/bin&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">env</span>(<span class="ruby-identifier">variable_name</span>, <span class="ruby-identifier">variable_value</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tells the remote end of the channel that no more data is forthcoming</span>
<span class="ruby-comment"># from this end of the channel. The remote end may still send data.</span>
<span class="ruby-comment"># The CHANNEL_EOF packet will be sent once the output buffer is empty.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the local end of the channel has declared that no more</span>
<span class="ruby-comment"># data is forthcoming (see #eof!). Trying to send data via #send_data when</span>
<span class="ruby-comment"># this is true will result in an exception being raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#308</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Syntactic sugar for executing a command. Sends a channel request asking</span>
<span class="ruby-comment"># that the given command be invoked. If the block is given, it will be</span>
<span class="ruby-comment"># called when the server responds. The first parameter will be the</span>
<span class="ruby-comment"># channel, and the second will be true or false, indicating whether the</span>
<span class="ruby-comment"># request succeeded or not. In this case, success means that the command</span>
<span class="ruby-comment"># is being executed, not that it has completed, and failure means that the</span>
<span class="ruby-comment"># command altogether failed to be executed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.exec &quot;ls -l /home&quot; do |ch, success|</span>
<span class="ruby-comment">#     if success</span>
<span class="ruby-comment">#       puts &quot;command has begun executing...&quot;</span>
<span class="ruby-comment">#       # this is a good place to hang callbacks like #on_data...</span>
<span class="ruby-comment">#     else</span>
<span class="ruby-comment">#       puts &quot;alas! the command could not be invoked!&quot;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exec</span>(<span class="ruby-identifier">command</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># True if we have sent CHANNEL_CLOSE to the remote server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_closed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The local id for this channel, assigned by the Net::SSH::Connection::Session instance.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum packet size that the local host can receive.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_maximum_packet_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum amount of data that the local end of this channel can</span>
<span class="ruby-comment"># receive. This is a total, not per-packet.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_maximum_window_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is the remaining window size on the local end of this channel. When</span>
<span class="ruby-comment"># this reaches zero, no more data can be received.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_window_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when the server acknowledges that a</span>
<span class="ruby-comment"># channel is closed. This is invoked with the channel as the sole argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_close do |ch|</span>
<span class="ruby-comment">#     puts &quot;remote end is closing!&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_close</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when data packets are received by the</span>
<span class="ruby-comment"># channel. The callback is called with the channel as the first argument,</span>
<span class="ruby-comment"># and the data as the second.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_data do |ch, data|</span>
<span class="ruby-comment">#     puts &quot;got data: #{data.inspect}&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Data received this way is typically the data written by the remote</span>
<span class="ruby-comment"># process to its +stdout+ stream.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_data</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when the server indicates that no more</span>
<span class="ruby-comment"># data will be sent to the channel (although the channel can still send</span>
<span class="ruby-comment"># data to the server). The channel is the sole argument to the callback.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_eof do |ch|</span>
<span class="ruby-comment">#     puts &quot;remote end is done sending data&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_eof</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when extended data packets are received</span>
<span class="ruby-comment"># by the channel. The callback is called with the channel as the first</span>
<span class="ruby-comment"># argument, the data type (as an integer) as the second, and the data as</span>
<span class="ruby-comment"># the third. Extended data is almost exclusively used to send +stderr+ data</span>
<span class="ruby-comment"># (+type+ == 1). Other extended data types are not defined by the SSH</span>
<span class="ruby-comment"># protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_extended_data do |ch, type, data|</span>
<span class="ruby-comment">#     puts &quot;got stderr: #{data.inspect}&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_extended_data</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when the server was unable to open</span>
<span class="ruby-comment"># the requested channel. The channel itself will be passed to the block,</span>
<span class="ruby-comment"># along with the integer &quot;reason code&quot; for the failure, and a textual</span>
<span class="ruby-comment"># description of the failure from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel = session.open_channel do |ch|</span>
<span class="ruby-comment">#     # ..</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_open_failed { |ch, code, desc| ... }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#430</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_open_failed</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked for each pass of the event loop for</span>
<span class="ruby-comment"># this channel. There are no guarantees on timeliness in the event loop,</span>
<span class="ruby-comment"># but it will be called roughly once for each packet received by the</span>
<span class="ruby-comment"># connection (not the channel). This callback is invoked with the channel</span>
<span class="ruby-comment"># as the sole argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Here&#39;s an example that accumulates the channel data into a variable on</span>
<span class="ruby-comment"># the channel itself, and displays individual lines in the input one</span>
<span class="ruby-comment"># at a time when the channel is processed:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel[:data] = &quot;&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_data do |ch, data|</span>
<span class="ruby-comment">#     channel[:data] &lt;&lt; data</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.on_process do |ch|</span>
<span class="ruby-comment">#     if channel[:data] =~ /^.*?\n/</span>
<span class="ruby-comment">#       puts $&amp;</span>
<span class="ruby-comment">#       channel[:data] = $&#39;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_process</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a callback to be invoked when a channel request of the given</span>
<span class="ruby-comment"># type is received. The callback will receive the channel as the first</span>
<span class="ruby-comment"># argument, and the associated (unparsed) data as the second. The data</span>
<span class="ruby-comment"># will be a Net::SSH::Buffer that you will need to parse, yourself,</span>
<span class="ruby-comment"># according to the kind of request you are watching.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># By default, if the request wants a reply, Net::SSH will send a</span>
<span class="ruby-comment"># CHANNEL_SUCCESS response for any request that was handled by a registered</span>
<span class="ruby-comment"># callback, and CHANNEL_FAILURE for any that wasn&#39;t, but if you want your</span>
<span class="ruby-comment"># registered callback to result in a CHANNEL_FAILURE response, just raise</span>
<span class="ruby-comment"># Net::SSH::ChannelRequestFailed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Some common channel requests that your programs might want to listen</span>
<span class="ruby-comment"># for are:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * &quot;exit-status&quot; : the exit status of the remote process will be reported</span>
<span class="ruby-comment">#   as a long integer in the data buffer, which you can grab via</span>
<span class="ruby-comment">#   data.read_long.</span>
<span class="ruby-comment"># * &quot;exit-signal&quot; : if the remote process died as a result of a signal</span>
<span class="ruby-comment">#   being sent to it, the signal will be reported as a string in the</span>
<span class="ruby-comment">#   data, via data.read_string. (Not all SSH servers support this channel</span>
<span class="ruby-comment">#   request type.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#     channel.on_request &quot;exit-status&quot; do |ch, data|</span>
<span class="ruby-comment">#       puts &quot;process terminated with exit status: #{data.read_long}&quot;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#461</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_request</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The output buffer for this channel. Data written to the channel is</span>
<span class="ruby-comment"># enqueued here, to be written as CHANNEL_DATA packets during each pass of</span>
<span class="ruby-comment"># the event loop. See Connection::Session#process and #enqueue_pending_output.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of pending requests. Each time a request is sent which requires</span>
<span class="ruby-comment"># a reply, the corresponding callback is pushed onto this queue. As responses</span>
<span class="ruby-comment"># arrive, they are shifted off the front and handled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending_requests</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If an #on_process handler has been set up, this will cause it to be</span>
<span class="ruby-comment"># invoked (passing the channel itself as an argument). It also causes all</span>
<span class="ruby-comment"># pending output to be enqueued as CHANNEL_DATA packets (see #enqueue_pending_output).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A hash of properties for this channel. These can be used to store state</span>
<span class="ruby-comment"># information about this channel. See also #[] and #[]=.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">properties</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_closed!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_closed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The remote id for this channel, assigned by the remote host.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum packet size that the remote host can receive.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_maximum_packet_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum amount of data that the remote end of this channel can</span>
<span class="ruby-comment"># receive. This is a total, not per-packet.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_maximum_window_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is the remaining window size on the remote end of this channel. When</span>
<span class="ruby-comment"># this reaches zero, no more data can be sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_window_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that a pseudo-tty (or &quot;pty&quot;) be made available for this channel.</span>
<span class="ruby-comment"># This is useful when you want to invoke and interact with some kind of</span>
<span class="ruby-comment"># screen-based program (e.g., vim, or some menuing system).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note, that without a pty some programs (e.g. sudo, or subversion) on</span>
<span class="ruby-comment"># some systems, will not be able to run interactively, and will error</span>
<span class="ruby-comment"># instead of prompt if they ever need some user interaction.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note, too, that when a pty is requested, user&#39;s shell configuration</span>
<span class="ruby-comment"># scripts (.bashrc and such) are not run by default, whereas they are</span>
<span class="ruby-comment"># run when a pty is not present.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.request_pty do |ch, success|</span>
<span class="ruby-comment">#     if success</span>
<span class="ruby-comment">#       puts &quot;pty successfully obtained&quot;</span>
<span class="ruby-comment">#     else</span>
<span class="ruby-comment">#       puts &quot;could not obtain pty&quot;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">request_pty</span>(<span class="ruby-identifier">opts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends a new channel request with the given name. The extra +data+</span>
<span class="ruby-comment"># parameter must either be empty, or consist of an even number of</span>
<span class="ruby-comment"># arguments. See Net::SSH::Buffer.from for a description of their format.</span>
<span class="ruby-comment"># If a block is given, it is registered as a callback for a pending</span>
<span class="ruby-comment"># request, and the packet will be flagged so that the server knows a</span>
<span class="ruby-comment"># reply is required. If no block is given, the server will send no</span>
<span class="ruby-comment"># response to this request. Responses, where required, will cause the</span>
<span class="ruby-comment"># callback to be invoked with the channel as the first argument, and</span>
<span class="ruby-comment"># either true or false as the second, depending on whether the request</span>
<span class="ruby-comment"># succeeded or not. The meaning of &quot;success&quot; and &quot;failure&quot; in this context</span>
<span class="ruby-comment"># is dependent on the specific request that was sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.send_channel_request &quot;shell&quot; do |ch, success|</span>
<span class="ruby-comment">#     if success</span>
<span class="ruby-comment">#       puts &quot;user shell started successfully&quot;</span>
<span class="ruby-comment">#     else</span>
<span class="ruby-comment">#       puts &quot;could not start user shell&quot;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Most channel requests you&#39;ll want to send are already wrapped in more</span>
<span class="ruby-comment"># convenient helper methods (see #exec and #subsystem).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#488</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_channel_request</span>(<span class="ruby-identifier">request_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">data</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends data to the channel&#39;s remote endpoint. This usually has the</span>
<span class="ruby-comment"># effect of sending the given string to the remote process&#39; stdin stream.</span>
<span class="ruby-comment"># Note that it does not immediately send the data across the channel,</span>
<span class="ruby-comment"># but instead merely appends the given data to the channel&#39;s output buffer,</span>
<span class="ruby-comment"># preparatory to being packaged up and sent out the next time the connection</span>
<span class="ruby-comment"># is accepting data. (A connection might not be accepting data if, for</span>
<span class="ruby-comment"># instance, it has filled its data window and has not yet been resized by</span>
<span class="ruby-comment"># the remote end-point.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This will raise an exception if the channel has previously declared</span>
<span class="ruby-comment"># that no more data will be sent (see #eof!).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.send_data(&quot;the password\n&quot;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [EOFError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_data</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Syntactic sugar for requesting that a subsystem be started. Subsystems</span>
<span class="ruby-comment"># are a way for other protocols (like SFTP) to be run, using SSH as</span>
<span class="ruby-comment"># the transport. Generally, you&#39;ll never need to call this directly unless</span>
<span class="ruby-comment"># you are the implementor of something that consumes an SSH subsystem, like</span>
<span class="ruby-comment"># SFTP.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.subsystem(&quot;sftp&quot;) do |ch, success|</span>
<span class="ruby-comment">#     if success</span>
<span class="ruby-comment">#       puts &quot;subsystem successfully started&quot;</span>
<span class="ruby-comment">#     else</span>
<span class="ruby-comment">#       puts &quot;subsystem could not be started&quot;</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">subsystem</span>(<span class="ruby-identifier">subsystem</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of this channel, usually &quot;session&quot;.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Runs the SSH event loop until the channel is no longer active. This is</span>
<span class="ruby-comment"># handy for blocking while you wait for some channel to finish.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.exec(&quot;grep ...&quot;) { ... }</span>
<span class="ruby-comment">#   channel.wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Gets an +Array+ of local environment variables in the remote process&#39;</span>
<span class="ruby-comment"># environment.</span>
<span class="ruby-comment"># A variable name can either be described by a +Regexp+ or +String+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.forward_local_env [/^GIT_.*$/, &quot;LANG&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#671</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward_local_env</span>(<span class="ruby-identifier">env_variable_patterns</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Set a +Hash+ of environment variables in the remote process&#39; environment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.set_remote_env foo: &#39;bar&#39;, baz: &#39;whale&#39;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#688</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_remote_env</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Updates the local window size by the given amount. If the window</span>
<span class="ruby-comment"># size drops to less than half of the local maximum (an arbitrary</span>
<span class="ruby-comment"># threshold), a CHANNEL_WINDOW_ADJUST message will be sent to the</span>
<span class="ruby-comment"># server telling it that the window size has grown.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#652</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_local_window_size</span>(<span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Runs the SSH event loop until the remote confirmed channel open</span>
<span class="ruby-comment"># experimental api</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/channel.rb#641</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait_until_open_confirmed</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/connection/channel.rb#646 Net::SSH::Connection::Channel::GOOD_LOCAL_MAXIUMUM_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/channel.rb#645 Net::SSH::Connection::Channel::LOCAL_WINDOW_SIZE_INCREMENT = T.let(T.unsafe(nil), Integer)</p>

<p># A hash of the valid PTY options (see #request_pty). # # source://net-ssh//lib/net/ssh/connection/channel.rb#194 Net::SSH::Connection::Channel::VALID_PTY_OPTIONS = T.let(T.unsafe(nil), Hash)</p>

<p># Definitions of constants that are specific to the connection layer of the # SSH protocol. # # source://net-ssh//lib/net/ssh/connection/constants.rb#6 module Net::SSH::Connection::Constants; end</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#26 Net::SSH::Connection::Constants::CHANNEL_CLOSE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#23 Net::SSH::Connection::Constants::CHANNEL_DATA = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#25 Net::SSH::Connection::Constants::CHANNEL_EOF = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#24 Net::SSH::Connection::Constants::CHANNEL_EXTENDED_DATA = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#29 Net::SSH::Connection::Constants::CHANNEL_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># – # Channel related messages # ++ # # source://net-ssh//lib/net/ssh/connection/constants.rb#19 Net::SSH::Connection::Constants::CHANNEL_OPEN = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#20 Net::SSH::Connection::Constants::CHANNEL_OPEN_CONFIRMATION = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#21 Net::SSH::Connection::Constants::CHANNEL_OPEN_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#27 Net::SSH::Connection::Constants::CHANNEL_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#28 Net::SSH::Connection::Constants::CHANNEL_SUCCESS = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#22 Net::SSH::Connection::Constants::CHANNEL_WINDOW_ADJUST = T.let(T.unsafe(nil), Integer)</p>

<p># – # Connection protocol generic messages # ++ # # source://net-ssh//lib/net/ssh/connection/constants.rb#11 Net::SSH::Connection::Constants::GLOBAL_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#13 Net::SSH::Connection::Constants::REQUEST_FAILURE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/constants.rb#12 Net::SSH::Connection::Constants::REQUEST_SUCCESS = T.let(T.unsafe(nil), Integer)</p>

<p># EventLoop can be shared across multiple sessions # # one issue is with blocks passed to loop, etc. # they should get current session as parameter, but in # case you’re using multiple sessions in an event loop it doesnt makes sense # and we don’t pass session. # # source://net-ssh//lib/net/ssh/connection/event_loop.rb#12 class Net::SSH::Connection::EventLoop</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># @return [EventLoop] a new instance of EventLoop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">logger</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Call preprocess on each session. If block given and that</span>
<span class="ruby-comment"># block retuns false then we exit the processing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_preprocess</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_select_and_postprocess</span>(<span class="ruby-identifier">wait</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># process until timeout</span>
<span class="ruby-comment"># if a block is given a session will be removed from loop</span>
<span class="ruby-comment"># if block returns false for that session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process</span>(<span class="ruby-identifier">wait</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># process the event loop but only for the sepcified session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_only</span>(<span class="ruby-identifier">session</span>, <span class="ruby-identifier">wait</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register</span>(<span class="ruby-identifier">session</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/connection/keepalive.rb#5 class Net::SSH::Connection::Keepalive</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># @return [Keepalive] a new instance of Keepalive</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">session</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interval</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keepalive_maxcount</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_as_needed</span>(<span class="ruby-identifier">was_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/keepalive.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_send?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A session class representing the connection service running on top of # the SSH transport layer. It manages the creation of channels (see # #open_channel), and the dispatching of messages to the various channels. # It also encapsulates the SSH event loop (via #loop and #process), # and serves as a central point-of-reference for all SSH-related services (e.g. # port forwarding, SFTP, SCP, etc.). # # You will rarely (if ever) need to instantiate this class directly; rather, # you’ll almost always use Net::SSH.start to initialize a new network # connection, authenticate a user, and return a new connection session, # all in one call. # #   Net::SSH.start(“localhost”, “user”) do |ssh| #     # ‘ssh’ is an instance of Net::SSH::Connection::Session #     ssh.exec! “/etc/init.d/some_process start” #   end # # source://net-ssh//lib/net/ssh/connection/session.rb#27 class Net::SSH::Connection::Session</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Create a new connection service instance atop the given transport</span>
<span class="ruby-comment"># layer. Initializes the listeners to be only the underlying socket object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Session] a new instance of Session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">transport</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Retrieves a custom property from this instance. This can be used to</span>
<span class="ruby-comment"># store additional state in applications that must manage multiple</span>
<span class="ruby-comment"># SSH connections.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets a custom property for this instance.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns +true+ if there are any channels currently active on this</span>
<span class="ruby-comment"># session. By default, this will not include &quot;invisible&quot; channels</span>
<span class="ruby-comment"># (such as those created by forwarding ports and such), but if you pass</span>
<span class="ruby-comment"># a +true+ value for +include_invisible+, then those will be counted.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This can be useful for determining whether the event loop should continue</span>
<span class="ruby-comment"># to be run.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.loop { ssh.busy? }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">busy?</span>(<span class="ruby-identifier">include_invisible</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of specialized handlers for opening specific channel types. See</span>
<span class="ruby-comment"># #on_open_channel.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_open_handlers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of channels, each key being the local-id for the channel.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channels</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#522</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cleanup_channel</span>(<span class="ruby-identifier">channel</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Closes the session gracefully, blocking until all channels have</span>
<span class="ruby-comment"># successfully closed, and then closes the underlying transport layer</span>
<span class="ruby-comment"># connection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the underlying transport has been closed. Note that</span>
<span class="ruby-comment"># this can be a little misleading, since if the remote server has</span>
<span class="ruby-comment"># closed the connection, the local end will still think it is open</span>
<span class="ruby-comment"># until the next operation on the socket. Nevertheless, this method can</span>
<span class="ruby-comment"># be useful if you just want to know if _you_ have closed the connection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the file descriptors the event loop should wait for read/write events,</span>
<span class="ruby-comment"># we also return the max wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_do_calculate_rw_wait</span>(<span class="ruby-identifier">wait</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># It loops over the given arrays of reader IO&#39;s and writer IO&#39;s,</span>
<span class="ruby-comment"># processing them as needed, and</span>
<span class="ruby-comment"># then calls Net::SSH::Transport::Session#rekey_as_needed to allow the</span>
<span class="ruby-comment"># transport layer to rekey. Then returns true.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_do_handle_events</span>(<span class="ruby-identifier">readers</span>, <span class="ruby-identifier">writers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># calls Net::SSH::Transport::Session#rekey_as_needed to allow the</span>
<span class="ruby-comment"># transport layer to rekey</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_do_postprocess</span>(<span class="ruby-identifier">was_events</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called by event loop to process available data before going to</span>
<span class="ruby-comment"># event multiplexing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_preprocess</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A convenience method for executing a command and interacting with it. If</span>
<span class="ruby-comment"># no block is given, all output is printed via $stdout and $stderr. Otherwise,</span>
<span class="ruby-comment"># the block is called for each data and extended data packet, with three</span>
<span class="ruby-comment"># arguments: the channel object, a symbol indicating the data type</span>
<span class="ruby-comment"># (:stdout or :stderr), and the data (as a string).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note that this method returns immediately, and requires an event loop</span>
<span class="ruby-comment"># (see Session#loop) in order for the command to actually execute.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This is effectively identical to calling #open_channel, and then</span>
<span class="ruby-comment"># Net::SSH::Connection::Channel#exec, and then setting up the channel</span>
<span class="ruby-comment"># callbacks. However, for most uses, this will be sufficient.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.exec &quot;grep something /some/files&quot; do |ch, stream, data|</span>
<span class="ruby-comment">#     if stream == :stderr</span>
<span class="ruby-comment">#       puts &quot;ERROR: #{data}&quot;</span>
<span class="ruby-comment">#     else</span>
<span class="ruby-comment">#       puts data</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#379</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exec</span>(<span class="ruby-identifier">command</span>, <span class="ruby-value">status:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Same as #exec, except this will block until the command finishes. Also,</span>
<span class="ruby-comment"># if no block is given, this will return all output (stdout and stderr)</span>
<span class="ruby-comment"># as a single string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   matches = ssh.exec!(&quot;grep something /some/files&quot;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># the returned string has an exitstatus method to query its exit status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exec!</span>(<span class="ruby-identifier">command</span>, <span class="ruby-value">status:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a reference to the Net::SSH::Service::Forward service, which can</span>
<span class="ruby-comment"># be used for forwarding ports over SSH.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#493</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the name of the host that was given to the transport layer to</span>
<span class="ruby-comment"># connect to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds an IO object for the event loop to listen to. If a callback</span>
<span class="ruby-comment"># is given, it will be invoked when the io is ready to be read, otherwise,</span>
<span class="ruby-comment"># the io will merely have its #fill method invoked.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Any +io+ value passed to this method _must_ have mixed into it the</span>
<span class="ruby-comment"># Net::SSH::BufferedIo functionality, typically by calling #extend on the</span>
<span class="ruby-comment"># object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The following example executes a process on the remote server, opens</span>
<span class="ruby-comment"># a socket to somewhere, and then pipes data from that socket to the</span>
<span class="ruby-comment"># remote process&#39; stdin stream:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel = ssh.open_channel do |ch|</span>
<span class="ruby-comment">#     ch.exec &quot;/some/process/that/wants/input&quot; do |ch, success|</span>
<span class="ruby-comment">#       abort &quot;can&#39;t execute!&quot; unless success</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#       io = TCPSocket.new(somewhere, port)</span>
<span class="ruby-comment">#       io.extend(Net::SSH::BufferedIo)</span>
<span class="ruby-comment">#       ssh.listen_to(io)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#       ch.on_process do</span>
<span class="ruby-comment">#         if io.available &gt; 0</span>
<span class="ruby-comment">#           ch.send_data(io.read_available)</span>
<span class="ruby-comment">#         end</span>
<span class="ruby-comment">#       end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#       ch.on_close do</span>
<span class="ruby-comment">#         ssh.stop_listening_to(io)</span>
<span class="ruby-comment">#         io.close</span>
<span class="ruby-comment">#       end</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">listen_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of listeners that the event loop knows about. See #listen_to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">listeners</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The main event loop. Calls #process until #process returns false. If a</span>
<span class="ruby-comment"># block is given, it is passed to #process, otherwise a default proc is</span>
<span class="ruby-comment"># used that just returns true if there are any channels active (see #busy?).</span>
<span class="ruby-comment"># The # +wait+ parameter is also passed through to #process (where it is</span>
<span class="ruby-comment"># interpreted as the maximum number of seconds to wait for IO.select to return).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # loop for as long as there are any channels active</span>
<span class="ruby-comment">#   ssh.loop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # loop for as long as there are any channels active, but make sure</span>
<span class="ruby-comment">#   # the event loop runs at least once per 0.1 second</span>
<span class="ruby-comment">#   ssh.loop(0.1)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # loop until ctrl-C is pressed</span>
<span class="ruby-comment">#   int_pressed = false</span>
<span class="ruby-comment">#   trap(&quot;INT&quot;) { int_pressed = true }</span>
<span class="ruby-comment">#   ssh.loop(0.1) { not int_pressed }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop</span>(<span class="ruby-identifier">wait</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the #preprocess and #postprocess callbacks for this session need to run</span>
<span class="ruby-comment"># periodically, this method returns the maximum number of seconds which may</span>
<span class="ruby-comment"># pass between callbacks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#532</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_select_wait_time</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a handler to be invoked when the server sends a global request</span>
<span class="ruby-comment"># of the given type. The callback receives the request data as the first</span>
<span class="ruby-comment"># parameter, and true/false as the second (indicating whether a response</span>
<span class="ruby-comment"># is required). If the callback sends the response, it should return</span>
<span class="ruby-comment"># :sent. Otherwise, if it returns true, REQUEST_SUCCESS will be sent, and</span>
<span class="ruby-comment"># if it returns false, REQUEST_FAILURE will be sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#517</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_global_request</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Registers a handler to be invoked when the server wants to open a</span>
<span class="ruby-comment"># channel on the client. The callback receives the connection object,</span>
<span class="ruby-comment"># the new channel object, and the packet itself as arguments, and should</span>
<span class="ruby-comment"># raise ChannelOpenFailed if it is unable to open the channel for some</span>
<span class="ruby-comment"># reason. Otherwise, the channel will be opened and a confirmation message</span>
<span class="ruby-comment"># sent to the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This is used by the Net::SSH::Service::Forward service to open a channel</span>
<span class="ruby-comment"># when a remote forwarded port receives a connection. However, you are</span>
<span class="ruby-comment"># welcome to register handlers for other channel types, as needed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#507</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_open_channel</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that a new channel be opened. By default, the channel will be</span>
<span class="ruby-comment"># of type &quot;session&quot;, but if you know what you&#39;re doing you can select any</span>
<span class="ruby-comment"># of the channel types supported by the SSH protocol. The +extra+ parameters</span>
<span class="ruby-comment"># must be even in number and conform to the same format as described for</span>
<span class="ruby-comment"># Net::SSH::Buffer.from. If a callback is given, it will be invoked when</span>
<span class="ruby-comment"># the server confirms that the channel opened successfully. The sole parameter</span>
<span class="ruby-comment"># for the callback is the channel object itself.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In general, you&#39;ll use #open_channel without any arguments; the only</span>
<span class="ruby-comment"># time you&#39;d want to set the channel type or pass additional initialization</span>
<span class="ruby-comment"># data is if you were implementing an SSH extension.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel = ssh.open_channel do |ch|</span>
<span class="ruby-comment">#     ch.exec &quot;grep something /some/files&quot; do |ch, success|</span>
<span class="ruby-comment">#       ...</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   channel.wait</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open_channel</span>(<span class="ruby-identifier">type</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">*</span><span class="ruby-identifier">extra</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">on_confirm</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of options that were used to initialize this instance.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The list of callbacks for pending requests. See #send_global_request.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending_requests</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is called internally as part of #process.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">postprocess</span>(<span class="ruby-identifier">readers</span>, <span class="ruby-identifier">writers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is called internally as part of #process. It dispatches any</span>
<span class="ruby-comment"># available incoming packets, and then runs Net::SSH::Connection::Channel#process</span>
<span class="ruby-comment"># for any active channels. If a block is given, it is invoked at the</span>
<span class="ruby-comment"># start of the method and again at the end, and if the block ever returns</span>
<span class="ruby-comment"># false, this method returns false. Otherwise, it returns true.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preprocess</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The core of the event loop. It processes a single iteration of the event</span>
<span class="ruby-comment"># loop. If a block is given, it should return false when the processing</span>
<span class="ruby-comment"># should abort, which causes #process to return false. Otherwise,</span>
<span class="ruby-comment"># #process returns true. The session itself is yielded to the block as its</span>
<span class="ruby-comment"># only argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If +wait+ is nil (the default), this method will block until any of the</span>
<span class="ruby-comment"># monitored IO objects are ready to be read from or written to. If you want</span>
<span class="ruby-comment"># it to not block, you can pass 0, or you can pass any other numeric value</span>
<span class="ruby-comment"># to indicate that it should block for no more than that many seconds.</span>
<span class="ruby-comment"># Passing 0 is a good way to poll the connection, but if you do it too</span>
<span class="ruby-comment"># frequently it can make your CPU quite busy!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This will also cause all active channels to be processed once each (see</span>
<span class="ruby-comment"># Net::SSH::Connection::Channel#on_process).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># TODO revise example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # process multiple Net::SSH connections in parallel</span>
<span class="ruby-comment">#   connections = [</span>
<span class="ruby-comment">#     Net::SSH.start(&quot;host1&quot;, ...),</span>
<span class="ruby-comment">#     Net::SSH.start(&quot;host2&quot;, ...)</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   connections.each do |ssh|</span>
<span class="ruby-comment">#     ssh.exec &quot;grep something /in/some/files&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   condition = Proc.new { |s| s.busy? }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   loop do</span>
<span class="ruby-comment">#     connections.delete_if { |ssh| !ssh.process(0.1, &amp;condition) }</span>
<span class="ruby-comment">#     break if connections.empty?</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process</span>(<span class="ruby-identifier">wait</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The collection of custom properties for this instance. (See #[] and #[]=).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">properties</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Send a global request of the given type. The +extra+ parameters must</span>
<span class="ruby-comment"># be even in number, and conform to the same format as described for</span>
<span class="ruby-comment"># Net::SSH::Buffer.from. If a callback is not specified, the request will</span>
<span class="ruby-comment"># not require a response from the server, otherwise the server is required</span>
<span class="ruby-comment"># to respond and indicate whether the request was successful or not. This</span>
<span class="ruby-comment"># success or failure is indicated by the callback being invoked, with the</span>
<span class="ruby-comment"># first parameter being true or false (success, or failure), and the second</span>
<span class="ruby-comment"># being the packet itself.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Generally, Net::SSH will manage global requests that need to be sent</span>
<span class="ruby-comment"># (e.g. port forward requests and such are handled in the Net::SSH::Service::Forward</span>
<span class="ruby-comment"># class, for instance). However, there may be times when you need to</span>
<span class="ruby-comment"># send a global request that isn&#39;t explicitly handled by Net::SSH, and so</span>
<span class="ruby-comment"># this method is available to you.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.send_global_request(&quot;keep-alive@openssh.com&quot;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#311</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_global_request</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">extra</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues a message to be sent to the server as soon as the socket is</span>
<span class="ruby-comment"># available for writing. Most programs will never need to call this, but</span>
<span class="ruby-comment"># if you are implementing an extension to the SSH protocol, or if you</span>
<span class="ruby-comment"># need to send a packet that Net::SSH does not directly support, you can</span>
<span class="ruby-comment"># use this to send it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#  ssh.send_message(Buffer.from(:byte, REQUEST_SUCCESS).to_s)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#443</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_message</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Performs a &quot;hard&quot; shutdown of the connection. In general, this should</span>
<span class="ruby-comment"># never be done, but it might be necessary (in a rescue clause, for instance,</span>
<span class="ruby-comment"># when the connection needs to close but you don&#39;t know the status of the</span>
<span class="ruby-comment"># underlying protocol&#39;s state).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes the given io object from the listeners collection, so that the</span>
<span class="ruby-comment"># event loop will no longer monitor it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#487</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stop_listening_to</span>(<span class="ruby-identifier">io</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying transport layer abstraction (see Net::SSH::Transport::Session).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transport</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#682</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_close</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#568</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_closed</span>(<span class="ruby-identifier">channel</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#667</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_data</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#677</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_eof</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#672</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_extended_data</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#694</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_failure</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called when the server wants to open a channel. If no registered</span>
<span class="ruby-comment"># channel handler exists for the given channel type, CHANNEL_OPEN_FAILURE</span>
<span class="ruby-comment"># is returned, otherwise the callback is invoked and everything proceeds</span>
<span class="ruby-comment"># accordingly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#612</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_open</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#645</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_open_confirmation</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#651</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_open_failure</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#662</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_request</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#689</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_success</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#657</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">channel_window_adjust</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read all pending packets from the connection and dispatch them as</span>
<span class="ruby-comment"># appropriate. Returns as soon as there are no more pending packets.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#545</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dispatch_incoming_packets</span>(<span class="ruby-value">raise_disconnect_errors:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># iterate channels with the posibility of callbacks opening new channels during the iteration</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#539</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_channel</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#562</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_channel_cleanup_on_close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the next available channel id to be assigned, and increments</span>
<span class="ruby-comment"># the counter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#558</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_next_channel_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked when a global request is received. The registered global</span>
<span class="ruby-comment"># request callback will be invoked, if one exists, and the necessary</span>
<span class="ruby-comment"># reply returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#579</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_request</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#699</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">io_select_wait</span>(<span class="ruby-identifier">wait</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># preserve a reference to Kernel#loop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_forever</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the next pending request callback with +false+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#602</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">request_failure</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invokes the next pending request callback with +true+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#595</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">request_success</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Default IO.select timeout threshold # # source://net-ssh//lib/net/ssh/connection/session.rb#32 Net::SSH::Connection::Session::DEFAULT_IO_SELECT_TIMEOUT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/connection/session.rb#703 Net::SSH::Connection::Session::MAP = T.let(T.unsafe(nil), Hash)</p>

<p># source://net-ssh//lib/net/ssh/connection/session.rb#56 class Net::SSH::Connection::Session::NilChannel</p>

<pre class="ruby"><span class="ruby-comment"># @return [NilChannel] a new instance of NilChannel</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">session</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_missing</span>(<span class="ruby-identifier">sym</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/connection/session.rb#350 class Net::SSH::Connection::Session::StringWithExitstatus &lt; ::String</p>

<pre class="ruby"><span class="ruby-comment"># @return [StringWithExitstatus] a new instance of StringWithExitstatus</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">exitstatus</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute exitstatus.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/session.rb#356</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exitstatus</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># optimized version for a single session # # source://net-ssh//lib/net/ssh/connection/event_loop.rb#98 class Net::SSH::Connection::SingleSessionEventLoop &lt; ::Net::SSH::Connection::EventLoop</p>

<pre class="ruby"><span class="ruby-comment"># Compatibility for original single session event loops:</span>
<span class="ruby-comment"># we call block with session as argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_preprocess</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/connection/event_loop.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ev_select_and_postprocess</span>(<span class="ruby-identifier">wait</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># These constants are used when requesting a pseudo-terminal (via # Net::SSH::Connection::Channel#request_pty). The descriptions for each are # taken directly from RFC 4254 (“The Secure Shell (SSH) Connection Protocol”), # <a href="http://tools.ietf.org/html/rfc4254">tools.ietf.org/html/rfc4254</a>. # # source://net-ssh//lib/net/ssh/connection/term.rb#8 module Net::SSH::Connection::Term; end</p>

<p># 7 bit mode. # # source://net-ssh//lib/net/ssh/connection/term.rb#161 Net::SSH::Connection::Term::CS7 = T.let(T.unsafe(nil), Integer)</p>

<p># 8 bit mode. # # source://net-ssh//lib/net/ssh/connection/term.rb#164 Net::SSH::Connection::Term::CS8 = T.let(T.unsafe(nil), Integer)</p>

<p># Enable echoing. # # source://net-ssh//lib/net/ssh/connection/term.rb#113 Net::SSH::Connection::Term::ECHO = T.let(T.unsafe(nil), Integer)</p>

<p># Echo control characters as ^(Char). # # source://net-ssh//lib/net/ssh/connection/term.rb#134 Net::SSH::Connection::Term::ECHOCTL = T.let(T.unsafe(nil), Integer)</p>

<p># Visually erase chars. # # source://net-ssh//lib/net/ssh/connection/term.rb#116 Net::SSH::Connection::Term::ECHOE = T.let(T.unsafe(nil), Integer)</p>

<p># Kill character discards current line. # # source://net-ssh//lib/net/ssh/connection/term.rb#119 Net::SSH::Connection::Term::ECHOK = T.let(T.unsafe(nil), Integer)</p>

<p># Visual erase for line kill. # # source://net-ssh//lib/net/ssh/connection/term.rb#137 Net::SSH::Connection::Term::ECHOKE = T.let(T.unsafe(nil), Integer)</p>

<p># Echo NL even if ECHO is off. # # source://net-ssh//lib/net/ssh/connection/term.rb#122 Net::SSH::Connection::Term::ECHONL = T.let(T.unsafe(nil), Integer)</p>

<p># Canonicalize input lines. # # source://net-ssh//lib/net/ssh/connection/term.rb#106 Net::SSH::Connection::Term::ICANON = T.let(T.unsafe(nil), Integer)</p>

<p># Map CR to NL on input. # # source://net-ssh//lib/net/ssh/connection/term.rb#85 Net::SSH::Connection::Term::ICRNL = T.let(T.unsafe(nil), Integer)</p>

<p># Enable extensions. # # source://net-ssh//lib/net/ssh/connection/term.rb#131 Net::SSH::Connection::Term::IEXTEN = T.let(T.unsafe(nil), Integer)</p>

<p># Ignore CR on input. # # source://net-ssh//lib/net/ssh/connection/term.rb#82 Net::SSH::Connection::Term::IGNCR = T.let(T.unsafe(nil), Integer)</p>

<p># The ignore parity flag. The parameter SHOULD be 0 if this flag is FALSE, # and 1 if it is TRUE. # # source://net-ssh//lib/net/ssh/connection/term.rb#67 Net::SSH::Connection::Term::IGNPAR = T.let(T.unsafe(nil), Integer)</p>

<p># Ring bell on input queue full. # # source://net-ssh//lib/net/ssh/connection/term.rb#100 Net::SSH::Connection::Term::IMAXBEL = T.let(T.unsafe(nil), Integer)</p>

<p># Map NL into CR on input. # # source://net-ssh//lib/net/ssh/connection/term.rb#79 Net::SSH::Connection::Term::INCLR = T.let(T.unsafe(nil), Integer)</p>

<p># Enable checking of parity errors. # # source://net-ssh//lib/net/ssh/connection/term.rb#73 Net::SSH::Connection::Term::INPCK = T.let(T.unsafe(nil), Integer)</p>

<p># Enable signals INTR, QUIT, [D]SUSP. # # source://net-ssh//lib/net/ssh/connection/term.rb#103 Net::SSH::Connection::Term::ISIG = T.let(T.unsafe(nil), Integer)</p>

<p># Strip 8th bit off characters. # # source://net-ssh//lib/net/ssh/connection/term.rb#76 Net::SSH::Connection::Term::ISTRIP = T.let(T.unsafe(nil), Integer)</p>

<p># Translate uppercase characters to lowercase. # # source://net-ssh//lib/net/ssh/connection/term.rb#88 Net::SSH::Connection::Term::IUCLC = T.let(T.unsafe(nil), Integer)</p>

<p># Any char will restart after stop. # # source://net-ssh//lib/net/ssh/connection/term.rb#94 Net::SSH::Connection::Term::IXANY = T.let(T.unsafe(nil), Integer)</p>

<p># Enable input flow control. # # source://net-ssh//lib/net/ssh/connection/term.rb#97 Net::SSH::Connection::Term::IXOFF = T.let(T.unsafe(nil), Integer)</p>

<p># Enable output flow control. # # source://net-ssh//lib/net/ssh/connection/term.rb#91 Net::SSH::Connection::Term::IXON = T.let(T.unsafe(nil), Integer)</p>

<p># Don’t flush after interrupt. # # source://net-ssh//lib/net/ssh/connection/term.rb#125 Net::SSH::Connection::Term::NOFLSH = T.let(T.unsafe(nil), Integer)</p>

<p># Translate carriage return to newline (output). # # source://net-ssh//lib/net/ssh/connection/term.rb#152 Net::SSH::Connection::Term::OCRNL = T.let(T.unsafe(nil), Integer)</p>

<p># Convert lowercase to uppercase. # # source://net-ssh//lib/net/ssh/connection/term.rb#146 Net::SSH::Connection::Term::OLCUC = T.let(T.unsafe(nil), Integer)</p>

<p># Map NL to CR-NL. # # source://net-ssh//lib/net/ssh/connection/term.rb#149 Net::SSH::Connection::Term::ONLCR = T.let(T.unsafe(nil), Integer)</p>

<p># Newline performs a carriage return (output). # # source://net-ssh//lib/net/ssh/connection/term.rb#158 Net::SSH::Connection::Term::ONLRET = T.let(T.unsafe(nil), Integer)</p>

<p># Translate newline to carriage return-newline (output). # # source://net-ssh//lib/net/ssh/connection/term.rb#155 Net::SSH::Connection::Term::ONOCR = T.let(T.unsafe(nil), Integer)</p>

<p># Enable output processing. # # source://net-ssh//lib/net/ssh/connection/term.rb#143 Net::SSH::Connection::Term::OPOST = T.let(T.unsafe(nil), Integer)</p>

<p># Parity enable. # # source://net-ssh//lib/net/ssh/connection/term.rb#167 Net::SSH::Connection::Term::PARENB = T.let(T.unsafe(nil), Integer)</p>

<p># Mark parity and framing errors. # # source://net-ssh//lib/net/ssh/connection/term.rb#70 Net::SSH::Connection::Term::PARMRK = T.let(T.unsafe(nil), Integer)</p>

<p># Odd parity, else even. # # source://net-ssh//lib/net/ssh/connection/term.rb#170 Net::SSH::Connection::Term::PARODD = T.let(T.unsafe(nil), Integer)</p>

<p># Retype pending input. # # source://net-ssh//lib/net/ssh/connection/term.rb#140 Net::SSH::Connection::Term::PENDIN = T.let(T.unsafe(nil), Integer)</p>

<p># Stop background jobs from output. # # source://net-ssh//lib/net/ssh/connection/term.rb#128 Net::SSH::Connection::Term::TOSTOP = T.let(T.unsafe(nil), Integer)</p>

<p># Specifies the input baud rate in bits per second. # # source://net-ssh//lib/net/ssh/connection/term.rb#173 Net::SSH::Connection::Term::TTY_OP_ISPEED = T.let(T.unsafe(nil), Integer)</p>

<p># Specifies the output baud rate in bits per second. # # source://net-ssh//lib/net/ssh/connection/term.rb#176 Net::SSH::Connection::Term::TTY_OP_OSPEED = T.let(T.unsafe(nil), Integer)</p>

<p># Toggles the flushing of terminal output. # # source://net-ssh//lib/net/ssh/connection/term.rb#63 Net::SSH::Connection::Term::VDISCARD = T.let(T.unsafe(nil), Integer)</p>

<p># Another suspend character. # # source://net-ssh//lib/net/ssh/connection/term.rb#41 Net::SSH::Connection::Term::VDSUSP = T.let(T.unsafe(nil), Integer)</p>

<p># End-of-file character (sends EOF from the terminal). # # source://net-ssh//lib/net/ssh/connection/term.rb#23 Net::SSH::Connection::Term::VEOF = T.let(T.unsafe(nil), Integer)</p>

<p># End-of-line character in addition to carriage return and/or linefeed. # # source://net-ssh//lib/net/ssh/connection/term.rb#26 Net::SSH::Connection::Term::VEOL = T.let(T.unsafe(nil), Integer)</p>

<p># Additional end-of-line character. # # source://net-ssh//lib/net/ssh/connection/term.rb#29 Net::SSH::Connection::Term::VEOL2 = T.let(T.unsafe(nil), Integer)</p>

<p># Erase the character to left of the cursor. # # source://net-ssh//lib/net/ssh/connection/term.rb#17 Net::SSH::Connection::Term::VERASE = T.let(T.unsafe(nil), Integer)</p>

<p># Character to flush output. # # source://net-ssh//lib/net/ssh/connection/term.rb#54 Net::SSH::Connection::Term::VFLUSH = T.let(T.unsafe(nil), Integer)</p>

<p># Interrupt character; 255 if none. Similarly for the other characters. # Not all of these characters are supported on all systems. # # source://net-ssh//lib/net/ssh/connection/term.rb#11 Net::SSH::Connection::Term::VINTR = T.let(T.unsafe(nil), Integer)</p>

<p># Kill the current input line. # # source://net-ssh//lib/net/ssh/connection/term.rb#20 Net::SSH::Connection::Term::VKILL = T.let(T.unsafe(nil), Integer)</p>

<p># Enter the next character typed literally, even if it is a special # character. # # source://net-ssh//lib/net/ssh/connection/term.rb#51 Net::SSH::Connection::Term::VLNEXT = T.let(T.unsafe(nil), Integer)</p>

<p># The quit character (sends SIGQUIT signal on POSIX systems). # # source://net-ssh//lib/net/ssh/connection/term.rb#14 Net::SSH::Connection::Term::VQUIT = T.let(T.unsafe(nil), Integer)</p>

<p># Reprints the current input line. # # source://net-ssh//lib/net/ssh/connection/term.rb#44 Net::SSH::Connection::Term::VREPRINT = T.let(T.unsafe(nil), Integer)</p>

<p># Continues paused output (normally control-Q). # # source://net-ssh//lib/net/ssh/connection/term.rb#32 Net::SSH::Connection::Term::VSTART = T.let(T.unsafe(nil), Integer)</p>

<p># Prints system status line (load, command, pid, etc). # # source://net-ssh//lib/net/ssh/connection/term.rb#60 Net::SSH::Connection::Term::VSTATUS = T.let(T.unsafe(nil), Integer)</p>

<p># Pauses output (normally control-S). # # source://net-ssh//lib/net/ssh/connection/term.rb#35 Net::SSH::Connection::Term::VSTOP = T.let(T.unsafe(nil), Integer)</p>

<p># Suspends the current program. # # source://net-ssh//lib/net/ssh/connection/term.rb#38 Net::SSH::Connection::Term::VSUSP = T.let(T.unsafe(nil), Integer)</p>

<p># Switch to a different shell layer. # # source://net-ssh//lib/net/ssh/connection/term.rb#57 Net::SSH::Connection::Term::VSWITCH = T.let(T.unsafe(nil), Integer)</p>

<p># Erases a word left of cursor. # # source://net-ssh//lib/net/ssh/connection/term.rb#47 Net::SSH::Connection::Term::VWERASE = T.let(T.unsafe(nil), Integer)</p>

<p># Enable input and output of uppercase characters by preceding their # lowercase equivalents with “&quot;. # # source://net-ssh//lib/net/ssh/connection/term.rb#110 Net::SSH::Connection::Term::XCASE = T.let(T.unsafe(nil), Integer)</p>

<p># This exception is raised when a connection attempt times out. # # source://net-ssh//lib/net/ssh/errors.rb#12 class Net::SSH::ConnectionTimeout &lt; ::Net::SSH::Exception; end</p>

<p># This exception is raised when the remote host has disconnected # unexpectedly. # # source://net-ssh//lib/net/ssh/errors.rb#16 class Net::SSH::Disconnect &lt; ::Net::SSH::Exception; end</p>

<p># A general exception class, to act as the ancestor of all other Net::SSH # exception classes. # # source://net-ssh//lib/net/ssh/errors.rb#5 class Net::SSH::Exception &lt; ::RuntimeError; end</p>

<p># Fixes for two issues by Miklós Fazekas: # #   * if client closes a forwarded connection, but the server is #     reading, net-ssh terminates with IOError socket closed. #   * if client force closes (RST) a forwarded connection, but #     server is reading, net-ssh terminates with [an exception] # # See: # #    <a href="http://net-ssh.lighthouseapp.com/projects/36253/tickets/7">net-ssh.lighthouseapp.com/projects/36253/tickets/7</a> #    <a href="http://github.com/net-ssh/net-ssh/tree/portfwfix">github.com/net-ssh/net-ssh/tree/portfwfix</a> # # source://net-ssh//lib/net/ssh/buffered_io.rb#168 module Net::SSH::ForwardedBufferedIo</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fill</span>(<span class="ruby-identifier">n</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/buffered_io.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_pending</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/known_hosts.rb#9 module Net::SSH::HostKeyEntries; end</p>

<p># @cert-authority entry # # source://net-ssh//lib/net/ssh/known_hosts.rb#40 class Net::SSH::HostKeyEntries::CertAuthority</p>

<pre class="ruby"><span class="ruby-comment"># @return [CertAuthority] a new instance of CertAuthority</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">key</span>, <span class="ruby-value">comment:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches_key?</span>(<span class="ruby-identifier">server_key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_types</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># regular public key entry # # source://net-ssh//lib/net/ssh/known_hosts.rb#11 class Net::SSH::HostKeyEntries::PubKey</p>

<pre class="ruby"><span class="ruby-comment"># @return [PubKey] a new instance of PubKey</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">key</span>, <span class="ruby-value">comment:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__getobj__</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches_key?</span>(<span class="ruby-identifier">server_key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_types</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Base class for host key exceptions. When rescuing this exception, you can # inspect the key fingerprint and, if you want to proceed anyway, simply call # the remember_host! method on the exception, and then retry. # # source://net-ssh//lib/net/ssh/errors.rb#46 class Net::SSH::HostKeyError &lt; ::Net::SSH::Exception</p>

<pre class="ruby"><span class="ruby-comment"># An accessor for getting at the data that was used to look up the host</span>
<span class="ruby-comment"># (see also #fingerprint, #host, #port, #ip, and #key).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the callback to use when #remember_host! is called</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># situation-specific data describing the host (see #host, #port, etc.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">data=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the fingerprint of the key for the host, which either was not</span>
<span class="ruby-comment"># found or did not match.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fingerprint</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the host name for the remote host, as reported by the socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the IP address of the remote host, as reported by the socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ip</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the key itself, as reported by the remote host.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the port number for the remote host, as reported by the socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">port</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tell Net::SSH to record this host and key in the known hosts file, so</span>
<span class="ruby-comment"># that subsequent connections will remember them.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/errors.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remember_host!</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when the cached key for a particular host does not match the # key given by the host, which can be indicative of a man-in-the-middle # attack. When rescuing this exception, you can inspect the key fingerprint # and, if you want to proceed anyway, simply call the remember_host! # method on the exception, and then retry. # # source://net-ssh//lib/net/ssh/errors.rb#97 class Net::SSH::HostKeyMismatch &lt; ::Net::SSH::HostKeyError; end</p>

<p># Raised when there is no cached key for a particular host, which probably # means that the host has simply not been seen before. # When rescuing this exception, you can inspect the key fingerprint and, if # you want to proceed anyway, simply call the remember_host! method on the # exception, and then retry. # # source://net-ssh//lib/net/ssh/errors.rb#104 class Net::SSH::HostKeyUnknown &lt; ::Net::SSH::HostKeyError; end</p>

<p># Represents the result of a search in known hosts # see search_for # # source://net-ssh//lib/net/ssh/known_hosts.rb#69 class Net::SSH::HostKeys</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>

<span class="ruby-comment"># @return [HostKeys] a new instance of HostKeys</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">host_keys</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">known_hosts</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_host_key</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute host.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A factory class for returning new Key classes. It is used for obtaining # OpenSSL key instances via their SSH names, and for loading both public and # private keys. It used used primarily by Net::SSH itself, internally, and # will rarely (if ever) be directly used by consumers of the library. # #   klass = Net::SSH::KeyFactory.get(“rsa”) #   assert klass.is_a?(OpenSSL::PKey::RSA) # #   key = Net::SSH::KeyFactory.load_public_key(“~/.ssh/id_dsa.pub”) # # source://net-ssh//lib/net/ssh/key_factory.rb#17 class Net::SSH::KeyFactory</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Fetch an OpenSSL key instance by its SSH name. It will be a new,</span>
  <span class="ruby-comment"># empty key of the given type.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loads a private key. It will correctly determine</span>
  <span class="ruby-comment"># whether the file describes an RSA or DSA key, and will load it</span>
  <span class="ruby-comment"># appropriately. The new key is returned. If the key itself is</span>
  <span class="ruby-comment"># encrypted (requiring a passphrase to use), the user will be</span>
  <span class="ruby-comment"># prompted to enter their password unless passphrase works.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#49</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_data_private_key</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">passphrase</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">ask_passphrase</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">filename</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">prompt</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loads a public key. It will correctly determine whether</span>
  <span class="ruby-comment"># the file describes an RSA or DSA key, and will load it</span>
  <span class="ruby-comment"># appropriately. The new public key is returned.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#89</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_data_public_key</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">filename</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loads a private key from a file. It will correctly determine</span>
  <span class="ruby-comment"># whether the file describes an RSA or DSA key, and will load it</span>
  <span class="ruby-comment"># appropriately. The new key is returned. If the key itself is</span>
  <span class="ruby-comment"># encrypted (requiring a passphrase to use), the user will be</span>
  <span class="ruby-comment"># prompted to enter their password unless passphrase works.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#39</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_private_key</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">passphrase</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">ask_passphrase</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">prompt</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loads a public key from a file. It will correctly determine whether</span>
  <span class="ruby-comment"># the file describes an RSA or DSA key, and will load it</span>
  <span class="ruby-comment"># appropriately. The new public key is returned.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#81</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_public_key</span>(<span class="ruby-identifier">filename</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># Determine whether the file describes an RSA or DSA key, and return how load it</span>
  <span class="ruby-comment"># appropriately.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/key_factory.rb#197</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classify_key</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">filename</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Specifies the mapping of SSH names to OpenSSL key classes. # # source://net-ssh//lib/net/ssh/key_factory.rb#19 Net::SSH::KeyFactory::MAP = T.let(T.unsafe(nil), Hash)</p>

<p># Searches an OpenSSH-style known-host file for a given host, and returns all # matching keys. This is used to implement host-key verification, as well as # to determine what key a user prefers to use for a given host. # # This is used internally by Net::SSH, and will never need to be used directly # by consumers of the library. # # source://net-ssh//lib/net/ssh/known_hosts.rb#100 class Net::SSH::KnownHosts</p>

<pre class="ruby"><span class="ruby-comment"># Instantiate a new KnownHosts instance that will search the given known-hosts</span>
<span class="ruby-comment"># file. The path is expanded file File.expand_path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [KnownHosts] a new instance of KnownHosts</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tries to append an entry to the current source file for the given host</span>
<span class="ruby-comment"># and key. If it is unable to (because the file is not writable, for</span>
<span class="ruby-comment"># instance), an exception will be raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all keys that are known to be associatd with the</span>
<span class="ruby-comment"># given host. The +host+ parameter is either the domain name or ip address</span>
<span class="ruby-comment"># of the host, or both (comma-separated). Additionally, if a non-standard</span>
<span class="ruby-comment"># port is being used, it may be specified by putting the host (or ip, or</span>
<span class="ruby-comment"># both) in square brackets, and appending the port outside the brackets</span>
<span class="ruby-comment"># after a colon. Possible formats for +host+, then, are;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   &quot;net.ssh.test&quot;</span>
<span class="ruby-comment">#   &quot;1.2.3.4&quot;</span>
<span class="ruby-comment">#   &quot;net.ssh.test,1.2.3.4&quot;</span>
<span class="ruby-comment">#   &quot;[net.ssh.test]:5555&quot;</span>
<span class="ruby-comment">#   &quot;[1,2,3,4]:5555&quot;</span>
<span class="ruby-comment">#   &quot;[net.ssh.test]:5555,[1.2.3.4]:5555</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys_for</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Indicates whether one of the entries matches an hostname that has been</span>
<span class="ruby-comment"># stored as a HMAC-SHA1 hash in the known hosts.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">known_host_hash?</span>(<span class="ruby-identifier">hostlist</span>, <span class="ruby-identifier">entries</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The host-key file name that this KnownHosts instance will use to search</span>
<span class="ruby-comment"># for keys.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Looks in all user known host files (see KnownHosts.hostfiles) and tries to</span>
  <span class="ruby-comment"># add an entry for the given host and key to the first file it is able</span>
  <span class="ruby-comment"># to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#145</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Looks in the given +options+ hash for the :user_known_hosts_file and</span>
  <span class="ruby-comment"># :global_known_hosts_file keys, and returns an array of all known</span>
  <span class="ruby-comment"># hosts files. If the :user_known_hosts_file key is not set, the</span>
  <span class="ruby-comment"># default is returned (~/.ssh/known_hosts and ~/.ssh/known_hosts2). If</span>
  <span class="ruby-comment"># :global_known_hosts_file is not set, the default is used</span>
  <span class="ruby-comment"># (/etc/ssh/ssh_known_hosts and /etc/ssh/ssh_known_hosts2).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If you only want the user known host files, you can pass :user as</span>
  <span class="ruby-comment"># the second option.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#130</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hostfiles</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">which</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Searches all known host files (see KnownHosts.hostfiles) for all keys</span>
  <span class="ruby-comment"># of the given host. Returns an enumerable of keys found.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#111</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">search_for</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Search for all known keys for the given host, in every file given in</span>
  <span class="ruby-comment"># the +files+ array. Returns the list of keys.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/known_hosts.rb#117</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">search_in</span>(<span class="ruby-identifier">files</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/known_hosts.rb#101 Net::SSH::KnownHosts::SUPPORTED_TYPE = T.let(T.unsafe(nil), Array)</p>

<p># A simple module to make logging easier to deal with. It assumes that the # logger instance (if not nil) quacks like a Logger object (in Ruby’s # standard library). Although used primarily internally by Net::SSH, it # can easily be used to add Net::SSH-like logging to your own programs. # #   class MyClass #     include Net::SSH::Loggable #   end # #   Net::SSH.start(…) do |ssh| #     obj = MyClass.new #     obj.logger = ssh.logger #     … #   end # # source://net-ssh//lib/net/ssh/loggable.rb#17 module Net::SSH::Loggable</p>

<pre class="ruby"><span class="ruby-comment"># Displays the result of yielding if the log level is Logger::DEBUG or</span>
<span class="ruby-comment"># greater.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Displays the result of yielding if the log level is Logger:ERROR or</span>
<span class="ruby-comment"># greater.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">error</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Displays the result of yielding if the log level is Logger::FATAL or</span>
<span class="ruby-comment"># greater.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fatal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Displays the result of yielding if the log level is Logger::INFO or</span>
<span class="ruby-comment"># greater.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">info</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The logger instance that will be used to log messages. If nil, nothing</span>
<span class="ruby-comment"># will be logged.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logger</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The logger instance that will be used to log messages. If nil, nothing</span>
<span class="ruby-comment"># will be logged.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logger=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Displays the result of yielding if the log level is Logger::WARN or</span>
<span class="ruby-comment"># greater. (Called lwarn to avoid shadowing with Kernel#warn.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lwarn</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Sets the &quot;facility&quot; value, used for reporting where a log message</span>
<span class="ruby-comment"># originates. It defaults to the name of class with the object_id</span>
<span class="ruby-comment"># appended.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/loggable.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">facility</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A specialization of Buffer that knows the format of certain common # packet types. It auto-parses those packet types, and allows them to # be accessed via the #[] accessor. # #   data = some_channel_request_packet #   packet = Net::SSH::Packet.new(data) # #   p packet.type #-&gt; 98 (CHANNEL_REQUEST) #   p <a href=":request">packet</a> #   p <a href=":want_reply">packet</a> # # This is used exclusively internally by Net::SSH, and unless you’re doing # protocol-level manipulation or are extending Net::SSH in some way, you’ll # never need to use this class directly. # # source://net-ssh//lib/net/ssh/packet.rb#22 class Net::SSH::Packet &lt; ::Net::SSH::Buffer</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Connection</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Authentication</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Create a new packet from the given payload. This will automatically</span>
<span class="ruby-comment"># parse the packet if it is one that has been previously registered with</span>
<span class="ruby-comment"># Packet.register; otherwise, the packet will need to be manually parsed</span>
<span class="ruby-comment"># using the methods provided in the Net::SSH::Buffer superclass.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Packet] a new instance of Packet</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/packet.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">payload</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Access one of the auto-parsed fields by name. Raises an error if no</span>
<span class="ruby-comment"># element by the given name exists.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/packet.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The (integer) type of this packet.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/packet.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Parse the packet&#39;s contents and assign the named elements, as described</span>
<span class="ruby-comment"># by the registered format for the packet.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/packet.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">instantiate!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Register a new packet type that should be recognized and auto-parsed by</span>
  <span class="ruby-comment"># Net::SSH::Packet. Note that any packet type that is not preregistered</span>
  <span class="ruby-comment"># will not be autoparsed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The +pairs+ parameter must be either empty, or an array of two-element</span>
  <span class="ruby-comment"># tuples, where the first element of each tuple is the name of the field,</span>
  <span class="ruby-comment"># and the second is the type.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   register DISCONNECT, [:reason_code, :long], [:description, :string], [:language, :string]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/packet.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Default prompt implementation, called for asking password from user. # It will never be instantiated directly, but will instead be created for # you automatically. # # A custom prompt objects can implement caching, or different UI. The prompt # object should implemnted a start method, which should return something implementing # ask and success. Net::SSH uses it like: # #   prompter = <a href=":password_prompt">options</a>.start({type:‘password’}) #   while !ok &amp;&amp; max_retries &lt; 3 #     user = prompter.ask(“user: ”, true) #     password = prompter.ask(“password: ”, false) #     ok = send(user, password) #     prompter.sucess if ok #   end # # source://net-ssh//lib/net/ssh/prompt.rb#21 class Net::SSH::Prompt</p>

<pre class="ruby"><span class="ruby-comment"># @return [Prompt] a new instance of Prompt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># start password session. Multiple questions might be asked multiple times</span>
<span class="ruby-comment"># on the returned object. Info hash tries to uniquely identify the password</span>
<span class="ruby-comment"># session, so caching implementations can save passwords properly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start</span>(<span class="ruby-identifier">info</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># factory</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># default prompt object implementation. More sophisticated implemenetations # might implement caching. # # source://net-ssh//lib/net/ssh/prompt.rb#31 class Net::SSH::Prompt::Prompter</p>

<pre class="ruby"><span class="ruby-comment"># @return [Prompter] a new instance of Prompter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">info</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># ask input from user, a prompter might ask for multiple inputs</span>
<span class="ruby-comment"># (like user and password) in a single session.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ask</span>(<span class="ruby-identifier">prompt</span>, <span class="ruby-identifier">echo</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># success method will be called when the password was accepted</span>
<span class="ruby-comment"># It&#39;s a good time to save password asked to a cache.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/prompt.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">success</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/proxy/errors.rb#5 module Net::SSH::Proxy; end</p>

<p># An implementation of a command proxy. To use it, instantiate it, # then pass the instantiated object via the :proxy key to # Net::SSH.start: # #   require ‘net/ssh/proxy/command’ # #   proxy = Net::SSH::Proxy::Command.new(‘ssh relay nc %h %p’) #   Net::SSH.start(‘host’, ‘user’, :proxy =&gt; proxy) do |ssh| #     … #   end # # source://net-ssh//lib/net/ssh/proxy/command.rb#18 class Net::SSH::Proxy::Command</p>

<pre class="ruby"><span class="ruby-comment"># Create a new socket factory that tunnels via a command executed</span>
<span class="ruby-comment"># with the user&#39;s shell, which is composed from the given command</span>
<span class="ruby-comment"># template.  In the command template, `%h&#39; will be substituted by</span>
<span class="ruby-comment"># the host name to connect and `%p&#39; by the port.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Command] a new instance of Command</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">command_line_template</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close_on_error</span>(<span class="ruby-identifier">io</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The command line for the session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The command line template</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_line_template</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return a new socket connected to the given host and port via the</span>
<span class="ruby-comment"># proxy that was requested when the socket factory was instantiated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">connection_options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Timeout in seconds in open, defaults to 60</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">timeout</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Timeout in seconds in open, defaults to 60</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/command.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">timeout=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Used for reporting proxy connection errors. # # source://net-ssh//lib/net/ssh/proxy/errors.rb#10 class Net::SSH::Proxy::ConnectError &lt; ::Net::SSH::Proxy::Error; end</p>

<p># A general exception class for all Proxy errors. # # source://net-ssh//lib/net/ssh/proxy/errors.rb#7 class Net::SSH::Proxy::Error &lt; ::Net::SSH::Exception; end</p>

<p># An implementation of a jump proxy. To use it, instantiate it, # then pass the instantiated object via the :proxy key to # Net::SSH.start: # #   require ‘net/ssh/proxy/jump’ # #   proxy = Net::SSH::Proxy::Jump.new(‘user@proxy’) #   Net::SSH.start(‘host’, ‘user’, :proxy =&gt; proxy) do |ssh| #     … #   end # # source://net-ssh//lib/net/ssh/proxy/jump.rb#17 class Net::SSH::Proxy::Jump &lt; ::Net::SSH::Proxy::Command</p>

<pre class="ruby"><span class="ruby-comment"># Create a new socket factory that tunnels via multiple jump proxes as</span>
<span class="ruby-comment"># [user@]host[:port].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Jump] a new instance of Jump</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/jump.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">jump_proxies</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># We cannot build the ProxyCommand template until we know if the :config</span>
<span class="ruby-comment"># option was specified during `Net::SSH.start`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/jump.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_proxy_command_equivalent</span>(<span class="ruby-identifier">connection_options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The jump proxies</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/jump.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">jump_proxies</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return a new socket connected to the given host and port via the jump</span>
<span class="ruby-comment"># proxy that was requested when the socket factory was instantiated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/proxy/jump.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">connection_options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Used when the server doesn’t recognize the user’s credentials. # # source://net-ssh//lib/net/ssh/proxy/errors.rb#13 class Net::SSH::Proxy::UnauthorizedError &lt; ::Net::SSH::Proxy::Error; end</p>

<p># source://net-ssh//lib/net/ssh/service/forward.rb#5 module Net::SSH::Service; end</p>

<p># This class implements various port forwarding services for use by # Net::SSH clients. The Forward class should never need to be instantiated # directly; instead, it should be accessed via the singleton instance # returned by Connection::Session#forward: # #   ssh.forward.local(1234, “<a href="www.capify.org">www.capify.org</a>”, 80) # # source://net-ssh//lib/net/ssh/service/forward.rb#12 class Net::SSH::Service::Forward</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># Instantiates a new Forward service instance atop the given connection</span>
<span class="ruby-comment"># service session. This will register new channel open handlers to handle</span>
<span class="ruby-comment"># the specialized channels that the SSH port forwarding protocols employ.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Forward] a new instance of Forward</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">session</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a list of all active locally forwarded sockets. The returned value</span>
<span class="ruby-comment"># is an array of Unix domain socket file paths.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_local_sockets</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a list of all active locally forwarded ports. The returned value</span>
<span class="ruby-comment"># is an array of arrays, where each element is a two-element tuple</span>
<span class="ruby-comment"># consisting of the local port and bind address corresponding to the</span>
<span class="ruby-comment"># forwarding port.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_locals</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns all active remote forwarded ports and where they forward to. The</span>
<span class="ruby-comment"># returned value is a hash from [&lt;forwarding port on the local host&gt;, &lt;local forwarding address&gt;]</span>
<span class="ruby-comment"># to [&lt;port on the remote host&gt;, &lt;remote bind address&gt;].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_remote_destinations</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns all active forwarded remote ports. The returned value is an</span>
<span class="ruby-comment"># array of two-element tuples, where the first element is the port on the</span>
<span class="ruby-comment"># remote host and the second is the bind address.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_remotes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enables SSH agent forwarding on the given channel. The forwarded agent</span>
<span class="ruby-comment"># will remain active even after the channel closes--the channel is only</span>
<span class="ruby-comment"># used as the transport for enabling the forwarded connection. You should</span>
<span class="ruby-comment"># never need to call this directly--it is called automatically the first</span>
<span class="ruby-comment"># time a session channel is opened, when the connection was created with</span>
<span class="ruby-comment"># :forward_agent set to true:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#    Net::SSH.start(&quot;remote.host&quot;, &quot;me&quot;, :forward_agent =&gt; true) do |ssh|</span>
<span class="ruby-comment">#      ssh.open_channel do |ch|</span>
<span class="ruby-comment">#        # agent will be automatically forwarded by this point</span>
<span class="ruby-comment">#      end</span>
<span class="ruby-comment">#      ssh.loop</span>
<span class="ruby-comment">#    end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#290</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">agent</span>(<span class="ruby-identifier">channel</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Terminates an active local forwarded port.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.forward.cancel_local(1234)</span>
<span class="ruby-comment">#   ssh.forward.cancel_local(1234, &quot;0.0.0.0&quot;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancel_local</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">bind_address</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Terminates an active local forwarded socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.forward.cancel_local_socket(&#39;/tmp/foo.sock&#39;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancel_local_socket</span>(<span class="ruby-identifier">local_socket_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that a remote forwarded port be cancelled. The remote forwarded</span>
<span class="ruby-comment"># port on the remote host, bound to the given address on the remote host,</span>
<span class="ruby-comment"># will be terminated, but not immediately. This method returns immediately</span>
<span class="ruby-comment"># after queueing the request to be sent to the server. If for some reason</span>
<span class="ruby-comment"># the port cannot be cancelled, an exception will be raised (asynchronously).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If you want to know when the connection has been cancelled, it will no</span>
<span class="ruby-comment"># longer be present in the #active_remotes list. If you want to block until</span>
<span class="ruby-comment"># the port is no longer active, you could do something like this:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.forward.cancel_remote(1234, &quot;0.0.0.0&quot;)</span>
<span class="ruby-comment">#   ssh.loop { ssh.forward.active_remotes.include?([1234, &quot;0.0.0.0&quot;]) }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cancel_remote</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">host</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Starts listening for connections on the local host, and forwards them</span>
<span class="ruby-comment"># to the specified remote host/port via the SSH connection. This method</span>
<span class="ruby-comment"># accepts either three or four arguments. When four arguments are given,</span>
<span class="ruby-comment"># they are:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * the local address to bind to</span>
<span class="ruby-comment"># * the local port to listen on</span>
<span class="ruby-comment"># * the remote host to forward connections to</span>
<span class="ruby-comment"># * the port on the remote host to connect to</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If three arguments are given, it is as if the local bind address is</span>
<span class="ruby-comment"># &quot;127.0.0.1&quot;, and the rest are applied as above.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># To request an ephemeral port on the remote server, provide 0 (zero) for</span>
<span class="ruby-comment"># the port number. In all cases, this method will return the port that</span>
<span class="ruby-comment"># has been assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.forward.local(1234, &quot;www.capify.org&quot;, 80)</span>
<span class="ruby-comment">#   assigned_port = ssh.forward.local(&quot;0.0.0.0&quot;, 0, &quot;www.capify.org&quot;, 80)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Starts listening for connections on the local host, and forwards them</span>
<span class="ruby-comment"># to the specified remote socket via the SSH connection. This will</span>
<span class="ruby-comment"># (re)create the local socket file. The remote server needs to have the</span>
<span class="ruby-comment"># socket file already available.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   ssh.forward.local_socket(&#39;/tmp/local.sock&#39;, &#39;/tmp/remote.sock&#39;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">local_socket</span>(<span class="ruby-identifier">local_socket_path</span>, <span class="ruby-identifier">remote_socket_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that all connections on the given remote-port be forwarded via</span>
<span class="ruby-comment"># the local host to the given port/host. The last argument describes the</span>
<span class="ruby-comment"># bind address on the remote host, and defaults to 127.0.0.1.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This method will return immediately, but the port will not actually be</span>
<span class="ruby-comment"># forwarded immediately. If the remote server is not able to begin the</span>
<span class="ruby-comment"># listener for this request, an exception will be raised asynchronously.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># To request an ephemeral port on the remote server, provide 0 (zero) for</span>
<span class="ruby-comment"># the port number. The assigned port will show up in the # #active_remotes</span>
<span class="ruby-comment"># list.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># remote_host is interpreted by the server per RFC 4254, which has these</span>
<span class="ruby-comment"># special values:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - &quot;&quot; means that connections are to be accepted on all protocol</span>
<span class="ruby-comment">#   families supported by the SSH implementation.</span>
<span class="ruby-comment"># - &quot;0.0.0.0&quot; means to listen on all IPv4 addresses.</span>
<span class="ruby-comment"># - &quot;::&quot; means to listen on all IPv6 addresses.</span>
<span class="ruby-comment"># - &quot;localhost&quot; means to listen on all protocol families supported by</span>
<span class="ruby-comment">#   the SSH implementation on loopback addresses only ([RFC3330] and</span>
<span class="ruby-comment">#   [RFC3513]).</span>
<span class="ruby-comment"># - &quot;127.0.0.1&quot; and &quot;::1&quot; indicate listening on the loopback</span>
<span class="ruby-comment">#   interfaces for IPv4 and IPv6, respectively.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># You may pass a block that will be called when the the port forward</span>
<span class="ruby-comment"># request receives a response.  This block will be passed the remote_port</span>
<span class="ruby-comment"># that was actually bound to, or nil if the binding failed.  If the block</span>
<span class="ruby-comment"># returns :no_exception, the &quot;failed binding&quot; exception will not be thrown.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If you want to block until the port is active, you could do something</span>
<span class="ruby-comment"># like this:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   got_remote_port = nil</span>
<span class="ruby-comment">#   remote(port, host, remote_port, remote_host) do |actual_remote_port|</span>
<span class="ruby-comment">#     got_remote_port = actual_remote_port || :error</span>
<span class="ruby-comment">#     :no_exception # will yield the exception on my own thread</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   session.loop { !got_remote_port }</span>
<span class="ruby-comment">#   if got_remote_port == :error</span>
<span class="ruby-comment">#     raise Net::SSH::Exception, &quot;remote forwarding request failed&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">remote_port</span>, <span class="ruby-identifier">remote_host</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests that all connections on the given remote-port be forwarded via</span>
<span class="ruby-comment"># the local host to the given port/host. The last argument describes the</span>
<span class="ruby-comment"># bind address on the remote host, and defaults to 127.0.0.1.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This method will return immediately, but the port will not actually be</span>
<span class="ruby-comment"># forwarded immediately. If the remote server is not able to begin the</span>
<span class="ruby-comment"># listener for this request, an exception will be raised asynchronously.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># To request an ephemeral port on the remote server, provide 0 (zero) for</span>
<span class="ruby-comment"># the port number. The assigned port will show up in the # #active_remotes</span>
<span class="ruby-comment"># list.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># remote_host is interpreted by the server per RFC 4254, which has these</span>
<span class="ruby-comment"># special values:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - &quot;&quot; means that connections are to be accepted on all protocol</span>
<span class="ruby-comment">#   families supported by the SSH implementation.</span>
<span class="ruby-comment"># - &quot;0.0.0.0&quot; means to listen on all IPv4 addresses.</span>
<span class="ruby-comment"># - &quot;::&quot; means to listen on all IPv6 addresses.</span>
<span class="ruby-comment"># - &quot;localhost&quot; means to listen on all protocol families supported by</span>
<span class="ruby-comment">#   the SSH implementation on loopback addresses only ([RFC3330] and</span>
<span class="ruby-comment">#   [RFC3513]).</span>
<span class="ruby-comment"># - &quot;127.0.0.1&quot; and &quot;::1&quot; indicate listening on the loopback</span>
<span class="ruby-comment">#   interfaces for IPv4 and IPv6, respectively.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># You may pass a block that will be called when the the port forward</span>
<span class="ruby-comment"># request receives a response.  This block will be passed the remote_port</span>
<span class="ruby-comment"># that was actually bound to, or nil if the binding failed.  If the block</span>
<span class="ruby-comment"># returns :no_exception, the &quot;failed binding&quot; exception will not be thrown.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If you want to block until the port is active, you could do something</span>
<span class="ruby-comment"># like this:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   got_remote_port = nil</span>
<span class="ruby-comment">#   remote(port, host, remote_port, remote_host) do |actual_remote_port|</span>
<span class="ruby-comment">#     got_remote_port = actual_remote_port || :error</span>
<span class="ruby-comment">#     :no_exception # will yield the exception on my own thread</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#   session.loop { !got_remote_port }</span>
<span class="ruby-comment">#   if got_remote_port == :error</span>
<span class="ruby-comment">#     raise Net::SSH::Exception, &quot;remote forwarding request failed&quot;</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># an alias, for token backwards compatibility with the 1.x API</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_to</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">host</span>, <span class="ruby-identifier">remote_port</span>, <span class="ruby-identifier">remote_host</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying connection service instance that the port-forwarding</span>
<span class="ruby-comment"># services employ.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">session</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># The callback used when an auth-agent channel is requested by the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#407</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">auth_agent_channel</span>(<span class="ruby-identifier">session</span>, <span class="ruby-identifier">channel</span>, <span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The callback used when a new &quot;forwarded-tcpip&quot; channel is requested</span>
<span class="ruby-comment"># by the server.  This will open a new socket to the host/port specified</span>
<span class="ruby-comment"># when the forwarded connection was first requested.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_tcpip</span>(<span class="ruby-identifier">session</span>, <span class="ruby-identifier">channel</span>, <span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Perform setup operations that are common to all forwarded channels.</span>
<span class="ruby-comment"># +client+ is a socket, +channel+ is the channel that was just created,</span>
<span class="ruby-comment"># and +type+ is an arbitrary string describing the type of the channel.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_client</span>(<span class="ruby-identifier">client</span>, <span class="ruby-identifier">channel</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># not a real socket, so use a simpler behaviour</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_simple_client</span>(<span class="ruby-identifier">client</span>, <span class="ruby-identifier">channel</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A simple class for representing a requested remote forwarded port. # # source://net-ssh//lib/net/ssh/service/forward.rb#20 class Net::SSH::Service::Forward::Remote &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute host</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of host</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute host</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute host to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute port</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of port</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">port</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute port</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute port to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">port=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/service/forward.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This exception is raised when the remote host has disconnected/ # timeouted unexpectedly. # # source://net-ssh//lib/net/ssh/errors.rb#20 class Net::SSH::Timeout &lt; ::Net::SSH::Disconnect; end</p>

<p># source://net-ssh//lib/net/ssh/transport/ctr.rb#4 module Net::SSH::Transport; end</p>

<p># Implements the aes128-gcm@openssh cipher # # source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#6 class Net::SSH::Transport::AES128_GCM</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">GCMCipher</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">encrypt:</span>, <span class="ruby-value">key:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algo_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cipher</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incr_nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iv_len</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mac_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce=</span>(<span class="ruby-identifier">iv_s</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_and_mac</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">mac</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_length</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_cipher_mac</span>(<span class="ruby-identifier">payload</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># --- RFC 5647 ---</span>
  <span class="ruby-comment"># K_LEN       AES key length                   16 octets</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implicit HMAC, do need to do anything # # source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#10 class Net::SSH::Transport::AES128_GCM::ImplicitHMac &lt; ::Net::SSH::Transport::HMAC::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aead</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes128_gcm.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements the aes256-gcm@openssh cipher # # source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#6 class Net::SSH::Transport::AES256_GCM</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">GCMCipher</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">encrypt:</span>, <span class="ruby-value">key:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algo_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cipher</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incr_nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iv_len</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mac_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonce=</span>(<span class="ruby-identifier">iv_s</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_and_mac</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">mac</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_length</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_cipher_mac</span>(<span class="ruby-identifier">payload</span>, <span class="ruby-identifier">_sequence_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># --- RFC 5647 ---</span>
  <span class="ruby-comment"># K_LEN       AES key length                   32 octets</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implicit HMAC, do need to do anything # # source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#10 class Net::SSH::Transport::AES256_GCM::ImplicitHMac &lt; ::Net::SSH::Transport::HMAC::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aead</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/aes256_gcm.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements the higher-level logic behind an SSH key-exchange. It handles # both the initial exchange, as well as subsequent re-exchanges (as needed). # It also encapsulates the negotiation of the algorithms, and provides a # single point of access to the negotiated algorithms. # # You will never instantiate or reference this directly. It is used # internally by the transport layer. # # source://net-ssh//lib/net/ssh/transport/algorithms.rb#22 class Net::SSH::Transport::Algorithms</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Instantiates a new Algorithms object, and prepares the hash of preferred</span>
<span class="ruby-comment"># algorithms based on the options parameter and the ALGORITHMS constant.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Algorithms] a new instance of Algorithms</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">session</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A convenience method for accessing the list of preferred types for a</span>
<span class="ruby-comment"># specific algorithm (see #algorithms).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called by the transport layer when a KEXINIT packet is received, indicating</span>
<span class="ruby-comment"># that the server wants to exchange keys. This can be spontaneous, or it</span>
<span class="ruby-comment"># can be in response to a client-initiated rekey request (see #rekey!). Either</span>
<span class="ruby-comment"># way, this will block until the key exchange completes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_kexinit</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The hash of algorithms preferred by the client, which will be told to</span>
<span class="ruby-comment"># the server during algorithm negotiation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algorithms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if no exchange is pending, and otherwise returns true or</span>
<span class="ruby-comment"># false depending on whether the given packet is of a type that is allowed</span>
<span class="ruby-comment"># during a key exchange.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow?</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of compression to use to compress packets being sent by the client.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compression_client</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of compression to use to decompress packets arriving from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compression_server</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of the cipher to use to encrypt packets sent from the client to</span>
<span class="ruby-comment"># the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encryption_client</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of the cipher to use to decrypt packets arriving from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encryption_server</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of HMAC to use to sign packets sent by the client.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hmac_client</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of HMAC to use to validate packets arriving from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hmac_server</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The type of host key that will be used for this session.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host_key_format</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the algorithms have been negotiated at all.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialized?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The kex algorithm to use settled on between the client and server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kex</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The language that will be used in messages sent by the client.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">language_client</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The language that will be used in messages sent from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">language_server</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The hash of options used to initialize this object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns +true+ if a key-exchange is pending. This will be true from the</span>
<span class="ruby-comment"># moment either the client or server requests the key exchange, until the</span>
<span class="ruby-comment"># exchange completes. While an exchange is pending, only a limited number</span>
<span class="ruby-comment"># of packets are allowed, so event processing essentially stops during this</span>
<span class="ruby-comment"># period.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Request a rekey operation. This will return immediately, and does not</span>
<span class="ruby-comment"># actually perform the rekey operation. It does cause the session to change</span>
<span class="ruby-comment"># state, however--until the key exchange finishes, no new packets will be</span>
<span class="ruby-comment"># processed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rekey!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying transport layer session that supports this object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">session</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The session-id for this session, as decided during the initial key exchange.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">session_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Start the algorithm negotation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Given the #algorithms map of preferred algorithm types, this constructs</span>
<span class="ruby-comment"># a KEXINIT packet to send to the server. It does not actually send it,</span>
<span class="ruby-comment"># it simply builds the packet and returns it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#372</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_client_algorithm_packet</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Composes the list of algorithms by taking supported algorithms and matching with supplied options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compose_algorithm_list</span>(<span class="ruby-identifier">supported</span>, <span class="ruby-identifier">option</span>, <span class="ruby-identifier">append_all_supported_algorithms</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Instantiates one of the Transport::Kex classes (based on the negotiated</span>
<span class="ruby-comment"># kex algorithm), and uses it to exchange keys. Then, the ciphers and</span>
<span class="ruby-comment"># HMACs are initialized and fed to the transport layer, to be used in</span>
<span class="ruby-comment"># further communication with the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#446</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exchange_keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Considers the sizes of the keys and block-sizes for the selected ciphers,</span>
<span class="ruby-comment"># and the lengths of the hmacs, and returns the largest as the byte requirement</span>
<span class="ruby-comment"># for the key-exchange algorithm.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#430</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kex_byte_requirement</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Negotiates a single algorithm based on the preferences reported by the</span>
<span class="ruby-comment"># server and those set by the client. This is called by</span>
<span class="ruby-comment"># #negotiate_algorithms.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negotiate</span>(<span class="ruby-identifier">algorithm</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Given the parsed server KEX packet, and the client&#39;s preferred algorithm</span>
<span class="ruby-comment"># lists in #algorithms, determine which preferred algorithms each has</span>
<span class="ruby-comment"># in common and set those as the selected algorithms. If, for any algorithm,</span>
<span class="ruby-comment"># no type can be settled on, an exception is raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#391</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negotiate_algorithms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Given the SSH name for some compression algorithm, return a normalized</span>
<span class="ruby-comment"># name as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">normalize_compression_name</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Parses a KEXINIT packet from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_server_algorithm_packet</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Prepares the list of preferred algorithms, based on the options hash</span>
<span class="ruby-comment"># that was given when the object was constructed, and the ALGORITHMS</span>
<span class="ruby-comment"># constant. Also, when determining the host_key type to use, the known</span>
<span class="ruby-comment"># hosts files are examined to see if the host has ever sent a host_key</span>
<span class="ruby-comment"># before, and if so, that key type is used as the preferred type for</span>
<span class="ruby-comment"># communicating with this server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_preferred_algorithms!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># After both client and server have sent their KEXINIT packets, this</span>
<span class="ruby-comment"># will do the algorithm negotiation and key exchange. Once both finish,</span>
<span class="ruby-comment"># the object leaves the pending state and the method returns.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proceed!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends a KEXINIT packet to the server. If a server KEXINIT has already</span>
<span class="ruby-comment"># been received, this will then invoke #proceed! to proceed with the key</span>
<span class="ruby-comment"># exchange, otherwise it returns immediately (but sets the object to the</span>
<span class="ruby-comment"># pending state).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_kexinit</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns true if the given packet can be processed during a key-exchange.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/algorithms.rb#150</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_packet?</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Define all algorithms, with the deprecated, supported by Net::SSH. # # source://net-ssh//lib/net/ssh/transport/algorithms.rb#78 Net::SSH::Transport::Algorithms::ALGORITHMS = T.let(T.unsafe(nil), Hash)</p>

<p># Define the default algorithms, in order of preference, supported by Net::SSH. # # source://net-ssh//lib/net/ssh/transport/algorithms.rb#27 Net::SSH::Transport::Algorithms::DEFAULT_ALGORITHMS = T.let(T.unsafe(nil), Hash)</p>

<p># Pure-Ruby implementation of Stateful Decryption Counter(SDCTR) Mode # for Block Ciphers. See RFC4344 for detail. # # source://net-ssh//lib/net/ssh/transport/ctr.rb#32 module Net::SSH::Transport::CTR</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#33</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended</span>(<span class="ruby-identifier">orig</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Loads chacha20 poly1305 support which requires optinal dependency rbnacl # # source://net-ssh//lib/net/ssh/transport/chacha20_poly1305_cipher_loader.rb#5 module Net::SSH::Transport::ChaCha20Poly1305CipherLoader; end</p>

<p># source://net-ssh//lib/net/ssh/transport/chacha20_poly1305_cipher_loader.rb#11 Net::SSH::Transport::ChaCha20Poly1305CipherLoader::ERROR = T.let(T.unsafe(nil), LoadError)</p>

<p># source://net-ssh//lib/net/ssh/transport/chacha20_poly1305_cipher_loader.rb#12 Net::SSH::Transport::ChaCha20Poly1305CipherLoader::LOADED = T.let(T.unsafe(nil), FalseClass)</p>

<p># Implements a factory of OpenSSL cipher algorithms. # # source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#14 class Net::SSH::Transport::CipherFactory</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Retrieves a new instance of the named algorithm. The new instance</span>
  <span class="ruby-comment"># will be initialized using an iv and key generated from the given</span>
  <span class="ruby-comment"># iv, key, shared, hash and digester values. Additionally, the</span>
  <span class="ruby-comment"># cipher will be put into encryption or decryption mode, based on the</span>
  <span class="ruby-comment"># value of the +encrypt+ parameter.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns a two-element array containing the [ key-length,</span>
  <span class="ruby-comment"># block-size ] for the named cipher algorithm. If the cipher</span>
  <span class="ruby-comment"># algorithm is unknown, or is &quot;none&quot;, 0 is returned for both elements</span>
  <span class="ruby-comment"># of the tuple.</span>
  <span class="ruby-comment"># if :iv_len option is supplied the third return value will be ivlen</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#101</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_lengths</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns true if the underlying OpenSSL library supports the given cipher,</span>
  <span class="ruby-comment"># and false otherwise.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#36 Net::SSH::Transport::CipherFactory::SSH_TO_CLASS = T.let(T.unsafe(nil), Hash)</p>

<p># Maps the SSH name of a cipher to it’s corresponding OpenSSL name # # source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#16 Net::SSH::Transport::CipherFactory::SSH_TO_OSSL = T.let(T.unsafe(nil), Hash)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#4 module Net::SSH::Transport::Constants; end</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#12 Net::SSH::Transport::Constants::DEBUG = T.let(T.unsafe(nil), Integer)</p>

<p># – # Transport layer generic messages # ++ # # source://net-ssh//lib/net/ssh/transport/constants.rb#9 Net::SSH::Transport::Constants::DISCONNECT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#10 Net::SSH::Transport::Constants::IGNORE = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#33 Net::SSH::Transport::Constants::KEXDH_GEX_GROUP = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#34 Net::SSH::Transport::Constants::KEXDH_GEX_INIT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#35 Net::SSH::Transport::Constants::KEXDH_GEX_REPLY = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#36 Net::SSH::Transport::Constants::KEXDH_GEX_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># – # Key exchange method specific messages # ++ # # source://net-ssh//lib/net/ssh/transport/constants.rb#27 Net::SSH::Transport::Constants::KEXDH_INIT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#28 Net::SSH::Transport::Constants::KEXDH_REPLY = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#30 Net::SSH::Transport::Constants::KEXECDH_INIT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#31 Net::SSH::Transport::Constants::KEXECDH_REPLY = T.let(T.unsafe(nil), Integer)</p>

<p># – # Algorithm negotiation messages # ++ # # source://net-ssh//lib/net/ssh/transport/constants.rb#20 Net::SSH::Transport::Constants::KEXINIT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#21 Net::SSH::Transport::Constants::NEWKEYS = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#14 Net::SSH::Transport::Constants::SERVICE_ACCEPT = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#13 Net::SSH::Transport::Constants::SERVICE_REQUEST = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/constants.rb#11 Net::SSH::Transport::Constants::UNIMPLEMENTED = T.let(T.unsafe(nil), Integer)</p>

<p># Extension module for aes(128|256)gcm ciphers # # source://net-ssh//lib/net/ssh/transport/gcm_cipher.rb#7 module Net::SSH::Transport::GCMCipher</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/gcm_cipher.rb#9</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended</span>(<span class="ruby-identifier">orig</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implements a simple factory interface for fetching hmac implementations, or # for finding the key lengths for hmac implementations.s # # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#7 module Net::SSH::Transport::HMAC</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Retrieves a new hmac instance of the given SSH type (+name+). If +key+ is</span>
  <span class="ruby-comment"># given, the new instance will be initialized with that key.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">key</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">parameters</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Retrieves the key length for the hmac of the given SSH type (+name+).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac.rb#43</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The base class of all OpenSSL-based HMAC algorithm wrappers. # # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#9 class Net::SSH::Transport::HMAC::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># @return [Abstract] a new instance of Abstract</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">key</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aead</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compute the HMAC digest for the given data string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest_class</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">etm</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The key in use for this instance.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the key to the given value, truncating it so that it is the correct</span>
<span class="ruby-comment"># length.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mac_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aead</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#59</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest_class</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">etm</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#35</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mac_length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The mapping of SSH hmac algorithms to their implementations # # source://net-ssh//lib/net/ssh/transport/hmac.rb#19 Net::SSH::Transport::HMAC::MAP = T.let(T.unsafe(nil), Hash)</p>

<p># The MD5 HMAC algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/md5.rb#5 class Net::SSH::Transport::HMAC::MD5 &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The MD5-96 HMAC algorithm. This returns only the first 12 bytes of # the digest. # # source://net-ssh//lib/net/ssh/transport/hmac/md5_96.rb#6 class Net::SSH::Transport::HMAC::MD5_96 &lt; ::Net::SSH::Transport::HMAC::MD5; end</p>

<p># The “none” algorithm. This has a key and mac length of 0. # # source://net-ssh//lib/net/ssh/transport/hmac/none.rb#5 class Net::SSH::Transport::HMAC::None &lt; ::Net::SSH::Transport::HMAC::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/hmac/none.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The RIPEMD-160 HMAC algorithm. This has a mac and key length of 20, and # uses the RIPEMD-160 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/ripemd160.rb#6 class Net::SSH::Transport::HMAC::RIPEMD160 &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The SHA1 HMAC algorithm. This has a mac and key length of 20, and # uses the SHA1 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/sha1.rb#6 class Net::SSH::Transport::HMAC::SHA1 &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The SHA1-96 HMAC algorithm. This returns only the first 12 bytes of # the digest. # # source://net-ssh//lib/net/ssh/transport/hmac/sha1_96.rb#6 class Net::SSH::Transport::HMAC::SHA1_96 &lt; ::Net::SSH::Transport::HMAC::SHA1; end</p>

<p># The SHA-256 HMAC algorithm. This has a mac and key length of 32, and # uses the SHA-256 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_256.rb#6 class Net::SSH::Transport::HMAC::SHA2_256 &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The SHA256-96 HMAC algorithm. This returns only the first 12 bytes of # the digest. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_256_96.rb#6 class Net::SSH::Transport::HMAC::SHA2_256_96 &lt; ::Net::SSH::Transport::HMAC::SHA2_256; end</p>

<p># The SHA-256 Encrypt-Then-Mac HMAC algorithm. This has a mac and # key length of 32, and uses the SHA-256 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_256_etm.rb#6 class Net::SSH::Transport::HMAC::SHA2_256_Etm &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The SHA-512 HMAC algorithm. This has a mac and key length of 64, and # uses the SHA-512 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_512.rb#6 class Net::SSH::Transport::HMAC::SHA2_512 &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># The SHA2-512-96 HMAC algorithm. This returns only the first 12 bytes of # the digest. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_512_96.rb#6 class Net::SSH::Transport::HMAC::SHA2_512_96 &lt; ::Net::SSH::Transport::HMAC::SHA2_512; end</p>

<p># The SHA-512 Encrypt-Then-Mac HMAC algorithm. This has a mac and # key length of 64, and uses the SHA-512 digest algorithm. # # source://net-ssh//lib/net/ssh/transport/hmac/sha2_512_etm.rb#6 class Net::SSH::Transport::HMAC::SHA2_512_Etm &lt; ::Net::SSH::Transport::HMAC::Abstract; end</p>

<p># A cipher that does nothing but pass the data through, unchanged. This # keeps things in the code nice and clean when a cipher has not yet been # determined (i.e., during key exchange). # # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#7 class Net::SSH::Transport::IdentityCipher</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># A default block size of 8 is required by the SSH2 protocol.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Does nothing. Returns self.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#29</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decrypt</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Does nothing. Returns self.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encrypt</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the empty string.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#39</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">final</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#58</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Does nothing. Returns nil.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#49</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iv=</span>(<span class="ruby-identifier">v</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns an arbitrary integer.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iv_len</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_length</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># The name of this cipher, which is &quot;identity&quot;.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Does nothing. Returns self.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Passes its single argument through unchanged.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#10 module Net::SSH::Transport::Kex; end</p>

<p># Abstract class that implement Diffie-Hellman Key Exchange # See <a href="https://tools.ietf.org/html/rfc4253#page-21">tools.ietf.org/html/rfc4253#page-21</a> # # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#13 class Net::SSH::Transport::Kex::Abstract</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Create a new instance of the Diffie-Hellman Key Exchange algorithm.</span>
<span class="ruby-comment"># The Diffie-Hellman (DH) key exchange provides a shared secret that</span>
<span class="ruby-comment"># cannot be determined by either party alone.  The key exchange is</span>
<span class="ruby-comment"># combined with a signature with the host key to provide host</span>
<span class="ruby-comment"># authentication.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Abstract] a new instance of Abstract</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">algorithms</span>, <span class="ruby-identifier">connection</span>, <span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute algorithms.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algorithms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute connection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">connection</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">data</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute dh.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dh</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Perform the key-exchange for the given session, with the given</span>
<span class="ruby-comment"># data. This method will return a hash consisting of the</span>
<span class="ruby-comment"># following keys:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># * :session_id</span>
<span class="ruby-comment"># * :server_key</span>
<span class="ruby-comment"># * :shared_secret</span>
<span class="ruby-comment"># * :hashing_algorithm</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The caller is expected to be able to understand how to use these</span>
<span class="ruby-comment"># deliverables.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exchange_keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Send the NEWKEYS message, and expect the NEWKEYS message in</span>
<span class="ruby-comment"># reply.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">confirm_newkeys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_key_fingerprint</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching?</span>(<span class="ruby-identifier">key_ssh_type</span>, <span class="ruby-identifier">host_key_alg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Verify that the given key is of the expected type, and that it</span>
<span class="ruby-comment"># really is the key for the session&#39;s host. Raise Net::SSH::Exception</span>
<span class="ruby-comment"># if it is not.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_server_key</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Verify the signature that was received. Raise Net::SSH::Exception</span>
<span class="ruby-comment"># if the signature could not be verified. Otherwise, return the new</span>
<span class="ruby-comment"># session-id.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_signature</span>(<span class="ruby-identifier">result</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Implement key-exchange algorithm from Elliptic Curve Algorithm Integration # in the Secure Shell Transport Layer (RFC 5656) # # source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#9 class Net::SSH::Transport::Kex::Abstract5656 &lt; ::Net::SSH::Transport::Kex::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">curve_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ecdh</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_signature_buffer</span>(<span class="ruby-identifier">result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_message_types</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_kexinit</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Loads Curve25519Sha256 support which requires optinal dependencies # # source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#6 module Net::SSH::Transport::Kex::Curve25519Sha256Loader</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependenciesRequiredForX25519</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @raise [NotImplementedError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raiseUnlessLoaded</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#12 Net::SSH::Transport::Kex::Curve25519Sha256Loader::ERROR = T.let(T.unsafe(nil), Gem::LoadError)</p>

<p># source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#13 Net::SSH::Transport::Kex::Curve25519Sha256Loader::LOADED = T.let(T.unsafe(nil), FalseClass)</p>

<p># A key-exchange service implementing the “diffie-hellman-group14-sha1” # key-exchange algorithm. (defined in RFC 4253) # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#9 class Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1 &lt; ::Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1; end</p>

<p># The group constant # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#32 Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::G = T.let(T.unsafe(nil), Integer)</p>

<p># The radix in which P_s represents the value of P # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#29 Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::P_r = T.let(T.unsafe(nil), Integer)</p>

<p># The value of ‘P’, as a string, in hexadecimal # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#11 Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::P_s = T.let(T.unsafe(nil), String)</p>

<p># A key-exchange service implementing the “diffie-hellman-group14-sha256” # key-exchange algorithm. # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha256.rb#6 class Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA256 &lt; ::Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha256.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A key-exchange service implementing the “diffie-hellman-group1-sha1” # key-exchange algorithm. # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#9 class Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1 &lt; ::Net::SSH::Transport::Kex::Abstract</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Build the signature buffer to use when verifying a signature from</span>
<span class="ruby-comment"># the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_signature_buffer</span>(<span class="ruby-identifier">result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Generate a DH key with a private key consisting of the given</span>
<span class="ruby-comment"># number of bytes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the INIT/REPLY constants used by this algorithm.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_message_types</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the DH key parameters for the current connection. [p, q]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Send the KEXDH_INIT message, and expect the KEXDH_REPLY. Return the</span>
<span class="ruby-comment"># resulting buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Parse the buffer from a KEXDH_REPLY message, returning a hash of</span>
<span class="ruby-comment"># the extracted values.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_kexinit</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The group constant # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#24 Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::G = T.let(T.unsafe(nil), Integer)</p>

<p># The radix in which P_s represents the value of P # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#21 Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::P_r = T.let(T.unsafe(nil), Integer)</p>

<p># The value of ‘P’, as a string, in hexadecimal # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#11 Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::P_s = T.let(T.unsafe(nil), String)</p>

<p># A key-exchange service implementing the # “diffie-hellman-group-exchange-sha1” key-exchange algorithm. # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#8 class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1 &lt; ::Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># Build the signature buffer to use when verifying a signature from</span>
<span class="ruby-comment"># the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_signature_buffer</span>(<span class="ruby-identifier">result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compute the number of bits needed for the given number of bytes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_need_bits</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the INIT/REPLY constants used by this algorithm.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_message_types</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the DH key parameters for the given session.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_parameters</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#10 Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1::MAXIMUM_BITS = T.let(T.unsafe(nil), Integer)</p>

<p># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#9 Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1::MINIMUM_BITS = T.let(T.unsafe(nil), Integer)</p>

<p># A key-exchange service implementing the # “diffie-hellman-group-exchange-sha256” key-exchange algorithm. # # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha256.rb#6 class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256 &lt; ::Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha256.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A key-exchange service implementing the “ecdh-sha2-nistp256” # key-exchange algorithm. (defined in RFC 5656) # # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#9 class Net::SSH::Transport::Kex::EcdhSHA2NistP256 &lt; ::Net::SSH::Transport::Kex::Abstract5656</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">curve_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># compute shared secret from server&#39;s public key and client&#39;s private key</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_shared_secret</span>(<span class="ruby-identifier">server_ecdh_pubkey</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># string   Q_C, client&#39;s ephemeral public key octet string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ecdh_public_key_bytes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_key</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A key-exchange service implementing the “ecdh-sha2-nistp256” # key-exchange algorithm. (defined in RFC 5656) # # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#9 class Net::SSH::Transport::Kex::EcdhSHA2NistP384 &lt; ::Net::SSH::Transport::Kex::EcdhSHA2NistP256</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">curve_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A key-exchange service implementing the “ecdh-sha2-nistp521” # key-exchange algorithm. (defined in RFC 5656) # # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#9 class Net::SSH::Transport::Kex::EcdhSHA2NistP521 &lt; ::Net::SSH::Transport::Kex::EcdhSHA2NistP256</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">curve_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Maps the supported key-exchange algorithms as named by the SSH protocol # to their corresponding implementors. # # source://net-ssh//lib/net/ssh/transport/kex.rb#15 Net::SSH::Transport::Kex::MAP = T.let(T.unsafe(nil), Hash)</p>

<p># source://net-ssh//lib/net/ssh/transport/key_expander.rb#4 module Net::SSH::Transport::KeyExpander</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Generate a key value in accordance with the SSH2 specification.</span>
  <span class="ruby-comment"># (RFC4253 7.2. &quot;Output from Key Exchange&quot;)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/key_expander.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_key</span>(<span class="ruby-identifier">bytes</span>, <span class="ruby-identifier">start</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/ctr.rb#6 class Net::SSH::Transport::OpenSSLAESCTR &lt; ::SimpleDelegator</p>

<pre class="ruby"><span class="ruby-comment"># @return [OpenSSLAESCTR] a new instance of OpenSSLAESCTR</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">original</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iv=</span>(<span class="ruby-identifier">iv_s</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/ctr.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># we add those mehtods to OpenSSL::Chipher instances # # source://net-ssh//lib/net/ssh/transport/openssl_cipher_extensions.rb#3 module Net::SSH::Transport::OpenSSLCipherExtensions</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl_cipher_extensions.rb#4</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_mac?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A module that builds additional functionality onto the Net::SSH::BufferedIo # module. It adds SSH encryption, compression, and packet validation, as # per the SSH2 protocol. It also adds an abstraction for polling packets, # to allow for both blocking and non-blocking reads. # # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#15 module Net::SSH::Transport::PacketStream</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">BufferedIo</span>

<span class="ruby-comment"># Returns true if the IO is available for reading, and false otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">available_for_read?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Performs any pending cleanup necessary on the IO and its associated</span>
<span class="ruby-comment"># state objects. (See State#cleanup).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cleanup</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The client state object, which encapsulates the algorithms used to build</span>
<span class="ruby-comment"># packets to send to the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">client</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the client (local) end of the socket, as reported by the</span>
<span class="ruby-comment"># socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">client_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues a packet to be sent, but does not immediately send the packet.</span>
<span class="ruby-comment"># The given payload is pre-processed according to the algorithms specified</span>
<span class="ruby-comment"># in the client state (compression, cipher, and hmac).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue_packet</span>(<span class="ruby-identifier">payload</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The map of &quot;hints&quot; that can be used to modify the behavior of the packet</span>
<span class="ruby-comment"># stream. For instance, when authentication succeeds, an &quot;authenticated&quot;</span>
<span class="ruby-comment"># hint is set, which is used to determine whether or not to compress the</span>
<span class="ruby-comment"># data when using the &quot;delayed&quot; compression algorithm.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hints</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the IO object requires a rekey operation (as indicated by either its</span>
<span class="ruby-comment"># client or server state objects, see State#needs_rekey?), this will</span>
<span class="ruby-comment"># yield. Otherwise, this does nothing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_needs_rekey?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the next full packet. If the mode parameter is :nonblock (the</span>
<span class="ruby-comment"># default), then this will return immediately, whether a packet is</span>
<span class="ruby-comment"># available or not, and will return nil if there is no packet ready to be</span>
<span class="ruby-comment"># returned. If the mode parameter is :block, then this method will block</span>
<span class="ruby-comment"># until a packet is available or timeout seconds have passed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_packet</span>(<span class="ruby-identifier">mode</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The IP address of the peer (remote) end of the socket, as reported by</span>
<span class="ruby-comment"># the socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">peer_ip</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues a packet to be sent, and blocks until the entire packet is</span>
<span class="ruby-comment"># sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_packet</span>(<span class="ruby-identifier">payload</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The server state object, which encapsulates the algorithms used to interpret</span>
<span class="ruby-comment"># packets coming from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">server</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Called when this module is used to extend an object. It initializes</span>
<span class="ruby-comment"># the states and generally prepares the object for use as a packet stream.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_ssh</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tries to read the next packet. If there is insufficient data to read</span>
<span class="ruby-comment"># an entire packet, this returns immediately, otherwise the packet is</span>
<span class="ruby-comment"># read, post-processed according to the cipher, hmac, and compression</span>
<span class="ruby-comment"># algorithms specified in the server state object, and returned as a</span>
<span class="ruby-comment"># new Packet object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::Exception]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">poll_next_packet</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended</span>(<span class="ruby-identifier">object</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/packet_stream.rb#16 Net::SSH::Transport::PacketStream::PROXY_COMMAND_HOST_IP = T.let(T.unsafe(nil), String)</p>

<p># Negotiates the SSH protocol version and trades information about server # and client. This is never used directly–it is always called by the # transport layer as part of the initialization process of the transport # layer. # # Note that this class also encapsulates the negotiated version, and acts as # the authoritative reference for any queries regarding the version in effect. # # source://net-ssh//lib/net/ssh/transport/server_version.rb#15 class Net::SSH::Transport::ServerVersion</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>

<span class="ruby-comment"># Instantiates a new ServerVersion and immediately (and synchronously)</span>
<span class="ruby-comment"># negotiates the SSH protocol in effect, using the given socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [ServerVersion] a new instance of ServerVersion</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/server_version.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">socket</span>, <span class="ruby-identifier">logger</span>, <span class="ruby-identifier">timeout</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Any header text sent by the server prior to sending the version.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/server_version.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The version string reported by the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/server_version.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Negotiates the SSH protocol to use, via the given socket. If the server</span>
<span class="ruby-comment"># reports an incompatible SSH version (e.g., SSH1), this will raise an</span>
<span class="ruby-comment"># exception.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [Net::SSH::ConnectionTimeout]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/server_version.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negotiate!</span>(<span class="ruby-identifier">socket</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The SSH version string as reported by Net::SSH # # source://net-ssh//lib/net/ssh/transport/server_version.rb#19 Net::SSH::Transport::ServerVersion::PROTO_VERSION = T.let(T.unsafe(nil), String)</p>

<p># The transport layer represents the lowest level of the SSH protocol, and # implements basic message exchanging and protocol initialization. It will # never be instantiated directly (unless you really know what you’re about), # but will instead be created for you automatically when you create a new # SSH session via Net::SSH.start. # # source://net-ssh//lib/net/ssh/transport/session.rb#23 class Net::SSH::Transport::Session</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Loggable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Transport</span><span class="ruby-operator">::</span><span class="ruby-constant">Constants</span>

<span class="ruby-comment"># Instantiates a new transport layer abstraction. This will block until</span>
<span class="ruby-comment"># the initial key exchange completes, leaving you with a ready-to-use</span>
<span class="ruby-comment"># transport session.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Session] a new instance of Session</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The Algorithms instance used to perform key exchanges.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algorithms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Cleans up (see PacketStream#cleanup) and closes the underlying socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the underlying socket has been closed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Configure&#39;s the packet stream&#39;s client state with the given set of</span>
<span class="ruby-comment"># options. This is typically used to define the cipher, compression, and</span>
<span class="ruby-comment"># hmac algorithms to use when sending packets to the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configure_client</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Configure&#39;s the packet stream&#39;s server state with the given set of</span>
<span class="ruby-comment"># options. This is typically used to define the cipher, compression, and</span>
<span class="ruby-comment"># hmac algorithms to use when reading packets from the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configure_server</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enqueues the given message, such that it will be sent at the earliest</span>
<span class="ruby-comment"># opportunity. This does not block, but returns immediately.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enqueue_message</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets a new hint for the packet stream, which the packet stream may use</span>
<span class="ruby-comment"># to change its behavior. (See PacketStream#hints).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#268</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hint</span>(<span class="ruby-identifier">which</span>, <span class="ruby-identifier">value</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The host to connect to, as given to the constructor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the host (and possibly IP address) in a format compatible with</span>
<span class="ruby-comment"># SSH known-host files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host_as_string</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The host-key verifier object used to verify host keys, to ensure that</span>
<span class="ruby-comment"># the connection is not being spoofed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host_key_verifier</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">host_keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Blocks until a new packet is available to be read, and returns that</span>
<span class="ruby-comment"># packet. See #poll_message.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The hash of options that were given to the object at initialization.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a hash of information about the peer (remote) side of the socket,</span>
<span class="ruby-comment"># including :ip, :port, :host, and :canonized (see #host_as_string).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">peer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Tries to read the next packet from the socket. If mode is :nonblock (the</span>
<span class="ruby-comment"># default), this will not block and will return nil if there are no packets</span>
<span class="ruby-comment"># waiting to be read. Otherwise, this will block until a packet is</span>
<span class="ruby-comment"># available. Note that some packet types (DISCONNECT, IGNORE, UNIMPLEMENTED,</span>
<span class="ruby-comment"># DEBUG, and KEXINIT) are handled silently by this method, and will never</span>
<span class="ruby-comment"># be returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If a key-exchange is in process and a disallowed packet type is</span>
<span class="ruby-comment"># received, it will be enqueued and otherwise ignored. When a key-exchange</span>
<span class="ruby-comment"># is not in process, and consume_queue is true, packets will be first</span>
<span class="ruby-comment"># read from the queue before the socket is queried.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">poll_message</span>(<span class="ruby-identifier">mode</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">consume_queue</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The port number to connect to, as given in the options to the constructor.</span>
<span class="ruby-comment"># If no port number was given, this will default to DEFAULT_PORT.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">port</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds the given packet to the packet queue. If the queue is non-empty,</span>
<span class="ruby-comment"># #poll_message will return packets from the queue in the order they</span>
<span class="ruby-comment"># were received.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-identifier">packet</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># this method is primarily for use in tests</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">queue</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Requests a rekey operation, and blocks until the operation completes.</span>
<span class="ruby-comment"># If a rekey is already pending, this returns immediately, having no</span>
<span class="ruby-comment"># effect.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rekey!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns immediately if a rekey is already in process. Otherwise, if a</span>
<span class="ruby-comment"># rekey is needed (as indicated by the socket, see PacketStream#if_needs_rekey?)</span>
<span class="ruby-comment"># one is performed, causing this method to block until it completes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rekey_as_needed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sends the given message via the packet stream, blocking until the</span>
<span class="ruby-comment"># entire message has been sent.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_message</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The ServerVersion instance that encapsulates the negotiated protocol</span>
<span class="ruby-comment"># version.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">server_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a new service_request packet for the given service name, ready</span>
<span class="ruby-comment"># for sending to the server.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">service_request</span>(<span class="ruby-identifier">service</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Performs a &quot;hard&quot; shutdown of the connection. In general, this should</span>
<span class="ruby-comment"># never be done, but it might be necessary (in a rescue clause, for instance,</span>
<span class="ruby-comment"># when the connection needs to close but you don&#39;t know the status of the</span>
<span class="ruby-comment"># underlying protocol&#39;s state).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shutdown!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The underlying socket object being used to communicate with the remote</span>
<span class="ruby-comment"># host.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">socket</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Waits (blocks) until the given block returns true. If no block is given,</span>
<span class="ruby-comment"># this just waits long enough to see if there are any pending packets. Any</span>
<span class="ruby-comment"># packets read are enqueued (see #push).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Instantiates a new host-key verification class, based on the value of</span>
<span class="ruby-comment"># the parameter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Usually, the argument is a symbol like `:never` which corresponds to</span>
<span class="ruby-comment"># a verifier, like `::Net::SSH::Verifiers::Never`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - :never (very insecure)</span>
<span class="ruby-comment"># - :accept_new_or_local_tunnel (insecure)</span>
<span class="ruby-comment"># - :accept_new (insecure)</span>
<span class="ruby-comment"># - :always (secure)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the argument happens to respond to :verify and :verify_signature,</span>
<span class="ruby-comment"># it is returned directly. Otherwise, an exception is raised.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Values false, true, and :very were deprecated in</span>
<span class="ruby-comment"># [#595](https://github.com/net-ssh/net-ssh/pull/595)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_host_key_verifier</span>(<span class="ruby-identifier">verifier</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Compatibility verifier which allows users to keep using # custom verifier code without adding new :verify_signature # method. # # source://net-ssh//lib/net/ssh/transport/session.rb#282 class Net::SSH::Transport::Session::CompatibleVerifier</p>

<pre class="ruby"><span class="ruby-comment"># @return [CompatibleVerifier] a new instance of CompatibleVerifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">verifier</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/session.rb#291</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_signature</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The standard port for the SSH protocol. # # source://net-ssh//lib/net/ssh/transport/session.rb#28 Net::SSH::Transport::Session::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)</p>

<p># Encapsulates state information about one end of an SSH connection. Such # state includes the packet sequence number, the algorithms in use, how # many packets and blocks have been processed since the last reset, and so # forth. This class will never be instantiated directly, but is used as # part of the internal state of the PacketStream module. # # source://net-ssh//lib/net/ssh/transport/state.rb#13 class Net::SSH::Transport::State</p>

<pre class="ruby"><span class="ruby-comment"># Creates a new state object, belonging to the given socket. Initializes</span>
<span class="ruby-comment"># the algorithms to &quot;none&quot;.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [State] a new instance of State</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">socket</span>, <span class="ruby-identifier">role</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The block size for the cipher</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of data blocks processed since the last call to #reset!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blocks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The cipher algorithm in use for this socket endpoint.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cipher</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Closes any the compressor and/or decompressor objects that have been</span>
<span class="ruby-comment"># instantiated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cleanup</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compresses the data. If no compression is in effect, this will just return</span>
<span class="ruby-comment"># the data unmodified, otherwise it uses #compressor to compress the data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compress</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The compression algorithm in use for this endpoint.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if data compression/decompression is enabled. This will</span>
<span class="ruby-comment"># return true if :standard compression is selected, or if :delayed</span>
<span class="ruby-comment"># compression is selected and the :authenticated hint has been received</span>
<span class="ruby-comment"># by the socket.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compression?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The compression level to use when compressing data (or nil, for the default).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compression_level</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The compressor object to use when compressing data. This takes into account</span>
<span class="ruby-comment"># the desired compression level.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compressor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Decompresses the data. If no compression is in effect, this will just return</span>
<span class="ruby-comment"># the data unmodified, otherwise it uses #decompressor to decompress the data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decompress</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The decompressor object to use when decompressing data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decompressor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">final_cipher</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The hmac algorithm in use for this endpoint.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hmac</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Increments the counters. The sequence number is incremented (and remapped</span>
<span class="ruby-comment"># so it always fits in a 32-bit integer). The number of packets and blocks</span>
<span class="ruby-comment"># are also incremented.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">increment</span>(<span class="ruby-identifier">packet_length</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of blocks that this endpoint wants to process before</span>
<span class="ruby-comment"># needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_blocks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of blocks that this endpoint wants to process before</span>
<span class="ruby-comment"># needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_blocks=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of packets that this endpoint wants to process before</span>
<span class="ruby-comment"># needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_packets</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The maximum number of packets that this endpoint wants to process before</span>
<span class="ruby-comment"># needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_packets=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the number of packets processed exceeds the maximum</span>
<span class="ruby-comment"># number of packets, or if the number of blocks processed exceeds the</span>
<span class="ruby-comment"># maximum number of blocks.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needs_rekey?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The number of packets processed since the last call to #reset!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">packets</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The user-specified maximum number of bytes that this endpoint ought to</span>
<span class="ruby-comment"># process before needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rekey_limit</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The user-specified maximum number of bytes that this endpoint ought to</span>
<span class="ruby-comment"># process before needing a rekey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rekey_limit=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Resets the counters on the state object, but leaves the sequence_number</span>
<span class="ruby-comment"># unchanged. It also sets defaults for and recomputes the max_packets and</span>
<span class="ruby-comment"># max_blocks values.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The role that this state plays (either :client or :server)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">role</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The next packet sequence number for this socket endpoint.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sequence_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A convenience method for quickly setting multiple values in a single</span>
<span class="ruby-comment"># command.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The socket object that owns this state object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">socket</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_cipher</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/state.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_next_iv</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">reset</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This is the set of options that Net::SSH.start recognizes. See # Net::SSH.start for a description of each option. # # source://net-ssh//lib/net/ssh.rb#65 Net::SSH::VALID_OPTIONS = T.let(T.unsafe(nil), Array)</p>

<p># source://net-ssh//lib/net/ssh/verifiers/always.rb#6 module Net::SSH::Verifiers; end</p>

<p># Does a strict host verification, looking the server up in the known # host files to see if a key has already been seen for this server. If this # server does not appear in any host file, this will silently add the # server. If the server does appear at least once, but the key given does # not match any known for the server, an exception will be raised (HostKeyMismatch). # Otherwise, this returns true. # # source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#14 class Net::SSH::Verifiers::AcceptNew &lt; ::Net::SSH::Verifiers::Always</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_signature</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Basically the same as the AcceptNew verifier, but does not try to actually # verify a connection if the server is the localhost and the port is a # nonstandard port number. Those two conditions will typically mean the # connection is being tunnelled through a forwarded port, so the known-hosts # file will not be helpful (in general). # # source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#11 class Net::SSH::Verifiers::AcceptNewOrLocalTunnel &lt; ::Net::SSH::Verifiers::AcceptNew</p>

<pre class="ruby"><span class="ruby-comment"># Tries to determine if the connection is being tunnelled, and if so,</span>
<span class="ruby-comment"># returns true. Otherwise, performs the standard strict verification.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># A connection is potentially being tunnelled if the port is not 22,</span>
<span class="ruby-comment"># and the ip refers to the localhost.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tunnelled?</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Does a strict host verification, looking the server up in the known # host files to see if a key has already been seen for this server. If this # server does not appear in any host file, an exception will be raised # (HostKeyUnknown). This is in contrast to the “Strict” class, which will # silently add the key to your known_hosts file. If the server does appear at # least once, but the key given does not match any known for the server, an # exception will be raised (HostKeyMismatch). # Otherwise, this returns true. # # source://net-ssh//lib/net/ssh/verifiers/always.rb#15 class Net::SSH::Verifiers::Always</p>

<pre class="ruby"><span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/always.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/always.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_signature</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/always.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_cache_miss</span>(<span class="ruby-identifier">host_keys</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">exc_class</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This host key verifier simply allows every key it sees, without # any verification. This is simple, but very insecure because it # exposes you to MiTM attacks. # # source://net-ssh//lib/net/ssh/verifiers/never.rb#7 class Net::SSH::Verifiers::Never</p>

<pre class="ruby"><span class="ruby-comment"># Returns true.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/never.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/verifiers/never.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_signature</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A class for describing the current version of a library. The version # consists of three parts: the <code>major</code> number, the <code>minor</code> number, and the # <code>tiny</code> (or <code>patch</code>) number. # # Two Version instances may be compared, so that you can test that a version # of a library is what you require: # #   require ‘net/ssh/version’ # #   if Net::SSH::Version::CURRENT &lt; <a href="2,1,0">Net::SSH::Version</a> #     abort “your software is too old!” #   end # # source://net-ssh//lib/net/ssh/version.rb#15 class Net::SSH::Version</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>

<span class="ruby-comment"># Create a new Version object with the given components.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Version] a new instance of Version</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">major</span>, <span class="ruby-identifier">minor</span>, <span class="ruby-identifier">tiny</span>, <span class="ruby-identifier">pre</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compare this version to the given +version+ object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute major.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">major</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute minor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minor</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute tiny.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tiny</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts this version to a canonical integer that may be compared</span>
<span class="ruby-comment"># against other version objects.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_i</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts this version object to a string, where each of the three</span>
<span class="ruby-comment"># version components are joined by the &#39;.&#39; character. E.g., 2.0.0.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># A convenience method for instantiating a new Version instance with the</span>
  <span class="ruby-comment"># given +major+, +minor+, and +tiny+ components.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/version.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">major</span>, <span class="ruby-identifier">minor</span>, <span class="ruby-identifier">tiny</span>, <span class="ruby-identifier">pre</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The current version of the Net::SSH library as a Version instance # # source://net-ssh//lib/net/ssh/version.rb#62 Net::SSH::Version::CURRENT = T.let(T.unsafe(nil), Net::SSH::Version)</p>

<p># The major component of this version of the Net::SSH library # # source://net-ssh//lib/net/ssh/version.rb#49 Net::SSH::Version::MAJOR = T.let(T.unsafe(nil), Integer)</p>

<p># The minor component of this version of the Net::SSH library # # source://net-ssh//lib/net/ssh/version.rb#52 Net::SSH::Version::MINOR = T.let(T.unsafe(nil), Integer)</p>

<p># The prerelease component of this version of the Net::SSH library # nil allowed # # source://net-ssh//lib/net/ssh/version.rb#59 Net::SSH::Version::PRE = T.let(T.unsafe(nil), T.untyped)</p>

<p># The current version of the Net::SSH library as a String # # source://net-ssh//lib/net/ssh/version.rb#65 Net::SSH::Version::STRING = T.let(T.unsafe(nil), String)</p>

<p># The tiny component of this version of the Net::SSH library # # source://net-ssh//lib/net/ssh/version.rb#55 Net::SSH::Version::TINY = T.let(T.unsafe(nil), Integer)</p>

<p># This class is originally defined in the OpenSSL module. As needed, methods # have been added to it by the Net::SSH module for convenience in dealing with # SSH functionality. # # source://net-ssh//lib/net/ssh/transport/openssl.rb#8 class OpenSSL::BN</p>

<pre class="ruby"><span class="ruby-comment"># Converts a BN object to a string. The format used is that which is</span>
<span class="ruby-comment"># required by the SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_ssh</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p>class OpenSSL::Config</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>
</pre>

<p>end</p>

<p># This class is originally defined in the OpenSSL module. As needed, methods # have been added to it by the Net::SSH module for convenience in dealing # with SSH functionality. # # source://net-ssh//lib/net/ssh/transport/openssl.rb#33 class OpenSSL::PKey::DH &lt; ::OpenSSL::PKey::PKey</p>

<pre class="ruby"><span class="ruby-comment"># Determines whether the pub_key for this key is valid. (This algorithm</span>
<span class="ruby-comment"># lifted more-or-less directly from OpenSSH, dh.c, dh_pub_is_valid.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class is originally defined in the OpenSSL module. As needed, methods # have been added to it by the Net::SSH module for convenience in dealing # with SSH functionality. # # source://net-ssh//lib/net/ssh/transport/openssl.rb#93 class OpenSSL::PKey::DSA &lt; ::OpenSSL::PKey::PKey</p>

<pre class="ruby"><span class="ruby-comment"># Signs the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [OpenSSL::PKey::DSAError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_sign</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Verifies the given signature matches the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_verify</span>(<span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns &quot;ssh-dss&quot;, which is the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns &quot;ssh-dss&quot;, which is the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts the key to a blob, according to the SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class is originally defined in the OpenSSL module. As needed, methods # have been added to it by the Net::SSH module for convenience in dealing # with SSH functionality. # # source://net-ssh//lib/net/ssh/transport/openssl.rb#140 class OpenSSL::PKey::EC &lt; ::OpenSSL::PKey::PKey</p>

<pre class="ruby"><span class="ruby-comment"># Returns the signature for the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_sign</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Verifies the given signature matches the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_verify</span>(<span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol, like &quot;ecdsa-sha2-nistp256&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol, like &quot;ecdsa-sha2-nistp256&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts the key to a blob, according to the SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digester</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#153</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_keyblob</span>(<span class="ruby-identifier">curve_name_in_type</span>, <span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/openssl.rb#141 OpenSSL::PKey::EC::CurveNameAlias = T.let(T.unsafe(nil), Hash)</p>

<p># source://net-ssh//lib/net/ssh/transport/openssl.rb#147 OpenSSL::PKey::EC::CurveNameAliasInv = T.let(T.unsafe(nil), Hash)</p>

<p># source://net-ssh//lib/net/ssh/transport/openssl.rb#255 class OpenSSL::PKey::EC::Point</p>

<pre class="ruby"><span class="ruby-comment"># Returns the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol, like &quot;ecdsa-sha2-nistp256&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol, like &quot;ecdsa-sha2-nistp256&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts the key to a blob, according to the SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://net-ssh//lib/net/ssh/transport/openssl.rb#26 class OpenSSL::PKey::PKey</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">SSH</span><span class="ruby-operator">::</span><span class="ruby-constant">Authentication</span><span class="ruby-operator">::</span><span class="ruby-constant">PubKeyFingerprint</span>
</pre>

<p>end</p>

<p># This class is originally defined in the OpenSSL module. As needed, methods # have been added to it by the Net::SSH module for convenience in dealing # with SSH functionality. # # source://net-ssh//lib/net/ssh/transport/openssl.rb#48 class OpenSSL::PKey::RSA &lt; ::OpenSSL::PKey::PKey</p>

<pre class="ruby"><span class="ruby-comment"># Returns the signature for the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_sign</span>(<span class="ruby-identifier">data</span>, <span class="ruby-identifier">sig_alg</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Verifies the given signature matches the given data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_do_verify</span>(<span class="ruby-identifier">sig</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns &quot;ssh-rsa&quot;, which is the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_signature_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns &quot;ssh-rsa&quot;, which is the description of this key type used by the</span>
<span class="ruby-comment"># SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ssh_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Converts the key to a blob, according to the SSH2 protocol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://net-ssh//lib/net/ssh/transport/openssl.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_blob</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p>class OpenSSL::Provider; end class OpenSSL::Provider::ProviderError &lt; ::OpenSSL::OpenSSLError; end module OpenSSL::Timestamp; end class OpenSSL::Timestamp::Factory; end class OpenSSL::Timestamp::Request; end class OpenSSL::Timestamp::Response; end class OpenSSL::Timestamp::TimestampError &lt; ::OpenSSL::OpenSSLError; end class OpenSSL::Timestamp::TokenInfo; end</p>

</main>

