<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>rubocop@1.78.0.rbi - RDoc Documentation</title>

  <meta name="keywords" content="ruby,documentation,rubocop@1.78.0.rbi">
  <meta name="description" content="rubocop@1.78.0.rbi: true # DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the `rubocop` gem. tapioca gem rubocop`.">


<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../Dockerfile.html">Dockerfile</a>
    <li><a href="../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../README_md.html">README</a>
    <li><a href="../../../Rakefile.html">Rakefile</a>
    <li><details><summary>app</summary>
    <ul class="link-list">
      <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
      <li><a href="../../../app/views/pwa/service-worker_js.html">service-worker.js</a>
    </ul></details>
    <li><a href="../../../bin/docker-entrypoint.html">docker-entrypoint</a>
    <li><a href="../../../config_ru.html">config.ru</a>
    <li><details><summary>config</summary>
    <ul class="link-list">
      <li><a href="../../../config/credentials_yml_enc.html">credentials.yml.enc</a>
      <li><a href="../../../config/master_key.html">master.key</a>
    </ul></details>
    <li><details><summary>log</summary>
    <ul class="link-list">
      <li><a href="../../../log/development_log.html">development.log</a>
      <li><a href="../../../log/test_log.html">test.log</a>
    </ul></details>
    <li><details><summary>public</summary>
    <ul class="link-list">
      <li><a href="../../../public/400_html.html">400.html</a>
      <li><a href="../../../public/404_html.html">404.html</a>
      <li><a href="../../../public/406-unsupported-browser_html.html">406-unsupported-browser.html</a>
      <li><a href="../../../public/422_html.html">422.html</a>
      <li><a href="../../../public/500_html.html">500.html</a>
      <li><a href="../../../public/robots_txt.html">robots</a>
    </ul></details>
    <li><details open><summary>sorbet</summary>
    <ul class="link-list">
      <li><a href="../../../sorbet/config.html">config</a>
      <li><a href="../../../sorbet/rbi/annotations/actionmailer_rbi.html">actionmailer.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionpack_rbi.html">actionpack.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionview_rbi.html">actionview.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activejob_rbi.html">activejob.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activemodel_rbi.html">activemodel.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activerecord_rbi.html">activerecord.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activesupport_rbi.html">activesupport.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/globalid_rbi.html">globalid.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/minitest_rbi.html">minitest.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/railties_rbi.html">railties.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/rainbow_rbi.html">rainbow.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actioncable@8_0_2_rbi.html">actioncable@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailbox@8_0_2_rbi.html">actionmailbox@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailer@8_0_2_rbi.html">actionmailer@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionpack@8_0_2_rbi.html">actionpack@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actiontext@8_0_2_rbi.html">actiontext@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionview@8_0_2_rbi.html">actionview@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activejob@8_0_2_rbi.html">activejob@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activemodel@8_0_2_rbi.html">activemodel@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activerecord@8_0_2_rbi.html">activerecord@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activestorage@8_0_2_rbi.html">activestorage@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activesupport@8_0_2_rbi.html">activesupport@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ast@2_4_3_rbi.html">ast@2.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/backport@1_2_0_rbi.html">backport@1.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/base64@0_3_0_rbi.html">base64@0.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bcrypt_pbkdf@1_1_1_rbi.html">bcrypt_pbkdf@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/benchmark@0_4_1_rbi.html">benchmark@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bigdecimal@3_2_2_rbi.html">bigdecimal@3.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bindex@0_8_1_rbi.html">bindex@0.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/brakeman@7_0_2_rbi.html">brakeman@7.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/commander@5_0_0_rbi.html">commander@5.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/concurrent-ruby@1_3_5_rbi.html">concurrent-ruby@1.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/connection_pool@2_5_3_rbi.html">connection_pool@2.5.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/crass@1_0_6_rbi.html">crass@1.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/csv@3_3_5_rbi.html">csv@3.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/date@3_4_1_rbi.html">date@3.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/diff-lcs@1_6_2_rbi.html">diff-lcs@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/dotenv@3_1_8_rbi.html">dotenv@3.1.8.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/drb@2_2_3_rbi.html">drb@2.2.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/e2mmap@0_1_0_rbi.html">e2mmap@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ed25519@1_4_0_rbi.html">ed25519@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erb@5_0_1_rbi.html">erb@5.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erubi@1_13_1_rbi.html">erubi@1.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/globalid@1_2_1_rbi.html">globalid@1.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/highline@3_0_1_rbi.html">highline@3.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/httparty@0_23_1_rbi.html">httparty@0.23.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/i18n@1_14_7_rbi.html">i18n@1.14.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/importmap-rails@2_1_0_rbi.html">importmap-rails@2.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/io-console@0_8_0_rbi.html">io-console@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/jaro_winkler@1_6_1_rbi.html">jaro_winkler@1.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/json@2_12_2_rbi.html">json@2.12.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kamal@2_7_0_rbi.html">kamal@2.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown-parser-gfm@1_1_0_rbi.html">kramdown-parser-gfm@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown@2_5_1_rbi.html">kramdown@2.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/language_server-protocol@3_17_0_5_rbi.html">language_server-protocol@3.17.0.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/lint_roller@1_1_0_rbi.html">lint_roller@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/logger@1_7_0_rbi.html">logger@1.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/loofah@2_24_1_rbi.html">loofah@2.24.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mail@2_8_1_rbi.html">mail@2.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/marcel@1_0_4_rbi.html">marcel@1.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/method_source@1_1_0_rbi.html">method_source@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mini_mime@1_1_5_rbi.html">mini_mime@1.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/minitest@5_25_5_rbi.html">minitest@5.25.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/multi_xml@0_7_2_rbi.html">multi_xml@0.7.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-imap@0_5_9_rbi.html">net-imap@0.5.9.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-pop@0_1_2_rbi.html">net-pop@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-protocol@0_2_2_rbi.html">net-protocol@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-scp@4_1_0_rbi.html">net-scp@4.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-sftp@4_0_0_rbi.html">net-sftp@4.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-smtp@0_5_1_rbi.html">net-smtp@0.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-ssh@7_3_0_rbi.html">net-ssh@7.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/netrc@0_11_0_rbi.html">netrc@0.11.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/nio4r@2_7_4_rbi.html">nio4r@2.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/observer@0_1_2_rbi.html">observer@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ostruct@0_6_2_rbi.html">ostruct@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parallel@1_27_0_rbi.html">parallel@1.27.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parlour@9_1_2_rbi.html">parlour@9.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parser@3_3_8_0_rbi.html">parser@3.3.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pattern_generator@0_1_0_rbi.html">pattern_generator@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/polyfill@1_9_0_rbi.html">polyfill@1.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pp@0_6_2_rbi.html">pp@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prettyprint@0_2_0_rbi.html">prettyprint@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prism@1_4_0_rbi.html">prism@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/propshaft@1_1_0_rbi.html">propshaft@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/psych@5_2_6_rbi.html">psych@5.2.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/puma@6_6_0_rbi.html">puma@6.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/racc@1_8_1_rbi.html">racc@1.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-session@2_1_1_rbi.html">rack-session@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-test@2_2_0_rbi.html">rack-test@2.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack@3_1_16_rbi.html">rack@3.1.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rackup@2_2_1_rbi.html">rackup@2.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-dom-testing@2_3_0_rbi.html">rails-dom-testing@2.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-html-sanitizer@1_6_2_rbi.html">rails-html-sanitizer@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails@8_0_2_rbi.html">rails@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/railties@8_0_2_rbi.html">railties@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rainbow@3_1_1_rbi.html">rainbow@3.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rake@13_3_0_rbi.html">rake@13.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbi@0_3_6_rbi.html">rbi@0.3.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbs@4_0_0_dev_4_rbi.html">rbs@4.0.0.dev.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rdoc@6_14_2_rbi.html">rdoc@6.14.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/redcarpet@3_6_1_rbi.html">redcarpet@3.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/regexp_parser@2_10_0_rbi.html">regexp_parser@2.10.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reline@0_6_1_rbi.html">reline@0.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/require-hooks@0_2_2_rbi.html">require-hooks@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reverse_markdown@2_1_1_rbi.html">reverse_markdown@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-core@3_13_5_rbi.html">rspec-core@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-expectations@3_13_5_rbi.html">rspec-expectations@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-mocks@3_13_5_rbi.html">rspec-mocks@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-rails@8_0_1_rbi.html">rspec-rails@8.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-support@3_13_4_rbi.html">rspec-support@3.13.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec@3_13_1_rbi.html">rspec@3.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-ast@1_45_1_rbi.html">rubocop-ast@1.45.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-performance@1_25_0_rbi.html">rubocop-performance@1.25.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails-omakase@1_1_0_rbi.html">rubocop-rails-omakase@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails@2_32_0_rbi.html">rubocop-rails@2.32.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop@1_78_0_rbi.html">rubocop@1.78.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp-rails@0_4_6_rbi.html">ruby-lsp-rails@0.4.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp@0_24_2_rbi.html">ruby-lsp@0.24.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-progressbar@1_13_0_rbi.html">ruby-progressbar@1.13.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/safe_type@1_1_1_rbi.html">safe_type@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/securerandom@0_4_1_rbi.html">securerandom@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph-rails@1_1_2_rbi.html">solargraph-rails@1.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph@0_48_0_rbi.html">solargraph@0.48.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-coerce@0_7_0_rbi.html">sorbet-coerce@0.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-rails@0_7_34_rbi.html">sorbet-rails@0.7.34.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-runtime-stub@0_2_0_rbi.html">sorbet-runtime-stub@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/spoom@1_7_4_rbi.html">spoom@1.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sshkit@1_24_0_rbi.html">sshkit@1.24.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stimulus-rails@1_3_4_rbi.html">stimulus-rails@1.3.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stringio@3_1_7_rbi.html">stringio@3.1.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tapioca@0_17_6_rbi.html">tapioca@0.17.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thor@1_3_2_rbi.html">thor@1.3.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thruster@0_1_14_rbi.html">thruster@0.1.14.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tilt@2_6_1_rbi.html">tilt@2.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/timeout@0_4_3_rbi.html">timeout@0.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/turbo-rails@2_0_16_rbi.html">turbo-rails@2.0.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tzinfo@2_0_6_rbi.html">tzinfo@2.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-display_width@2_6_0_rbi.html">unicode-display_width@2.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/uri@1_0_3_rbi.html">uri@1.0.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/useragent@0_16_11_rbi.html">useragent@0.16.11.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/web-console@4_2_1_rbi.html">web-console@4.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-driver@0_8_0_rbi.html">websocket-driver@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-extensions@0_1_5_rbi.html">websocket-extensions@0.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-kramdown@0_0_1_rbi.html">yard-kramdown@0.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-solargraph@0_1_0_rbi.html">yard-solargraph@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-sorbet@0_9_0_rbi.html">yard-sorbet@0.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard@0_9_37_rbi.html">yard@0.9.37.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/zeitwerk@2_7_3_rbi.html">zeitwerk@2.7.3.rbi</a>
      <li><a href="../../../sorbet/rbi/todo_rbi.html">todo.rbi</a>
    </ul></details>
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  </ul>
</div>


  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-label="Page sorbet/rbi/gems/rubocop@1.78.0.rbi">

<p># typed: true</p>

<p># DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the ‘rubocop` gem. # Please instead update this file by running `bin/tapioca gem rubocop`.</p>

<p>class Parser::Source::Comment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">Comment</span>
</pre>

<p>end</p>

<p>class Parser::Source::Range</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">Range</span>
</pre>

<p>end</p>

<p>class Regexp::Expression::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">RegexpParser</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
</pre>

<p>end</p>

<p>class Regexp::Expression::CharacterSet &lt; ::Regexp::Expression::Subexpression</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">RegexpParser</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span><span class="ruby-operator">::</span><span class="ruby-constant">CharacterSet</span>
</pre>

<p>end</p>

<p>class Regexp::Expression::Quantifier</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">RegexpParser</span><span class="ruby-operator">::</span><span class="ruby-constant">Expression</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/version.rb#3 module RuboCop; end</p>

<p>class RuboCop::AST::ProcessedSource</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">ProcessedSource</span>
</pre>

<p>end</p>

<p>class RuboCop::AST::RegexpNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">RegexpNode</span>
</pre>

<p>end</p>

<p># This is a class that reads optional command line arguments to rubocop from environment variable. # # @api private # # source://rubocop//lib/rubocop/arguments_env.rb#6 class RuboCop::ArgumentsEnv</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/arguments_env.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_as_arguments</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This is a class that reads optional command line arguments to rubocop from .rubocop file. # # @api private # # source://rubocop//lib/rubocop/arguments_file.rb#6 class RuboCop::ArgumentsFile</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/arguments_file.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_as_arguments</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The CLI is a class responsible of handling all the command line interface # logic. # # source://rubocop//lib/rubocop/cli.rb#8 class RuboCop::CLI</p>

<pre class="ruby"><span class="ruby-comment"># @return [CLI] a new instance of CLI</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config_store.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_store</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Entry point for the application logic. Here we</span>
<span class="ruby-comment"># do the command line arguments processing and inspect</span>
<span class="ruby-comment"># the target files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param args [Array&lt;String&gt;] command line arguments</span>
<span class="ruby-comment"># @return [Integer] UNIX exit code</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">args</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">act_on_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_default_formatter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_runners</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_editor_mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [Finished]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_exiting_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parallel_by_default!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">profile_if_needed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_pending_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_gem</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_command</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_options_to_config_loader</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_options_to_pending_cops_reporter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suggest_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_options_vs_config</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Home of subcommands in the CLI. # # @api private # # source://rubocop//lib/rubocop/cli/command.rb#7 module RuboCop::CLI::Command</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Find the command with a given name and run it in an environment.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">env</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_for</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Generate a configuration file acting as a TODO list. # # @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#8 class RuboCop::CLI::Command::AutoGenerateConfig &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_formatter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_inheritance_from_auto_generated_file</span>(<span class="ruby-identifier">config_file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_runner</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">existing_configuration</span>(<span class="ruby-identifier">config_file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length_cop</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length_enabled?</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maybe_run_line_length_cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_exclude?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options_has_only_flag?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_path_to_todo_from_options_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_config_and_auto_gen_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_all_cops</span>(<span class="ruby-identifier">line_length_contents</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Do an initial run with only Layout/LineLength so that cops that</span>
<span class="ruby-comment"># depend on Layout/LineLength:Max get the correct value for that</span>
<span class="ruby-comment"># parameter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_line_length_cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_max_line_length?</span>(<span class="ruby-identifier">config1</span>, <span class="ruby-identifier">config2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_line_length_cop</span>(<span class="ruby-identifier">reason</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_config_file</span>(<span class="ruby-identifier">file_name</span>, <span class="ruby-identifier">file_string</span>, <span class="ruby-identifier">rubocop_yml_contents</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#11 RuboCop::CLI::Command::AutoGenerateConfig::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#15 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1 = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#19 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_DISABLED = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#18 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_OVERRIDDEN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#20 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_SKIPPED_ONLY_COPS = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#22 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_SKIPPED_ONLY_EXCLUDE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#16 RuboCop::CLI::Command::AutoGenerateConfig::PHASE_2 = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#13 RuboCop::CLI::Command::AutoGenerateConfig::PLACEHOLDER = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/auto_generate_config.rb#12 RuboCop::CLI::Command::AutoGenerateConfig::YAML_OPTIONAL_DOC_START = T.let(T.unsafe(nil), Regexp)</p>

<p># A subcommand in the CLI. # # @api private # # source://rubocop//lib/rubocop/cli/command/base.rb#8 class RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Base] a new instance of Base</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">env</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#21</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_command_name</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_name</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_name=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/base.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">subclass</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Run all the selected cops and report the result. # # @api private # # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#8 class RuboCop::CLI::Command::ExecuteRunner &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bug_tracker_uri</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_error_summary</span>(<span class="ruby-identifier">errors</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_summary</span>(<span class="ruby-identifier">runner</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_warning_summary</span>(<span class="ruby-identifier">warnings</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_runner</span>(<span class="ruby-identifier">paths</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maybe_print_corrected_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/execute_runner.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_redirect</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Combination of short and long formatter names. # # @api private # # source://rubocop//lib/rubocop/cli/command/execute_runner.rb#12 RuboCop::CLI::Command::ExecuteRunner::INTEGRATION_FORMATTERS = T.let(T.unsafe(nil), Array)</p>

<p># Generate a .rubocop.yml file in the current directory. # # @api private # # source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#8 class RuboCop::CLI::Command::InitDotfile &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/init_dotfile.rb#9 RuboCop::CLI::Command::InitDotfile::DOTFILE = T.let(T.unsafe(nil), String)</p>

<p># Start Language Server Protocol of RuboCop. # # @api private # # source://rubocop//lib/rubocop/cli/command/lsp.rb#8 class RuboCop::CLI::Command::LSP &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/lsp.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Shows the given cops, or all cops by default, and their configurations # for the current directory. # # @api private # # source://rubocop//lib/rubocop/cli/command/show_cops.rb#9 class RuboCop::CLI::Command::ShowCops &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ShowCops] a new instance of ShowCops</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_lines</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops_of_department</span>(<span class="ruby-identifier">cops</span>, <span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_available_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_cop_details</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_cops_of_department</span>(<span class="ruby-identifier">registry</span>, <span class="ruby-identifier">department</span>, <span class="ruby-identifier">show_all</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selected_cops_of_department</span>(<span class="ruby-identifier">cops</span>, <span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/show_cops.rb#12 class RuboCop::CLI::Command::ShowCops::ExactMatcher &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute pattern to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cli/command/show_cops.rb#18 class RuboCop::CLI::Command::ShowCops::WildcardMatcher &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute pattern to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_cops.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Prints out url to documentation of provided cops # or documentation base url by default. # # @api private # # source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#9 class RuboCop::CLI::Command::ShowDocsUrl &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ShowDocsUrl] a new instance of ShowDocsUrl</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops_array</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_documentation_url</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/show_docs_url.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry_hash</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Suggest RuboCop extensions to install based on <a href="../../../Gemfile.html">Gemfile</a> dependencies. # Only primary dependencies are evaluated, so if a dependency depends on a # gem with an extension, it is not suggested. However, if an extension is # a transitive dependency, it will not be suggested. # # @api private # # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#11 class RuboCop::CLI::Command::SuggestExtensions &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_formatter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependent_gems</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">installed_and_not_loaded_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">installed_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">installed_gems</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lockfile</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_installed_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_install_suggestions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_load_suggestions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_opt_out_instruction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">puts</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Combination of short and long formatter names. # # @api private # # source://rubocop//lib/rubocop/cli/command/suggest_extensions.rb#13 RuboCop::CLI::Command::SuggestExtensions::INCLUDED_FORMATTERS = T.let(T.unsafe(nil), Array)</p>

<p># Display version. # # @api private # # source://rubocop//lib/rubocop/cli/command/version.rb#8 class RuboCop::CLI::Command::Version &lt; ::RuboCop::CLI::Command::Base</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/command/version.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cli.rb#13 RuboCop::CLI::DEFAULT_PARALLEL_OPTIONS = T.let(T.unsafe(nil), Array)</p>

<p># Execution environment for a CLI command. # # @api private # # source://rubocop//lib/rubocop/cli/environment.rb#7 class RuboCop::CLI::Environment</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Environment] a new instance of Environment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/environment.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">config_store</span>, <span class="ruby-identifier">paths</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/environment.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_store</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/environment.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/environment.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">paths</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Run a command in this environment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cli/environment.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cli.rb#20 class RuboCop::CLI::Finished &lt; ::StandardError; end</p>

<p># source://rubocop//lib/rubocop/cli.rb#11 RuboCop::CLI::STATUS_ERROR = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cli.rb#12 RuboCop::CLI::STATUS_INTERRUPTED = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cli.rb#10 RuboCop::CLI::STATUS_OFFENSES = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cli.rb#9 RuboCop::CLI::STATUS_SUCCESS = T.let(T.unsafe(nil), Integer)</p>

<p># This class represents the cache config of the caching RuboCop runs. # # @api private # # source://rubocop//lib/rubocop/cache_config.rb#6 class RuboCop::CacheConfig</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cache_config.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_dir</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Converts RuboCop objects to and from the serialization format JSON. # # @api private # # source://rubocop//lib/rubocop/cached_data.rb#8 class RuboCop::CachedData</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [CachedData] a new instance of CachedData</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">filename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_json</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_json</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Restore an offense object loaded from a JSON file.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deserialize_offenses</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location_from_source_buffer</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serialize_offense</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Delay creation until needed. Some type of offenses will have no buffer associated with them</span>
<span class="ruby-comment"># and be global only. For these, trying to create the buffer will likely fail, for example</span>
<span class="ruby-comment"># because of unknown encoding comments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cached_data.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_buffer</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># and provides a way to check if each cop is enabled at arbitrary line. # # source://rubocop//lib/rubocop/comment_config.rb#6 class RuboCop::CommentConfig</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [CommentConfig] a new instance of CommentConfig</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_only_line?</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_disabled_line_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_enabled_at_line?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_opted_in?</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_enabled_comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute processed_source.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">analyze</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">analyze_cop</span>(<span class="ruby-identifier">analysis</span>, <span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">analyze_disabled</span>(<span class="ruby-identifier">analysis</span>, <span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">analyze_rest</span>(<span class="ruby-identifier">analysis</span>, <span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">analyze_single_line</span>(<span class="ruby-identifier">analysis</span>, <span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_line_ranges</span>(<span class="ruby-identifier">analysis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_directive</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_enabled_comments_with_names</span>(<span class="ruby-value">extras:</span>, <span class="ruby-value">names:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_enable_all</span>(<span class="ruby-identifier">directive</span>, <span class="ruby-identifier">names</span>, <span class="ruby-identifier">extras</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Collect cops that have been disabled or enabled by name in a directive comment</span>
<span class="ruby-comment"># so that `Lint/RedundantCopEnableDirective` can register offenses correctly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_switch</span>(<span class="ruby-identifier">directive</span>, <span class="ruby-identifier">names</span>, <span class="ruby-identifier">extras</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject_disabled_cops_directives</span>(<span class="ruby-identifier">analyses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_comment_token_line_numbers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opt_in_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_cop_name</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/comment_config.rb#9 RuboCop::CommentConfig::CONFIG_DISABLED_LINE_RANGE_MIN = T.let(T.unsafe(nil), Float)</p>

<p># This class provides an API compatible with RuboCop::DirectiveComment # to be used for cops that are disabled in the config file # # source://rubocop//lib/rubocop/comment_config.rb#13 class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">Comment</span>

<span class="ruby-comment"># @return [ConfigDisabledCopDirectiveComment] a new instance of ConfigDisabledCopDirectiveComment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line_number.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute loc.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute text.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/comment_config.rb#19 class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute line to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/comment_config.rb#18 class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute expression</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of expression</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute expression</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute expression to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/comment_config.rb#28 class RuboCop::CommentConfig::CopAnalysis &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute line_ranges</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line_ranges</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute line_ranges</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute line_ranges to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_ranges=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute start_line_number</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of start_line_number</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_line_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute start_line_number</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute start_line_number to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_line_number=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/comment_config.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class represents the configuration of the RuboCop application # and all its cops. A Config is associated with a YAML configuration # file from which it was read. Several different Configs can be used # during a run of the rubocop program, if files in several # directories are inspected. # # source://rubocop//lib/rubocop/config.rb#12 class RuboCop::Config</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">FileFinder</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [Config] a new instance of Config</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">hash</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">loaded_path</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_support_extensions_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_excludes_from_higher_level</span>(<span class="ruby-identifier">highest_config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_camel_case_file?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Paths specified in configuration files starting with .rubocop are</span>
<span class="ruby-comment"># relative to the directory where that file is. Paths in other config files</span>
<span class="ruby-comment"># are relative to the current directory. This is so that paths in</span>
<span class="ruby-comment"># config/default.yml, for example, are not relative to RuboCop&#39;s config</span>
<span class="ruby-comment"># directory since that wouldn&#39;t work.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_dir_for_path_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bundler_lock_file_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean] whether config for this badge has &#39;Include&#39; or &#39;Exclude&#39; keys</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clusivity_config_for_badge?</span>(<span class="ruby-identifier">badge</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_enabled?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecation_check</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled_new_cops?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_key</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled_new_cops?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#261</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_to_exclude?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_to_include?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_all_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Note: the &#39;Enabled&#39; attribute is same as that returned by `for_cop`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Config] for the given cop merged with that of its department (if any)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_badge</span>(<span class="ruby-identifier">badge</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Note: the &#39;Enabled&#39; attribute is calculated according to the department&#39;s</span>
<span class="ruby-comment"># and &#39;AllCops&#39; configuration; other attributes are not inherited.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Config] for the given cop / cop name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_cop</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Note: the &#39;Enabled&#39; attribute will be present only if specified</span>
<span class="ruby-comment"># at the department&#39;s level</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Config] for the given department name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_department</span>(<span class="ruby-identifier">department_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the given cop is enabled, returns its configuration hash.</span>
<span class="ruby-comment"># Otherwise, returns an empty hash.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Config, Hash] for the given cop / cop name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_enabled_cop</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns target&#39;s locked gem versions (i.e. from Gemfile.lock or gems.locked)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_versions_in_target</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#342</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># True if this is a config file that is shipped with RuboCop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_features</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute loaded_path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_plugins</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_excludes_absolute</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_engine</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path_relative_to_config</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">patterns_to_exclude</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">patterns_to_include</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if there&#39;s a chance that an Include pattern matches hidden</span>
<span class="ruby-comment"># files, false if that&#39;s definitely not possible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">possibly_include_hidden?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">signature</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#308</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smart_loaded_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literals_frozen_by_default?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_rails_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby_version</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_hash</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transform_values</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_after_resolution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_of</span>(<span class="ruby-identifier">qualified_cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#380</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_cop?</span>(<span class="ruby-identifier">qualified_cop_name</span>, <span class="ruby-identifier">cop_options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param gem_version [Gem::Version] an object like `Gem::Version.new(&quot;7.1.2.3&quot;)`</span>
<span class="ruby-comment"># @return [Float] The major and minor version, like `7.1`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#367</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_version_to_major_minor_float</span>(<span class="ruby-identifier">gem_version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#373</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_gem_versions_from_target_lockfile</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Float, nil] The Rails version as a `major.minor` Float.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#354</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_rails_version_from_bundler_lock_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Float, nil] The Rails version as a `major.minor` Float.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_rails_version_from_bundler_lock_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">path</span>, <span class="ruby-value">check:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/config.rb#17 class RuboCop::Config::CopConfig &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute metadata</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of metadata</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute metadata</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute metadata to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute name to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/config.rb#20 RuboCop::Config::DEFAULT_RAILS_VERSION = T.let(T.unsafe(nil), Float)</p>

<p># source://rubocop//lib/rubocop/config.rb#19 RuboCop::Config::EMPTY_CONFIG = T.let(T.unsafe(nil), Hash)</p>

<p># This class has methods related to finding configuration path. # # @api private # # source://rubocop//lib/rubocop/config_finder.rb#8 class RuboCop::ConfigFinder</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">FileFinder</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_config_path</span>(<span class="ruby-identifier">target_dir</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the path RuboCop inferred as the root of the project. No file</span>
  <span class="ruby-comment"># searches will go past this directory.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#26</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">project_root</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">project_root=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#69</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_path</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_project_dotfile</span>(<span class="ruby-identifier">target_dir</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#32</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_project_root</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_project_root_dot_config</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_user_dotfile</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_finder.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_user_xdg_config</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_finder.rb#12 RuboCop::ConfigFinder::DEFAULT_FILE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_finder.rb#9 RuboCop::ConfigFinder::DOTFILE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_finder.rb#11 RuboCop::ConfigFinder::RUBOCOP_HOME = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_finder.rb#10 RuboCop::ConfigFinder::XDG_CONFIG = T.let(T.unsafe(nil), String)</p>

<p># This class represents the configuration of the RuboCop application # and all its cops. A Config is associated with a YAML configuration # file from which it was read. Several different Configs can be used # during a run of the rubocop program, if files in several # directories are inspected. # # source://rubocop//lib/rubocop/config_loader.rb#17 class RuboCop::ConfigLoader</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">FileFinder</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#130</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_excludes_from_files</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">config_file</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Used to add features that were required inside a config or from</span>
  <span class="ruby-comment"># the CLI using `--require`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#204</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_loaded_features</span>(<span class="ruby-identifier">loaded_features</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Used to add plugins that were required inside a config or from</span>
  <span class="ruby-comment"># the CLI using `--plugin`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#197</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_loaded_plugins</span>(<span class="ruby-identifier">loaded_plugins</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#83</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_missing_namespaces</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#33</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_options</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the path of .rubocop.yml searching upwards in the</span>
  <span class="ruby-comment"># directory structure starting at the given directory where the</span>
  <span class="ruby-comment"># inspected file is. If no .rubocop.yml is found there, the</span>
  <span class="ruby-comment"># user&#39;s home directory is checked. If there&#39;s no .rubocop.yml</span>
  <span class="ruby-comment"># there either, the path to the default file is returned.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#111</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configuration_file_for</span>(<span class="ruby-identifier">target_dir</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#115</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configuration_from_file</span>(<span class="ruby-identifier">config_file</span>, <span class="ruby-value">check:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute debug.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute debug</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute debug to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute debug.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#140</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_configuration</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute default_configuration</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute default_configuration to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_configuration=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute disable_pending_cops.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_pending_cops</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute disable_pending_cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute disable_pending_cops to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_pending_cops=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute enable_pending_cops.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_pending_cops</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute enable_pending_cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute enable_pending_cops to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_pending_cops=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute ignore_parent_exclusion.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_parent_exclusion</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute ignore_parent_exclusion</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute ignore_parent_exclusion to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_parent_exclusion=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute ignore_parent_exclusion.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_parent_exclusion?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute ignore_unrecognized_cops.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_unrecognized_cops</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute ignore_unrecognized_cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute ignore_unrecognized_cops to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_unrecognized_cops=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># This API is primarily intended for testing and documenting plugins.</span>
  <span class="ruby-comment"># When testing a plugin using `rubocop/rspec/support`, the plugin is loaded automatically,</span>
  <span class="ruby-comment"># so this API is usually not needed. It is intended to be used only when implementing tests</span>
  <span class="ruby-comment"># that do not use `rubocop/rspec/support`.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#152</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject_defaults!</span>(<span class="ruby-identifier">config_yml_path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#45</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_file</span>(<span class="ruby-identifier">file</span>, <span class="ruby-value">check:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @raise [TypeError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#70</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_yaml_configuration</span>(<span class="ruby-identifier">absolute_path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute loaded_features.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_features</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute loaded_plugins.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loaded_plugins</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Return a recursive merge of two hashes. That is, a normal hash merge,</span>
  <span class="ruby-comment"># with the addition that any value that is a hash, and occurs in both</span>
  <span class="ruby-comment"># arguments, will also be merged. And so on.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#102</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Merges the given configuration with the default one.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#190</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_with_default</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">config_file</span>, <span class="ruby-value">unset_nil:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the path RuboCop inferred as the root of the project. No file</span>
  <span class="ruby-comment"># searches will go past this directory.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @deprecated Use `RuboCop::ConfigFinder.project_root` instead.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#180</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">project_root</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#218</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_duplication</span>(<span class="ruby-identifier">yaml_code</span>, <span class="ruby-identifier">absolute_path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#210</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_path</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Read the specified file, or exit with a friendly, concise message on</span>
  <span class="ruby-comment"># stderr. Care is taken to use the standard OS exit code for a &quot;file not</span>
  <span class="ruby-comment"># found&quot; error.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#238</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_file</span>(<span class="ruby-identifier">absolute_path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#214</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolver</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#244</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yaml_tree_to_hash</span>(<span class="ruby-identifier">yaml_tree</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader.rb#254</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yaml_tree_to_hash!</span>(<span class="ruby-identifier">yaml_tree</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/config_loader.rb#20 RuboCop::ConfigLoader::DEFAULT_FILE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/config_loader.rb#18 RuboCop::ConfigLoader::DOTFILE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/config_loader.rb#19 RuboCop::ConfigLoader::RUBOCOP_HOME = T.let(T.unsafe(nil), String)</p>

<p># A help class for ConfigLoader that handles configuration resolution. # # @api private # # source://rubocop//lib/rubocop/config_loader_resolver.rb#10 class RuboCop::ConfigLoaderResolver</p>

<pre class="ruby"><span class="ruby-comment"># When one .rubocop.yml file inherits from another .rubocop.yml file, the Include paths in the</span>
<span class="ruby-comment"># base configuration are relative to the directory where the base configuration file is. For the</span>
<span class="ruby-comment"># derived configuration, we need to make those paths relative to where the derived configuration</span>
<span class="ruby-comment"># file is.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_include_paths</span>(<span class="ruby-identifier">base_config_path</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return a recursive merge of two hashes. That is, a normal hash merge,</span>
<span class="ruby-comment"># with the addition that any value that is a hash, and occurs in both</span>
<span class="ruby-comment"># arguments, will also be merged. And so on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Merges the given configuration with the default one. If</span>
<span class="ruby-comment"># AllCops:DisabledByDefault is true, it changes the Enabled params so that</span>
<span class="ruby-comment"># only cops from user configuration are enabled. If</span>
<span class="ruby-comment"># AllCops:EnabledByDefault is true, it changes the Enabled params so that</span>
<span class="ruby-comment"># only cops explicitly disabled in user configuration are disabled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_with_default</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">config_file</span>, <span class="ruby-value">unset_nil:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># An `Enabled: true` setting in user configuration for a cop overrides an</span>
<span class="ruby-comment"># `Enabled: false` setting for its department.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">override_department_setting_for_cops</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If a cop was previously explicitly enabled, but then superseded by the</span>
<span class="ruby-comment"># department being disabled, disable it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">override_enabled_for_disabled_departments</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_inheritance</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">file</span>, <span class="ruby-identifier">debug</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_inheritance_from_gems</span>(<span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_plugins</span>(<span class="ruby-identifier">rubocop_config</span>, <span class="ruby-identifier">plugins</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_requires</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_configs</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">inherit_from</span>, <span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">determine_inherit_mode</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled?</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicate_setting?</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">inherited_file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicate_setting_warning</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_config_path</span>(<span class="ruby-identifier">gem_name</span>, <span class="ruby-identifier">relative_config_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_disabled_by_default</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">new_default_configuration</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited_file</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">inherit_from</span>, <span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_hashes?</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_config?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_merge?</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_override?</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_union?</span>(<span class="ruby-identifier">derived_hash</span>, <span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">root_mode</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transform</span>(<span class="ruby-identifier">config</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_loader_resolver.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warn_on_duplicate_setting</span>(<span class="ruby-identifier">base_hash</span>, <span class="ruby-identifier">derived_hash</span>, <span class="ruby-identifier">key</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when a RuboCop configuration file is not found. # # source://rubocop//lib/rubocop/config_loader.rb#9 class RuboCop::ConfigNotFoundError &lt; ::RuboCop::Error; end</p>

<p># This class handles obsolete configuration. # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#4 class RuboCop::ConfigObsoletion</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ConfigObsoletion] a new instance of ConfigObsoletion</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_cop_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">legacy_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject_obsolete!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rules</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warnings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_rules</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Cop rules are keyed by the name of the original cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_cop_rules</span>(<span class="ruby-identifier">rules</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Parameter rules may apply to multiple cops and multiple parameters</span>
<span class="ruby-comment"># and are given as an array. Each combination is turned into a separate</span>
<span class="ruby-comment"># rule object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_parameter_rules</span>(<span class="ruby-identifier">rules</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Default rules for obsoletions are in config/obsoletion.yml</span>
<span class="ruby-comment"># Additional rules files can be added with `RuboCop::ConfigObsoletion.files &lt;&lt; filename`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_rules</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">obsoletions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#45</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_cop_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#49</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_names_for</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#26</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">legacy_cop_names</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset!</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rules_cache_key</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion.rb#8 RuboCop::ConfigObsoletion::COP_RULE_CLASSES = T.let(T.unsafe(nil), Hash)</p>

<p># Encapsulation of a ConfigObsoletion rule for changing a parameter # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#7 class RuboCop::ConfigObsoletion::ChangedEnforcedStyles &lt; ::RuboCop::ConfigObsoletion::ParameterRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">violated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion/changed_enforced_styles.rb#8 RuboCop::ConfigObsoletion::ChangedEnforcedStyles::BASE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Encapsulation of a ConfigObsoletion rule for changing a parameter # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#7 class RuboCop::ConfigObsoletion::ChangedParameter &lt; ::RuboCop::ConfigObsoletion::ParameterRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion/changed_parameter.rb#8 RuboCop::ConfigObsoletion::ChangedParameter::BASE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Base class for ConfigObsoletion rules relating to cops # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#7 class RuboCop::ConfigObsoletion::CopRule &lt; ::RuboCop::ConfigObsoletion::Rule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [CopRule] a new instance of CopRule</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">old_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_rule?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">old_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">violated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Cop rules currently can only be failures, not warnings</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/cop_rule.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warning?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion.rb#7 RuboCop::ConfigObsoletion::DEFAULT_RULES_FILE = T.let(T.unsafe(nil), String)</p>

<p># Encapsulation of a ConfigObsoletion rule for splitting a cop’s # functionality into multiple new cops. # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#8 class RuboCop::ConfigObsoletion::ExtractedCop &lt; ::RuboCop::ConfigObsoletion::CopRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ExtractedCop] a new instance of ExtractedCop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">old_name</span>, <span class="ruby-identifier">gem</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rule_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">violated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">affected_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/extracted_cop.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">plugin_loaded?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion.rb#18 RuboCop::ConfigObsoletion::LOAD_RULES_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion.rb#14 RuboCop::ConfigObsoletion::PARAMETER_RULE_CLASSES = T.let(T.unsafe(nil), Hash)</p>

<p># Base class for ConfigObsoletion rules relating to parameters # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#7 class RuboCop::ConfigObsoletion::ParameterRule &lt; ::RuboCop::ConfigObsoletion::Rule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ParameterRule] a new instance of ParameterRule</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">cop</span>, <span class="ruby-identifier">parameter</span>, <span class="ruby-identifier">metadata</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parameter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parameter_rule?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">violated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warning?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternatives</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">applies_to_current_ruby_version?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/parameter_rule.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">severity</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Encapsulation of a ConfigObsoletion rule for removing # a previously defined cop. # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#8 class RuboCop::ConfigObsoletion::RemovedCop &lt; ::RuboCop::ConfigObsoletion::CopRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [RemovedCop] a new instance of RemovedCop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">old_name</span>, <span class="ruby-identifier">metadata</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">old_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rule_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternatives</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reason</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_obsoletion/removed_cop.rb#11 RuboCop::ConfigObsoletion::RemovedCop::BASE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Encapsulation of a ConfigObsoletion rule for renaming # a cop or moving it to a new department. # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#8 class RuboCop::ConfigObsoletion::RenamedCop &lt; ::RuboCop::ConfigObsoletion::CopRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [RenamedCop] a new instance of RenamedCop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">old_name</span>, <span class="ruby-identifier">name_or_hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rule_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warning?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">moved?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">severity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/renamed_cop.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verb</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Abstract base class for ConfigObsoletion rules # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/rule.rb#7 class RuboCop::ConfigObsoletion::Rule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Rule] a new instance of Rule</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does this rule relate to cops?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_rule?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does this rule relate to parameters?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parameter_rule?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">violated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smart_loaded_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/rule.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sentence</span>(<span class="ruby-identifier">collection</span>, <span class="ruby-value">connector:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Encapsulation of a ConfigObsoletion rule for splitting a cop’s # functionality into multiple new cops. # # @api private # # source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#8 class RuboCop::ConfigObsoletion::SplitCop &lt; ::RuboCop::ConfigObsoletion::CopRule</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [SplitCop] a new instance of SplitCop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">old_name</span>, <span class="ruby-identifier">metadata</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rule_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_obsoletion/split_cop.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternatives</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class handles collecting the options for regenerating a TODO file. # # @api private # # source://rubocop//lib/rubocop/config_regeneration.rb#6 class RuboCop::ConfigRegeneration</p>

<pre class="ruby"><span class="ruby-comment"># Get options from the comment in the TODO file, and parse them as options</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_regeneration.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_regeneration.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generation_command</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_regeneration.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">todo_exists?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_regeneration.rb#7 RuboCop::ConfigRegeneration::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_regeneration.rb#8 RuboCop::ConfigRegeneration::COMMAND_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_regeneration.rb#9 RuboCop::ConfigRegeneration::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)</p>

<p># Handles caching of configurations and association of inspected # ruby files to configurations. # # source://rubocop//lib/rubocop/config_store.rb#6 class RuboCop::ConfigStore</p>

<pre class="ruby"><span class="ruby-comment"># @return [ConfigStore] a new instance of ConfigStore</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If type (file/dir) is known beforehand,</span>
<span class="ruby-comment"># prefer using #for_file or #for_dir for improved performance</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">for</span>(<span class="ruby-identifier ruby-title">file_or_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_dir</span>(<span class="ruby-identifier">dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_file</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_pwd</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_default_config!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options_config=</span>(<span class="ruby-identifier">options_config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unvalidated</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute validated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validated</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute validated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_store.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validated?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles validation of configuration, for example cop names, parameter # names, and Ruby versions. # # source://rubocop//lib/rubocop/config_validator.rb#7 class RuboCop::ConfigValidator</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [ConfigValidator] a new instance of ConfigValidator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_all_cops</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smart_loaded_path</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Validations that should only be run after all config resolving has</span>
<span class="ruby-comment"># taken place:</span>
<span class="ruby-comment"># * The target ruby version is only checked once the entire inheritance</span>
<span class="ruby-comment"># chain has been loaded so that only the final value is validated, and</span>
<span class="ruby-comment"># any obsolete but overridden values are ignored.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_after_resolution</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alert_about_unrecognized_cops</span>(<span class="ruby-identifier">invalid_cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#263</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_cop_config_value</span>(<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">parent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_obsoletions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_target_ruby</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_invalid_parameter</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">list_unknown_cops</span>(<span class="ruby-identifier">invalid_cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># FIXME: Handling colors in exception messages like this is ugly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">param_error_message</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">supposed_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject_conflicting_safe_settings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject_mutually_exclusive_defaults</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suggestion</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute target_ruby.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_enforced_styles</span>(<span class="ruby-identifier">valid_cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_new_cops_parameter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_parameter_names</span>(<span class="ruby-identifier">valid_cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_parameter_shape</span>(<span class="ruby-identifier">valid_cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_support_and_has_list</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">formats</span>, <span class="ruby-identifier">valid</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/config_validator.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_syntax_cop</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/config_validator.rb#11 RuboCop::ConfigValidator::COMMON_PARAMS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/config_validator.rb#23 RuboCop::ConfigValidator::CONFIG_CHECK_AUTOCORRECTS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/config_validator.rb#22 RuboCop::ConfigValidator::CONFIG_CHECK_DEPARTMENTS = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_validator.rb#21 RuboCop::ConfigValidator::CONFIG_CHECK_KEYS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_validator.rb#14 RuboCop::ConfigValidator::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/config_validator.rb#18 RuboCop::ConfigValidator::NEW_COPS_VALUES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/util.rb#4 module RuboCop::Cop; end</p>

<p># This module checks for nodes that should be aligned to the left or right. # This amount is determined by the instance variable @column_delta. # # source://rubocop//lib/rubocop/cop/mixin/alignment.rb#7 module RuboCop::Cop::Alignment</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_alignment</span>(<span class="ruby-identifier">items</span>, <span class="ruby-identifier">base_column</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute column_delta.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_delta</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configured_indentation_width</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_column</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_bad_alignment</span>(<span class="ruby-identifier">items</span>, <span class="ruby-identifier">base_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use processed_source.line_with_comment?(line)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_of_line_comment</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offset</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">offense_node</span>, <span class="ruby-identifier">message_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within?</span>(<span class="ruby-identifier">inner</span>, <span class="ruby-identifier">outer</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/alignment.rb#8 RuboCop::Cop::Alignment::SPACE = T.let(T.unsafe(nil), String)</p>

<p># This class does autocorrection of nodes that should just be moved to # the left or to the right, amount being determined by the instance # variable column_delta. # # source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#8 class RuboCop::Cop::AlignmentCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#29</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_end</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">align_to</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">column_delta</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute processed_source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#113</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_column</span>(<span class="ruby-identifier">align_to</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_line</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">line_begin_pos</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">column_delta</span>, <span class="ruby-identifier">taboo_ranges</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#81</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_comment_within?</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#87</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate_range</span>(<span class="ruby-identifier">expr</span>, <span class="ruby-identifier">line_begin_pos</span>, <span class="ruby-identifier">column_delta</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Some special kinds of string literals are not composed of literal</span>
  <span class="ruby-comment"># characters between two delimiters:</span>
  <span class="ruby-comment"># - The source map of `?a` responds to :begin and :end but its end is</span>
  <span class="ruby-comment">#   nil.</span>
  <span class="ruby-comment"># - The source map of `__FILE__` responds to neither :begin nor :end.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#75</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimited_string_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#99</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_line</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#60</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_string_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_string_ranges</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/alignment_corrector.rb#107</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module encapsulates the ability to allow certain identifiers in a cop. # # source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#6 module RuboCop::Cop::AllowedIdentifiers</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_identifier?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_identifiers</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># if a variable starts with a sigil it will be removed # # source://rubocop//lib/rubocop/cop/mixin/allowed_identifiers.rb#7 RuboCop::Cop::AllowedIdentifiers::SIGILS = T.let(T.unsafe(nil), String)</p>

<p># This module encapsulates the ability to allow certain methods when # parsing. Even if the code is in offense, if it contains methods # that are allowed. This module is equivalent to the IgnoredMethods module, # which will be deprecated in RuboCop 2.0. # # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#9 module RuboCop::Cop::AllowedMethods</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config_allowed_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config_deprecated_values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use allowed_method? instead</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_method?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module encapsulates the ability to ignore certain lines when # parsing. # # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#7 module RuboCop::Cop::AllowedPattern</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_line?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_patterns</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config_deprecated_methods_values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config_patterns_values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use allowed_line? instead</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_line?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches_allowed_pattern?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use matches_allowed_pattern? instead</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches_ignored_pattern?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module encapsulates the ability to allow certain receivers in a cop. # # source://rubocop//lib/rubocop/cop/mixin/allowed_receivers.rb#6 module RuboCop::Cop::AllowedReceivers</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_receivers.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_receiver?</span>(<span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_receivers.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_receivers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/allowed_receivers.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_name</span>(<span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Error raised when an unqualified cop name is used that could # refer to two or more cops under different departments # # source://rubocop//lib/rubocop/cop/registry.rb#7 class RuboCop::Cop::AmbiguousCopName &lt; ::RuboCop::Error</p>

<pre class="ruby"><span class="ruby-comment"># @return [AmbiguousCopName] a new instance of AmbiguousCopName</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">origin</span>, <span class="ruby-identifier">badges</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/registry.rb#8 RuboCop::Cop::AmbiguousCopName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Representation of an annotation comment in source code (eg. ‘# TODO: blah blah blah`). # # source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#6 class RuboCop::Cop::AnnotationComment</p>

<pre class="ruby"><span class="ruby-comment"># @param comment [Parser::Source::Comment]</span>
<span class="ruby-comment"># @param keywords [Array&lt;String&gt;]</span>
<span class="ruby-comment"># @return [AnnotationComment] a new instance of AnnotationComment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">keywords</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the range bounds for just the annotation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bounds</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute colon.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colon</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct?</span>(<span class="ruby-value">colon:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute margin.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">margin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute note.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">note</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute space.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">just_keyword_of_sentence?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_appearance?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute keywords.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keywords</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regex</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">split_comment</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/annotation_comment.rb#48 RuboCop::Cop::AnnotationComment::KEYWORDS_REGEX_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># Handles the ‘MinSize` configuration option for array-based cops # `Style/SymbolArray` and `Style/WordArray`, which check for use of the # relevant percent literal syntax such as `%<a href="...">i</a>` and `%<a href="...">w</a>` # # source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#8 module RuboCop::Cop::ArrayMinSize</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_style_detected</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">ary_size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">below_array_length?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_brackets_size</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">ary_size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_size_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_min_size.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smallest_percent_size</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">ary_size</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common code for ordinary arrays with [] that can be written with % # syntax. # # source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#7 module RuboCop::Cop::ArraySyntax</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/array_syntax.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bracketed_array_of?</span>(<span class="ruby-identifier">element_type</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># extend this module to signal autocorrection support # # source://rubocop//lib/rubocop/cop/mixin/auto_corrector.rb#6 module RuboCop::Cop::AutoCorrector</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/auto_corrector.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_autocorrect?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module encapsulates the logic for autocorrect behavior for a cop. # # source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#6 module RuboCop::Cop::AutocorrectLogic</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_requested?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_with_disable_uncorrectable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_uncorrectable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_offense</span>(<span class="ruby-identifier">offense_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_offense_at_end_of_line</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_offense_before_and_after</span>(<span class="ruby-identifier">range_by_lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_offense_with_eol_or_surround_comment</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eol_comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eol_comment_would_be_inside_literal?</span>(<span class="ruby-identifier">offense_range</span>, <span class="ruby-identifier">literal_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_with_eol_comment_too_long?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_ranges</span>(<span class="ruby-identifier">offense_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Expand the given range to include all of any lines it covers. Does not</span>
<span class="ruby-comment"># include newline at end of the last line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_by_lines</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_first_line</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_continuation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">surrounding_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/autocorrect_logic.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">surrounding_percent_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Identifier of all cops containing a department and cop name. # # All cops are identified by their badge. For example, the badge for # ‘RuboCop::Cop::Layout::IndentationStyle` is `Layout/IndentationStyle`. # Badges can be parsed as either `Department/CopName` or just `CopName` to # allow for badge references in source files that omit the department for # RuboCop to infer. # # source://rubocop//lib/rubocop/cop/badge.rb#12 class RuboCop::Cop::Badge</p>

<pre class="ruby"><span class="ruby-comment"># @return [Badge] a new instance of Badge</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">class_name_parts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop_name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute department.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute department_name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eql?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">camel_case</span>(<span class="ruby-identifier">name_part</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">for</span>(<span class="ruby-identifier ruby-title">class_name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/badge.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">identifier</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A scaffold for concrete cops. # # The Cop::Base class is meant to be extended. # # Cops track offenses and can autocorrect them on the fly. # # A commissioner object is responsible for traversing the AST and invoking # the specific callbacks on each cop. # # First the callback ‘on_new_investigation` is called; # if a cop needs to do its own processing of the AST or depends on # something else. # # Then callbacks like `on_def`, `on_send` (see AST::Traversal) are called # with their respective nodes. # # Finally the callback `on_investigation_end` is called. # # Within these callbacks, cops are meant to call `add_offense` or # `add_global_offense`. Use the `processed_source` method to # get the currently processed source being investigated. # # In case of invalid syntax / unparsable content, # the callback `on_other_file` is called instead of all the other # `on_…` callbacks. # # Private methods are not meant for custom cops consumption, # nor are any instance variables. # # source://rubocop//lib/rubocop/cop/base.rb#34 class RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">IgnoredNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutocorrectLogic</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">ExcludeLimit</span>

<span class="ruby-comment"># @return [Base] a new instance of Base</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">active_support_extensions_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds an offense that has no particular location.</span>
<span class="ruby-comment"># No correction can be applied to global offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_global_offense</span>(<span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">severity:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds an offense on the specified range (or node with an expression)</span>
<span class="ruby-comment"># Unless that offense is disabled for this range, a corrector will be yielded</span>
<span class="ruby-comment"># to provide the cop the opportunity to autocorrect the offense.</span>
<span class="ruby-comment"># If message is not specified, the method `message` will be called.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense</span>(<span class="ruby-identifier">node_or_range</span>, <span class="ruby-value">message:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">severity:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#357</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called before any investigation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#343</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_investigation</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">original:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callbacks_needed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_to_allow_offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_to_allow_offenses=</span>(<span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contextual_autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Configuration Helpers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excluded_file?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This method should be overridden when a cop&#39;s behavior depends</span>
<span class="ruby-comment"># on state that lives outside of these locations:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   (1) the file under inspection</span>
<span class="ruby-comment">#   (2) the cop&#39;s source code</span>
<span class="ruby-comment">#   (3) the config (eg a .rubocop.yml file)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># For example, some cops may want to look at other parts of</span>
<span class="ruby-comment"># the codebase being inspected to find violations. A cop may</span>
<span class="ruby-comment"># use the presence or absence of file `foo.rb` to determine</span>
<span class="ruby-comment"># whether a certain violation exists in `bar.rb`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Overriding this method allows the cop to indicate to RuboCop&#39;s</span>
<span class="ruby-comment"># ResultCache system when those external dependencies change,</span>
<span class="ruby-comment"># ie when the ResultCache should be invalidated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">external_dependency_checksum</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#367</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gets called if no message is specified when calling `add_offense` or</span>
<span class="ruby-comment"># `add_global_offense`</span>
<span class="ruby-comment"># Cops are discouraged to override this; instead pass your message directly</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Make potential errors with previous API more obvious</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called after all on_... have been called</span>
<span class="ruby-comment"># When refining this method, always call `super`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_investigation_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called before all on_... have been called</span>
<span class="ruby-comment"># When refining this method, always call `super`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called instead of all on_... callbacks for unrecognized files / syntax errors</span>
<span class="ruby-comment"># When refining this method, always call `super`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_other_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># There should be very limited reasons for a Cop to do it&#39;s own parsing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#300</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">path</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_engine</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute processed_source.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called between investigations</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ready</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_file?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literals_frozen_by_default?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a gems locked versions (i.e. from Gemfile.lock or gems.locked)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_gem_version</span>(<span class="ruby-identifier">gem_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_rails_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#485</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotate</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#379</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_correction</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Symbol] offense status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attempt_correction</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reserved for Cop::Cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_argument</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called to complete an investigation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Symbol, Corrector] offense status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#423</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#393</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_corrector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reserved for Commissioner:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_offense_locations</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#397</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">currently_disabled_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#513</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">custom_severity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#509</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_severity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#463</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_uncorrectable</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#499</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled_line?</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#491</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_name_matches_any?</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">parameter</span>, <span class="ruby-identifier">default_result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_message</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#505</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_severity</span>(<span class="ruby-identifier">_range</span>, <span class="ruby-identifier">severity</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#526</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_original</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#470</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_from_node_or_range</span>(<span class="ruby-identifier">node_or_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Actually private methods</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#534</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_satisfies_all_gem_version_requirements?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Symbol] offense status</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#438</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_corrector</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># List of cops that should not try to autocorrect at the same</span>
  <span class="ruby-comment"># time as this cop</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api public</span>
  <span class="ruby-comment"># @return [Array&lt;RuboCop::Cop::Base&gt;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#59</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Naming</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#93</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">badge</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#329</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callbacks_needed</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#97</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#101</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns a url to view this cops documentation online.</span>
  <span class="ruby-comment"># Requires &#39;DocumentationBaseURL&#39; to be set for your department.</span>
  <span class="ruby-comment"># Will follow the convention of RuboCops own documentation structure,</span>
  <span class="ruby-comment"># overwrite this method to accommodate your custom layout.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api public</span>
  <span class="ruby-comment"># @return [String, nil]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#70</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">documentation_url</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Call for abstract Cop classes</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#81</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclude_from_registry</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute gem_requirements.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#138</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_requirements</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#74</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">subclass</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Override and return the Force class(es) you need to join</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#118</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#105</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lint?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns true if the cop name or the cop namespace matches any of the</span>
  <span class="ruby-comment"># given names.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#111</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">given_names</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Register a version requirement for the given gem name.</span>
  <span class="ruby-comment"># This cop will be skipped unless the target satisfies *all* requirements.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api public</span>
  <span class="ruby-comment"># @param gem_name [String]</span>
  <span class="ruby-comment"># @param version_requirements [Array&lt;String&gt;] The version requirements,</span>
  <span class="ruby-comment">#   using the same syntax as a Gemfile, e.g. &quot;&gt;= 1.2.3&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   If omitted, any version of the gem will be accepted.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   https://guides.rubygems.org/patterns/#declaring-dependencies</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#151</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_gem</span>(<span class="ruby-identifier">gem_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">version_requirements</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns if class supports autocorrect.</span>
  <span class="ruby-comment"># It is recommended to extend AutoCorrector instead of overriding</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#87</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_autocorrect?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Override if your cop should be called repeatedly for multiple investigations</span>
  <span class="ruby-comment"># Between calls to `on_new_investigation` and `on_investigation_end`,</span>
  <span class="ruby-comment"># the result of `processed_source` will remain constant.</span>
  <span class="ruby-comment"># You should invalidate any caches that depend on the current `processed_source`</span>
  <span class="ruby-comment"># in the `on_new_investigation` callback.</span>
  <span class="ruby-comment"># If your cop does autocorrections, be aware that your instance may be called</span>
  <span class="ruby-comment"># multiple times with the same `processed_source.path` but different content.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#129</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_multiple_source?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#401</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restrict_on_send</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/base.rb#405 RuboCop::Cop::Base::EMPTY_OFFENSES = T.let(T.unsafe(nil), Array)</p>

<p># Reports of an investigation. # Immutable # Consider creation API private # # source://rubocop//lib/rubocop/cop/base.rb#48 class RuboCop::Cop::Base::InvestigationReport &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute cop to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute corrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of corrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute corrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute corrector to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrector=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute offenses to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute processed_source to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/base.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># List of methods names to restrict calls for ‘on_send` / `on_csend` # # source://rubocop//lib/rubocop/cop/base.rb#51 RuboCop::Cop::Base::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#5 module RuboCop::Cop::Bundler; end</p>

<p># A Gem’s requirements should be listed only once in a <a href="../../../Gemfile.html">Gemfile</a>. # # @example #   # bad #   gem ‘rubocop’ #   gem ‘rubocop’ # #   # bad #   group :development do #   gem ‘rubocop’ #   end # #   group :test do #   gem ‘rubocop’ #   end # #   # good #   group :development, :test do #   gem ‘rubocop’ #   end # #   # good #   gem ‘rubocop’, groups: [:development, :test] # #   # good - conditional declaration #   if Dir.exist?(local) #   gem ‘rubocop’, path: local #   elsif <a href="&#39;RUBOCOP_VERSION&#39;">ENV</a> == ‘master’ #   gem ‘rubocop’, git: ‘<a href="https://github.com/rubocop/rubocop.git">github.com/rubocop/rubocop.git</a>’ #   else #   gem ‘rubocop’, ‘~&gt; 0.90.0’ #   end # # source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#39 class RuboCop::Cop::Bundler::DuplicatedGem &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_declaration?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicated_gem_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">gem_name</span>, <span class="ruby-identifier">line_of_first_occurrence</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_conditional?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">conditional_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/duplicated_gem.rb#42 RuboCop::Cop::Bundler::DuplicatedGem::MSG = T.let(T.unsafe(nil), String)</p>

<p># A Gem group, or a set of groups, should be listed only once in a <a href="../../../Gemfile.html">Gemfile</a>. # # For example, if the values of ‘source`, `git`, `platforms`, or `path` # surrounding `group` are different, no offense will be registered: # # [source,ruby] # —– # platforms :ruby do #   group :default do #     gem ’openssl’ #   end # end # # platforms :jruby do #   group :default do #     gem ‘jruby-openssl’ #   end # end # —– # # @example #   # bad #   group :development do #   gem ‘rubocop’ #   end # #   group :development do #   gem ‘rubocop-rails’ #   end # #   # bad (same set of groups declared twice) #   group :development, :test do #   gem ‘rubocop’ #   end # #   group :test, :development do #   gem ‘rspec’ #   end # #   # good #   group :development do #   gem ‘rubocop’ #   end # #   group :development, :test do #   gem ‘rspec’ #   end # #   # good #   gem ‘rubocop’, groups: [:development, :test] #   gem ‘rspec’, groups: [:development, :test] # # source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#58 class RuboCop::Cop::Bundler::DuplicatedGroup &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicated_group_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_source_key</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_attributes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">group_name</span>, <span class="ruby-identifier">line_of_first_occurrence</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#61 RuboCop::Cop::Bundler::DuplicatedGroup::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/duplicated_group.rb#63 RuboCop::Cop::Bundler::DuplicatedGroup::SOURCE_BLOCK_NAMES = T.let(T.unsafe(nil), Array)</p>

<p># Each gem in the <a href="../../../Gemfile.html">Gemfile</a> should have a comment explaining # its purpose in the project, or the reason for its version # or source. # # The optional “OnlyFor” configuration array # can be used to only register offenses when the gems # use certain options or have version specifiers. # # When “version_specifiers” is included, a comment # will be enforced if the gem has any version specifier. # # When “restrictive_version_specifiers” is included, a comment # will be enforced if the gem has a version specifier that # holds back the version of the gem. # # For any other value in the array, a comment will be enforced for # a gem if an option by the same name is present. # A useful use case is to enforce a comment when using # options that change the source of a gem: # # - ‘bitbucket` # - `gist` # - `git` # - `github` # - `source` # # For a full list of options supported by bundler, # see <a href="https://bundler.io/man/gemfile.5.html">bundler.io/man/gemfile.5.html</a> # . # # @example OnlyFor: [] (default) #   # bad # #   gem ’foo’ # #   # good # #   # Helpers for the foo things. #   gem ‘foo’ # @example OnlyFor: [‘version_specifiers’] #   # bad # #   gem ‘foo’, ‘&lt; 2.1’ # #   # good # #   # Version 2.1 introduces breaking change baz #   gem ‘foo’, ‘&lt; 2.1’ # @example OnlyFor: [‘restrictive_version_specifiers’] #   # bad # #   gem ‘foo’, ‘&lt; 2.1’ # #   # good # #   gem ‘foo’, ‘&gt;= 1.0’ # #   # Version 2.1 introduces breaking change baz #   gem ‘foo’, ‘&lt; 2.1’ # @example OnlyFor: [‘version_specifiers’, ‘github’] #   # bad # #   gem ‘foo’, github: ‘some_account/some_fork_of_foo’ # #   gem ‘bar’, ‘&lt; 2.1’ # #   # good # #   # Using this fork because baz #   gem ‘foo’, github: ‘some_account/some_fork_of_foo’ # #   # Version 2.1 introduces breaking change baz #   gem ‘bar’, ‘&lt; 2.1’ # # source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#83 class RuboCop::Cop::Bundler::GemComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DefNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemDeclaration</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">checked_options_present?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">commented?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">commented_any_descendant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_checked_options?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_options</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_gem?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The args node1 &amp; node2 may represent a RuboCop::AST::Node</span>
<span class="ruby-comment"># or a Parser::Source::Comment. Both respond to #loc.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">precede?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_comment?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Version specifications that restrict all updates going forward. This excludes versions</span>
<span class="ruby-comment"># like &quot;&gt;= 1.0&quot; or &quot;!= 2.0.3&quot;.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restrictive_version_specified_gem?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Besides the gem name, all other *positional* arguments to `gem` are version specifiers,</span>
<span class="ruby-comment"># as long as it has one we know there&#39;s at least one version specifier.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_specified_gem?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#88 RuboCop::Cop::Bundler::GemComment::CHECKED_OPTIONS_CONFIG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#87 RuboCop::Cop::Bundler::GemComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#91 RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#90 RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#92 RuboCop::Cop::Bundler::GemComment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_comment.rb#89 RuboCop::Cop::Bundler::GemComment::VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)</p>

<p># Verifies that a project contains <a href="../../../Gemfile.html">Gemfile</a> or gems.rb file and correct # associated lock file based on the configuration. # # @example EnforcedStyle: <a href="../../../Gemfile.html">Gemfile</a> (default) #   # bad #   Project contains gems.rb and gems.locked files # #   # bad #   Project contains <a href="../../../Gemfile.html">Gemfile</a> and gems.locked file # #   # good #   Project contains <a href="../../../Gemfile.html">Gemfile</a> and <a href="../../../Gemfile_lock.html">Gemfile.lock</a> # @example EnforcedStyle: gems.rb #   # bad #   Project contains <a href="../../../Gemfile.html">Gemfile</a> and <a href="../../../Gemfile_lock.html">Gemfile.lock</a> files # #   # bad #   Project contains gems.rb and <a href="../../../Gemfile_lock.html">Gemfile.lock</a> file # #   # good #   Project contains gems.rb and gems.locked files # # source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#28 class RuboCop::Cop::Bundler::GemFilename &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_gemfile?</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gemfile_offense?</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gemfile_required?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gems_rb_offense?</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gems_rb_required?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_gemfile_offense</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_gems_rb_offense</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#39 RuboCop::Cop::Bundler::GemFilename::GEMFILE_FILES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#40 RuboCop::Cop::Bundler::GemFilename::GEMS_RB_FILES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#35 RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_MISMATCHED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#31 RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_REQUIRED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#37 RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_MISMATCHED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_filename.rb#33 RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_REQUIRED = T.let(T.unsafe(nil), String)</p>

<p># Enforce that Gem version specifications or a commit reference (branch, # ref, or tag) are either required or forbidden. # # @example EnforcedStyle: required (default) #   # bad #   gem ‘rubocop’ # #   # good #   gem ‘rubocop’, ‘~&gt; 1.12’ # #   # good #   gem ‘rubocop’, ‘&gt;= 1.10.0’ # #   # good #   gem ‘rubocop’, ‘&gt;= 1.5.0’, ‘&lt; 1.10.0’ # #   # good #   gem ‘rubocop’, branch: ‘feature-branch’ # #   # good #   gem ‘rubocop’, ref: ‘74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b’ # #   # good #   gem ‘rubocop’, tag: ‘v1.17.0’ # @example EnforcedStyle: forbidden #   # good #   gem ‘rubocop’ # #   # bad #   gem ‘rubocop’, ‘~&gt; 1.12’ # #   # bad #   gem ‘rubocop’, ‘&gt;= 1.10.0’ # #   # bad #   gem ‘rubocop’, ‘&gt;= 1.5.0’, ‘&lt; 1.10.0’ # #   # bad #   gem ‘rubocop’, branch: ‘feature-branch’ # #   # bad #   gem ‘rubocop’, ref: ‘74b5bfbb2c4b6fd6cdbbc7254bd7084b36e0c85b’ # #   # bad #   gem ‘rubocop’, tag: ‘v1.17.0’ # # source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#53 class RuboCop::Cop::Bundler::GemVersion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemDeclaration</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">includes_commit_reference?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">includes_version_specification?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_gem?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_gems</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_specification?</span>(<span class="ruby-identifier">expression</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#58 RuboCop::Cop::Bundler::GemVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#57 RuboCop::Cop::Bundler::GemVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#59 RuboCop::Cop::Bundler::GemVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/gem_version.rb#60 RuboCop::Cop::Bundler::GemVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Passing symbol arguments to ‘source` (e.g. `source :rubygems`) is # deprecated because they default to using HTTP requests. Instead, specify # `’<a href="https://rubygems.org">rubygems.org</a>’‘ if possible, or `’<a href="http://rubygems.org">rubygems.org</a>’‘ if not. # # When autocorrecting, this cop will replace symbol arguments with # `’<a href="https://rubygems.org">rubygems.org</a>’‘. # # This cop will not replace existing sources that use `http://`. This may # be necessary where HTTPS is not available. For example, where using an # internal gem server via an intranet, or where HTTPS is prohibited. # However, you should strongly prefer `https://` where possible, as it is # more secure. # # If you don’t allow ‘http://`, please set `false` to `AllowHttpProtocol`. # This option is `true` by default for safe autocorrection. # # @example #   # bad #   source :gemcutter #   source :rubygems #   source :rubyforge # #   # good #   source ’<a href="https://rubygems.org">rubygems.org</a>’ # strongly recommended # @example AllowHttpProtocol: true (default) # #   # good #   source ‘<a href="http://rubygems.org">rubygems.org</a>’ # use only if HTTPS is unavailable # @example AllowHttpProtocol: false # #   # bad #   source ‘<a href="http://rubygems.org">rubygems.org</a>’ # # source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#41 class RuboCop::Cop::Bundler::InsecureProtocolSource &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insecure_protocol_source?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_http_protocol?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#44 RuboCop::Cop::Bundler::InsecureProtocolSource::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#48 RuboCop::Cop::Bundler::InsecureProtocolSource::MSG_HTTP_PROTOCOL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/bundler/insecure_protocol_source.rb#50 RuboCop::Cop::Bundler::InsecureProtocolSource::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Gems should be alphabetically sorted within groups. # # @example #   # bad #   gem ‘rubocop’ #   gem ‘rspec’ # #   # good #   gem ‘rspec’ #   gem ‘rubocop’ # #   # good #   gem ‘rubocop’ # #   gem ‘rspec’ # @example TreatCommentsAsGroupSeparators: true (default) #   # good #   # For code quality #   gem ‘rubocop’ #   # For tests #   gem ‘rspec’ # @example TreatCommentsAsGroupSeparators: false #   # bad #   # For code quality #   gem ‘rubocop’ #   # For tests #   gem ‘rspec’ # # source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#35 class RuboCop::Cop::Bundler::OrderedGems &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedGemNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_declaration</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/bundler/ordered_gems.rb#39 RuboCop::Cop::Bundler::OrderedGems::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking assignment nodes. # # source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#6 module RuboCop::Cop::CheckAssignment</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_assignment.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This mixin detects collections that are safe to “break” # by inserting new lines. This is useful for breaking # up long lines. # # Let’s look at hashes as an example: # # We know hash keys are safe to break across lines. We can add # linebreaks into hashes on lines longer than the specified maximum. # Then in further passes cops can clean up the multi-line hash. # For example, say the maximum line length is as indicated below: # #                                         | #                                         v # {foo: “0000000000”, bar: “0000000000”, baz: “0000000000”} # # In a LineLength autocorrection pass, a line is added before # the first key that exceeds the column limit: # # {foo: “0000000000”, bar: “0000000000”, # baz: “0000000000”} # # In a MultilineHashKeyLineBreaks pass, lines are inserted # before all keys: # # {foo: “0000000000”, # bar: “0000000000”, # baz: “0000000000”} # # Then in future passes FirstHashElementLineBreak, # MultilineHashBraceLayout, and TrailingCommaInHashLiteral will # manipulate as well until we get: # # { #   foo: “0000000000”, #   bar: “0000000000”, #   baz: “0000000000”, # } # # (Note: Passes may not happen exactly in this sequence.) # # source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#44 module RuboCop::Cop::CheckLineBreakable</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_breakable_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">max</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_on_same_line?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">already_on_multiple_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_collection?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_to_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children_could_be_broken_up?</span>(<span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contained_by_breakable_collection_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contained_by_multiline_collection_that_could_be_broken_up?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_breakable_node_from_elements</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">max</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_first_element_over_column_limit</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">max</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_is_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_args</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_to_ignore?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If a `send` or `csend` node contains a heredoc argument, splitting cannot happen</span>
<span class="ruby-comment"># after the heredoc or else it will cause a syntax error.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shift_elements_for_heredoc_arg</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_line_breakable.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_column_limit?</span>(<span class="ruby-identifier">element</span>, <span class="ruby-identifier">max</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for code on multiple lines that could be rewritten on a single line # without changing semantics or exceeding the ‘Max` parameter of `Layout/LineLength`. # # source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#7 module RuboCop::Cop::CheckSingleLineSuitability</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suitable_as_single_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_within?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_to_split?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_single_line</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/check_single_line_suitability.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking length of code segments. # # source://rubocop//lib/rubocop/cop/mixin/code_length.rb#6 module RuboCop::Cop::CodeLength</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">ExcludeLimit</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_code_length_calculator</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_code_length</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_as_one</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_comments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true for lines that shall not be included in the count.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">irrelevant_line</span>(<span class="ruby-identifier">source_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">length</span>, <span class="ruby-identifier">max_length</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/code_length.rb#9 RuboCop::Cop::CodeLength::MSG = T.let(T.unsafe(nil), String)</p>

<p># Help methods for working with nodes containing comments. # # source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#6 module RuboCop::Cop::CommentsHelp</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_contain_disables?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_in_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_comments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range_with_comment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos_with_comment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_position_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the end line of a node, which might be a comment and not part of the AST</span>
<span class="ruby-comment"># End line is considered either the line at which another node starts, or</span>
<span class="ruby-comment"># the line at which the parent node ends.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_end_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/comments_help.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_line_position</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Commissioner class is responsible for processing the AST and delegating # work to the specified cops. # # source://rubocop//lib/rubocop/cop/commissioner.rb#7 class RuboCop::Cop::Commissioner</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Traversal</span>

<span class="ruby-comment"># @return [Commissioner] a new instance of Commissioner</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">cops</span>, <span class="ruby-identifier">forces</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute errors.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [InvestigationReport]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">original:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___ENCODING__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___FILE__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___LINE__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_alias</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg_expr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array_pattern_with_tail</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_back_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block_pass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_blockarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_break</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cbase</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_complex</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dsym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_eflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_empty_else</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_false</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_find_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_float</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forward_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forward_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_kwrestarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_restarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_iflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_index</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_indexasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_int</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwargs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwnilarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwrestarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwsplat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lambda</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_alt</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_as</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_current_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_nil_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern_p</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_rest</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_var</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_with_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_with_trailing_comma</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_mlhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_next</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nil</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_not</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nth_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_optarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_postexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_preexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_procarg0</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rational</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_redo</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regopt</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_restarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_retry</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_self</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_shadowarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_splat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_true</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_undef</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_unless_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_zsuper</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_investigation</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span>, <span class="ruby-value">original:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_callbacks</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_callbacks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invoke</span>(<span class="ruby-identifier">callback</span>, <span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invoke_with_argument</span>(<span class="ruby-identifier">callback</span>, <span class="ruby-identifier">cops</span>, <span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restrict_callbacks</span>(<span class="ruby-identifier">callbacks</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># NOTE: mutates `callbacks` in place</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restricted_map</span>(<span class="ruby-identifier">callbacks</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trigger_responding_cops</span>(<span class="ruby-identifier">callback</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trigger_restricted_cops</span>(<span class="ruby-identifier">event</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Allow blind rescues here, since we&#39;re absorbing and packaging or</span>
<span class="ruby-comment"># re-raising exceptions that can be raised from within the individual</span>
<span class="ruby-comment"># cops&#39; `#investigate` methods.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_cop_error_handling</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># How a Commissioner returns the results of the investigation # as a list of Cop::InvestigationReport and any errors caught # during the investigation. # Immutable # Consider creation API private # # source://rubocop//lib/rubocop/cop/commissioner.rb#18 class RuboCop::Cop::Commissioner::InvestigationReport &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute cop_reports</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of cop_reports</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_reports</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute cop_reports</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute cop_reports to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_reports=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute errors</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of errors</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute errors</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute errors to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge</span>(<span class="ruby-identifier">investigation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_per_cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute processed_source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute processed_source to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/commissioner.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/commissioner.rb#10 RuboCop::Cop::Commissioner::RESTRICTED_CALLBACKS = T.let(T.unsafe(nil), Array)</p>

<p># This class does condition autocorrection # # source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#6 class RuboCop::Cop::ConditionCorrector</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_negative_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/condition_corrector.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negated_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles ‘EnforcedStyle` configuration parameters. # # source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#6 module RuboCop::Cop::ConfigurableEnforcedStyle</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative_styles</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_style_detected</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">possibilities</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conflicting_styles_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_style=</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_acceptable_style!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_acceptable_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite_style_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_configured?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_detected</span>(<span class="ruby-identifier">detected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_styles</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unexpected_style_detected</span>(<span class="ruby-identifier">unexpected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unrecognized_style_detected</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/configurable_enforced_style.rb#23 RuboCop::Cop::ConfigurableEnforcedStyle::SYMBOL_TO_STRING_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># Shared functionality between mixins that enforce naming conventions # # source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#6 module RuboCop::Cop::ConfigurableFormatting</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_name</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">name_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A class emitter method is a singleton method in a class/module, where</span>
<span class="ruby-comment"># the method has the same name as a class defined in the class/module.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_emitter_method?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_opposing_styles</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_formatting.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_name?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">given_style</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles ‘Max` configuration parameters, especially setting them to an # appropriate value with –auto-gen-config. # # @deprecated Use `exclude_limit &lt;ParameterName&gt;` instead. # # source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#8 module RuboCop::Cop::ConfigurableMax</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/configurable_max.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_parameter_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module provides functionality for checking if names match the # configured EnforcedStyle. # # source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#7 module RuboCop::Cop::ConfigurableNaming</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableFormatting</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/configurable_naming.rb#10 RuboCop::Cop::ConfigurableNaming::FORMATS = T.let(T.unsafe(nil), Hash)</p>

<p># This module provides functionality for checking if numbering match the # configured EnforcedStyle. # # source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#7 module RuboCop::Cop::ConfigurableNumbering</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableFormatting</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/configurable_numbering.rb#11 RuboCop::Cop::ConfigurableNumbering::FORMATS = T.let(T.unsafe(nil), Hash)</p>

<p># Monkey-patch Cop for tests to provide easy access to messages and # highlights. # # source://rubocop//lib/rubocop/cop/cop.rb#11 class RuboCop::Cop::Cop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense</span>(<span class="ruby-identifier">node_or_range</span>, <span class="ruby-value">location:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">message:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">severity:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called before any investigation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_investigation</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">original:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrections</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_location</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offenses.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called after all on_... have been called</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_investigation_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Called before all on_... have been called</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use class method</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_correction</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Override Base</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_argument</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_lambda</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dedupe_on_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Just for legacy</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield [corrector]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emulate_v0_callsequence</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_original</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suppress_clobbering</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @deprecated Use Registry.all</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#56</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">_subclass</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @deprecated Use Registry.qualified_cop_name</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#65</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_cop_name</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">origin</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @deprecated Use Registry.global</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#33</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_autocorrect?</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @deprecated # # source://rubocop//lib/rubocop/cop/cop.rb#17 class RuboCop::Cop::Cop::Correction &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute cop to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute lambda</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of lambda</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute lambda</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute lambda to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute node to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/cop.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class takes a source buffer and rewrite its source # based on the different correction rules supplied. # # Important! # The nodes modified by the corrections should be part of the # AST of the source_buffer. # # source://rubocop//lib/rubocop/cop/corrector.rb#11 class RuboCop::Cop::Corrector &lt; ::Parser::Source::TreeRewriter</p>

<pre class="ruby"><span class="ruby-comment"># corrector = Corrector.new(cop)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param source [Parser::Source::Buffer, or anything</span>
<span class="ruby-comment"># leading to one via `(processed_source.)buffer`]</span>
<span class="ruby-comment"># @return [Corrector] a new instance of Corrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes `size` characters from the beginning of the given range.</span>
<span class="ruby-comment"># If `size` is greater than the size of `range`, the removed region can</span>
<span class="ruby-comment"># overrun the end of `range`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param range [Parser::Source::Range, RuboCop::AST::Node] or node</span>
<span class="ruby-comment"># @param size [Integer]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_leading</span>(<span class="ruby-identifier">node_or_range</span>, <span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes `size` characters prior to the source range.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param range [Parser::Source::Range, RuboCop::AST::Node] or node</span>
<span class="ruby-comment"># @param size [Integer]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_preceding</span>(<span class="ruby-identifier">node_or_range</span>, <span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Removes `size` characters from the end of the given range.</span>
<span class="ruby-comment"># If `size` is greater than the size of `range`, the removed region can</span>
<span class="ruby-comment"># overrun the beginning of `range`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param range [Parser::Source::Range, RuboCop::AST::Node] or node</span>
<span class="ruby-comment"># @param size [Integer]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_trailing</span>(<span class="ruby-identifier">node_or_range</span>, <span class="ruby-identifier">size</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Legacy</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rewrite</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Swaps sources at the given ranges.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node_or_range1 [Parser::Source::Range, RuboCop::AST::Node]</span>
<span class="ruby-comment"># @param node_or_range2 [Parser::Source::Range, RuboCop::AST::Node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap</span>(<span class="ruby-identifier">node_or_range1</span>, <span class="ruby-identifier">node_or_range2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_range_validity</span>(<span class="ruby-identifier">node_or_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_range</span>(<span class="ruby-identifier">node_or_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_buffer</span>(<span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Duck typing for get to a ::Parser::Source::Buffer</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/corrector.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_buffer</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># noop # # source://rubocop//lib/rubocop/cop/corrector.rb#12 RuboCop::Cop::Corrector::NOOP_CONSUMER = T.let(T.unsafe(nil), Proc)</p>

<p># Common functionality for checking def nodes. # # source://rubocop//lib/rubocop/cop/mixin/def_node.rb#6 module RuboCop::Cop::DefNode</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/def_node.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_public_modifier?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/def_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_public?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/def_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_non_public_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Help methods for working with ‘Enumerable#dig` in cops. # Used by `Style::DigChain` and `Style::SingleArgumentDig` # # source://rubocop//lib/rubocop/cop/mixin/dig_help.rb#7 module RuboCop::Cop::DigHelp</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/dig_help.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/dig_help.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_argument_dig?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/dig_help.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig_chain_enabled?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Helpers for builtin documentation # # source://rubocop//lib/rubocop/cop/documentation.rb#6 module RuboCop::Cop::Documentation</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_url_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">builtin?</span>(<span class="ruby-identifier">cop_class</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_base_url</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_extension</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_to_basename</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extension_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">url_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_url_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#57</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">builtin?</span>(<span class="ruby-identifier">cop_class</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_base_url</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_extension</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_to_basename</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extension_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/documentation.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">url_for</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking documentation. # # source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#6 module RuboCop::Cop::DocumentationComment</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotation_keywords</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">documentation_comment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpreter_directive_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The args node1 &amp; node2 may represent a RuboCop::AST::Node</span>
<span class="ruby-comment"># or a Parser::Source::Comment. Both respond to #loc.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">precede?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The args node1 &amp; node2 may represent a RuboCop::AST::Node</span>
<span class="ruby-comment"># or a Parser::Source::Comment. Both respond to #loc.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_comment?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/documentation_comment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_directive_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for dealing with duplication. # # source://rubocop//lib/rubocop/cop/mixin/duplication.rb#6 module RuboCop::Cop::Duplication</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns the consecutive duplicates, leaving out the first instance of</span>
<span class="ruby-comment"># the duplicated elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param collection [Array] an array to return consecutive duplicates for</span>
<span class="ruby-comment"># @return [Array] the consecutive duplicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/duplication.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consecutive_duplicates</span>(<span class="ruby-identifier">collection</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns all duplicates, including the first instance of the duplicated</span>
<span class="ruby-comment"># elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param collection [Array] an array to return duplicates for</span>
<span class="ruby-comment"># @return [Array] all the duplicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/duplication.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicates</span>(<span class="ruby-identifier">collection</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Whether the `collection` contains any duplicates.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param collection [Array] an array to check for duplicates</span>
<span class="ruby-comment"># @return [Boolean] whether the array contains any duplicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/duplication.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicates?</span>(<span class="ruby-identifier">collection</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a hash of grouped duplicates. The key will be the first</span>
<span class="ruby-comment"># instance of the element, and  the value an `array` of the initial</span>
<span class="ruby-comment"># element and all duplicate instances.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param collection [Array] an array to group duplicates for</span>
<span class="ruby-comment"># @return [Array] the grouped duplicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/duplication.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grouped_duplicates</span>(<span class="ruby-identifier">collection</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class autocorrects ‘#each` enumeration to `for` iteration. # # source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#6 class RuboCop::Cop::EachToForCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [EachToForCorrector] a new instance of EachToForCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns the value of attribute argument_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute block_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute collection_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#10 RuboCop::Cop::EachToForCorrector::CORRECTION_WITHOUT_ARGUMENTS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/correctors/each_to_for_corrector.rb#9 RuboCop::Cop::EachToForCorrector::CORRECTION_WITH_ARGUMENTS = T.let(T.unsafe(nil), String)</p>

<p># This class does empty line autocorrection # # source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#6 class RuboCop::Cop::EmptyLineCorrector</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/empty_line_corrector.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_before</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common code for empty parameter cops. # # source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#6 module RuboCop::Cop::EmptyParameter</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_arguments?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_parameter.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Functions for checking the alignment of the ‘end` keyword. # # source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#6 module RuboCop::Cop::EndKeywordAlignment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_end_kw_alignment?</span>(<span class="ruby-identifier">end_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_misalignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">align_with</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_end_kw_alignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">align_ranges</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_end_kw_in_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_break_before_keyword?</span>(<span class="ruby-identifier">whole_expression</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_ranges</span>(<span class="ruby-identifier">end_loc</span>, <span class="ruby-identifier">align_ranges</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_line_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_alignment?</span>(<span class="ruby-identifier">whole_expression</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">end_alignment_style</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/end_keyword_alignment.rb#10 RuboCop::Cop::EndKeywordAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for rewriting endless methods to normal method definitions # # source://rubocop//lib/rubocop/cop/mixin/endless_method_rewriter.rb#6 module RuboCop::Cop::EndlessMethodRewriter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/endless_method_rewriter.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_multiline</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/endless_method_rewriter.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">missing</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking for a line break before the first # element in a multi-line collection. # # source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#7 module RuboCop::Cop::FirstElementLineBreak</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_children_line_break</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">children</span>, <span class="ruby-identifier">start</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">ignore_last:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_method_line_break</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">children</span>, <span class="ruby-value">ignore_last:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_by_line</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-value">ignore_last:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/first_element_line_break.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_uses_parens?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">limit</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class autocorrects ‘for` iteration to `#each` enumeration. # # source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#6 class RuboCop::Cop::ForToEachCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [ForToEachCorrector] a new instance of ForToEachCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">for_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute collection_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute for_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_begin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parentheses?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute variable_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_node</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/correctors/for_to_each_corrector.rb#9 RuboCop::Cop::ForToEachCorrector::CORRECTION = T.let(T.unsafe(nil), String)</p>

<p># This module encapsulates the ability to forbid certain identifiers in a cop. # # source://rubocop//lib/rubocop/cop/mixin/forbidden_identifiers.rb#6 module RuboCop::Cop::ForbiddenIdentifiers</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/forbidden_identifiers.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_identifier?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/forbidden_identifiers.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_identifiers</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># if a variable starts with a sigil it will be removed # # source://rubocop//lib/rubocop/cop/mixin/forbidden_identifiers.rb#7 RuboCop::Cop::ForbiddenIdentifiers::SIGILS = T.let(T.unsafe(nil), String)</p>

<p># This module encapsulates the ability to forbid certain patterns in a cop. # # source://rubocop//lib/rubocop/cop/mixin/forbidden_pattern.rb#6 module RuboCop::Cop::ForbiddenPattern</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/forbidden_pattern.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_pattern?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/forbidden_pattern.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_patterns</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A scaffold for concrete forces. # # source://rubocop//lib/rubocop/cop/force.rb#6 class RuboCop::Cop::Force</p>

<pre class="ruby"><span class="ruby-comment"># @return [Force] a new instance of Force</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cops.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">_processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_hook</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#19</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_name</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">subclass</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/force.rb#8 class RuboCop::Cop::Force::HookError &lt; ::StandardError</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [HookError] a new instance of HookError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">joining_cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/force.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_cop</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for dealing with frozen string literals. # # source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#6 module RuboCop::Cop::FrozenStringLiteral</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal_comment_exists?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal_specified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literals_disabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literals_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_comment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_magic_comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uninterpolated_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uninterpolated_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal_comment_exists?</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#9 RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_ENABLED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/frozen_string_literal.rb#10 RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_TYPES_RUBY27 = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for checking gem declarations. # # source://rubocop//lib/rubocop/cop/mixin/gem_declaration.rb#6 module RuboCop::Cop::GemDeclaration</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gem_declaration.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_declaration?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/add_runtime_dependency.rb#5 module RuboCop::Cop::Gemspec; end</p>

<p># Prefer ‘add_dependency` over `add_runtime_dependency` as the latter is # considered soft-deprecated. # # @example # #   # bad #   Gem::Specification.new do |spec| #   spec.add_runtime_dependency(’rubocop’) #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_dependency(‘rubocop’) #   end # # source://rubocop//lib/rubocop/cop/gemspec/add_runtime_dependency.rb#21 class RuboCop::Cop::Gemspec::AddRuntimeDependency &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/add_runtime_dependency.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/add_runtime_dependency.rb#24 RuboCop::Cop::Gemspec::AddRuntimeDependency::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/add_runtime_dependency.rb#26 RuboCop::Cop::Gemspec::AddRuntimeDependency::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Use consistent style for Gemspec attributes assignment. # # @example # #   # bad #   # This example uses two styles for assignment of metadata attribute. #   Gem::Specification.new do |spec| #   spec.metadata = { ‘key’ =&gt; ‘value’ } #   <a href="&#39;another-key&#39;">spec.metadata</a> = ‘another-value’ #   end # #   # good #   Gem::Specification.new do |spec| #   <a href="&#39;key&#39;">spec.metadata</a> = ‘value’ #   <a href="&#39;another-key&#39;">spec.metadata</a> = ‘another-value’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.metadata = { ‘key’ =&gt; ‘value’, ‘another-key’ =&gt; ‘another-value’ } #   end # #   # bad #   # This example uses two styles for assignment of authors attribute. #   Gem::Specification.new do |spec| #   spec.authors = %w[author-0 author-1] #   <a href="2">spec.authors</a> = ‘author-2’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.authors = %w[author-0 author-1 author-2] #   end # #   # good #   Gem::Specification.new do |spec| #   <a href="0">spec.authors</a> = ‘author-0’ #   <a href="1">spec.authors</a> = ‘author-1’ #   <a href="2">spec.authors</a> = ‘author-2’ #   end # #   # good #   # This example uses consistent assignment per attribute, #   # even though two different styles are used overall. #   Gem::Specification.new do |spec| #   spec.metadata = { ‘key’ =&gt; ‘value’ } #   <a href="0">spec.authors</a> = ‘author-0’ #   <a href="1">spec.authors</a> = ‘author-1’ #   <a href="2">spec.authors</a> = ‘author-2’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/attribute_assignment.rb#57 class RuboCop::Cop::Gemspec::AttributeAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemspecHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/attribute_assignment.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/attribute_assignment.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_assignments</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/attribute_assignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_indexed_assignments</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/attribute_assignment.rb#60 RuboCop::Cop::Gemspec::AttributeAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforce that gem dependency version specifications or a commit reference (branch, # ref, or tag) are either required or forbidden. # # @example EnforcedStyle: required (default) # #   # bad #   Gem::Specification.new do |spec| #   spec.add_dependency ‘parser’ #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.add_development_dependency ‘parser’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_dependency ‘parser’, ‘&gt;= 2.3.3.1’, ‘&lt; 3.0’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_development_dependency ‘parser’, ‘&gt;= 2.3.3.1’, ‘&lt; 3.0’ #   end # @example EnforcedStyle: forbidden # #   # bad #   Gem::Specification.new do |spec| #   spec.add_dependency ‘parser’, ‘&gt;= 2.3.3.1’, ‘&lt; 3.0’ #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.add_development_dependency ‘parser’, ‘&gt;= 2.3.3.1’, ‘&lt; 3.0’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_dependency ‘parser’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_development_dependency ‘parser’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#53 class RuboCop::Cop::Gemspec::DependencyVersion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemspecHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_dependency_method_declaration?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">includes_commit_reference?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">includes_version_specification?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_dependency_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_gem?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_gems</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_block_variable_name?</span>(<span class="ruby-identifier">receiver_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_specification?</span>(<span class="ruby-identifier">expression</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#61 RuboCop::Cop::Gemspec::DependencyVersion::ADD_DEPENDENCY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#58 RuboCop::Cop::Gemspec::DependencyVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#57 RuboCop::Cop::Gemspec::DependencyVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#64 RuboCop::Cop::Gemspec::DependencyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/dependency_version.rb#59 RuboCop::Cop::Gemspec::DependencyVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks that deprecated attributes are not set in a gemspec file. # Removing deprecated attributes allows the user to receive smaller packed gems. # # @example # #   # bad #   Gem::Specification.new do |spec| #   spec.name = ‘your_cool_gem_name’ #   spec.test_files = Dir.glob(‘test/<strong>*/</strong>’) #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.name = ‘your_cool_gem_name’ #   spec.test_files += Dir.glob(‘test/<strong>*/</strong>’) #   end # #   # good #   Gem::Specification.new do |spec| #   spec.name = ‘your_cool_gem_name’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#28 class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_specification</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message_from</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_and_method_name</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">attribute</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_deprecated_attributes?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_parameter</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/deprecated_attribute_assignment.rb#32 RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforce that development dependencies for a gem are specified in # ‘Gemfile`, rather than in the `gemspec` using # `add_development_dependency`. Alternatively, using `EnforcedStyle: # gemspec`, enforce that all dependencies are specified in `gemspec`, # rather than in `Gemfile`. # # @example EnforcedStyle: <a href="../../../Gemfile.html">Gemfile</a> (default) #   # Specify runtime dependencies in your gemspec, #   # but all other dependencies in your <a href="../../../Gemfile.html">Gemfile</a>. # #   # bad #   # example.gemspec #   s.add_development_dependency “foo” # #   # good #   # <a href="../../../Gemfile.html">Gemfile</a> #   gem “foo” # #   # good #   # gems.rb #   gem “foo” # #   # good (with AllowedGems: [“bar”]) #   # example.gemspec #   s.add_development_dependency “bar” # @example EnforcedStyle: gems.rb #   # Specify runtime dependencies in your gemspec, #   # but all other dependencies in your <a href="../../../Gemfile.html">Gemfile</a>. #   # #   # Identical to `EnforcedStyle: Gemfile`, but with a different error message. #   # Rely on Bundler/GemFilename to enforce the use of `Gemfile` vs `gems.rb`. # #   # bad #   # example.gemspec #   s.add_development_dependency “foo” # #   # good #   # <a href="../../../Gemfile.html">Gemfile</a> #   gem “foo” # #   # good #   # gems.rb #   gem “foo” # #   # good (with AllowedGems: [“bar”]) #   # example.gemspec #   s.add_development_dependency “bar” # @example EnforcedStyle: gemspec #   # Specify all dependencies in your gemspec. # #   # bad #   # <a href="../../../Gemfile.html">Gemfile</a> #   gem “foo” # #   # good #   # example.gemspec #   s.add_development_dependency “foo” # #   # good (with AllowedGems: [“bar”]) #   # <a href="../../../Gemfile.html">Gemfile</a> #   gem “bar” # # source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#70 class RuboCop::Cop::Gemspec::DevelopmentDependencies &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_development_dependency?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_gem?</span>(<span class="ruby-identifier">gem_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#73 RuboCop::Cop::Gemspec::DevelopmentDependencies::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/development_dependencies.rb#74 RuboCop::Cop::Gemspec::DevelopmentDependencies::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># An attribute assignment method calls should be listed only once # in a gemspec. # # Assigning to an attribute with the same name using ‘spec.foo =` or # `spec.attribute#[]=` will be an unintended usage. On the other hand, # duplication of methods such # as `spec.requirements`, # `spec.add_runtime_dependency`, and others are permitted because it is # the intended use of appending values. # # @example #   # bad #   Gem::Specification.new do |spec| #   spec.name = ’rubocop’ #   spec.name = ‘rubocop2’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.name = ‘rubocop’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.requirements &lt;&lt; ‘libmagick, v6.0’ #   spec.requirements &lt;&lt; ‘A good graphics card’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_dependency(‘parallel’, ‘~&gt; 1.10’) #   spec.add_dependency(‘parser’, ‘&gt;= 2.3.3.1’, ‘&lt; 3.0’) #   end # #   # bad #   Gem::Specification.new do |spec| #   <a href="&quot;key&quot;">spec.metadata</a> = “value” #   <a href="&quot;key&quot;">spec.metadata</a> = “value” #   end # #   # good #   Gem::Specification.new do |spec| #   <a href="&quot;key&quot;">spec.metadata</a> = “value” #   end # # source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#50 class RuboCop::Cop::Gemspec::DuplicatedAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemspecHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicated_assignment_method_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicated_indexed_assignment_method_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_assignment_method_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_indexed_assignment_method_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">assignment</span>, <span class="ruby-identifier">line_of_first_occurrence</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/duplicated_assignment.rb#54 RuboCop::Cop::Gemspec::DuplicatedAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Dependencies in the gemspec should be alphabetically sorted. # # @example #   # bad #   spec.add_dependency ‘rubocop’ #   spec.add_dependency ‘rspec’ # #   # good #   spec.add_dependency ‘rspec’ #   spec.add_dependency ‘rubocop’ # #   # good #   spec.add_dependency ‘rubocop’ # #   spec.add_dependency ‘rspec’ # #   # bad #   spec.add_development_dependency ‘rubocop’ #   spec.add_development_dependency ‘rspec’ # #   # good #   spec.add_development_dependency ‘rspec’ #   spec.add_development_dependency ‘rubocop’ # #   # good #   spec.add_development_dependency ‘rubocop’ # #   spec.add_development_dependency ‘rspec’ # #   # bad #   spec.add_runtime_dependency ‘rubocop’ #   spec.add_runtime_dependency ‘rspec’ # #   # good #   spec.add_runtime_dependency ‘rspec’ #   spec.add_runtime_dependency ‘rubocop’ # #   # good #   spec.add_runtime_dependency ‘rubocop’ # #   spec.add_runtime_dependency ‘rspec’ # @example TreatCommentsAsGroupSeparators: true (default) #   # good #   # For code quality #   spec.add_dependency ‘rubocop’ #   # For tests #   spec.add_dependency ‘rspec’ # @example TreatCommentsAsGroupSeparators: false #   # bad #   # For code quality #   spec.add_dependency ‘rubocop’ #   # For tests #   spec.add_dependency ‘rspec’ # # source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#61 class RuboCop::Cop::Gemspec::OrderedDependencies &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedGemNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependency_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_dependency_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_declaration</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/ordered_dependencies.rb#65 RuboCop::Cop::Gemspec::OrderedDependencies::MSG = T.let(T.unsafe(nil), String)</p>

<p># Requires a gemspec to have ‘rubygems_mfa_required` metadata set. # # This setting tells RubyGems that MFA (Multi-Factor Authentication) is # required for accounts to be able perform privileged operations, such as # (see RubyGems’ documentation for the full list of privileged # operations): # # * ‘gem push` # * `gem yank` # * `gem owner –add/remove` # * adding or removing owners using gem ownership page # # This helps make your gem more secure, as users can be more # confident that gem updates were pushed by maintainers. # # @example #   # bad #   Gem::Specification.new do |spec| #   # no `rubygems_mfa_required` metadata specified #   end # #   # good #   Gem::Specification.new do |spec| #   spec.metadata = { #   ’rubygems_mfa_required’ =&gt; ‘true’ #   } #   end # #   # good #   Gem::Specification.new do |spec| #   <a href="&#39;rubygems_mfa_required&#39;">spec.metadata</a> = ‘true’ #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.metadata = { #   ‘rubygems_mfa_required’ =&gt; ‘false’ #   } #   end # #   # good #   Gem::Specification.new do |spec| #   spec.metadata = { #   ‘rubygems_mfa_required’ =&gt; ‘true’ #   } #   end # #   # bad #   Gem::Specification.new do |spec| #   <a href="&#39;rubygems_mfa_required&#39;">spec.metadata</a> = ‘false’ #   end # #   # good #   Gem::Specification.new do |spec| #   <a href="&#39;rubygems_mfa_required&#39;">spec.metadata</a> = ‘true’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#63 class RuboCop::Cop::Gemspec::RequireMFA &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemspecHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata_assignment</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubygems_mfa_required</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">true_string?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_var</span>, <span class="ruby-identifier">metadata</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">change_value</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_metadata</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">metadata</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_mfa_required</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mfa_value</span>(<span class="ruby-identifier">metadata_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/require_mfa.rb#67 RuboCop::Cop::Gemspec::RequireMFA::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that ‘required_ruby_version` in a gemspec file is set to a valid # value (non-blank) and matches `TargetRubyVersion` as set in RuboCop’s # configuration for the gem. # # This ensures that RuboCop is using the same Ruby version as the gem. # # @example #   # When ‘TargetRubyVersion` of .rubocop.yml is `2.5`. # #   # bad #   Gem::Specification.new do |spec| #   # no `required_ruby_version` specified #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ’&gt;= 2.4.0’ #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ‘&gt;= 2.6.0’ #   end # #   # bad #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ” #   end # #   # good #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ‘&gt;= 2.5.0’ #   end # #   # good #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ‘&gt;= 2.5’ #   end # #   # accepted but not recommended #   Gem::Specification.new do |spec| #   spec.required_ruby_version = [‘&gt;= 2.5.0’, ‘&lt; 2.7.0’] #   end # #   # accepted but not recommended, since #   # Ruby does not really follow semantic versioning #   Gem::Specification.new do |spec| #   spec.required_ruby_version = ‘~&gt; 2.5’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#55 class RuboCop::Cop::Gemspec::RequiredRubyVersion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_ruby_version</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_ruby_version?</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dynamic_version?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_ruby_version</span>(<span class="ruby-identifier">required_ruby_version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_equal_message</span>(<span class="ruby-identifier">required_ruby_version</span>, <span class="ruby-identifier">target_ruby_version</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#60 RuboCop::Cop::Gemspec::RequiredRubyVersion::MISSING_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#57 RuboCop::Cop::Gemspec::RequiredRubyVersion::NOT_EQUAL_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/required_ruby_version.rb#56 RuboCop::Cop::Gemspec::RequiredRubyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks that ‘RUBY_VERSION` constant is not used in gemspec. # Using `RUBY_VERSION` is dangerous because value of the # constant is determined by `rake release`. # It’s possible to have dependency based on ruby version used # to execute ‘rake release` and not user’s ruby version. # # @example # #   # bad #   Gem::Specification.new do |spec| #   if RUBY_VERSION &gt;= ‘3.0’ #   spec.add_dependency ‘gem_a’ #   else #   spec.add_dependency ‘gem_b’ #   end #   end # #   # good #   Gem::Specification.new do |spec| #   spec.add_dependency ‘gem_a’ #   end # # source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#28 class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">GemspecHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_version?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_spec_with_ruby_version?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/gemspec/ruby_version_globals_usage.rb#31 RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking gem declarations. # # source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#6 module RuboCop::Cop::GemspecHelp</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_method_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_specification</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_specification?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indexed_assignment_method_declarations</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/gemspec_help.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_block_variable_name?</span>(<span class="ruby-identifier">receiver_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Source and spec generator for new cops # # This generator will take a cop name and generate a source file # and spec file when given a valid qualified cop name. # # @api private # # source://rubocop//lib/rubocop/cop/generator.rb#10 class RuboCop::Cop::Generator</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [Generator] a new instance of Generator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">name</span>, <span class="ruby-value">output:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject_config</span>(<span class="ruby-value">config_file_path:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">version_added:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject_require</span>(<span class="ruby-value">root_file_path:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">todo</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_spec</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">badge</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate</span>(<span class="ruby-identifier">template</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generated_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generated_spec</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">snake_case</span>(<span class="ruby-identifier">camel_case_string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">spec_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_unless_file_exists</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">contents</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/generator.rb#115 RuboCop::Cop::Generator::CONFIGURATION_ADDED_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># A class that injects a require directive into the root RuboCop file. # It looks for other directives that require files in the same (cop) # namespace and injects the provided one in alpha # # source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#9 class RuboCop::Cop::Generator::ConfigurationInjector</p>

<pre class="ruby"><span class="ruby-comment"># @return [ConfigurationInjector] a new instance of ConfigurationInjector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">configuration_file_path:</span>, <span class="ruby-value">badge:</span>, <span class="ruby-value">version_added:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns the value of attribute badge.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">badge</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configuration_entries</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute configuration_file_path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configuration_file_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name_line?</span>(<span class="ruby-identifier">yaml</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_configuration_entry</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute output.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute version_added.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_added</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/generator/configuration_injector.rb#10 RuboCop::Cop::Generator::ConfigurationInjector::TEMPLATE = T.let(T.unsafe(nil), String)</p>

<p># A class that injects a require directive into the root RuboCop file. # It looks for other directives that require files in the same (cop) # namespace and injects the provided one in alpha # # source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#9 class RuboCop::Cop::Generator::RequireFileInjector</p>

<pre class="ruby"><span class="ruby-comment"># @return [RequireFileInjector] a new instance of RequireFileInjector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">source_path:</span>, <span class="ruby-value">root_file_path:</span>, <span class="ruby-value">output:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">injectable_require_directive</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute output.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute require_entries.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_entries</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_exists?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_path_fragments</span>(<span class="ruby-identifier">require_directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute root_file_path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_file_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute source_path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">updated_directives</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/generator/require_file_injector.rb#10 RuboCop::Cop::Generator::RequireFileInjector::REQUIRE_PATH = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/generator.rb#11 RuboCop::Cop::Generator::SOURCE_TEMPLATE = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/generator.rb#91 RuboCop::Cop::Generator::SPEC_TEMPLATE = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking hash alignment. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#6 module RuboCop::Cop::HashAlignmentStyles; end</p>

<p># Handles calculation of deltas when the enforced style is ‘key’. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#8 class RuboCop::Cop::HashAlignmentStyles::KeyAlignment</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">checkable_layout?</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas_for_first_pair</span>(<span class="ruby-identifier">first_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separator_delta</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_delta</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles calculation of deltas for ‘kwsplat` nodes. # This is a special case that just ensures the kwsplat is aligned with the rest of the hash # since a `kwsplat` does not have a key, separator or value. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#146 class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles calculation of deltas when the enforced style is ‘separator’. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#121 class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashAlignmentStyles</span><span class="ruby-operator">::</span><span class="ruby-constant">ValueAlignment</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas_for_first_pair</span>(<span class="ruby-identifier">_first_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_rocket_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Handles calculation of deltas when the enforced style is ‘table’. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#81 class RuboCop::Cop::HashAlignmentStyles::TableAlignment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashAlignmentStyles</span><span class="ruby-operator">::</span><span class="ruby-constant">ValueAlignment</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas_for_first_pair</span>(<span class="ruby-identifier">first_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_rocket_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_delimiter_width</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_key_width</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking alignment of hash values. # # source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#56 module RuboCop::Cop::HashAlignmentStyles::ValueAlignment</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">checkable_layout?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deltas</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_alignment_styles.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separator_delta</span>(<span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">current_pair</span>, <span class="ruby-identifier">key_delta</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module checks for Ruby 3.1’s hash value omission syntax. # # source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#7 module RuboCop::Cop::HashShorthandSyntax</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash_for_mixed_shorthand</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brackets?</span>(<span class="ruby-identifier">method_dispatch_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakdown_value_types_of_hash</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_node_that_require_parentheses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_omittable_value_pair</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_omitted_value_pair</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforced_shorthand_syntax</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_ancestor_method_dispatch_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_with_mixed_shorthand_syntax?</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_with_values_that_cant_be_omitted?</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_explicit_omissible_hash_shorthand_syntax?</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_hash_shorthand_syntax?</span>(<span class="ruby-identifier">pair_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_mixed_hash_shorthand_syntax?</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_dispatch_as_argument?</span>(<span class="ruby-identifier">method_dispatch_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_shorthand_syntax_check</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_mixed_shorthand_syntax_check</span>(<span class="ruby-identifier">hash_value_type_breakdown</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_hash_value?</span>(<span class="ruby-identifier">hash_key_source</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_hash_value_for_around_hash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_element_of_hash_literal_as_receiver?</span>(<span class="ruby-identifier">ancestor</span>, <span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_modifier_form_without_parenthesized_method_call?</span>(<span class="ruby-identifier">ancestor</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#12 RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_EXPLICIT_VALUE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#10 RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_MSG_PREFIX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#11 RuboCop::Cop::HashShorthandSyntax::DO_NOT_MIX_OMIT_VALUE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14 class RuboCop::Cop::HashShorthandSyntax::DefNode &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute node to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#9 RuboCop::Cop::HashShorthandSyntax::EXPLICIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_shorthand_syntax.rb#8 RuboCop::Cop::HashShorthandSyntax::OMIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for Style/HashExcept and Style/HashSlice cops. # It registers an offense on methods with blocks that are equivalent # to Hash#except or Hash#slice. # # source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#9 module RuboCop::Cop::HashSubset</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_with_first_arg_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decorate_source</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">except_key</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">except_key_source</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_body_if_negated</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extracts_hash_subset?</span>(<span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included?</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">negated</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_included?</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">negated</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_include?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_to_register_offense?</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">except_key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantically_except_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantically_slice_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantically_subset_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slices_key?</span>(<span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">key_arg</span>, <span class="ruby-identifier">value_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_subset_method?</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">using_value_variable?</span>(<span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">value_arg</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#16 RuboCop::Cop::HashSubset::ACTIVE_SUPPORT_SUBSET_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#18 RuboCop::Cop::HashSubset::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#13 RuboCop::Cop::HashSubset::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_subset.rb#15 RuboCop::Cop::HashSubset::SUBSET_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for Style/HashTransformKeys and # Style/HashTransformValues # # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#7 module RuboCop::Cop::HashTransformMethod</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_receiver?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">execute_correction</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">correction</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Captures]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_captures</span>(<span class="ruby-identifier">_match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_possible_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">match</span>, <span class="ruby-identifier">match_desc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract Implemented with `def_node_matcher`</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_each_with_object</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract Implemented with `def_node_matcher`</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_hash_brackets_map</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract Implemented with `def_node_matcher`</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_map_to_h</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @abstract Implemented with `def_node_matcher`</span>
<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_to_h</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Internal helper class to hold autocorrect data # # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31 class RuboCop::Cop::HashTransformMethod::Autocorrection &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute block_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of block_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute block_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute block_node to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_node=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute leading</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of leading</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute leading</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute leading to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute match</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of match</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute match</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute match to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_new_arg_name</span>(<span class="ruby-identifier">transformed_argname</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_new_body_expression</span>(<span class="ruby-identifier">transforming_body_expr</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_new_method_name</span>(<span class="ruby-identifier">new_method_name</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strip_prefix_and_suffix</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute trailing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of trailing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute trailing</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute trailing to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#32</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_each_with_object</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_hash_brackets_map</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_map_to_h</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_to_h</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Internal helper class to hold match data # # source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13 class RuboCop::Cop::HashTransformMethod::Captures &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">noop_transformation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transformation_uses_both_args?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute transformed_argname</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of transformed_argname</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transformed_argname</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute transformed_argname</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute transformed_argname to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transformed_argname=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute transforming_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of transforming_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transforming_body_expr</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute transforming_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute transforming_body_expr to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transforming_body_expr=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute unchanged_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of unchanged_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unchanged_body_expr</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute unchanged_body_expr</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute unchanged_body_expr to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unchanged_body_expr=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_transformed_argname?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/hash_transform_method.rb#10 RuboCop::Cop::HashTransformMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for working with heredoc strings. # # source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#6 module RuboCop::Cop::Heredoc</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter_string</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent_level</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/heredoc.rb#7 RuboCop::Cop::Heredoc::OPENING_DELIMITER = T.let(T.unsafe(nil), Regexp)</p>

<p># This class autocorrects ‘if…then` structures to a multiline `if` statement # # source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#6 class RuboCop::Cop::IfThenCorrector</p>

<pre class="ruby"><span class="ruby-comment"># @return [IfThenCorrector] a new instance of IfThenCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">if_node</span>, <span class="ruby-value">indentation:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_body_indentation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute if_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute indentation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">indentation</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rewrite_else_branch</span>(<span class="ruby-identifier">else_branch</span>, <span class="ruby-identifier">indentation</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/correctors/if_then_corrector.rb#7 RuboCop::Cop::IfThenCorrector::DEFAULT_INDENTATION_WIDTH = T.let(T.unsafe(nil), Integer)</p>

<p># @deprecated IgnoredMethods class has been replaced with AllowedMethods. # # source://rubocop//lib/rubocop/cop/mixin/allowed_methods.rb#46 RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods</p>

<p># Handles adding and checking ignored nodes. # # source://rubocop//lib/rubocop/cop/ignored_node.rb#6 module RuboCop::Cop::IgnoredNode</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/ignored_node.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/ignored_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/ignored_node.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">part_of_ignored_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/ignored_node.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_nodes</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @deprecated IgnoredPattern class has been replaced with AllowedPattern. # # source://rubocop//lib/rubocop/cop/mixin/allowed_pattern.rb#66 RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern</p>

<p># Common functionality for checking integer nodes. # # source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#6 module RuboCop::Cop::IntegerNode</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/integer_node.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integer_part</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for working with string interpolations. # # @abstract Subclasses are expected to implement {#on_interpolation}. # # source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#8 module RuboCop::Cop::Interpolation</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dsym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_node_with_interpolations</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/interpolation.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class autocorrects lambda literal to method notation. # # source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#6 class RuboCop::Cop::LambdaLiteralToMethodCorrector</p>

<pre class="ruby"><span class="ruby-comment"># @return [LambdaLiteralToMethodCorrector] a new instance of LambdaLiteralToMethodCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_to_unparenthesized_call?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute arguments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_begin_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_end_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_begin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute block_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_arguments</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_separating_space</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_arg_string</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needs_separating_space?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_arguments</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_leading_whitespace</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_trailing_whitespace</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_unparenthesized_whitespace</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_delimiters</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_selector</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selector_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/lambda_literal_to_method_corrector.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separating_space?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#5 module RuboCop::Cop::Layout; end</p>

<p># Bare access modifiers (those not applying to specific methods) should be # indented as deep as method definitions, or as deep as the ‘class`/`module` # keyword, depending on configuration. # # @example EnforcedStyle: indent (default) #   # bad #   class Plumbus #   private #   def smooth; end #   end # #   # good #   class Plumbus #   private #   def smooth; end #   end # @example EnforcedStyle: outdent #   # bad #   class Plumbus #   private #   def smooth; end #   end # #   # good #   class Plumbus #   private #   def smooth; end #   end # # source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#35 class RuboCop::Cop::Layout::AccessModifierIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_body</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_modifier</span>(<span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">end_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_indent_offset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># An offset that is not expected, but correct if the configuration is</span>
<span class="ruby-comment"># changed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unexpected_indent_offset</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/access_modifier_indentation.rb#41 RuboCop::Cop::Layout::AccessModifierIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check that the arguments on a multi-line method call are aligned. # # @example EnforcedStyle: with_first_argument (default) #   # good # #   foo :bar, #   :baz, #   key: value # #   foo( #   :bar, #   :baz, #   key: value #   ) # #   # bad # #   foo :bar, #   :baz, #   key: value # #   foo( #   :bar, #   :baz, #   key: value #   ) # @example EnforcedStyle: with_fixed_indentation #   # good # #   foo :bar, #   :baz, #   key: value # #   # bad # #   foo :bar, #   :baz, #   key: value # # source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#45 class RuboCop::Cop::Layout::ArgumentAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_or_first_arg_pairs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_with_last_arg_pairs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with_other_cops?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">first_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_hash_argument_with_separator?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flattened_arguments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_method_lineno</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_first_argument_style?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#49 RuboCop::Cop::Layout::ArgumentAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/argument_alignment.rb#51 RuboCop::Cop::Layout::ArgumentAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)</p>

<p># Check that the elements of a multi-line array literal are # aligned. # # @example EnforcedStyle: with_first_element (default) #   # good # #   array = [1, 2, 3, #   4, 5, 6] #   array = [‘run’, #   ‘forrest’, #   ‘run’] # #   # bad # #   array = [1, 2, 3, #   4, 5, 6] #   array = [‘run’, #   ‘forrest’, #   ‘run’] # @example EnforcedStyle: with_fixed_indentation #   # good # #   array = [1, 2, 3, #   4, 5, 6] # #   # bad # #   array = [1, 2, 3, #   4, 5, 6] # # source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#36 class RuboCop::Cop::Layout::ArrayAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_method_lineno</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#40 RuboCop::Cop::Layout::ArrayAlignment::ALIGN_ELEMENTS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/array_alignment.rb#43 RuboCop::Cop::Layout::ArrayAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the first line of the # right-hand-side of a multi-line assignment. # # The indentation of the remaining lines can be corrected with # other cops such as ‘Layout/IndentationConsistency` and `Layout/EndAlignment`. # # @example #   # bad #   value = #   if foo #   ’bar’ #   end # #   # good #   value = #   if foo #   ‘bar’ #   end # # source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#25 class RuboCop::Cop::Layout::AssignmentIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leftmost_multiple_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/assignment_indentation.rb#30 RuboCop::Cop::Layout::AssignmentIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the end keyword of ‘begin` is aligned properly. # # Two modes are supported through the `EnforcedStyleAlignWith` configuration # parameter. If it’s set to ‘start_of_line` (which is the default), the # `end` shall be aligned with the start of the line where the `begin` # keyword is. If it’s set to ‘begin`, the `end` shall be aligned with the # `begin` keyword. # # `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) # by default. On the other hand, `||= begin` that this cop targets tends to # align with the start of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`. # These style can be configured by each cop. # # @example EnforcedStyleAlignWith: start_of_line (default) #   # bad #   foo ||= begin #   do_something #   end # #   # good #   foo ||= begin #   do_something #   end # @example EnforcedStyleAlignWith: begin #   # bad #   foo ||= begin #   do_something #   end # #   # good #   foo ||= begin #   do_something #   end # # source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#41 class RuboCop::Cop::Layout::BeginEndAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_begin_alignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/begin_end_alignment.rb#45 RuboCop::Cop::Layout::BeginEndAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the end keywords are aligned properly for do # end blocks. # # Three modes are supported through the ‘EnforcedStyleAlignWith` # configuration parameter: # # `start_of_block` : the `end` shall be aligned with the # start of the line where the `do` appeared. # # `start_of_line` : the `end` shall be aligned with the # start of the line where the expression started. # # `either` (which is the default) : the `end` is allowed to be in either # location. The autocorrect will default to `start_of_line`. # # @example EnforcedStyleAlignWith: either (default) #   # bad # #   foo.bar #   .each do #   baz #   end # #   # good # #   foo.bar #   .each do #   baz #   end # @example EnforcedStyleAlignWith: start_of_block #   # bad # #   foo.bar #   .each do #   baz #   end # #   # good # #   foo.bar #   .each do #   baz #   end # @example EnforcedStyleAlignWith: start_of_line #   # bad # #   foo.bar #   .each do #   baz #   end # #   # good # #   foo.bar #   .each do #   baz #   end # # source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#66 class RuboCop::Cop::Layout::BlockAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_end_align_target?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_space_before</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">loc</span>, <span class="ruby-identifier">delta</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alt_start_msg</span>(<span class="ruby-identifier">start_loc</span>, <span class="ruby-identifier">source_line_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_end_align_target</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_block_alignment</span>(<span class="ruby-identifier">start_node</span>, <span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_do_source_line_column</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">end_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compute_start_col</span>(<span class="ruby-identifier">ancestor_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disqualified_parent?</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_align_target?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># In offense message, we want to show the assignment LHS rather than</span>
<span class="ruby-comment"># the entire assignment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_lhs_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">start_loc</span>, <span class="ruby-identifier">end_loc</span>, <span class="ruby-identifier">do_source_line_column</span>, <span class="ruby-identifier">error_source_line_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_source_line_column</span>(<span class="ruby-identifier">source_line_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc_to_source_line_column</span>(<span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">block_node</span>, <span class="ruby-identifier">start_loc</span>, <span class="ruby-identifier">end_loc</span>, <span class="ruby-identifier">do_source_line_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_space_before</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">end_pos</span>, <span class="ruby-identifier">delta</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_for_block_node</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_for_line_node</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/block_alignment.rb#71 RuboCop::Cop::Layout::BlockAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the end statement of a do..end block # is on its own line. # # @example #   # bad #   blah do |i| #   foo(i) end # #   # good #   blah do |i| #   foo(i) #   end # #   # bad #   blah { |i| #   foo(i) } # #   # good #   blah { |i| #   foo(i) #   } # # source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#27 class RuboCop::Cop::Layout::BlockEndNewline &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_heredoc_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">offense_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/block_end_newline.rb#31 RuboCop::Cop::Layout::BlockEndNewline::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks how the ‘when` and “in“s of a `case` expression # are indented in relation to its `case` or `end` keyword. # # It will register a separate offense for each misaligned `when` and `in`. # # @example #   # If Layout/EndAlignment is set to keyword style (default) #   # <strong>case</strong> and <strong>end</strong> should always be aligned to same depth, #   # and therefore <strong>when</strong> should always be aligned to both - #   # regardless of configuration. # #   # bad for all styles #   case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   case n #   in pattern #   x * 2 #   else #   y / 3 #   end # #   # good for all styles #   case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   case n #   in pattern #   x * 2 #   else #   y / 3 #   end # @example EnforcedStyle: case (default) #   # if EndAlignment is set to other style such as #   # start_of_line (as shown below), then <strong>when</strong> alignment #   # configuration does have an effect. # #   # bad #   a = case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   a = case n #   in pattern #   x * 2 #   else #   y / 3 #   end # #   # good #   a = case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   a = case n #   in pattern #   x * 2 #   else #   y / 3 #   end # @example EnforcedStyle: end #   # bad #   a = case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   a = case n #   in pattern #   x * 2 #   else #   y / 3 #   end # #   # good #   a = case n #   when 0 #   x * 2 #   else #   y / 3 #   end # #   a = case n #   in pattern #   x * 2 #   else #   y / 3 #   end # # source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#112 class RuboCop::Cop::Layout::CaseIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">case_match_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column</span>(<span class="ruby-identifier">case_node</span>, <span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_when</span>(<span class="ruby-identifier">when_node</span>, <span class="ruby-identifier">branch_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect_incorrect_style</span>(<span class="ruby-identifier">when_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_and_last_conditional_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforced_style_end?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_style</span>(<span class="ruby-identifier">when_node</span>, <span class="ruby-identifier">branch_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent_one_step?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_width</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/case_indentation.rb#118 RuboCop::Cop::Layout::CaseIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if the code style follows the ‘ExpectedOrder` configuration: # # `Categories` allows us to map macro names into a category. # # Consider an example of code style that covers the following order: # # * Module inclusion (`include`, `prepend`, `extend`) # * Constants # * Associations (`has_one`, `has_many`) # * Public attribute macros (`attr_accessor`, `attr_writer`, `attr_reader`) # * Other macros (`validates`, `validate`) # * Public class methods # * Initializer # * Public instance methods # * Protected attribute macros (`attr_accessor`, `attr_writer`, `attr_reader`) # * Protected instance methods # * Private attribute macros (`attr_accessor`, `attr_writer`, `attr_reader`) # * Private instance methods # # NOTE: Simply enabling the cop with `Enabled: true` will not use # the example order shown below. # To enforce the order of macros like `attr_reader`, # you must define both `ExpectedOrder` <strong>and</strong> `Categories`. # # You can configure the following order: # # [source,yaml] # —- #  Layout/ClassStructure: #    ExpectedOrder: #      - module_inclusion #      - constants #      - association #      - public_attribute_macros #      - public_delegate #      - macros #      - public_class_methods #      - initializer #      - public_methods #      - protected_attribute_macros #      - protected_methods #      - private_attribute_macros #      - private_delegate #      - private_methods # —- # # Instead of putting all literals in the expected order, is also # possible to group categories of macros. Visibility levels are handled # automatically. # # [source,yaml] # —- #  Layout/ClassStructure: #    Categories: #      association: #        - has_many #        - has_one #      attribute_macros: #        - attr_accessor #        - attr_reader #        - attr_writer #      macros: #        - validates #        - validate #      module_inclusion: #        - include #        - prepend #        - extend # —- # # If you only set `ExpectedOrder` # without defining `Categories`, # macros such as `attr_reader` or `has_many` # will not be recognized as part of a category, and their order will not be validated. # For example, the following will NOT raise any offenses, even if the order is incorrect: # # [source,yaml] # —- # Layout/ClassStructure: #   Enabled: true #   ExpectedOrder: #     - public_attribute_macros #     - initializer # —- # # To make it work as expected, you must also specify `Categories` like this: # # [source,yaml] # —- # Layout/ClassStructure: #   ExpectedOrder: #     - public_attribute_macros #     - initializer #   Categories: #     attribute_macros: #       - attr_reader #       - attr_writer #       - attr_accessor # —- # # @example #   # bad #   # Expect extend be before constant #   class Person &lt; ApplicationRecord #   has_many :orders #   ANSWER = 42 # #   extend SomeModule #   include AnotherModule #   end # #   # good #   class Person #   # extend and include go first #   extend SomeModule #   include AnotherModule # #   # inner classes #   CustomError = Class.new(StandardError) # #   # constants are next #   SOME_CONSTANT = 20 # #   # afterwards we have public attribute macros #   attr_reader :name # #   # followed by other macros (if any) #   validates :name # #   # then we have public delegate macros #   delegate :to_s, to: :name # #   # public class methods are next in line #   def self.some_method #   end # #   # initialization goes between class methods and instance methods #   def initialize #   end # #   # followed by other public instance methods #   def some_method #   end # #   # protected attribute macros and methods go next #   protected # #   attr_reader :protected_name # #   def some_protected_method #   end # #   # private attribute macros, delegate macros and methods #   # are grouped near the end #   private # #   attr_reader :private_name # #   delegate :some_private_delegate, to: :name # #   def some_private_method #   end #   end # # source://rubocop//lib/rubocop/cop/layout/class_structure.rb#177 class RuboCop::Cop::Layout::ClassStructure &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># Validates code style on class declaration.</span>
<span class="ruby-comment"># Add offense when find a node out of expected order.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Validates code style on class declaration.</span>
<span class="ruby-comment"># Add offense when find a node out of expected order.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Autocorrect by swapping between two nodes autocorrecting them</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos_with_comment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#363</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Setting categories hash allow you to group methods in group to match</span>
<span class="ruby-comment"># in the {expected_order}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#375</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">categories</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_elements</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Classifies a node to match with something in the {expected_order}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node to be analysed</span>
<span class="ruby-comment"># @return String when the node type is a `:block` then</span>
<span class="ruby-comment">#   {classify} recursively with the first children</span>
<span class="ruby-comment"># @return String when the node type is a `:send` then {find_category}</span>
<span class="ruby-comment">#   by method name</span>
<span class="ruby-comment"># @return String otherwise trying to {humanize_node} of the current node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classify</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dynamic_constant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#330</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_position_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Load expected order from `ExpectedOrder` config.</span>
<span class="ruby-comment"># Define new terms in the expected order by adding new {categories}.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#369</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_order</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Categorize a node according to the {expected_order}</span>
<span class="ruby-comment"># Try to match {categories} values against the node&#39;s method_name given</span>
<span class="ruby-comment"># also its visibility.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node to be analysed.</span>
<span class="ruby-comment"># @return [String] with the key category or the `method_name` as string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_category</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#359</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">humanize_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">classification</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#288</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_for_autocorrect?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sibling</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marked_as_private_constant?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#314</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_constant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#355</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_line_position</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">walk_over_nested_class_definition</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whole_line_comment_at_line?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#182 RuboCop::Cop::Layout::ClassStructure::HUMANIZED_NODE_TYPE = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/layout/class_structure.rb#189 RuboCop::Cop::Layout::ClassStructure::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of here document closings. # # @example # #   # bad #   class Foo #   def bar #   &lt;&lt;~SQL #   ‘Hi’ #   SQL #   end #   end # #   # good #   class Foo #   def bar #   &lt;&lt;~SQL #   ‘Hi’ #   SQL #   end #   end # #   # bad # #   # heredoc contents is before closing heredoc. #   foo arg, #   &lt;&lt;~EOS #   Hi #   EOS # #   # good #   foo arg, #   &lt;&lt;~EOS #   Hi #   EOS # #   # good #   foo arg, #   &lt;&lt;~EOS #   Hi #   EOS # # source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#48 class RuboCop::Cop::Layout::ClosingHeredocIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_indentation_correct?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_node_used_heredoc_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_closing</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_opening</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent_level</span>(<span class="ruby-identifier">source_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opening_indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#53 RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#54 RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG_ARG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/closing_heredoc_indentation.rb#52 RuboCop::Cop::Layout::ClosingHeredocIndentation::SIMPLE_HEREDOC = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of hanging closing parentheses in # method calls, method definitions, and grouped expressions. A hanging # closing parenthesis means ‘)` preceded by a line break. # # @example # #   # bad #   some_method( #   a, #   b #   ) # #   some_method( #   a, b #   ) # #   some_method(a, b, c #   ) # #   some_method(a, #   b, #   c #   ) # #   some_method(a, #   x: 1, #   y: 2 #   ) # #   # Scenario 1: When First Parameter Is On Its Own Line # #   # good: when first param is on a new line, right paren is <strong>always</strong> #   #       outdented by IndentationWidth #   some_method( #   a, #   b #   ) # #   # good #   some_method( #   a, b #   ) # #   # Scenario 2: When First Parameter Is On The Same Line # #   # good: when all other params are also on the same line, outdent #   #       right paren by IndentationWidth #   some_method(a, b, c #   ) # #   # good: when all other params are on multiple lines, but are lined #   #       up, align right paren with left paren #   some_method(a, #   b, #   c #   ) # #   # good: when other params are not lined up on multiple lines, outdent #   #       right paren by IndentationWidth #   some_method(a, #   x: 1, #   y: 2 #   ) # # source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#71 class RuboCop::Cop::Layout::ClosingParenthesisIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_elements_aligned?</span>(<span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_elements</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_no_elements</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_column_candidates</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left_paren</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_column</span>(<span class="ruby-identifier">left_paren</span>, <span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_line</span>(<span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_break_after_left_paren?</span>(<span class="ruby-identifier">left_paren</span>, <span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">correct_column</span>, <span class="ruby-identifier">left_paren</span>, <span class="ruby-identifier">right_paren</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#77 RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/closing_parenthesis_indentation.rb#75 RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of comments. # # @example #   # bad #   # comment here #   def method_name #   end # #   # comment here #   a = ‘hello’ # #   # yet another comment #   if true #   true #   end # #   # good #   # comment here #   def method_name #   end # #   # comment here #   a = ‘hello’ # #   # yet another comment #   if true #   true #   end # @example AllowForAlignment: false (default) #   # bad #   a = 1 # A really long comment #   # spanning two lines. # #   # good #   # A really long comment spanning one line. #   a = 1 # @example AllowForAlignment: true #   # good #   a = 1 # A really long comment #   # spanning two lines. # # source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#48 class RuboCop::Cop::Layout::CommentIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_one</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Corrects all comment lines that occur immediately before the given</span>
<span class="ruby-comment"># comment and have the same indentation. This is to avoid a long chain</span>
<span class="ruby-comment"># of correcting, saving the file, parsing and inspecting again, and</span>
<span class="ruby-comment"># then correcting one more line, and so on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_preceding_comments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">comment_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_indentation</span>(<span class="ruby-identifier">next_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if:</span>
<span class="ruby-comment"># a) the cop is configured to allow extra indentation for alignment, and</span>
<span class="ruby-comment"># b) the currently inspected comment is aligned with the nearest preceding end-of-line</span>
<span class="ruby-comment">#    comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctly_aligned_with_preceding_comment?</span>(<span class="ruby-identifier">comment_index</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">less_indented?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_after_comment</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">correct_comment_indentation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">own_line_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_correct?</span>(<span class="ruby-identifier">preceding_comment</span>, <span class="ruby-identifier">reference_comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">two_alternatives?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/comment_indentation.rb#52 RuboCop::Cop::Layout::CommentIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for conditions that are not on the same line as # if/while/until. # # @example # #   # bad #   if #   some_condition #   do_something #   end # #   # good #   if some_condition #   do_something #   end # # source://rubocop//lib/rubocop/cop/layout/condition_position.rb#21 class RuboCop::Cop::Layout::ConditionPosition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/condition_position.rb#25 RuboCop::Cop::Layout::ConditionPosition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the end keywords of method definitions are # aligned properly. # # Two modes are supported through the EnforcedStyleAlignWith configuration # parameter. If it’s set to ‘start_of_line` (which is the default), the # `end` shall be aligned with the start of the line where the `def` # keyword is. If it’s set to ‘def`, the `end` shall be aligned with the # `def` keyword. # # @example EnforcedStyleAlignWith: start_of_line (default) #   # bad # #   private def foo #   end # #   # good # #   private def foo #   end # @example EnforcedStyleAlignWith: def #   # bad # #   private def foo #   end # #   # good # #   private def foo #   end # # source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#36 class RuboCop::Cop::Layout::DefEndAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/def_end_alignment.rb#41 RuboCop::Cop::Layout::DefEndAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the . position in multi-line method calls. # # @example EnforcedStyle: leading (default) #   # bad #   something. #   method # #   # good #   something #   .method # @example EnforcedStyle: trailing #   # bad #   something #   .method # #   # good #   something. #   method # # source://rubocop//lib/rubocop/cop/layout/dot_position.rb#25 class RuboCop::Cop::Layout::DotPosition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">dot</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_dot_position_style?</span>(<span class="ruby-identifier">dot_line</span>, <span class="ruby-identifier">selector_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_heredoc_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_between?</span>(<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">second_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">dot</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_dot_position?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_end_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selector_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/dot_position.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks the alignment of else keywords. Normally they should # be aligned with an if/unless/while/until/begin/def/rescue keyword, but there # are special cases when they should follow the same rules as the # alignment of end. # # @example #   # bad #   if something #   code #   else #   code #   end # #   # bad #   if something #   code #   elsif something #   code #   end # #   # good #   if something #   code #   else #   code #   end # # source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#32 class RuboCop::Cop::Layout::ElseAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_for_method_definition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_range_of_if</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_range_of_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_alignment</span>(<span class="ruby-identifier">base_range</span>, <span class="ruby-identifier">else_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_nested</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/else_alignment.rb#38 RuboCop::Cop::Layout::ElseAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks empty comment. # # @example #   # bad # #   # #   class Foo #   end # #   # good # #   # #   # Description of ‘Foo` class. #   # #   class Foo #   end # @example AllowBorderComment: true (default) #   # good # #   def foo #   end # #   ################# # #   def bar #   end # @example AllowBorderComment: false #   # bad # #   def foo #   end # #   ################# # #   def bar #   end # @example AllowMarginComment: true (default) #   # good # #   # #   # Description of `Foo` class. #   # #   class Foo #   end # @example AllowMarginComment: false #   # bad # #   # #   # Description of `Foo` class. #   # #   class Foo #   end # # source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#63 class RuboCop::Cop::Layout::EmptyComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_border_comment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_margin_comment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_text</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">concat_consecutive_comments</span>(<span class="ruby-identifier">comments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_token</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_comment_only?</span>(<span class="ruby-identifier">comment_text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">comments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_token</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_comment.rb#67 RuboCop::Cop::Layout::EmptyComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces empty line after guard clause. # # This cop allows ‘# :nocov:` directive after guard clause because # SimpleCov excludes code from the coverage report by wrapping it in `# :nocov:`: # # [source,ruby] # —- # def foo #   # :nocov: #   return if condition #   # :nocov: #   bar # end # —- # # Refer to SimpleCov’s documentation for more details: # <a href="https://github.com/simplecov-ruby/simplecov#ignoringskipping-code">github.com/simplecov-ruby/simplecov#ignoringskipping-code</a> # # @example # #   # bad #   def foo #   return if need_return? #   bar #   end # #   # good #   def foo #   return if need_return? # #   bar #   end # #   # good #   def foo #   return if something? #   return if something_different? # #   bar #   end # #   # also good #   def foo #   if something? #   do_something #   return if need_return? #   end #   end # # source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#54 class RuboCop::Cop::Layout::EmptyLineAfterGuardClause &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_guard_clause?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_heredoc_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_heredoc_argument_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_statements_on_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_allowed_directive_comment?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty_or_allowed_directive_comment?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_rescue_or_ensure?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_sibling_empty_or_guard_clause?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_sibling_parent_empty_or_else?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># SimpleCov excludes code from the coverage report by wrapping it in `# :nocov:`:</span>
<span class="ruby-comment"># https://github.com/simplecov-ruby/simplecov#ignoringskipping-code</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simplecov_directive_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_heredoc_in_condition?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#60 RuboCop::Cop::Layout::EmptyLineAfterGuardClause::END_OF_HEREDOC_LINE = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#59 RuboCop::Cop::Layout::EmptyLineAfterGuardClause::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_after_guard_clause.rb#61 RuboCop::Cop::Layout::EmptyLineAfterGuardClause::SIMPLE_DIRECTIVE_COMMENT_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for a newline after the final magic comment. # # @example #   # good #   # frozen_string_literal: true # #   # Some documentation for Person #   class Person #   # Some code #   end # #   # bad #   # frozen_string_literal: true #   # Some documentation for Person #   class Person #   # Some code #   end # # source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#23 class RuboCop::Cop::Layout::EmptyLineAfterMagicComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_before_code</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Find the last magic comment in the source file.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Take all comments that precede the first line of code (or just take</span>
<span class="ruby-comment"># them all in the case when there is no code), select the</span>
<span class="ruby-comment"># magic comments, and return the last magic comment in the file.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Parser::Source::Comment] if magic comments exist before code</span>
<span class="ruby-comment"># @return [nil] otherwise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_magic_comment</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">last_magic_comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_after_magic_comment.rb#27 RuboCop::Cop::Layout::EmptyLineAfterMagicComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces empty line after multiline condition. # # @example #   # bad #   if multiline &amp;&amp; #   condition #   do_something #   end # #   # good #   if multiline &amp;&amp; #   condition # #   do_something #   end # #   # bad #   case x #   when foo, #   bar #   do_something #   end # #   # good #   case x #   when foo, #   bar # #   do_something #   end # #   # bad #   begin #   do_something #   rescue FooError, #   BarError #   handle_error #   end # #   # good #   begin #   do_something #   rescue FooError, #   BarError # #   handle_error #   end # # source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#54 class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_condition</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_rescue_exceptions?</span>(<span class="ruby-identifier">exception_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_when_condition?</span>(<span class="ruby-identifier">when_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_after_multiline_condition.rb#58 RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether class/module/method definitions are # separated by one or more empty lines. # # ‘NumberOfEmptyLines` can be an integer (default is 1) or # an array (e.g. [1, 2]) to specify a minimum and maximum # number of empty lines permitted. # # `AllowAdjacentOneLineDefs` configures whether adjacent # one-line definitions are considered an offense. # # @example EmptyLineBetweenMethodDefs: true (default) #   # checks for empty lines between method definitions. # #   # bad #   def a #   end #   def b #   end # #   # good #   def a #   end # #   def b #   end # @example EmptyLineBetweenClassDefs: true (default) #   # checks for empty lines between class definitions. # #   # bad #   class A #   end #   class B #   end #   def b #   end # #   # good #   class A #   end # #   class B #   end # #   def b #   end # @example EmptyLineBetweenModuleDefs: true (default) #   # checks for empty lines between module definitions. # #   # bad #   module A #   end #   module B #   end #   def b #   end # #   # good #   module A #   end # #   module B #   end # #   def b #   end # @example AllowAdjacentOneLineDefs: true (default) # #   # good #   class ErrorA &lt; BaseError; end #   class ErrorB &lt; BaseError; end #   class ErrorC &lt; BaseError; end # #   # good #   class ErrorA &lt; BaseError; end # #   class ErrorB &lt; BaseError; end # #   class ErrorC &lt; BaseError; end # @example AllowAdjacentOneLineDefs: false # #   # bad #   class ErrorA &lt; BaseError; end #   class ErrorB &lt; BaseError; end #   class ErrorC &lt; BaseError; end # #   # good #   class ErrorA &lt; BaseError; end # #   class ErrorB &lt; BaseError; end # #   class ErrorC &lt; BaseError; end # # source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#102 class RuboCop::Cop::Layout::EmptyLineBetweenDefs &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">prev_def</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_defs</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># We operate on `begin` nodes, instead of using `OnMethodDef`,</span>
<span class="ruby-comment"># so that we can walk over pairs of consecutive nodes and</span>
<span class="ruby-comment"># efficiently access a node&#39;s predecessor; #prev_node ends up</span>
<span class="ruby-comment"># doing a linear scan over siblings, so we don&#39;t want to call</span>
<span class="ruby-comment"># it on each def.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowance_range?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_insert_lines</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">newline_pos</span>, <span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_remove_lines</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">newline_pos</span>, <span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blank_lines_count_between</span>(<span class="ruby-identifier">first_def_node</span>, <span class="ruby-identifier">second_def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">candidate?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_candidate?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_location</span>(<span class="ruby-identifier">correction_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_start</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_line_between_macros</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_loc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_count_allowed?</span>(<span class="ruby-identifier">count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lines_between_defs</span>(<span class="ruby-identifier">first_def_node</span>, <span class="ruby-identifier">second_def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">macro_candidate?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maximum_empty_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">count:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_candidate?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minimum_empty_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_candidate?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_blank_lines_groups?</span>(<span class="ruby-identifier">first_def_node</span>, <span class="ruby-identifier">second_def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#108</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_line_between_defs.rb#106 RuboCop::Cop::Layout::EmptyLineBetweenDefs::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for two or more consecutive blank lines. # # @example # #   # bad - It has two empty lines. #   some_method #   # one empty line #   # two empty lines #   some_method # #   # good #   some_method #   # one empty line #   some_method # # source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#21 class RuboCop::Cop::Layout::EmptyLines &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_extra_empty_line</span>(<span class="ruby-identifier">lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exceeds_line_offset?</span>(<span class="ruby-identifier">line_diff</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_and_current_lines_empty?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#26 RuboCop::Cop::Layout::EmptyLines::LINE_OFFSET = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines.rb#25 RuboCop::Cop::Layout::EmptyLines::MSG = T.let(T.unsafe(nil), String)</p>

<p># Access modifiers should be surrounded by blank lines. # # @example EnforcedStyle: around (default) # #   # bad #   class Foo #   def bar; end #   private #   def baz; end #   end # #   # good #   class Foo #   def bar; end # #   private # #   def baz; end #   end # @example EnforcedStyle: only_before # #   # bad #   class Foo #   def bar; end #   private #   def baz; end #   end # #   # good #   class Foo #   def bar; end # #   private #   def baz; end #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#43 class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [EmptyLinesAroundAccessModifier] a new instance of EmptyLinesAroundAccessModifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_only_before_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_start?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_end?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_def?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_next_line_if_denied_style</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_lines_around?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_empty_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_around_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_only_before_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_empty_line_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty?</span>(<span class="ruby-identifier">last_send_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty_and_exists?</span>(<span class="ruby-identifier">last_send_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_empty_lines_around_block_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_line_empty?</span>(<span class="ruby-identifier">send_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_line_ignoring_comments</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">send_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_insert_line_after?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_insert_line_before?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#48 RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#52 RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#49 RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_AND_AFTER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#51 RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_access_modifier.rb#54 RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks if empty lines exist around the arguments # of a method invocation. # # @example #   # bad #   do_something( #   foo # #   ) # #   process(bar, # #   baz: qux, #   thud: fred) # #   some_method( # #   [1,2,3], #   x: y #   ) # #   # good #   do_something( #   foo #   ) # #   process(bar, #   baz: qux, #   thud: fred) # #   some_method( #   [1,2,3], #   x: y #   ) # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#41 class RuboCop::Cop::Layout::EmptyLinesAroundArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_numbers</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">outer_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_and_method_call_on_different_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_arguments.rb#45 RuboCop::Cop::Layout::EmptyLinesAroundArguments::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a newline after an attribute accessor or a group of them. # ‘alias` syntax and `alias_method`, `public`, `protected`, and `private` methods are allowed # by default. These are customizable with `AllowAliasSyntax` and `AllowedMethods` options. # # @example #   # bad #   attr_accessor :foo #   def do_something #   end # #   # good #   attr_accessor :foo # #   def do_something #   end # #   # good #   attr_accessor :foo #   attr_reader :bar #   attr_writer :baz #   attr :qux # #   def do_something #   end # @example AllowAliasSyntax: true (default) #   # good #   attr_accessor :foo #   alias :foo? :foo # #   def do_something #   end # @example AllowAliasSyntax: false #   # bad #   attr_accessor :foo #   alias :foo? :foo # #   def do_something #   end # #   # good #   attr_accessor :foo # #   alias :foo? :foo # #   def do_something #   end # @example AllowedMethods: [’private’] #   # good #   attr_accessor :foo #   private :foo # #   def do_something #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#63 class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_alias?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_alias_syntax?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_or_allowed_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_empty_or_enable_directive_comment?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_enable_directive_comment?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_line_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_empty_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_attribute_accessor.rb#68 RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines exist around the bodies of begin-end # blocks. # # @example # #   # bad #   begin # #   # … # #   end # #   # good #   begin #   # … #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#23 class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_begin_body.rb#27 RuboCop::Cop::Layout::EmptyLinesAroundBeginBody::KIND = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines around the bodies of blocks match # the configuration. # # @example EnforcedStyle: no_empty_lines (default) #   # good # #   foo do |bar| #   # … #   end # @example EnforcedStyle: empty_lines #   # good # #   foo do |bar| # #   # … # #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#24 class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_block_body.rb#28 RuboCop::Cop::Layout::EmptyLinesAroundBlockBody::KIND = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking if presence/absence of empty lines # around some kind of body matches the configuration. # # source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#8 module RuboCop::Cop::Layout::EmptyLinesAroundBody</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_line_required?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>, <span class="ruby-value">adjusted_first_line:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_beginning</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">first_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_both</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_deferred_empty_line</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_empty_lines_except_namespace</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_empty_lines_special</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ending</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_line</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_source</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">line_no</span>, <span class="ruby-identifier">desc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deferred_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_child_requires_empty_line?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_empty_line_required_child</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">desc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace?</span>(<span class="ruby-identifier">body</span>, <span class="ruby-value">with_one_child:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_line_ignoring_comments</span>(<span class="ruby-identifier">send_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_body_style?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#15 RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_DEFERRED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#13 RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_EXTRA = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/empty_lines_around_body.rb#14 RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_MISSING = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines around the bodies of classes match # the configuration. # # @example EnforcedStyle: no_empty_lines (default) #   # good # #   class Foo #   def bar #   # … #   end #   end # @example EnforcedStyle: empty_lines #   # good # #   class Foo # #   def bar #   # … #   end # #   end # @example EnforcedStyle: empty_lines_except_namespace #   # good # #   class Foo #   class Bar # #   # … # #   end #   end # @example EnforcedStyle: empty_lines_special #   # good #   class Foo # #   def bar; end # #   end # @example EnforcedStyle: beginning_only #   # good # #   class Foo # #   def bar #   # … #   end #   end # @example EnforcedStyle: ending_only #   # good # #   class Foo #   def bar #   # … #   end # #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#67 class RuboCop::Cop::Layout::EmptyLinesAroundClassBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_class_body.rb#71 RuboCop::Cop::Layout::EmptyLinesAroundClassBody::KIND = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines exist around the bodies of ‘begin` # sections. This cop doesn’t check empty lines at ‘begin` body # beginning/end and around method definition body. # `Layout/EmptyLinesAroundBeginBody` or `Layout/EmptyLinesAroundMethodBody` # can be used for this purpose. # # @example # #   # good # #   begin #   do_something #   rescue #   do_something2 #   else #   do_something3 #   ensure #   do_something4 #   end # #   # good # #   def foo #   do_something #   rescue #   do_something2 #   end # #   # bad # #   begin #   do_something # #   rescue # #   do_something2 # #   else # #   do_something3 # #   ensure # #   do_something4 #   end # #   # bad # #   def foo #   do_something # #   rescue # #   do_something2 #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#61 class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_body</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">line_of_def_or_kwbegin</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_locations</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_locations_in_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_locations_in_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_body_and_end_on_same_line?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">location</span>, <span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_exception_handling_keywords.rb#65 RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines exist around the bodies of methods. # # @example # #   # good # #   def foo #   # … #   end # #   # bad # #   def bar # #   # … # #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#23 class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_endless_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense_for_endless_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_method_body.rb#27 RuboCop::Cop::Layout::EmptyLinesAroundMethodBody::KIND = T.let(T.unsafe(nil), String)</p>

<p># Checks if empty lines around the bodies of modules match # the configuration. # # @example EnforcedStyle: no_empty_lines (default) #   # good # #   module Foo #   def bar #   # … #   end #   end # @example EnforcedStyle: empty_lines #   # good # #   module Foo # #   def bar #   # … #   end # #   end # @example EnforcedStyle: empty_lines_except_namespace #   # good # #   module Foo #   module Bar # #   # … # #   end #   end # @example EnforcedStyle: empty_lines_special #   # good #   module Foo # #   def bar; end # #   end # # source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#47 class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Layout</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyLinesAroundBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/empty_lines_around_module_body.rb#51 RuboCop::Cop::Layout::EmptyLinesAroundModuleBody::KIND = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the end keywords are aligned properly. # # Three modes are supported through the ‘EnforcedStyleAlignWith` # configuration parameter: # # If it’s set to ‘keyword` (which is the default), the `end` # shall be aligned with the start of the keyword (if, class, etc.). # # If it’s set to ‘variable` the `end` shall be aligned with the # left-hand-side of the variable assignment, if there is one. # # If it’s set to ‘start_of_line`, the `end` shall be aligned with the # start of the line where the matching keyword appears. # # This `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) # by default. On the other hand, `Layout/BeginEndAlignment` cop aligns with # `EnforcedStyleAlignWith: start_of_line` by default due to `||= begin` tends # to align with the start of the line. `Layout/DefEndAlignment` cop also aligns with # `EnforcedStyleAlignWith: start_of_line` by default. # These style can be configured by each cop. # # @example EnforcedStyleAlignWith: keyword (default) #   # bad # #   variable = if true #   end # #   # good # #   variable = if true #   end # #   variable = #   if true #   end # @example EnforcedStyleAlignWith: variable #   # bad # #   variable = if true #   end # #   # good # #   variable = if true #   end # #   variable = #   if true #   end # @example EnforcedStyleAlignWith: start_of_line #   # bad # #   variable = if true #   end # #   puts(if true #   end) # #   # good # #   variable = if true #   end # #   puts(if true #   end) # #   variable = #   if true #   end # # source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#77 class RuboCop::Cop::Layout::EndAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_node_for_variable_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">asgn_variable_align_with</span>(<span class="ruby-identifier">outer_node</span>, <span class="ruby-identifier">inner_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_or_operator_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_asgn_alignment</span>(<span class="ruby-identifier">outer_node</span>, <span class="ruby-identifier">inner_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_alignment.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_other_alignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for Windows-style line endings in the source code. # # @example EnforcedStyle: native (default) #   # The ‘native` style means that CR+LF (Carriage Return + Line Feed) is #   # enforced on Windows, and LF is enforced on other platforms. # #   # bad #   puts ’Hello’ # Return character is LF on Windows. #   puts ‘Hello’ # Return character is CR+LF on other than Windows. # #   # good #   puts ‘Hello’ # Return character is CR+LF on Windows. #   puts ‘Hello’ # Return character is LF on other than Windows. # @example EnforcedStyle: lf #   # The ‘lf` style means that LF (Line Feed) is enforced on #   # all platforms. # #   # bad #   puts ’Hello’ # Return character is CR+LF on all platforms. # #   # good #   puts ‘Hello’ # Return character is LF on all platforms. # @example EnforcedStyle: crlf #   # The ‘crlf` style means that CR+LF (Carriage Return + Line Feed) is #   # enforced on all platforms. # #   # bad #   puts ’Hello’ # Return character is LF on all platforms. # #   # good #   puts ‘Hello’ # Return character is CR+LF on all platforms. # # source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#40 class RuboCop::Cop::Layout::EndOfLine &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If there is no LF on the last line, we don&#39;t care if there&#39;s no CR.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unimportant_missing_cr?</span>(<span class="ruby-identifier">index</span>, <span class="ruby-identifier">last_line</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#44 RuboCop::Cop::Layout::EndOfLine::MSG_DETECTED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/end_of_line.rb#45 RuboCop::Cop::Layout::EndOfLine::MSG_MISSING = T.let(T.unsafe(nil), String)</p>

<p># Checks for extra/unnecessary whitespace. # # @example # #   # good if AllowForAlignment is true #   name      = “RuboCop” #   # Some comment and an empty line # #   website  += “/rubocop/rubocop” unless cond #   puts        “rubocop”          if     debug # #   # bad for any configuration #   set_app(“RuboCop”) #   website  = “<a href="https://github.com/rubocop/rubocop">github.com/rubocop/rubocop</a>” # #   # good only if AllowBeforeTrailingComments is true #   object.method(arg)  # this is a comment # #   # good even if AllowBeforeTrailingComments is false or not set #   object.method(arg) # this is a comment # #   # good with either AllowBeforeTrailingComments or AllowForAlignment #   object.method(arg)         # this is a comment #   another_object.method(arg) # this is another comment #   some_object.method(arg)    # this is some comment # # source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#31 class RuboCop::Cop::Layout::ExtraSpacing &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PrecedingFollowingAlignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_column</span>(<span class="ruby-identifier">asgn_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_equal_sign</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">align_to</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_equal_signs</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_locations</span>(<span class="ruby-identifier">locs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_tok?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_relevant_assignment_lines</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_for_trailing_comments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_other</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>, <span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_tokens</span>(<span class="ruby-identifier">ast</span>, <span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [range_between(start_pos, end_pos)]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_space_range</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_equal_sign_alignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_range?</span>(<span class="ruby-identifier">ast</span>, <span class="ruby-identifier">start_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of ranges that should not be reported. It&#39;s the</span>
<span class="ruby-comment"># extra spaces between the keys and values in a multiline hash,</span>
<span class="ruby-comment"># since those are handled by the Layout/HashAlignment cop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_ranges</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#37 RuboCop::Cop::Layout::ExtraSpacing::MSG_UNALIGNED_ASGN = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/extra_spacing.rb#36 RuboCop::Cop::Layout::ExtraSpacing::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the first argument in a method call. # Arguments after the first one are checked by ‘Layout/ArgumentAlignment`, # not by this cop. # # For indenting the first parameter of method <em>definitions</em>, check out # `Layout/FirstParameterIndentation`. # # This cop will respect `Layout/ArgumentAlignment` and will not work when # `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArgumentAlignment`. # # @example # #   # bad #   some_method( #   first_param, #   second_param) # #   foo = some_method( #   first_param, #   second_param) # #   foo = some_method(nested_call( #   nested_first_param), #   second_param) # #   foo = some_method( #   nested_call( #   nested_first_param), #   second_param) # #   some_method nested_call( #   nested_first_param), #   second_param # @example EnforcedStyle: special_for_inner_method_call_in_parentheses (default) #   # Same as `special_for_inner_method_call` except that the special rule #   # only applies if the outer method call encloses its arguments in #   # parentheses. # #   # good #   some_method( #   first_param, #   second_param) # #   foo = some_method( #   first_param, #   second_param) # #   foo = some_method(nested_call( #   nested_first_param), #   second_param) # #   foo = some_method( #   nested_call( #   nested_first_param), #   second_param) # #   some_method nested_call( #   nested_first_param), #   second_param # @example EnforcedStyle: consistent #   # The first argument should always be indented one step more than the #   # preceding line. # #   # good #   some_method( #   first_param, #   second_param) # #   foo = some_method( #   first_param, #   second_param) # #   foo = some_method(nested_call( #   nested_first_param), #   second_param) # #   foo = some_method( #   nested_call( #   nested_first_param), #   second_param) # #   some_method nested_call( #   nested_first_param), #   second_param # @example EnforcedStyle: consistent_relative_to_receiver #   # The first argument should always be indented one level relative to #   # the parent that is receiving the argument # #   # good #   some_method( #   first_param, #   second_param) # #   foo = some_method( #   first_param, #   second_param) # #   foo = some_method(nested_call( #   nested_first_param), #   second_param) # #   foo = some_method( #   nested_call( #   nested_first_param), #   second_param) # #   some_method nested_call( #   nested_first_param), #   second_params # @example EnforcedStyle: special_for_inner_method_call #   # The first argument should normally be indented one step more than #   # the preceding line, but if it’s an argument for a method call that #   # is itself an argument in a method call, then the inner argument #   # should be indented relative to the inner method. # #   # good #   some_method( #   first_param, #   second_param) # #   foo = some_method( #   first_param, #   second_param) # #   foo = some_method(nested_call( #   nested_first_param), #   second_param) # #   foo = some_method( #   nested_call( #   nested_first_param), #   second_param) # #   some_method nested_call( #   nested_first_param), #   second_param # # source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#147 class RuboCop::Cop::Layout::FirstArgumentIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_method_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bare_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_range</span>(<span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">arg_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the column of the given range. For single line ranges, this</span>
<span class="ruby-comment"># is simple. For ranges with line breaks, we look a the last code line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_of</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_layout_first_method_argument_line_break?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_first_argument_with_fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">arg_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Takes the line number of a given code line and returns a string</span>
<span class="ruby-comment"># containing the previous line that&#39;s not a comment line or a blank</span>
<span class="ruby-comment"># line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_code_line</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_check?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_inner_call_indentation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_argument_indentation.rb#153 RuboCop::Cop::Layout::FirstArgumentIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the first element in an array literal # where the opening bracket and the first element are on separate lines. # The other elements’ indentations are handled by ‘Layout/ArrayAlignment` cop. # # This cop will respect `Layout/ArrayAlignment` and will not work when # `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArrayAlignment`. # # By default, array literals that are arguments in a method call with # parentheses, and where the opening square bracket of the array is on the # same line as the opening parenthesis of the method call, shall have # their first element indented one step (two spaces) more than the # position inside the opening parenthesis. # # Other array literals shall have their first element indented one step # more than the start of the line where the opening square bracket is. # # This default style is called ’special_inside_parentheses’. Alternative # styles are ‘consistent’ and ‘align_brackets’. Here are examples: # # @example EnforcedStyle: special_inside_parentheses (default) #   # The ‘special_inside_parentheses` style enforces that the first #   # element in an array literal where the opening bracket and first #   # element are on separate lines is indented one step (two spaces) more #   # than the position inside the opening parenthesis. # #   # bad #   array = [ #   :value #   ] #   and_in_a_method_call([ #   :no_difference #   ]) # #   # good #   array = [ #   :value #   ] #   but_in_a_method_call([ #   :its_like_this #   ]) # @example EnforcedStyle: consistent #   # The `consistent` style enforces that the first element in an array #   # literal where the opening bracket and the first element are on #   # separate lines is indented the same as an array literal which is not #   # defined inside a method call. # #   # bad #   array = [ #   :value #   ] #   but_in_a_method_call([ #   :its_like_this #   ]) # #   # good #   array = [ #   :value #   ] #   and_in_a_method_call([ #   :no_difference #   ]) # @example EnforcedStyle: align_brackets #   # The `align_brackets` style enforces that the opening and closing #   # brackets are indented to the same position. # #   # bad #   and_now_for_something = [ #   :completely_different #   ] # #   # good #   and_now_for_something = [ #   :completely_different #   ] # # source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#82 class RuboCop::Cop::Layout::FirstArrayElementIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementIndentation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of what the correct indentation is based on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_description</span>(<span class="ruby-identifier">indent_base_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brace_alignment_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">array_node</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_right_bracket</span>(<span class="ruby-identifier">right_bracket</span>, <span class="ruby-identifier">first_elem</span>, <span class="ruby-identifier">left_bracket</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_first_argument_with_fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">base_description</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_right_bracket</span>(<span class="ruby-identifier">indent_base_type</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_array_element_indentation.rb#88 RuboCop::Cop::Layout::FirstArrayElementIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a line break before the first element in a # multi-line array. # # @example # #   # bad #   [ :a, #   :b] # #   # good #   [ #   :a, #   :b] # #   # good #   [:a, :b] # @example AllowMultilineFinalElement: false (default) # #   # bad #   [ :a, { #   :b =&gt; :c #   }] # #   # good #   [ #   :a, { #   :b =&gt; :c #   }] # @example AllowMultilineFinalElement: true # #   # good #   [:a, { #   :b =&gt; :c #   }] # # source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#43 class RuboCop::Cop::Layout::FirstArrayElementLineBreak &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FirstElementLineBreak</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_array_element_line_break.rb#47 RuboCop::Cop::Layout::FirstArrayElementLineBreak::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the first key in a hash literal # where the opening brace and the first key are on separate lines. The # other keys’ indentations are handled by the HashAlignment cop. # # By default, ‘Hash` literals that are arguments in a method call with # parentheses, and where the opening curly brace of the hash is on the # same line as the opening parenthesis of the method call, shall have # their first key indented one step (two spaces) more than the position # inside the opening parenthesis. # # Other hash literals shall have their first key indented one step more # than the start of the line where the opening curly brace is. # # This default style is called ’special_inside_parentheses’. Alternative # styles are ‘consistent’ and ‘align_braces’. Here are examples: # # @example EnforcedStyle: special_inside_parentheses (default) #   # The ‘special_inside_parentheses` style enforces that the first key #   # in a hash literal where the opening brace and the first key are on #   # separate lines is indented one step (two spaces) more than the #   # position inside the opening parentheses. # #   # bad #   hash = { #   key: :value #   } #   and_in_a_method_call({ #   no: :difference #   }) #   takes_multi_pairs_hash(x: { #   a: 1, #   b: 2 #   }, #   y: { #   c: 1, #   d: 2 #   }) # #   # good #   special_inside_parentheses #   hash = { #   key: :value #   } #   but_in_a_method_call({ #   its_like: :this #   }) #   takes_multi_pairs_hash(x: { #   a: 1, #   b: 2 #   }, #   y: { #   c: 1, #   d: 2 #   }) # @example EnforcedStyle: consistent #   # The `consistent` style enforces that the first key in a hash #   # literal where the opening brace and the first key are on #   # separate lines is indented the same as a hash literal which is not #   # defined inside a method call. # #   # bad #   hash = { #   key: :value #   } #   but_in_a_method_call({ #   its_like: :this #   }) # #   # good #   hash = { #   key: :value #   } #   and_in_a_method_call({ #   no: :difference #   }) # @example EnforcedStyle: align_braces #   # The `align_brackets` style enforces that the opening and closing #   # braces are indented to the same position. # #   # bad #   and_now_for_something = { #   completely: :different #   } #   takes_multi_pairs_hash(x: { #   a: 1, #   b: 2 #   }, #   y: { #   c: 1, #   d: 2 #   }) # #   # good #   and_now_for_something = { #   completely: :different #   } #   takes_multi_pairs_hash(x: { #   a: 1, #   b: 2 #   }, #   y: { #   c: 1, #   d: 2 #   }) # # source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#113 class RuboCop::Cop::Layout::FirstHashElementIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementIndentation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of what the correct indentation is based on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_description</span>(<span class="ruby-identifier">indent_base_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brace_alignment_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">hash_node</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_based_on_longest_key</span>(<span class="ruby-identifier">hash_node</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_right_brace</span>(<span class="ruby-identifier">right_brace</span>, <span class="ruby-identifier">first_pair</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_first_argument_with_fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">base_description</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_right_brace</span>(<span class="ruby-identifier">indent_base_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separator_style?</span>(<span class="ruby-identifier">first_pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_hash_element_indentation.rb#119 RuboCop::Cop::Layout::FirstHashElementIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a line break before the first element in a # multi-line hash. # # @example # #   # bad #   { a: 1, #   b: 2} # #   # good #   { #   a: 1, #   b: 2 } # #   # good #   { #   a: 1, b: { #   c: 3 #   }} # @example AllowMultilineFinalElement: false (default) # #   # bad #   { a: 1, b: { #   c: 3 #   }} # @example AllowMultilineFinalElement: true # #   # bad #   { a: 1, #   b: { #   c: 3 #   }} # #   # good #   { a: 1, b: { #   c: 3 #   }} # # source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#46 class RuboCop::Cop::Layout::FirstHashElementLineBreak &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FirstElementLineBreak</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_hash_element_line_break.rb#50 RuboCop::Cop::Layout::FirstHashElementLineBreak::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a line break before the first argument in a # multi-line method call. # # @example # #   # bad #   method(foo, bar, #   baz) # #   # good #   method( #   foo, bar, #   baz) # #   # ignored #   method foo, bar, #   baz # @example AllowMultilineFinalElement: false (default) # #   # bad #   method(foo, bar, { #   baz: “a”, #   qux: “b”, #   }) # #   # good #   method( #   foo, bar, { #   baz: “a”, #   qux: “b”, #   }) # @example AllowMultilineFinalElement: true # #   # bad #   method(foo, #   bar, #   { #   baz: “a”, #   qux: “b”, #   } #   ) # #   # good #   method(foo, bar, { #   baz: “a”, #   qux: “b”, #   }) # #   # good #   method( #   foo, #   bar, #   { #   baz: “a”, #   qux: “b”, #   } #   ) # @example AllowedMethods: [‘some_method’] # #   # good #   some_method(foo, bar, #   baz) # # source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#71 class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FirstElementLineBreak</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_method_argument_line_break.rb#76 RuboCop::Cop::Layout::FirstMethodArgumentLineBreak::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a line break before the first parameter in a # multi-line method parameter definition. # # @example # #   # bad #   def method(foo, bar, #   baz) #   do_something #   end # #   # good #   def method( #   foo, bar, #   baz) #   do_something #   end # #   # ignored #   def method foo, #   bar #   do_something #   end # @example AllowMultilineFinalElement: false (default) # #   # bad #   def method(foo, bar, baz = { #   :a =&gt; “b”, #   }) #   do_something #   end # #   # good #   def method( #   foo, bar, baz = { #   :a =&gt; “b”, #   }) #   do_something #   end # @example AllowMultilineFinalElement: true # #   # good #   def method(foo, bar, baz = { #   :a =&gt; “b”, #   }) #   do_something #   end # # source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#56 class RuboCop::Cop::Layout::FirstMethodParameterLineBreak &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FirstElementLineBreak</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_method_parameter_line_break.rb#60 RuboCop::Cop::Layout::FirstMethodParameterLineBreak::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the first parameter in a method # definition. Parameters after the first one are checked by # ‘Layout/ParameterAlignment`, not by this cop. # # For indenting the first argument of method <em>calls</em>, check out # `Layout/FirstArgumentIndentation`, which supports options related to # nesting that are irrelevant for method <em>definitions</em>. # # @example # #   # bad #   def some_method( #   first_param, #   second_param) #   123 #   end # @example EnforcedStyle: consistent (default) #   # The first parameter should always be indented one step more than the #   # preceding line. # #   # good #   def some_method( #   first_param, #   second_param) #   123 #   end # @example EnforcedStyle: align_parentheses #   # The first parameter should always be indented one step more than the #   # opening parenthesis. # #   # good #   def some_method( #   first_param, #   second_param) #   123 #   end # # source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#44 class RuboCop::Cop::Layout::FirstParameterIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementIndentation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the description of what the correct indentation is based on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_description</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brace_alignment_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">base_description</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/first_parameter_indentation.rb#50 RuboCop::Cop::Layout::FirstParameterIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check that the keys, separators, and values of a multi-line hash # literal are aligned according to configuration. The configuration # options are: # # * key (left align keys, one space before hash rockets and values) # * separator (align hash rockets and colons, right align keys) # * table (left align keys, hash rockets, and values) # # The treatment of hashes passed as the last argument to a method call # can also be configured. The options are: # # * always_inspect # * always_ignore # * ignore_implicit (without curly braces) # # Alternatively you can specify multiple allowed styles. That’s done by # passing a list of styles to EnforcedHashRocketStyle and EnforcedColonStyle. # # @example EnforcedLastArgumentHashStyle: ignore_explicit #   # Ignore only explicit hashes. # #   # bad #   do_something(foo: 1, #   bar: 2) # #   # good #   do_something({foo: 1, #   bar: 2}) # @example EnforcedHashRocketStyle: separator #   # bad #   { #   :foo =&gt; bar, #   :ba =&gt; baz #   } #   { #   :foo =&gt; bar, #   :ba  =&gt; baz #   } # #   # good #   { #   :foo =&gt; bar, #   :ba =&gt; baz #   } # @example EnforcedHashRocketStyle: table #   # bad #   { #   :foo =&gt; bar, #   :ba =&gt; baz #   } # #   # good #   { #   :foo =&gt; bar, #   :ba  =&gt; baz #   } # @example EnforcedColonStyle: key (default) #   # bad #   { #   foo: bar, #   ba: baz #   } #   { #   foo: bar, #   ba:  baz #   } # #   # good #   { #   foo: bar, #   ba: baz #   } # @example EnforcedColonStyle: separator #   # bad #   { #   foo: bar, #   ba: baz #   } # #   # good #   { #   foo: bar, #   ba: baz #   } # @example EnforcedColonStyle: table #   # bad #   { #   foo: bar, #   ba: baz #   } # #   # good #   { #   foo: bar, #   ba:  baz #   } # @example EnforcedLastArgumentHashStyle: always_inspect (default) #   # Inspect both implicit and explicit hashes. # #   # bad #   do_something(foo: 1, #   bar: 2) # #   # bad #   do_something({foo: 1, #   bar: 2}) # #   # good #   do_something(foo: 1, #   bar: 2) # #   # good #   do_something( #   foo: 1, #   bar: 2 #   ) # #   # good #   do_something({foo: 1, #   bar: 2}) # #   # good #   do_something({ #   foo: 1, #   bar: 2 #   }) # @example EnforcedLastArgumentHashStyle: always_ignore #   # Ignore both implicit and explicit hashes. # #   # good #   do_something(foo: 1, #   bar: 2) # #   # good #   do_something({foo: 1, #   bar: 2}) # @example EnforcedLastArgumentHashStyle: ignore_implicit #   # Ignore only implicit hashes. # #   # bad #   do_something({foo: 1, #   bar: 2}) # #   # good #   do_something(foo: 1, #   bar: 2) # @example EnforcedHashRocketStyle: key (default) #   # bad #   { #   :foo =&gt; bar, #   :ba =&gt; baz #   } #   { #   :foo =&gt; bar, #   :ba  =&gt; baz #   } # #   # good #   { #   :foo =&gt; bar, #   :ba =&gt; baz #   } # # source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#178 class RuboCop::Cop::Layout::HashAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashAlignmentStyles</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># Returns the value of attribute column_deltas.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_deltas</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute column_deltas</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute column_deltas to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_deltas=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offenses_by.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_by</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute offenses_by</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute offenses_by to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_by=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#373</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">delta</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_for</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#316</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_for_colons</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_for_hash_rockets</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_before_hash</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with_other_cops?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_delta</span>(<span class="ruby-identifier">delta</span>, <span class="ruby-value">node:</span>, <span class="ruby-value">alignment:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_pairs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#339</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_key_value</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">delta</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">separator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_no_value</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">key_delta</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">delta</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_splat?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#386</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_first_argument_with_fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#382</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">good_alignment?</span>(<span class="ruby-identifier">column_deltas</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_hash_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#355</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_alignment</span>(<span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offenses_with_format</span>(<span class="ruby-identifier">offenses</span>, <span class="ruby-identifier">format</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#391</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#183 RuboCop::Cop::Layout::HashAlignment::MESSAGES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/layout/hash_alignment.rb#193 RuboCop::Cop::Layout::HashAlignment::SEPARATOR_ALIGNMENT_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the placement of the closing parenthesis # in a method call that passes a HEREDOC string as an argument. # It should be placed at the end of the line containing the # opening HEREDOC tag. # # @example #   # bad # #   foo(&lt;&lt;-SQL #   bar #   SQL #   ) # #   foo(&lt;&lt;-SQL, 123, &lt;&lt;-NOSQL, #   bar #   SQL #   baz #   NOSQL #   ) # #   foo( #   bar(&lt;&lt;-SQL #   baz #   SQL #   ), #   123, #   ) # #   # good # #   foo(&lt;&lt;-SQL) #   bar #   SQL # #   foo(&lt;&lt;-SQL, 123, &lt;&lt;-NOSQL) #   bar #   SQL #   baz #   NOSQL # #   foo( #   bar(&lt;&lt;-SQL), #   baz #   SQL #   123, #   ) # # source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#53 class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_correct_closing_paren</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_correct_external_trailing_comma</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Autocorrection note:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Commas are a bit tricky to handle when the method call is</span>
<span class="ruby-comment"># embedded in another expression. Here&#39;s an example:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># [</span>
<span class="ruby-comment">#   first_array_value,</span>
<span class="ruby-comment">#   foo(&lt;&lt;-SQL, 123, 456,</span>
<span class="ruby-comment">#     SELECT * FROM db</span>
<span class="ruby-comment">#   SQL</span>
<span class="ruby-comment">#   ),</span>
<span class="ruby-comment">#   third_array_value,</span>
<span class="ruby-comment"># ]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The &quot;internal&quot; trailing comma is after `456`.</span>
<span class="ruby-comment"># The &quot;external&quot; trailing comma is after `)`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># To autocorrect, we remove the latter, and move the former up:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># [</span>
<span class="ruby-comment">#   first_array_value,</span>
<span class="ruby-comment">#   foo(&lt;&lt;-SQL, 123, 456),</span>
<span class="ruby-comment">#     SELECT * FROM db</span>
<span class="ruby-comment">#   SQL</span>
<span class="ruby-comment">#   third_array_value,</span>
<span class="ruby-comment"># ]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Closing parenthesis helpers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_keyword_before_closing_parenthesis?</span>(<span class="ruby-identifier">parenthesized_send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_argument_between_heredoc_end_and_closing_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#290</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">external_trailing_comma?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns nil if no trailing external comma.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">external_trailing_comma_offset_from_loc_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_heredoc_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_most_bottom_of_heredoc_end</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_closing_parenthesis</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># External trailing comma helpers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_external_trailing_comma</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_parenthesis_removal_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_parenthesis_removal_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#245</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal_trailing_comma?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns nil if no trailing internal comma.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal_trailing_comma_offset_from_last_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">outermost_send_on_same_line</span>(<span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_incorrect_closing_paren</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_incorrect_external_trailing_comma</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Internal trailing comma helpers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_internal_trailing_comma</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_to_remove_line_containing_closing_paren?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_missing_closing_parens?</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">child</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_send_with_heredoc_receiver?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space?</span>(<span class="ruby-identifier">pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">subsequent_closing_parentheses_in_same_line?</span>(<span class="ruby-identifier">outermost_send</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#60</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/heredoc_argument_closing_parenthesis.rb#57 RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the here document bodies. The bodies # are indented one step. # # NOTE: When “Layout/LineLength“‘s `AllowHeredoc` is false (not default), #       this cop does not add any offenses for long here documents to #       avoid “Layout/LineLength“’s offenses. # # @example #   # bad #   &lt;&lt;-RUBY #   something #   RUBY # #   # good #   &lt;&lt;~RUBY #   something #   RUBY # # source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#24 class RuboCop::Cop::Layout::HeredocIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust_minus</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust_squiggly</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_indent_level</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_body</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns &#39;~&#39;, &#39;-&#39; or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_indent_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_body</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_too_long?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">longest_line</span>(<span class="ruby-identifier">lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">heredoc_indent_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc_indent_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type_message</span>(<span class="ruby-identifier">indentation_width</span>, <span class="ruby-identifier">current_indent_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unlimited_heredoc_length?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">width_message</span>(<span class="ruby-identifier">indentation_width</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#32 RuboCop::Cop::Layout::HeredocIndentation::TYPE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/heredoc_indentation.rb#34 RuboCop::Cop::Layout::HeredocIndentation::WIDTH_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for inconsistent indentation. # # The difference between ‘indented_internal_methods` and `normal` is # that the `indented_internal_methods` style prescribes that in # classes and modules the `protected` and `private` modifier keywords # shall be indented the same as public methods and that protected and # private members shall be indented one step more than the modifiers. # Other than that, both styles mean that entities on the same logical # depth shall have the same indentation. # # @example EnforcedStyle: normal (default) #   # bad #   class A #   def test #   puts ’hello’ #   puts ‘world’ #   end #   end # #   # bad #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end # #   protected # #   def foo #   end # #   private # #   def bar #   end #   end # #   # good #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end #   end # #   # good #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end # #   protected # #   def foo #   end # #   private # #   def bar #   end #   end # @example EnforcedStyle: indented_internal_methods #   # bad #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end #   end # #   # bad #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end # #   protected # #   def foo #   end # #   private # #   def bar #   end #   end # #   # good #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end #   end # #   # good #   class A #   def test #   puts ‘hello’ #   puts ‘world’ #   end # #   protected # #   def foo #   end # #   private # #   def bar #   end #   end # # source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#121 class RuboCop::Cop::Layout::IndentationConsistency &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Not all nodes define `bare_access_modifier?` (for example,</span>
<span class="ruby-comment"># `RuboCop::AST::DefNode` does not), so we must check `send_type?` first</span>
<span class="ruby-comment"># to avoid a NoMethodError.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bare_access_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an integer representing the correct indentation, or nil to</span>
<span class="ruby-comment"># indicate that the correct indentation is that of the first child that</span>
<span class="ruby-comment"># is not an access modifier.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column_for_normal_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_indented_internal_methods_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_normal_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/indentation_consistency.rb#126 RuboCop::Cop::Layout::IndentationConsistency::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that the indentation method is consistent. # Either tabs only or spaces only are used for indentation. # # @example EnforcedStyle: spaces (default) #   # bad #   # This example uses a tab to indent bar. #   def foo #   bar #   end # #   # good #   # This example uses spaces to indent bar. #   def foo #   bar #   end # @example EnforcedStyle: tabs #   # bad #   # This example uses spaces to indent bar. #   def foo #   bar #   end # #   # good #   # This example uses a tab to indent bar. #   def foo #   bar #   end # # source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#34 class RuboCop::Cop::Layout::IndentationStyle &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_lambda_for_spaces</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_lambda_for_tabs</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">lineno</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_string_literal?</span>(<span class="ruby-identifier">ranges</span>, <span class="ruby-identifier">tabs_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literal_ranges</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/indentation_style.rb#40 RuboCop::Cop::Layout::IndentationStyle::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for indentation that doesn’t use the specified number of spaces. # The indentation width can be configured using the ‘Width` setting. The default width is 2. # # See also the `Layout/IndentationConsistency` cop which is the companion to this one. # # @example Width: 2 (default) #   # bad #   class A #   def test #   puts ’hello’ #   end #   end # #   # good #   class A #   def test #   puts ‘hello’ #   end #   end # @example AllowedPatterns: [‘^s*module’] #   # bad #   module A #   class B #   def test #   puts ‘hello’ #   end #   end #   end # #   # good #   module A #   class B #   def test #   puts ‘hello’ #   end #   end #   end # # source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#44 class RuboCop::Cop::Layout::IndentationWidth &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">case_match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">base</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_indentation_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_if</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">else_clause</span>, <span class="ruby-identifier">base_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_indentation</span>(<span class="ruby-identifier">base_loc</span>, <span class="ruby-identifier">body_node</span>, <span class="ruby-identifier">style</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_members</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">members</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_members_for_indented_internal_methods_style</span>(<span class="ruby-identifier">members</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_members_for_normal_style</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">members</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_rescue?</span>(<span class="ruby-identifier">rescue_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configured_indentation_width</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_member</span>(<span class="ruby-identifier">members</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_consistency_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_to_check?</span>(<span class="ruby-identifier">base_loc</span>, <span class="ruby-identifier">body_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_internal_methods_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leftmost_modifier_of</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">configured_indentation_width</span>, <span class="ruby-identifier">indentation</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">body_node</span>, <span class="ruby-identifier">indentation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense</span>(<span class="ruby-identifier">body_node</span>, <span class="ruby-identifier">indentation</span>, <span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the given node is within another node that has</span>
<span class="ruby-comment"># already been marked for autocorrection by this cop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#314</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">other_offense_in_same_range?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_check_member</span>(<span class="ruby-identifier">member</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_check?</span>(<span class="ruby-identifier">base_loc</span>, <span class="ruby-identifier">body_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#368</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">starts_with_access_modifier?</span>(<span class="ruby-identifier">body_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/indentation_width.rb#52 RuboCop::Cop::Layout::IndentationWidth::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for indentation of the first non-blank non-comment # line in a file. # # @example #   # bad #   class A #   def foo; end #   end # #   # good #   class A #   def foo; end #   end # # source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#20 class RuboCop::Cop::Layout::InitialIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_token</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [range_between(space_range.begin_pos, token.begin_pos)]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_before</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/initial_indentation.rb#24 RuboCop::Cop::Layout::InitialIndentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether comments have a leading space after the # ‘#` denoting the start of the comment. The leading space is not # required for some RDoc special syntax, like `#++`, `#–`, # `#:nodoc`, `=begin`- and `=end` comments, “shebang” directives, # or rackup options. # # @example AllowSteepAnnotation: true # #   # good # #   [1, 2, 3].each_with_object([]) do |n, list| #$ <a href="Integer">Array</a> #   list &lt;&lt; n #   end # #   name = ’John’      #: String # @example AllowDoxygenCommentStyle: false (default) # #   # bad # #   #** #   # Some comment #   # Another line of comment #   #* # @example AllowDoxygenCommentStyle: true # #   # good # #   #** #   # Some comment #   # Another line of comment #   #* # @example AllowGemfileRubyComment: false (default) # #   # bad # #   #ruby=2.7.0 #   #ruby-gemset=myproject # @example AllowGemfileRubyComment: true # #   # good # #   #ruby=2.7.0 #   #ruby-gemset=myproject # @example AllowRBSInlineAnnotation: false (default) # #   # bad # #   include Enumerable #[Integer] # #   attr_reader :name #: String #   attr_reader :age  #: Integer? # #   #: ( #   #|   Integer, #   #|   String #   #| ) -&gt; void #   def foo; end # @example AllowRBSInlineAnnotation: true # #   # good # #   include Enumerable #[Integer] # #   attr_reader :name #: String #   attr_reader :age  #: Integer? # #   #: ( #   #|   Integer, #   #|   String #   #| ) -&gt; void #   def foo; end # @example AllowSteepAnnotation: false (default) # #   # bad #   [1, 2, 3].each_with_object([]) do |n, list| #$ <a href="Integer">Array</a> #   list &lt;&lt; n #   end # #   name = ‘John’      #: String # @example # #   # bad #   #Some comment # #   # good #   # Some comment # # source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#101 class RuboCop::Cop::Layout::LeadingCommentSpace &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_doxygen_comment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_gemfile_ruby_comment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_rbs_inline_annotation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_steep_annotation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_on_first_line?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">doxygen_comment_style?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gemfile?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gemfile_ruby_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_mark</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rackup_config_file?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rackup_options?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rbs_inline_annotation?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_comment_in_gemfile?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shebang?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shebang_continuation?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">steep_annotation?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/leading_comment_space.rb#105 RuboCop::Cop::Layout::LeadingCommentSpace::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for unnecessary leading blank lines at the beginning # of a file. # # @example # #   # bad #   # (start of file) # #   class Foo #   end # #   # bad #   # (start of file) # #   # a comment # #   # good #   # (start of file) #   class Foo #   end # #   # good #   # (start of file) #   # a comment # # source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#30 class RuboCop::Cop::Layout::LeadingEmptyLines &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/leading_empty_lines.rb#33 RuboCop::Cop::Layout::LeadingEmptyLines::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that strings broken over multiple lines (by a backslash) contain # trailing spaces instead of leading spaces (default) or leading spaces # instead of trailing spaces. # # @example EnforcedStyle: trailing (default) #   # bad #   ‘this text contains a lot of’ \ #   ‘               spaces’ # #   # good #   ‘this text contains a lot of               ’ \ #   ‘spaces’ # #   # bad #   ‘this text is too’ \ #   ‘ long’ # #   # good #   ‘this text is too ’ \ #   ‘long’ # @example EnforcedStyle: leading #   # bad #   ‘this text contains a lot of               ’ \ #   ‘spaces’ # #   # good #   ‘this text contains a lot of’ \ #   ‘               spaces’ # #   # bad #   ‘this text is too ’ \ #   ‘long’ # #   # good #   ‘this text is too’ \ #   ‘ long’ # # source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#43 class RuboCop::Cop::Layout::LineContinuationLeadingSpace &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">offense_range</span>, <span class="ruby-identifier">insert_pos</span>, <span class="ruby-identifier">spaces</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">continuation?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_num</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforced_style_leading?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">second_line</span>, <span class="ruby-identifier">end_of_first_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate_leading_style</span>(<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">second_line</span>, <span class="ruby-identifier">end_of_first_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate_trailing_style</span>(<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">second_line</span>, <span class="ruby-identifier">end_of_first_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_offense_range</span>(<span class="ruby-identifier">end_of_first_line</span>, <span class="ruby-identifier">matches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raw_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_offense_range</span>(<span class="ruby-identifier">end_of_first_line</span>, <span class="ruby-identifier">matches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># When both cops are activated and run in the same iteration of the correction loop,</span>
  <span class="ruby-comment"># `Style/StringLiterals` undoes the moving of spaces that</span>
  <span class="ruby-comment"># `Layout/LineContinuationLeadingSpace` performs. This is because `Style/StringLiterals`</span>
  <span class="ruby-comment"># takes the original string content and transforms it, rather than just modifying the</span>
  <span class="ruby-comment"># delimiters, in order to handle escaping for quotes within the string.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#59</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#49 RuboCop::Cop::Layout::LineContinuationLeadingSpace::LEADING_STYLE_OFFENSE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#47 RuboCop::Cop::Layout::LineContinuationLeadingSpace::LINE_1_ENDING = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#48 RuboCop::Cop::Layout::LineContinuationLeadingSpace::LINE_2_BEGINNING = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_continuation_leading_space.rb#50 RuboCop::Cop::Layout::LineContinuationLeadingSpace::TRAILING_STYLE_OFFENSE = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks that the backslash of a line continuation is separated from # preceding text by exactly one space (default) or zero spaces. # # @example EnforcedStyle: space (default) #   # bad #   ‘a’\ #   ‘b’  \ #   ‘c’ # #   # good #   ‘a’ \ #   ‘b’ \ #   ‘c’ # @example EnforcedStyle: no_space #   # bad #   ‘a’ \ #   ‘b’  \ #   ‘c’ # #   # good #   ‘a’\ #   ‘b’\ #   ‘c’ # # source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#30 class RuboCop::Cop::Layout::LineContinuationSpacing &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_ranges</span>(<span class="ruby-identifier">comments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offensive_spacing</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_range?</span>(<span class="ruby-identifier">backtick_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_literal_ranges</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_parent?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_space_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_continuation_spacing.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_style?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks the indentation of the next line after a line that ends with a string # literal and a backslash. # # If ‘EnforcedStyle: aligned` is set, the concatenated string parts shall be aligned with the # first part. There are some exceptions, such as implicit return values, where the # concatenated string parts shall be indented regardless of `EnforcedStyle` configuration. # # If `EnforcedStyle: indented` is set, it’s the second line that shall be indented one step # more than the first line. Lines 3 and forward shall be aligned with line 2. # # @example #   # bad #   def some_method #   ‘x’ \ #   ‘y’ \ #   ‘z’ #   end # #   my_hash = { #   first: ‘a message’ \ #   ‘in two parts’ #   } # #   # good #   def some_method #   ‘x’ \ #   ‘y’ \ #   ‘z’ #   end # @example EnforcedStyle: aligned (default) #   # bad #   puts ‘x’ \ #   ‘y’ # #   my_hash = { #   first: ‘a message’ \ #   ‘in two parts’ #   } # #   # good #   puts ‘x’ \ #   ‘y’ # #   my_hash = { #   first: ‘a message’ \ #   ‘in two parts’ #   } # @example EnforcedStyle: indented #   # bad #   result = ‘x’ \ #   ‘y’ # #   my_hash = { #   first: ‘a message’ \ #   ‘in two parts’ #   } # #   # good #   result = ‘x’ \ #   ‘y’ # #   my_hash = { #   first: ‘a message’ \ #   ‘in two parts’ #   } # # source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#74 class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_and_correction</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_indented?</span>(<span class="ruby-identifier">dstr_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_aligned</span>(<span class="ruby-identifier">children</span>, <span class="ruby-identifier">start_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_indented</span>(<span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strings_concatenated_with_backslash?</span>(<span class="ruby-identifier">dstr_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#79 RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#80 RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_end_string_concatenation_indentation.rb#81 RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::PARENT_TYPES_FOR_INDENTED = T.let(T.unsafe(nil), Array)</p>

<p># Checks the length of lines in the source code. # The maximum length is configurable. # The tab size is configured in the ‘IndentationWidth` # of the `Layout/IndentationStyle` cop. # It also ignores a shebang line by default. # # This cop has some autocorrection capabilities. # It can programmatically shorten certain long lines by # inserting line breaks into expressions that can be safely # split across lines. These include arrays, hashes, and # method calls with argument lists. # # If autocorrection is enabled, the following cops # are recommended to further format the broken lines. # (Many of these are enabled by default.) # # * `Layout/ArgumentAlignment` # * `Layout/ArrayAlignment` # * `Layout/BlockAlignment` # * `Layout/BlockEndNewline` # * `Layout/ClosingParenthesisIndentation` # * `Layout/FirstArgumentIndentation` # * `Layout/FirstArrayElementIndentation` # * `Layout/FirstHashElementIndentation` # * `Layout/FirstParameterIndentation` # * `Layout/HashAlignment` # * `Layout/IndentationWidth` # * `Layout/MultilineArrayLineBreaks` # * `Layout/MultilineBlockLayout` # * `Layout/MultilineHashBraceLayout` # * `Layout/MultilineHashKeyLineBreaks` # * `Layout/MultilineMethodArgumentLineBreaks` # * `Layout/MultilineMethodParameterLineBreaks` # * `Layout/ParameterAlignment` # * `Style/BlockDelimiters` # # Together, these cops will pretty print hashes, arrays, # method calls, etc. For example, let’s say the max columns # is 25: # # @example # #   # bad #   {foo: “0000000000”, bar: “0000000000”, baz: “0000000000”} # #   # good #   {foo: “0000000000”, #   bar: “0000000000”, baz: “0000000000”} # #   # good (with recommended cops enabled) #   { #   foo: “0000000000”, #   bar: “0000000000”, #   baz: “0000000000”, #   } # # source://rubocop//lib/rubocop/cop/layout/line_length.rb#63 class RuboCop::Cop::Layout::LineLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckLineBreakable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_investigation_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_potential_breakable_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#309</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_heredoc?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#317</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_string_split?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_combination?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">uri_range</span>, <span class="ruby-identifier">qualified_name_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_heredoc</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_line?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_block_range</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_dstr?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_dstr_begin_position</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute breakable_range.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute breakable_range</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute breakable_range to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_range=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_range_after_semicolon</span>(<span class="ruby-identifier">semicolon_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_range_by_line_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_string_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_string_position</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Locate where to break a string that is too long, ensuring that escape characters</span>
<span class="ruby-comment"># are not bisected.</span>
<span class="ruby-comment"># If the string contains spaces, use them to determine a place for a clean break;</span>
<span class="ruby-comment"># otherwise, the string will be broken at the line length limit.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">breakable_string_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#344</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_directive_line</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_breakable_block</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_breakable_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_breakable_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_breakable_semicolons</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_breakable_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_line</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#361</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_line_for_exemptions</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#294</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excess_range</span>(<span class="ruby-identifier">uri_range</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#321</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_heredocs</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredocs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">highlight_start</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Find the largest possible substring of a string node to retain before a break</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#405</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_possible_string</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_in_heredoc?</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_in_permitted_heredoc?</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#371</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_if_applicable</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">loc</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>, <span class="ruby-value">length:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shebang?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/line_length.rb#394</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_delimiter</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/line_length.rb#72 RuboCop::Cop::Layout::LineLength::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that the closing brace in an array literal is either # on the same line as the last array element or on a new line. # # When using the ‘symmetrical` (default) style: # # If an array’s opening brace is on the same line as the first element # of the array, then the closing brace should be on the same line as # the last element of the array. # # If an array’s opening brace is on the line above the first element # of the array, then the closing brace should be on the line below # the last element of the array. # # When using the ‘new_line` style: # # The closing brace of a multi-line array literal must be on the line # after the last element of the array. # # When using the `same_line` style: # # The closing brace of a multi-line array literal must be on the same # line as the last element of the array. # # @example EnforcedStyle: symmetrical (default) #   # bad #   [ :a, #   :b #   ] # #   # bad #   [ #   :a, #   :b ] # #   # good #   [ :a, #   :b ] # #   # good #   [ #   :a, #   :b #   ] # @example EnforcedStyle: new_line #   # bad #   [ #   :a, #   :b ] # #   # bad #   [ :a, #   :b ] # #   # good #   [ :a, #   :b #   ] # #   # good #   [ #   :a, #   :b #   ] # @example EnforcedStyle: same_line #   # bad #   [ :a, #   :b #   ] # #   # bad #   [ #   :a, #   :b #   ] # #   # good #   [ #   :a, #   :b ] # #   # good #   [ :a, #   :b ] # # source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#91 class RuboCop::Cop::Layout::MultilineArrayBraceLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineLiteralBraceLayout</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#103 RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#106 RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#99 RuboCop::Cop::Layout::MultilineArrayBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_array_brace_layout.rb#95 RuboCop::Cop::Layout::MultilineArrayBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Ensures that each item in a multi-line array # starts on a separate line. # # @example # #   # bad #   [ #   a, b, #   c #   ] # #   # good #   [ #   a, #   b, #   c #   ] # #   # good #   [ #   a, #   b, #   foo( #   bar #   ) #   ] # @example AllowMultilineFinalElement: false (default) # #   # bad #   [a, b, foo( #   bar #   )] # @example AllowMultilineFinalElement: true # #   # good #   [a, b, foo( #   bar #   )] # # source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#47 class RuboCop::Cop::Layout::MultilineArrayLineBreaks &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementLineBreaks</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_array_line_breaks.rb#51 RuboCop::Cop::Layout::MultilineArrayLineBreaks::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the multiline assignments have a newline # after the assignment operator. # # @example EnforcedStyle: new_line (default) #   # bad #   foo = if expression #   ‘bar’ #   end # #   # good #   foo = #   if expression #   ‘bar’ #   end # #   # good #   foo = #   begin #   compute #   rescue =&gt; e #   nil #   end # @example EnforcedStyle: same_line #   # good #   foo = if expression #   ‘bar’ #   end # @example SupportedTypes: [‘block’, ‘case’, ‘class’, ‘if’, ‘kwbegin’, ‘module’] (default) #   # good #   foo = #   if expression #   ‘bar’ #   end # #   # good #   foo = #   [1].map do |i| #   i + 1 #   end # @example SupportedTypes: [‘block’] #   # good #   foo = if expression #   ‘bar’ #   end # #   # good #   foo = #   [1].map do |i| #   ‘bar’ * i #   end # # source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#60 class RuboCop::Cop::Layout::MultilineAssignmentLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_by_enforced_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_new_line_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_same_line_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_types</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#66 RuboCop::Cop::Layout::MultilineAssignmentLayout::NEW_LINE_OFFENSE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_assignment_layout.rb#69 RuboCop::Cop::Layout::MultilineAssignmentLayout::SAME_LINE_OFFENSE = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the multiline do end blocks have a newline # after the start of the block. Additionally, it checks whether the block # arguments, if any, are on the same line as the start of the # block. Putting block arguments on separate lines, because the whole # line would otherwise be too long, is accepted. # # @example #   # bad #   blah do |i| foo(i) #   bar(i) #   end # #   # bad #   blah do #   |i| foo(i) #   bar(i) #   end # #   # good #   blah do |i| #   foo(i) #   bar(i) #   end # #   # bad #   blah { |i| foo(i) #   bar(i) #   } # #   # good #   blah { |i| #   foo(i) #   bar(i) #   } # #   # good #   blah { | #   long_list, #   of_parameters, #   that_would_not, #   fit_on_one_line #   | #   foo(i) #   bar(i) #   } # # source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#51 class RuboCop::Cop::Layout::MultilineBlockLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_expression</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_on_beginning_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_arguments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_body</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_arg_string</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">characters_needed_for_space_and_pipes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_trailing_comma?</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_break_necessary_in_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needed_length_for_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#56 RuboCop::Cop::Layout::MultilineBlockLayout::ARG_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#55 RuboCop::Cop::Layout::MultilineBlockLayout::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_block_layout.rb#57 RuboCop::Cop::Layout::MultilineBlockLayout::PIPE_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># Checks that the closing brace in a hash literal is either # on the same line as the last hash element, or a new line. # # When using the ‘symmetrical` (default) style: # # If a hash’s opening brace is on the same line as the first element # of the hash, then the closing brace should be on the same line as # the last element of the hash. # # If a hash’s opening brace is on the line above the first element # of the hash, then the closing brace should be on the line below # the last element of the hash. # # When using the ‘new_line` style: # # The closing brace of a multi-line hash literal must be on the line # after the last element of the hash. # # When using the `same_line` style: # # The closing brace of a multi-line hash literal must be on the same # line as the last element of the hash. # # @example EnforcedStyle: symmetrical (default) # #   # bad #   { a: 1, #   b: 2 #   } #   # bad #   { #   a: 1, #   b: 2 } # #   # good #   { a: 1, #   b: 2 } # #   # good #   { #   a: 1, #   b: 2 #   } # @example EnforcedStyle: new_line #   # bad #   { #   a: 1, #   b: 2 } # #   # bad #   { a: 1, #   b: 2 } # #   # good #   { a: 1, #   b: 2 #   } # #   # good #   { #   a: 1, #   b: 2 #   } # @example EnforcedStyle: same_line #   # bad #   { a: 1, #   b: 2 #   } # #   # bad #   { #   a: 1, #   b: 2 #   } # #   # good #   { #   a: 1, #   b: 2 } # #   # good #   { a: 1, #   b: 2 } # # source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#91 class RuboCop::Cop::Layout::MultilineHashBraceLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineLiteralBraceLayout</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#103 RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#106 RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#99 RuboCop::Cop::Layout::MultilineHashBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_hash_brace_layout.rb#95 RuboCop::Cop::Layout::MultilineHashBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Ensures that each key in a multi-line hash # starts on a separate line. # # @example # #   # bad #   { #   a: 1, b: 2, #   c: 3 #   } # #   # good #   { #   a: 1, #   b: 2, #   c: 3 #   } # #   # good #   { #   a: 1, #   b: { #   c: 3, #   } #   } # @example AllowMultilineFinalElement: false (default) # #   # bad #   { a: 1, b: { #   c: 3, #   }} # @example AllowMultilineFinalElement: true # #   # good #   { a: 1, b: { #   c: 3, #   }} # # source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#46 class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementLineBreaks</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">starts_with_curly_brace?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_hash_key_line_breaks.rb#50 RuboCop::Cop::Layout::MultilineHashKeyLineBreaks::MSG = T.let(T.unsafe(nil), String)</p>

<p># Ensures that each argument in a multi-line method call # starts on a separate line. # # NOTE: This cop does not move the first argument, if you want that to # be on a separate line, see ‘Layout/FirstMethodArgumentLineBreak`. # # @example # #   # bad #   foo(a, b, #   c #   ) # #   # bad #   foo(a, b, { #   foo: “bar”, #   }) # #   # good #   foo( #   a, #   b, #   c #   ) # #   # good #   foo(a, b, c) # @example AllowMultilineFinalElement: false (default) # #   # bad #   foo(a, b, #   c #   ) # #   # bad #   foo( #   a, b, { #   foo: “bar”, #   } #   ) # #   # good #   foo( #   a, #   b, #   { #   foo: “bar”, #   } #   ) # @example AllowMultilineFinalElement: true # #   # bad #   foo(a, b, #   c #   ) # #   # good #   foo( #   a, b, { #   foo: “bar”, #   } #   ) # #   # good #   foo( #   a, #   b, #   { #   foo: “bar”, #   } #   ) # # source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#80 class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementLineBreaks</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_argument_line_breaks.rb#84 RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that the closing brace in a method call is either # on the same line as the last method argument, or a new line. # # When using the ‘symmetrical` (default) style: # # If a method call’s opening brace is on the same line as the first # argument of the call, then the closing brace should be on the same # line as the last argument of the call. # # If a method call’s opening brace is on the line above the first # argument of the call, then the closing brace should be on the line # below the last argument of the call. # # When using the ‘new_line` style: # # The closing brace of a multi-line method call must be on the line # after the last argument of the call. # # When using the `same_line` style: # # The closing brace of a multi-line method call must be on the same # line as the last argument of the call. # # @example EnforcedStyle: symmetrical (default) #   # bad #   foo(a, #   b #   ) # #   # bad #   foo( #   a, #   b) # #   # good #   foo(a, #   b) # #   # good #   foo( #   a, #   b #   ) # @example EnforcedStyle: new_line #   # bad #   foo( #   a, #   b) # #   # bad #   foo(a, #   b) # #   # good #   foo(a, #   b #   ) # #   # good #   foo( #   a, #   b #   ) # @example EnforcedStyle: same_line #   # bad #   foo(a, #   b #   ) # #   # bad #   foo( #   a, #   b #   ) # #   # good #   foo( #   a, #   b) # #   # good #   foo(a, #   b) # # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#91 class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineLiteralBraceLayout</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_ignoring_receiver?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#103 RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#106 RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#99 RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_brace_layout.rb#95 RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the method name part in method calls # that span more than one line. # # @example EnforcedStyle: aligned (default) #   # bad #   while myvariable #   .b #   # do something #   end # #   # good #   while myvariable #   .b #   # do something #   end # #   # good #   Thing.a #   .b #   .c # @example EnforcedStyle: indented #   # good #   while myvariable #   .b # #   # do something #   end # @example EnforcedStyle: indented_relative_to_receiver #   # good #   while myvariable #   .a #   .b # #   # do something #   end # #   # good #   myvariable = Thing #   .a #   .b #   .c # # source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#49 class RuboCop::Cop::Layout::MultilineMethodCallIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineExpressionIndentation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_with_base_message</span>(<span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_base</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">given_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_indentation</span>(<span class="ruby-identifier">given_style</span>, <span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_multiline_block_chain_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_call_has_a_dot</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_dot_right_above</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_base_message</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">given_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [operation_rhs.first_argument]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operation_rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_rhs?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># a</span>
<span class="ruby-comment">#   .b</span>
<span class="ruby-comment">#   .c</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_alignment_base</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_to_receiver_message</span>(<span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_node?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_hand_side</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># a.b</span>
<span class="ruby-comment">#  .c</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantic_alignment_base</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantic_alignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_align_with_base?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_indent_relative_to_receiver?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_call_indentation.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">syntactic_alignment_base</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks that the closing brace in a method definition is either # on the same line as the last method parameter, or a new line. # # When using the ‘symmetrical` (default) style: # # If a method definition’s opening brace is on the same line as the # first parameter of the definition, then the closing brace should be # on the same line as the last parameter of the definition. # # If a method definition’s opening brace is on the line above the first # parameter of the definition, then the closing brace should be on the # line below the last parameter of the definition. # # When using the ‘new_line` style: # # The closing brace of a multi-line method definition must be on the line # after the last parameter of the definition. # # When using the `same_line` style: # # The closing brace of a multi-line method definition must be on the same # line as the last parameter of the definition. # # @example EnforcedStyle: symmetrical (default) #   # bad #   def foo(a, #   b #   ) #   end # #   # bad #   def foo( #   a, #   b) #   end # #   # good #   def foo(a, #   b) #   end # #   # good #   def foo( #   a, #   b #   ) #   end # @example EnforcedStyle: new_line #   # bad #   def foo( #   a, #   b) #   end # #   # bad #   def foo(a, #   b) #   end # #   # good #   def foo(a, #   b #   ) #   end # #   # good #   def foo( #   a, #   b #   ) #   end # @example EnforcedStyle: same_line #   # bad #   def foo(a, #   b #   ) #   end # #   # bad #   def foo( #   a, #   b #   ) #   end # #   # good #   def foo( #   a, #   b) #   end # #   # good #   def foo(a, #   b) #   end # # source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#103 class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineLiteralBraceLayout</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#115 RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#118 RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#111 RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_definition_brace_layout.rb#107 RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Ensures that each parameter in a multi-line method definition # starts on a separate line. # # NOTE: This cop does not move the first argument, if you want that to # be on a separate line, see ‘Layout/FirstMethodParameterLineBreak`. # # @example # #   # bad #   def foo(a, b, #   c #   ) #   end # #   # good #   def foo( #   a, #   b, #   c #   ) #   end # #   # good #   def foo( #   a, #   b = { #   foo: “bar”, #   } #   ) #   end # #   # good #   def foo(a, b, c) #   end # @example AllowMultilineFinalElement: false (default) # #   # bad #   def foo(a, b = { #   foo: “bar”, #   }) #   end # @example AllowMultilineFinalElement: true # #   # good #   def foo(a, b = { #   foo: “bar”, #   }) #   end # # source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#57 class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineElementLineBreaks</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_last_element?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/multiline_method_parameter_line_breaks.rb#61 RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the indentation of the right hand side operand in binary operations that # span more than one line. # # The ‘aligned` style checks that operators are aligned if they are part of an `if` or `while` # condition, an explicit `return` statement, etc. In other contexts, the second operand should # be indented regardless of enforced style. # # @example EnforcedStyle: aligned (default) #   # bad #   if a + #   b #   something &amp;&amp; #   something_else #   end # #   # good #   if a + #   b #   something &amp;&amp; #   something_else #   end # @example EnforcedStyle: indented #   # bad #   if a + #   b #   something &amp;&amp; #   something_else #   end # #   # good #   if a + #   b #   something &amp;&amp; #   something_else #   end # # source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#43 class RuboCop::Cop::Layout::MultilineOperationIndentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineExpressionIndentation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [ValidationError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_and_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">given_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_hand_side</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/multiline_operation_indentation.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_align?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">given_style</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Check that the parameters on a multi-line method call or definition are aligned. # # To set the alignment of the first argument, use the # ‘Layout/FirstParameterIndentation` cop. # # @example EnforcedStyle: with_first_parameter (default) #   # good # #   def foo(bar, #   baz) #   123 #   end # #   def foo( #   bar, #   baz #   ) #   123 #   end # #   # bad # #   def foo(bar, #   baz) #   123 #   end # #   # bad # #   def foo( #   bar, #   baz) #   123 #   end # @example EnforcedStyle: with_fixed_indentation #   # good # #   def foo(bar, #   baz) #   123 #   end # #   def foo( #   bar, #   baz #   ) #   123 #   end # #   # bad # #   def foo(bar, #   baz) #   123 #   end # #   # bad # #   def foo( #   bar, #   baz) #   123 #   end # # source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#70 class RuboCop::Cop::Layout::ParameterAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_column</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixed_indentation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_method_lineno</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#74 RuboCop::Cop::Layout::ParameterAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/parameter_alignment.rb#77 RuboCop::Cop::Layout::ParameterAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether certain expressions, e.g. method calls, that could fit # completely on a single line, are broken up into multiple lines unnecessarily. # # @example #   # bad #   foo( #   a, #   b #   ) # #   # good #   foo(a, b) # #   # bad #   puts ‘string that fits on ’ \ #   ‘a single line’ # #   # good #   puts ‘string that fits on a single line’ # #   # bad #   things #   .select { |thing| thing.cond? } #   .join(‘-’) # #   # good #   things.select { |thing| thing.cond? }.join(‘-’) # @example InspectBlocks: false (default) #   # good #   foo(a) do |x| #   puts x #   end # @example InspectBlocks: true #   # bad #   foo(a) do |x| #   puts x #   end # #   # good #   foo(a) { |x| puts x } # # source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#49 class RuboCop::Cop::Layout::RedundantLineBreak &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckSingleLineSuitability</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">_rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configured_to_not_be_inspected?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convertible_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_with_percent_blank_string?</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index_access_call_chained?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">other_cop_takes_precedence?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_backslash?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_block_chain_enabled?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/redundant_line_break.rb#54 RuboCop::Cop::Layout::RedundantLineBreak::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether the rescue and ensure keywords are aligned # properly. # # @example # #   # bad #   begin #   something #   rescue #   puts ‘error’ #   end # #   # good #   begin #   something #   rescue #   puts ‘error’ #   end # # source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#24 class RuboCop::Cop::Layout::RescueEnsureAlignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndKeywordAlignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_leading_dot?</span>(<span class="ruby-identifier">do_keyword_line</span>, <span class="ruby-identifier">send_node_loc</span>, <span class="ruby-identifier">rescue_keyword_column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_line_break_method?</span>(<span class="ruby-identifier">ancestor_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_location</span>(<span class="ruby-identifier">alignment_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># We will use ancestor or wrapper with access modifier.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alignment_source</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">starting_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ancestor_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">alignment_location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_end_alignment_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Check alignment of node with rescue or ensure modifiers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">alignment_node</span>, <span class="ruby-identifier">alignment_loc</span>, <span class="ruby-identifier">kw_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#33 RuboCop::Cop::Layout::RescueEnsureAlignment::ALTERNATIVE_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#32 RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/layout/rescue_ensure_alignment.rb#29 RuboCop::Cop::Layout::RescueEnsureAlignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if method calls are chained onto single line blocks. It considers that a # line break before the dot improves the readability of the code. # # @example #   # bad #   example.select { |item| item.cond? }.join(‘-’) # #   # good #   example.select { |item| item.cond? } #   .join(‘-’) # #   # good (not a concern for this cop) #   example.select do |item| #   item.cond? #   end.join(‘-’) # # source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#22 class RuboCop::Cop::Layout::SingleLineBlockChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_method_after_block?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">dot_range</span>, <span class="ruby-identifier">closing_block_delimiter_line_num</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selector_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/single_line_block_chain.rb#26 RuboCop::Cop::Layout::SingleLineBlockChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for colon (‘:`) not followed by some kind of space. # N.B. this cop does not handle spaces after a ternary operator, which are # instead handled by `Layout/SpaceAroundOperators`. # # @example #   # bad #   def f(a:, b:2); {a:3}; end # #   # good #   def f(a:, b: 2); {a: 3}; end # # source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#16 class RuboCop::Cop::Layout::SpaceAfterColon &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">followed_by_space?</span>(<span class="ruby-identifier">colon</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">colon</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_after_colon.rb#19 RuboCop::Cop::Layout::SpaceAfterColon::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for comma (‘,`) not followed by some kind of space. # # @example # #   # bad #   [1,2] #   { foo:bar,} # #   # good #   [1, 2] #   { foo:bar, } # # source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#17 class RuboCop::Cop::Layout::SpaceAfterComma &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SpaceAfterPunctuation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kind</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_style_before_rcurly</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_comma.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_semicolon?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for space between a method name and a left parenthesis in defs. # # @example # #   # bad #   def func (x) end #   def method= (y) end # #   # good #   def func(x) end #   def method=(y) end # # source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#17 class RuboCop::Cop::Layout::SpaceAfterMethodName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_after_method_name.rb#21 RuboCop::Cop::Layout::SpaceAfterMethodName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for space after ‘!`. # # @example #   # bad #   ! something # #   # good #   !something # # source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#14 class RuboCop::Cop::Layout::SpaceAfterNot &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_after_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#18 RuboCop::Cop::Layout::SpaceAfterNot::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_after_not.rb#19 RuboCop::Cop::Layout::SpaceAfterNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for semicolon (‘;`) not followed by some kind of space. # # @example #   # bad #   x = 1;y = 2 # #   # good #   x = 1; y = 2 # # source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#14 class RuboCop::Cop::Layout::SpaceAfterSemicolon &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SpaceAfterPunctuation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kind</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_missing?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_style_before_rcurly</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_after_semicolon.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semicolon_sequence?</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">next_token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks the spacing inside and after block parameters pipes. Line breaks # inside parameter pipes are checked by ‘Layout/MultilineBlockLayout` and # not by this cop. # # @example EnforcedStyleInsidePipes: no_space (default) #   # bad #   {}.each { | x,  y |puts x } #   -&gt;( x,  y ) { puts x } # #   # good #   {}.each { |x, y| puts x } #   -&gt;(x, y) { puts x } # @example EnforcedStyleInsidePipes: space #   # bad #   {}.each { |x,  y| puts x } #   -&gt;(x,  y) { puts x } # #   # good #   {}.each { | x, y | puts x } #   -&gt;( x, y ) { puts x } # # source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#27 class RuboCop::Cop::Layout::SpaceAroundBlockParameters &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_after_closing_pipe</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_arg</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_closing_pipe_space</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">closing_pipe</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_each_arg</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_inside_pipes</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_no_space</span>(<span class="ruby-identifier">space_begin_pos</span>, <span class="ruby-identifier">space_end_pos</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_no_space_style_inside_pipes</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_opening_pipe_space</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">opening_pipe</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space</span>(<span class="ruby-identifier">space_begin_pos</span>, <span class="ruby-identifier">space_end_pos</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">msg</span>, <span class="ruby-identifier">node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space_style_inside_pipes</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_end_pos_inside_pipes</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pipes</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pipes?</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_block_parameters.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks that the equals signs in parameter default assignments # have or don’t have surrounding space depending on configuration. # # @example EnforcedStyle: space (default) #   # bad #   def some_method(arg1=:default, arg2=nil, arg3=[]) #   # do something… #   end # #   # good #   def some_method(arg1 = :default, arg2 = nil, arg3 = []) #   # do something… #   end # @example EnforcedStyle: no_space #   # bad #   def some_method(arg1 = :default, arg2 = nil, arg3 = []) #   # do something… #   end # #   # good #   def some_method(arg1=:default, arg2=nil, arg3=[]) #   # do something… #   end # # source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#30 class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_optarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_optarg</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">equals</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_style_detected</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_surrounding_space?</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">equals</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_on_both_sides?</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">equals</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_equals_in_parameter_default.rb#36 RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the spacing around the keywords. # # @example # #   # bad #   something ‘test’do|x| #   end # #   while(something) #   end # #   something = 123if test # #   # good #   something ‘test’ do |x| #   end # #   while (something) #   end # #   something = 123 if test # # source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#27 class RuboCop::Cop::Layout::SpaceAroundKeyword &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_break</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Handle one-line pattern matching syntax (`in`) with `Parser::Ruby27`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Handle one-line pattern matching syntax (`in`) with `Parser::Ruby30`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern_p</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_next</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_postexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_preexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_unless_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_zsuper</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_left_parenthesis?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_left_square_bracket?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_namespace_operator?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accepted_opening_delimiter?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">locations</span>, <span class="ruby-identifier">begin_keyword</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_begin</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">begin_keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_end</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">begin_keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_keyword</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace_operator?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceded_by_operator?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_navigation_call?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_after_missing?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_before_missing?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#36 RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_PAREN = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#37 RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#38 RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#33 RuboCop::Cop::Layout::SpaceAroundKeyword::DO = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#31 RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_AFTER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#30 RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_BEFORE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#35 RuboCop::Cop::Layout::SpaceAroundKeyword::NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#39 RuboCop::Cop::Layout::SpaceAroundKeyword::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_keyword.rb#34 RuboCop::Cop::Layout::SpaceAroundKeyword::SAFE_NAVIGATION = T.let(T.unsafe(nil), String)</p>

<p># Checks method call operators to not have spaces around them. # # @example #   # bad #   foo. bar #   foo .bar #   foo . bar #   foo. bar .buzz #   foo #   . bar #   . buzz #   foo&amp;. bar #   foo &amp;.bar #   foo &amp;. bar #   foo &amp;. bar&amp;. buzz</p>
<dl class="rdoc-list note-list"><dt>#   RuboCop</dt>
<dd>
<p>Cop</p>
</dd><dt>#   RuboCop</dt>
<dd><dl class="rdoc-list note-list"><dt>Cop</dt>
<dd>
<p>Base</p>
</dd></dl>
</dd><dt>#   </dt>
<dd>
<p>RuboCop::Cop</p>
</dd></dl>

<p># #   # good #   foo.bar #   foo.bar.buzz #   foo #   .bar #   .buzz #   foo&amp;.bar #   foo&amp;.bar&amp;.buzz #   RuboCop::Cop #   RuboCop::Cop::Base #   ::RuboCop::Cop # # source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#37 class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space</span>(<span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space_after_dot</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space_after_double_colon</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_space_before_dot</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#43 RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_method_call_operator.rb#41 RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks that operators have space around them, except for ** which # should or shouldn’t have surrounding space depending on configuration. # It allows vertical alignment consisting of one or more whitespace # around operators. # # This cop has ‘AllowForAlignment` option. When `true`, allows most # uses of extra spacing if the intent is to align with an operator on # the previous or next line, not counting empty lines or comment lines. # # @example #   # bad #   total = 3*4 #   “apple”+“juice” #   my_number = 38/4 # #   # good #   total = 3 * 4 #   “apple” + “juice” #   my_number = 38 / 4 # @example AllowForAlignment: true (default) #   # good #   { #   1 =&gt;  2, #   11 =&gt; 3 #   } # @example AllowForAlignment: false #   # bad #   { #   1 =&gt;  2, #   11 =&gt; 3 #   } # @example EnforcedStyleForExponentOperator: no_space (default) #   # bad #   a ** b # #   # good #   a**b # @example EnforcedStyleForExponentOperator: space #   # bad #   a**b # #   # good #   a ** b # @example EnforcedStyleForRationalLiterals: no_space (default) #   # bad #   1 / 48r # #   # good #   1/48r # @example EnforcedStyleForRationalLiterals: space #   # bad #   1/48r # #   # good #   1 / 48r # # source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#67 class RuboCop::Cop::Layout::SpaceAroundOperators &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PrecedingFollowingAlignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RationalLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_binary</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_setter_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">align_hash_cop_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_operator</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enclose_operator_with_space</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excess_leading_space?</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">with_space</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excess_trailing_space?</span>(<span class="ruby-identifier">right_operand</span>, <span class="ruby-identifier">with_space</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_equal_sign_alignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_table_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [msg]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">with_space</span>, <span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">with_space</span>, <span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_with_regular_syntax?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regular_operator?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_not_have_surrounding_space?</span>(<span class="ruby-identifier">operator</span>, <span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_around_exponent_operator?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#273</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_around_slash_operator?</span>(<span class="ruby-identifier">right_operand</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#76</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#74 RuboCop::Cop::Layout::SpaceAroundOperators::EXCESSIVE_SPACE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_around_operators.rb#73 RuboCop::Cop::Layout::SpaceAroundOperators::IRREGULAR_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks that block braces have or don’t have a space before the opening # brace depending on configuration. # # @example EnforcedStyle: space (default) #   # bad #   foo.map{ |a| #   a.bar.to_s #   } # #   # good #   foo.map { |a| #   a.bar.to_s #   } # @example EnforcedStyle: no_space #   # bad #   foo.map { |a| #   a.bar.to_s #   } # #   # good #   foo.map{ |a| #   a.bar.to_s #   } # @example EnforcedStyleForEmptyBraces: space (default) #   # bad #   7.times{} # #   # good #   7.times {} # @example EnforcedStyleForEmptyBraces: no_space #   # bad #   7.times {} # #   # good #   7.times{} # # source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#44 class RuboCop::Cop::Layout::SpaceBeforeBlockBraces &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_delimiters_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_empty</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">space_plus_brace</span>, <span class="ruby-identifier">used_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_non_empty</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">space_plus_brace</span>, <span class="ruby-identifier">used_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conflict_with_block_delimiters?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_braces?</span>(<span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_different_styles_for_empty_braces</span>(<span class="ruby-identifier">used_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_detected</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">space_plus_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_missing</span>(<span class="ruby-identifier">left_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_for_empty_braces</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#50 RuboCop::Cop::Layout::SpaceBeforeBlockBraces::DETECTED_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_block_braces.rb#49 RuboCop::Cop::Layout::SpaceBeforeBlockBraces::MISSING_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for space between the name of a receiver and a left # brackets. # # @example # #   # bad #   collection [index_or_key] # #   # good #   <a href="index_or_key">collection</a> # # source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#17 class RuboCop::Cop::Layout::SpaceBeforeBrackets &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#21 RuboCop::Cop::Layout::SpaceBeforeBrackets::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_brackets.rb#22 RuboCop::Cop::Layout::SpaceBeforeBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for comma (‘,`) preceded by space. # # @example #   # bad #   [1 , 2 , 3] #   a(1 , 2) #   each { |a , b| } # #   # good #   [1, 2, 3] #   a(1, 2) #   each { |a, b| } # # source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#19 class RuboCop::Cop::Layout::SpaceBeforeComma &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SpaceBeforePunctuation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_comma.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kind</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for missing space between a token and a comment on the # same line. # # @example #   # bad #   1 + 1# this operation does … # #   # good #   1 + 1 # this operation does … # # source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#15 class RuboCop::Cop::Layout::SpaceBeforeComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_comment.rb#18 RuboCop::Cop::Layout::SpaceBeforeComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that exactly one space is used between a method name and the # first argument for method calls without parentheses. # # Alternatively, extra spaces can be added to align the argument with # something on a preceding or following line, if the AllowForAlignment # config parameter is true. # # @example #   # bad #   something  x #   something   y, z #   something’hello’ # #   # good #   something x #   something y, z #   something ‘hello’ # # source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#24 class RuboCop::Cop::Layout::SpaceBeforeFirstArg &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PrecedingFollowingAlignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expect_params_after_method_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_space_between_method_name_and_first_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regular_method_call_with_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_before_first_arg.rb#29 RuboCop::Cop::Layout::SpaceBeforeFirstArg::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for semicolon (‘;`) preceded by space. # # @example #   # bad #   x = 1 ; y = 2 # #   # good #   x = 1; y = 2 # # source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#14 class RuboCop::Cop::Layout::SpaceBeforeSemicolon &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SpaceBeforePunctuation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_before_semicolon.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kind</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for spaces between ‘-&gt;` and opening parameter # parenthesis (`(`) in lambda literals. # # @example EnforcedStyle: require_no_space (default) #   # bad #   a = -&gt; (x, y) { x + y } # #   # good #   a = -&gt;(x, y) { x + y } # @example EnforcedStyle: require_space #   # bad #   a = -&gt;(x, y) { x + y } # #   # good #   a = -&gt; (x, y) { x + y } # # source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#22 class RuboCop::Cop::Layout::SpaceInLambdaLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arrow_lambda_with_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_arguments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_after_arrow</span>(<span class="ruby-identifier">lambda_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_after_arrow?</span>(<span class="ruby-identifier">lambda_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#28 RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_NO_SPACE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_in_lambda_literal.rb#27 RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_SPACE = T.let(T.unsafe(nil), String)</p>

<p># Checks that brackets used for array literals have or don’t have # surrounding space depending on configuration. # # Array pattern matching is handled in the same way. # # @example EnforcedStyle: no_space (default) #   # The ‘no_space` style enforces that array literals have #   # no surrounding space. # #   # bad #   array = [ a, b, c, d ] #   array = [ a, [ b, c ]] # #   # good #   array = [a, b, c, d] #   array = [a, [b, c]] # @example EnforcedStyle: space #   # The `space` style enforces that array literals have #   # surrounding space. # #   # bad #   array = [a, b, c, d] #   array = [ a, [ b, c ]] # #   # good #   array = [ a, b, c, d ] #   array = [ a, [ b, c ] ] # @example EnforcedStyle: compact #   # The `compact` style normally requires a space inside #   # array brackets, with the exception that successive left #   # or right brackets are collapsed together in nested arrays. # #   # bad #   array = [a, b, c, d] #   array = [ a, [ b, c ] ] #   array = [ #   [ a ], #   [ b, c ] #   ] # #   # good #   array = [ a, b, c, d ] #   array = [ a, [ b, c ]] #   array = [[ a ], #   [ b, c ]] # @example EnforcedStyleForEmptyBrackets: no_space (default) #   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that #   # empty array brackets do not contain spaces. # #   # bad #   foo = [ ] #   bar = [     ] # #   # good #   foo = [] #   bar = [] # @example EnforcedStyleForEmptyBrackets: space #   # The `space` EnforcedStyleForEmptyBrackets style enforces that #   # empty array brackets contain exactly one space. # #   # bad #   foo = [] #   bar = [    ] # #   # good #   foo = [ ] #   bar = [ ] # # source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#78 class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_brackets</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">bracket</span>, <span class="ruby-identifier">side</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_corrections</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>, <span class="ruby-value">side:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>, <span class="ruby-identifier">start_ok</span>, <span class="ruby-identifier">end_ok</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_has_own_line?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_node_with_brackets</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index_for</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">issue_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>, <span class="ruby-identifier">start_ok</span>, <span class="ruby-identifier">end_ok</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_and_column_for</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multi_dimensional_array?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>, <span class="ruby-value">side:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_to_bracket?</span>(<span class="ruby-identifier">token</span>, <span class="ruby-value">side:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_to_comment?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_to_newline?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualifies_for_compact?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>, <span class="ruby-value">side:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#84 RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_array_literal_brackets.rb#83 RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for unnecessary additional spaces inside array percent literals # (i.e. %i/%w). # # Note that blank percent literals (e.g. ‘%i( )`) are checked by # `Layout/SpaceInsidePercentLiteralDelimiters`. # # @example # #   # bad #   %w(foo  bar  baz) #   # good #   %i(foo bar baz) # # source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#18 class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MatchRange</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_unnecessary_space_match</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">blk</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#23 RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_array_percent_literal.rb#24 RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks that block braces have or don’t have surrounding space inside # them on configuration. For blocks taking parameters, it checks that the # left brace has or doesn’t have trailing space depending on # configuration. # # @example EnforcedStyle: space (default) #   # The ‘space` style enforces that block braces have #   # surrounding space. # #   # bad #   some_array.each {puts e} # #   # good #   some_array.each { puts e } # @example EnforcedStyle: no_space #   # The `no_space` style enforces that block braces don’t #   # have surrounding space. # #   # bad #   some_array.each { puts e } # #   # good #   some_array.each {puts e} # @example EnforcedStyleForEmptyBraces: no_space (default) #   # The ‘no_space` EnforcedStyleForEmptyBraces style enforces that #   # block braces don’t have a space in between when empty. # #   # bad #   some_array.each {   } #   some_array.each {  } #   some_array.each { } # #   # good #   some_array.each {} # @example EnforcedStyleForEmptyBraces: space #   # The ‘space` EnforcedStyleForEmptyBraces style enforces that #   # block braces have at least a space in between when empty. # #   # bad #   some_array.each {} # #   # good #   some_array.each { } #   some_array.each {  } #   some_array.each {   } # @example SpaceBeforeBlockParameters: true (default) #   # The SpaceBeforeBlockParameters style set to `true` enforces that #   # there is a space between `{` and `|`. Overrides `EnforcedStyle` #   # if there is a conflict. # #   # bad #   [1, 2, 3].each {|n| n * 2 } # #   # good #   [1, 2, 3].each { |n| n * 2 } # @example SpaceBeforeBlockParameters: false #   # The SpaceBeforeBlockParameters style set to `false` enforces that #   # there is no space between `{` and `|`. Overrides `EnforcedStyle` #   # if there is a conflict. # #   # bad #   [1, 2, 3].each { |n| n * 2 } # #   # good #   [1, 2, 3].each {|n| n * 2 } # # source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#79 class RuboCop::Cop::Layout::SpaceInsideBlockBraces &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjacent_braces</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">right_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_braces?</span>(<span class="ruby-identifier">inner</span>, <span class="ruby-identifier">right_brace</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_with_contents_inside</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">inner</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_inside</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">right_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_left_brace</span>(<span class="ruby-identifier">inner</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">args_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_right_brace</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">inner</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">right_brace</span>, <span class="ruby-identifier">single_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_last_space_count</span>(<span class="ruby-identifier">inner</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_block?</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">right_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_space</span>(<span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_space_inside_left_brace</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">args_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense</span>(<span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>, <span class="ruby-identifier">msg</span>, <span class="ruby-identifier">style_param</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pipe?</span>(<span class="ruby-identifier">args_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space</span>(<span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_inside_left_brace</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">args_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_inside_right_brace</span>(<span class="ruby-identifier">inner</span>, <span class="ruby-identifier">right_brace</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_for_empty_braces</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_block_braces.rb#85</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks that braces used for hash literals have or don’t have # surrounding space depending on configuration. # # Hash pattern matching is handled in the same way. # # @example EnforcedStyle: space (default) #   # The ‘space` style enforces that hash literals have #   # surrounding space. # #   # bad #   h = {a: 1, b: 2} #   foo = {{ a: 1 } =&gt; { b: { c: 2 }}} # #   # good #   h = { a: 1, b: 2 } #   foo = { { a: 1 } =&gt; { b: { c: 2 } } } # @example EnforcedStyle: no_space #   # The `no_space` style enforces that hash literals have #   # no surrounding space. # #   # bad #   h = { a: 1, b: 2 } #   foo = {{ a: 1 } =&gt; { b: { c: 2 }}} # #   # good #   h = {a: 1, b: 2} #   foo = {{a: 1} =&gt; {b: {c: 2}}} # @example EnforcedStyle: compact #   # The `compact` style normally requires a space inside #   # hash braces, with the exception that successive left #   # braces or right braces are collapsed together in nested hashes. # #   # bad #   h = { a: { b: 2 } } #   foo = { { a: 1 } =&gt; { b: { c: 2 } } } # #   # good #   h = { a: { b: 2 }} #   foo = {{ a: 1 } =&gt; { b: { c: 2 }}} # @example EnforcedStyleForEmptyBraces: no_space (default) #   # The `no_space` EnforcedStyleForEmptyBraces style enforces that #   # empty hash braces do not contain spaces. # #   # bad #   foo = { } #   bar = {    } #   baz = { #   } # #   # good #   foo = {} #   bar = {} #   baz = {} # @example EnforcedStyleForEmptyBraces: space #   # The `space` EnforcedStyleForEmptyBraces style enforces that #   # empty hash braces contain space. # #   # bad #   foo = {} # #   # good #   foo = { } #   foo = {    } #   foo = { #   } # # source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#76 class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_or_unexpected_style_detected</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">is_match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_whitespace_only_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_no_space_style_for_empty_braces?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expect_space?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_style_detected</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>, <span class="ruby-identifier">expect_space</span>, <span class="ruby-identifier">is_empty_braces</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">brace</span>, <span class="ruby-identifier">is_empty_braces</span>, <span class="ruby-identifier">expect_space</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">expect_space</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_inside_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_space_to_the_left</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_space_to_the_right</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_range</span>(<span class="ruby-identifier">token_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_hash_literal_braces.rb#82 RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for spaces inside ordinary round parentheses. # # @example EnforcedStyle: no_space (default) #   # The ‘no_space` style enforces that parentheses do not have spaces. # #   # bad #   f( 3) #   g = (a + 3 ) #   f( ) # #   # good #   f(3) #   g = (a + 3) #   f() # @example EnforcedStyle: space #   # The `space` style enforces that parentheses have a space at the #   # beginning and end. #   # Note: Empty parentheses should not have spaces. # #   # bad #   f(3) #   g = (a + 3) #   y( ) # #   # good #   f( 3 ) #   g = ( a + 3 ) #   y() # @example EnforcedStyle: compact #   # The `compact` style enforces that parentheses have a space at the #   # beginning with the exception that successive parentheses are allowed. #   # Note: Empty parentheses should not have spaces. # #   # bad #   f(3) #   g = (a + 3) #   y( ) #   g( f( x ) ) #   g( f( x( 3 ) ), 5 ) #   g( ( ( 3 + 5 ) * f) ** x, 5 ) # #   # good #   f( 3 ) #   g = ( a + 3 ) #   y() #   g( f( x )) #   g( f( x( 3 )), 5 ) #   g((( 3 + 5 ) * f ) ** x, 5 ) # # source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#57 class RuboCop::Cop::Layout::SpaceInsideParens &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_be_ignored?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_extraneous_space</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_extraneous_space_between_consecutive_parens</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_extraneous_space_in_empty_parens</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_missing_space</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_parens?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parens?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_with_compact_style</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_with_space_style</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_parens?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#63 RuboCop::Cop::Layout::SpaceInsideParens::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_parens.rb#64 RuboCop::Cop::Layout::SpaceInsideParens::MSG_SPACE = T.let(T.unsafe(nil), String)</p>

<p># Checks for unnecessary additional spaces inside the delimiters of # %i/%w/%x literals. # # @example # #   # bad #   %i( foo bar baz ) # #   # good #   %i(foo bar baz) # #   # bad #   %w( foo bar baz ) # #   # good #   %w(foo bar baz) # #   # bad #   %x(  ls -l ) # #   # good #   %x(ls -l) # #   # bad #   %w( ) #   %w( #   ) # #   # good #   %w() # # source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#36 class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MatchRange</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offenses_for_blank_spaces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offenses_for_unnecessary_spaces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regex_matches</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">blk</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#42 RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::BEGIN_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#43 RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::END_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_percent_literal_delimiters.rb#41 RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for spaces inside range literals. # # @example #   # bad #   1 .. 3 # #   # good #   1..3 # #   # bad #   ‘a’ .. ‘z’ # #   # good #   ‘a’..‘z’ # # source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#20 class RuboCop::Cop::Layout::SpaceInsideRangeLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_range_literal.rb#23 RuboCop::Cop::Layout::SpaceInsideRangeLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that reference brackets have or don’t have # surrounding space depending on configuration. # # @example EnforcedStyle: no_space (default) #   # The ‘no_space` style enforces that reference brackets have #   # no surrounding space. # #   # bad #   hash[ :key ] #   array[ index ] # #   # good #   <a href=":key">hash</a> #   <a href="index">array</a> # @example EnforcedStyle: space #   # The `space` style enforces that reference brackets have #   # surrounding space. # #   # bad #   <a href=":key">hash</a> #   <a href="index">array</a> # #   # good #   hash[ :key ] #   array[ index ] # @example EnforcedStyleForEmptyBrackets: no_space (default) #   # The `no_space` EnforcedStyleForEmptyBrackets style enforces that #   # empty reference brackets do not contain spaces. # #   # bad #   foo[ ] #   foo[     ] #   foo[ #   ] # #   # good #   foo[] # @example EnforcedStyleForEmptyBrackets: space #   # The `space` EnforcedStyleForEmptyBrackets style enforces that #   # empty reference brackets contain exactly one space. # #   # bad #   foo[] #   foo[    ] #   foo[ #   ] # #   # good #   foo[ ] # # source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#60 class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_bracket</span>(<span class="ruby-identifier">tokens</span>, <span class="ruby-identifier">opening_bracket</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_ref_bracket</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_token</span>(<span class="ruby-identifier">current_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference_brackets</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#66 RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#65 RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_reference_brackets.rb#68 RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for whitespace within string interpolations. # # @example EnforcedStyle: no_space (default) #   # bad #   var = “This is the #{ space } example” # #   # good #   var = “This is the #{no_space} example” # @example EnforcedStyle: space #   # bad #   var = “This is the #{no_space} example” # #   # good #   var = “This is the #{ space } example” # # source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#21 class RuboCop::Cop::Layout::SpaceInsideStringInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiters</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/space_inside_string_interpolation.rb#27 RuboCop::Cop::Layout::SpaceInsideStringInterpolation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for trailing blank lines and a final newline in the # source code. # # @example EnforcedStyle: final_newline (default) #   # ‘final_newline` looks for one newline at the end of files. # #   # bad #   class Foo; end # #   # EOF # #   # bad #   class Foo; end # EOF # #   # good #   class Foo; end #   # EOF # @example EnforcedStyle: final_blank_line #   # `final_blank_line` looks for one blank line followed by a new line #   # at the end of files. # #   # bad #   class Foo; end #   # EOF # #   # bad #   class Foo; end # EOF # #   # good #   class Foo; end # #   # EOF # # source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#40 class RuboCop::Cop::Layout::TrailingEmptyLines &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_with_percent_blank_string?</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_in_end?</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">wanted_blank_lines</span>, <span class="ruby-identifier">blank_lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_empty_lines.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_detected</span>(<span class="ruby-identifier">buffer</span>, <span class="ruby-identifier">wanted_blank_lines</span>, <span class="ruby-identifier">blank_lines</span>, <span class="ruby-identifier">whitespace_at_end</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Looks for trailing whitespace in the source code. # # @example #   # The line in this example contains spaces after the 0. #   # bad #   x = 0 # #   # The line in this example ends directly after the 0. #   # good #   x = 0 # @example AllowInHeredoc: false (default) #   # The line in this example contains spaces after the 0. #   # bad #   code = &lt;&lt;~RUBY #   x = 0 #   RUBY # #   # ok #   code = &lt;&lt;~RUBY #   x = 0 #{} #   RUBY # #   # good #   trailing_whitespace = ‘ ’ #   code = &lt;&lt;~RUBY #   x = 0#{trailing_whitespace} #   RUBY # @example AllowInHeredoc: true #   # The line in this example contains spaces after the 0. #   # good #   code = &lt;&lt;~RUBY #   x = 0 #   RUBY # # source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#42 class RuboCop::Cop::Layout::TrailingWhitespace &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_heredocs</span>(<span class="ruby-identifier">ast</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_heredoc</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredocs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_line</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">lineno</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_line_in_heredoc</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_heredoc?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">static?</span>(<span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_is_indentation?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">level</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_only?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/layout/trailing_whitespace.rb#47 RuboCop::Cop::Layout::TrailingWhitespace::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#5 module RuboCop::Cop::Legacy; end</p>

<p># Legacy support for Corrector#corrections # See <a href="https://docs.rubocop.org/rubocop/v1_upgrade_notes.html">docs.rubocop.org/rubocop/v1_upgrade_notes.html</a> # # source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#8 class RuboCop::Cop::Legacy::CorrectionsProxy</p>

<pre class="ruby"><span class="ruby-comment"># @return [CorrectionsProxy] a new instance of CorrectionsProxy</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">callable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">concat</span>(<span class="ruby-identifier">corrections</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Returns the value of attribute corrector.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/legacy/corrections_proxy.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suppress_clobbering</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class handles autocorrection for code that needs to be moved # to new lines. # # source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#7 class RuboCop::Cop::LineBreakCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_line_before</span>(<span class="ruby-value">range:</span>, <span class="ruby-value">node:</span>, <span class="ruby-value">corrector:</span>, <span class="ruby-value">configured_width:</span>, <span class="ruby-value">indent_steps:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_trailing_body</span>(<span class="ruby-value">configured_width:</span>, <span class="ruby-value">corrector:</span>, <span class="ruby-value">node:</span>, <span class="ruby-value">processed_source:</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#35</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_comment</span>(<span class="ruby-value">eol_comment:</span>, <span class="ruby-value">node:</span>, <span class="ruby-value">corrector:</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute processed_source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#45</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_semicolon</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#51</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semicolon</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/line_break_corrector.rb#60</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_class_definition?</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Help methods for determining if a line is too long. # # source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#6 module RuboCop::Cop::LineLengthHelp</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_qualified_name?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_uri?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_position?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_on_source_line?</span>(<span class="ruby-identifier">line_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extend_end_position</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">end_position</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_excessive_range</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_cop_directives?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_difference</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length_without_directive</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_qualified_names</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_uris</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_name_regexp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tab_indentation_width</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uri_regexp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/line_length_help.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_uri?</span>(<span class="ruby-identifier">uri_ish_string</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#5 module RuboCop::Cop::Lint; end</p>

<p># Checks for mistyped shorthand assignments. # # @example #   # bad #   x =- y #   x =+ y #   x =* y #   x =! y # #   # good #   x -= y # or x = -y #   x += y # or x = +y #   x *= y # or x = *y #   x != y # or x = !y # # source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#21 class RuboCop::Cop::Lint::AmbiguousAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#28 RuboCop::Cop::Lint::AmbiguousAssignment::MISTAKES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#24 RuboCop::Cop::Lint::AmbiguousAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_assignment.rb#26 RuboCop::Cop::Lint::AmbiguousAssignment::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ambiguous block association with method # when param passed without parentheses. # # This cop can customize allowed methods with ‘AllowedMethods`. # By default, there are no methods to allowed. # # @example # #   # bad #   some_method a { |val| puts val } # #   # good #   # With parentheses, there’s no ambiguity. #   some_method(a { |val| puts val }) #   # or (different meaning) #   some_method(a) { |val| puts val } # #   # good #   # Operator methods require no disambiguation #   foo == bar { |b| b.baz } # #   # good #   # Lambda arguments require no disambiguation #   foo = -&gt;(bar) { bar.baz } # @example AllowedMethods: [] (default) # #   # bad #   expect { do_something }.to change { object.attribute } # @example AllowedMethods: [change] # #   # good #   expect { do_something }.to change { object.attribute } # @example AllowedPatterns: [] (default) # #   # bad #   expect { do_something }.to change { object.attribute } # @example AllowedPatterns: [‘change’] # #   # good #   expect { do_something }.to change { object.attribute } #   expect { do_something }.to not_change { object.attribute } # # source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#52 class RuboCop::Cop::Lint::AmbiguousBlockAssociation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_pattern?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_block_association?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap_in_parentheses</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_block_association.rb#58 RuboCop::Cop::Lint::AmbiguousBlockAssociation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ambiguous operators in the first argument of a # method invocation without parentheses. # # @example # #   # bad # #   # The ‘*` is interpreted as a splat operator but it could possibly be #   # a `*` method invocation (i.e. `do_something.*(some_array)`). #   do_something *some_array # #   # good # #   # With parentheses, there’s no ambiguity. #   do_something(*some_array) # # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#21 class RuboCop::Cop::Lint::AmbiguousOperator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_node_by</span>(<span class="ruby-identifier">diagnostic</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">diagnostic</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_position?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">diagnostic</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unary_operator?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">diagnostic</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#39</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#24 RuboCop::Cop::Lint::AmbiguousOperator::AMBIGUITIES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator.rb#34 RuboCop::Cop::Lint::AmbiguousOperator::MSG_FORMAT = T.let(T.unsafe(nil), String)</p>

<p># Looks for expressions containing multiple binary operators # where precedence is ambiguous due to lack of parentheses. For example, # in ‘1 + 2 * 3`, the multiplication will happen before the addition, but # lexically it appears that the addition will happen first. # # The cop does not consider unary operators (ie. `!a` or `-b`) or comparison # operators (ie. `a =~ b`) because those are not ambiguous. # # NOTE: Ranges are handled by `Lint/AmbiguousRange`. # # @example #   # bad #   a + b * c #   a || b &amp;&amp; c #   a ** b + c # #   # good (different precedence) #   a + (b * c) #   a || (b &amp;&amp; c) #   (a ** b) + c # #   # good (same precedence) #   a + b + c #   a * b / c % d # # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#30 class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">greater_precedence?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">precedence</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#45 RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::MSG = T.let(T.unsafe(nil), String)</p>

<p># See <a href="https://ruby-doc.org/core-3.0.2/doc/syntax/precedence_rdoc.html">ruby-doc.org/core-3.0.2/doc/syntax/precedence_rdoc.html</a> # # source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#34 RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::PRECEDENCE = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_operator_precedence.rb#44 RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ambiguous ranges. # # Ranges have quite low precedence, which leads to unexpected behavior when # using a range with other operators. This cop avoids that by making ranges # explicit by requiring parenthesis around complex range boundaries (anything # that is not a literal: numerics, strings, symbols, etc.). # # This cop can be configured with ‘RequireParenthesesForMethodChains` in order to # specify whether method chains (including `self.foo`) should be wrapped in parens # by this cop. # # NOTE: Regardless of this configuration, if a method receiver is a basic literal # value, it will be wrapped in order to prevent the ambiguity of `1..2.to_a`. # # @example #   # bad #   x || 1..2 #   x - 1..2 #   (x || 1..2) #   x || 1..y || 2 #   1..2.to_a # #   # good, unambiguous #   1..2 #   ’a’..‘z’ #   :bar..:baz #   MyClass::MIN..MyClass::MAX #   @min..@max #   a..b #   -a..b # #   # good, ambiguity removed #   x || (1..2) #   (x - 1)..2 #   (x || 1)..2 #   (x || 1)..(y || 2) #   (1..2).to_a # @example RequireParenthesesForMethodChains: false (default) #   # good #   a.foo..b.bar #   (a.foo)..(b.bar) # @example RequireParenthesesForMethodChains: true #   # bad #   a.foo..b.bar # #   # good #   (a.foo)..(b.bar) # # source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#62 class RuboCop::Cop::Lint::AmbiguousRange &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RationalLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [range.begin]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_boundary</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses_for_method_chain?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_range.rb#66 RuboCop::Cop::Lint::AmbiguousRange::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ambiguous regexp literals in the first argument of # a method invocation without parentheses. # # @example # #   # bad # #   # This is interpreted as a method invocation with a regexp literal, #   # but it could possibly be ‘/` method invocations. #   # (i.e. `do_something./(pattern)./(i)`) #   do_something /pattern/i # #   # good # #   # With parentheses, there’s no ambiguity. #   do_something(/pattern/i) # # source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#22 class RuboCop::Cop::Lint::AmbiguousRegexpLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">regexp_receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_node_by</span>(<span class="ruby-identifier">diagnostic</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_is_regexp?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_chain_to_regexp_receiver?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">regexp_receiver</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ambiguous_regexp_literal.rb#25 RuboCop::Cop::Lint::AmbiguousRegexpLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for an array literal interpolated inside a regexp. # # When interpolating an array literal, it is converted to a string. This means # that when inside a regexp, it acts as a character class but with additional # quotes, spaces and commas that are likely not intended. For example, # ‘/#{%w[a b c]}/` parses as `/[“a”, “b”, “c”]/` (or `/[“a, bc]/` without # repeated characters). # # The cop can autocorrect to a character class (if all items in the array are a # single character) or alternation (if the array contains longer items). # # NOTE: This only considers interpolated arrays that contain only strings, symbols, # integers, and floats. Any other type is not easily convertible to a character class # or regexp alternation. # # @example #   # bad #   /#{%w[a b c]}/ # #   # good #   /[abc]/ # #   # bad #   /#{%w[foo bar baz]}/ # #   # good #   /(?:foo|bar|baz)/ # #   # bad - construct a regexp rather than interpolate an array of identifiers #   /#{[foo, bar]}/ # # source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#41 class RuboCop::Cop::Lint::ArrayLiteralInRegexp &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternation_for</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_of_literal_values?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_values</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">character_class?</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">character_class_for</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape_values</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_array_of_literal_values</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_array_of_nonliteral_values</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#45 RuboCop::Cop::Lint::ArrayLiteralInRegexp::LITERAL_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#49 RuboCop::Cop::Lint::ArrayLiteralInRegexp::MSG_ALTERNATION = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#48 RuboCop::Cop::Lint::ArrayLiteralInRegexp::MSG_CHARACTER_CLASS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/array_literal_in_regexp.rb#50 RuboCop::Cop::Lint::ArrayLiteralInRegexp::MSG_UNKNOWN = T.let(T.unsafe(nil), String)</p>

<p># Checks for assignments in the conditions of # if/while/until. # # ‘AllowSafeAssignment` option for safe assignment. # By safe assignment we mean putting parentheses around # an assignment to indicate “I know I’m using an assignment # as a condition. It’s not a mistake.” # # @example #   # bad #   if some_var = value #   do_something #   end # #   # good #   if some_var == value #   do_something #   end # @example AllowSafeAssignment: true (default) #   # good #   if (some_var = value) #   do_something #   end # @example AllowSafeAssignment: false #   # bad #   if (some_var = value) #   do_something #   end # # source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#41 class RuboCop::Cop::Lint::AssignmentInCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeAssignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_construct?</span>(<span class="ruby-identifier">asgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_assignment?</span>(<span class="ruby-identifier">asgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_children?</span>(<span class="ruby-identifier">asgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">traverse_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#53 RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#50 RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/assignment_in_condition.rb#46 RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)</p>

<p># ‘BigDecimal.new()` is deprecated since BigDecimal 1.3.3. # This cop identifies places where `BigDecimal.new()` # can be replaced by `BigDecimal()`. # # @example #   # bad #   BigDecimal.new(123.456, 3) # #   # good #   BigDecimal(123.456, 3) # # source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#17 class RuboCop::Cop::Lint::BigDecimalNew &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">big_decimal_new</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#20 RuboCop::Cop::Lint::BigDecimalNew::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/big_decimal_new.rb#21 RuboCop::Cop::Lint::BigDecimalNew::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where binary operator has identical operands. # # It covers comparison operators: ‘==`, `===`, `=~`, `&gt;`, `&gt;=`, `&lt;`, “&lt;=“; # bitwise operators: `|`, `^`, `&amp;`; # boolean operators: `&amp;&amp;`, `||` # and “spaceship” operator - “&lt;=&gt;“. # # Simple arithmetic operations are allowed by this cop: `+`, `*`, `**`, `&lt;&lt;` and `&gt;&gt;`. # Although these can be rewritten in a different way, it should not be necessary to # do so. Operations such as `-` or `/` where the result will always be the same # (`x - x` will always be 0; `x / x` will always be 1) are offenses, but these # are covered by `Lint/NumericOperationWithConstantResult` instead. # # @example #   # bad #   x.top &gt;= x.top # #   if a.x != 0 &amp;&amp; a.x != 0 #   do_something #   end # #   def child? #   left_child || left_child #   end # #   # good #   x + x #   1 &lt;&lt; 1 # # source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#46 class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#47 RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/binary_operator_with_identical_operands.rb#48 RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘:true` and `:false` symbols. # In most cases it would be a typo. # # @example # #   # bad #   :true # #   # good #   true # #   # bad #   :false # #   # good #   false # # source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#27 class RuboCop::Cop::Lint::BooleanSymbol &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">boolean_symbol?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/boolean_symbol.rb#30 RuboCop::Cop::Lint::BooleanSymbol::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for circular argument references in optional keyword # arguments and optional ordinal arguments. # # NOTE: This syntax was made invalid on Ruby 2.7 - Ruby 3.3 but is allowed # again since Ruby 3.4. # # @example # #   # bad #   def bake(pie: pie) #   pie.heat_up #   end # #   # good #   def bake(pie:) #   pie.refrigerate #   end # #   # good #   def bake(pie: self.pie) #   pie.feed_to(user) #   end # #   # bad #   def cook(dry_ingredients = dry_ingredients) #   dry_ingredients.reduce(&amp;:+) #   end # #   # good #   def cook(dry_ingredients = self.dry_ingredients) #   dry_ingredients.combine #   end # # source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#38 class RuboCop::Cop::Lint::CircularArgumentReference &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_optarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_circular_argument_references</span>(<span class="ruby-identifier">arg_name</span>, <span class="ruby-identifier">arg_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/circular_argument_reference.rb#41 RuboCop::Cop::Lint::CircularArgumentReference::MSG = T.let(T.unsafe(nil), String)</p>

<p># Do not define constants within a block, since the block’s scope does not # isolate or namespace the constant in any way. # # If you are trying to define that constant once, define it outside of # the block instead, or use a variable or method if defining the constant # in the outer scope would be problematic. # # For meta-programming, use ‘const_set`. # # @example #   # bad #   task :lint do #   FILES_TO_LINT = <a href="&#39;lib/*.rb&#39;">Dir</a> #   end # #   # bad #   describe ’making a request’ do #   class TestRequest; end #   end # #   # bad #   module M #   extend ActiveSupport::Concern #   included do #   LIST = [] #   end #   end # #   # good #   task :lint do #   files_to_lint = <a href="&#39;lib/*.rb&#39;">Dir</a> #   end # #   # good #   describe ‘making a request’ do #   let(:test_request) { Class.new } #   # see also ‘stub_const` for RSpec #   end # #   # good #   module M #   extend ActiveSupport::Concern #   included do #   const_set(:LIST, []) #   end #   end # @example AllowedMethods: [’enums’] (default) #   # good # #   # ‘enums` for Typed Enums via `T::Enum` in Sorbet. #   # <a href="https://sorbet.org/docs/tenum">sorbet.org/docs/tenum</a> #   class TestEnum &lt; T::Enum #   enums do #   Foo = new(“foo”) #   end #   end # # source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#64 class RuboCop::Cop::Lint::ConstantDefinitionInBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_assigned_in_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_defined_in_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/constant_definition_in_block.rb#67 RuboCop::Cop::Lint::ConstantDefinitionInBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for overwriting an exception with an exception result by use “rescue =&gt;“. # # You intended to write as ‘rescue StandardError`. # However, you have written `rescue =&gt; StandardError`. # In that case, the result of `rescue` will overwrite `StandardError`. # # @example # #   # bad #   begin #   something #   rescue =&gt; StandardError #   end # #   # good #   begin #   something #   rescue StandardError #   end # # source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#26 class RuboCop::Cop::Lint::ConstantOverwrittenInRescue &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">overwritten_constant</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/constant_overwritten_in_rescue.rb#30 RuboCop::Cop::Lint::ConstantOverwrittenInRescue::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for constant reassignments. # # Emulates Ruby’s runtime warning “already initialized constant X” # when a constant is reassigned in the same file and namespace using the # ‘NAME = value` syntax. # # The cop cannot catch all offenses, like, for example, when a constant # is reassigned in another file, or when using metaprogramming (`Module#const_set`). # # The cop only takes into account constants assigned in a “simple” way: directly # inside class/module definition, or within another constant. Other type of assignments # (e.g., inside a conditional) are disregarded. # # The cop also tracks constant removal using `Module#remove_const` with symbol # or string argument. # # @example #   # bad #   X = :foo #   X = :bar # #   # bad #   class A #   X = :foo #   X = :bar #   end # #   # bad #   module A #   X = :foo #   X = :bar #   end # #   # good - keep only one assignment #   X = :bar # #   class A #   X = :bar #   end # #   module A #   X = :bar #   end # #   # good - use OR assignment #   X = :foo #   X ||= :bar # #   # good - use conditional assignment #   X = :foo #   X = :bar unless defined?(X) # #   # good - remove the assigned constant first #   class A #   X = :foo #   remove_const :X #   X = :bar #   end # # source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#65 class RuboCop::Cop::Lint::ConstantReassignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_constant</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ancestor_namespaces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_namespaces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixed_constant_path?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">freeze_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fully_qualified_constant_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fully_qualified_name_for</span>(<span class="ruby-identifier">namespaces</span>, <span class="ruby-identifier">constant</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#66 RuboCop::Cop::Lint::ConstantReassignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/constant_reassignment.rb#68 RuboCop::Cop::Lint::ConstantReassignment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Check that certain constants are fully qualified. # # This is not enabled by default because it would mark a lot of offenses # unnecessarily. # # Generally, gems should fully qualify all constants to avoid conflicts with # the code that uses the gem. Enable this cop without using ‘Only`/`Ignore` # # Large projects will over time end up with one or two constant names that # are problematic because of a conflict with a library or just internally # using the same name a namespace and a class. To avoid too many unnecessary # offenses, Enable this cop with `Only: [The, Constant, Names, Causing, Issues]` # # NOTE: `Style/RedundantConstantBase` cop is disabled if this cop is enabled to prevent # conflicting rules. Because it respects user configurations that want to enable # this cop which is disabled by default. # # @example #   # By default checks every constant # #   # bad #   User # #   # bad #   User::Login # #   # good #   ::User # #   # good #   ::User::Login # @example Only: [’Login’] #   # Restrict this cop to only being concerned about certain constants # #   # bad #   Login # #   # good #   ::Login # #   # good #   User::Login # @example Ignore: [‘Login’] #   # Restrict this cop not being concerned about certain constants # #   # bad #   User # #   # good #   ::User::Login # #   # good #   Login # # source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#62 class RuboCop::Cop::Lint::ConstantResolution &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unqualified_const?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_names</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/constant_resolution.rb#63 RuboCop::Cop::Lint::ConstantResolution::MSG = T.let(T.unsafe(nil), String)</p>

<p># are strictly formatted. # # A comment can be added to the directive by prefixing it with ‘–`. # # @example #   # bad #   # rubocop:disable Layout/LineLength Style/Encoding #   #                                  ^ missing comma # #   # bad #   # rubocop:disable # #   # bad #   # rubocop:disable Layout/LineLength # rubocop:disable Style/Encoding # #   # bad #   # rubocop:wrongmode Layout/LineLength # #   # good #   # rubocop:disable Layout/LineLength # #   # good #   # rubocop:disable Layout/LineLength, Style/Encoding # #   # good #   # rubocop:disable all # #   # good #   # rubocop:disable Layout/LineLength – This is a good comment. # # source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#39 class RuboCop::Cop::Lint::CopDirectiveSyntax &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message</span>(<span class="ruby-identifier">directive_comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#40 RuboCop::Cop::Lint::CopDirectiveSyntax::COMMON_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#43 RuboCop::Cop::Lint::CopDirectiveSyntax::INVALID_MODE_NAME_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#45 RuboCop::Cop::Lint::CopDirectiveSyntax::MALFORMED_COP_NAMES_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#44 RuboCop::Cop::Lint::CopDirectiveSyntax::MISSING_COP_NAME_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/cop_directive_syntax.rb#42 RuboCop::Cop::Lint::CopDirectiveSyntax::MISSING_MODE_NAME_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for debug calls (such as ‘debugger` or `binding.pry`) that should # not be kept for production code. # # The cop can be configured using `DebuggerMethods`. By default, a number of gems # debug entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `debug.rb`, # `Pry`, `Rails`, `RubyJard`, and `WebConsole`). Additional methods can be added. # # Specific default groups can be disabled if necessary: # # [source,yaml] # —- # Lint/Debugger: #   DebuggerMethods: #     WebConsole: ~ # —- # # You can also add your own methods by adding a new category: # # [source,yaml] # —- # Lint/Debugger: #   DebuggerMethods: #     MyDebugger: #       MyDebugger.debug_this # —- # # Some gems also ship files that will start a debugging session when required, # for example `require ’debug/start’‘ from `ruby/debug`. These requires can # be configured through `DebuggerRequires`. It has the same structure as # `DebuggerMethods`, which you can read about above. # # @example # #   # bad (ok during development) # #   # using pry #   def some_method #   binding.pry #   do_something #   end # #   # bad (ok during development) # #   # using byebug #   def some_method #   byebug #   do_something #   end # #   # good # #   def some_method #   do_something #   end # @example DebuggerMethods: [my_debugger] # #   # bad (ok during development) # #   def some_method #   my_debugger #   end # @example DebuggerRequires: [my_debugger/start] # #   # bad (ok during development) # #   require ’my_debugger/start’ # # source://rubocop//lib/rubocop/cop/lint/debugger.rb#74 class RuboCop::Cop::Lint::Debugger &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assumed_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assumed_usage_context?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_method_name</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debugger_method?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debugger_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debugger_require?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debugger_requires</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/debugger.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/debugger.rb#76 RuboCop::Cop::Lint::Debugger::BLOCK_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/debugger.rb#75 RuboCop::Cop::Lint::Debugger::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of the deprecated class method usages. # # @example # #   # bad #   File.exists?(some_path) #   Dir.exists?(some_path) #   iterator? #   attr :name, true #   attr :name, false #   ENV.freeze # Calling ‘Env.freeze` raises `TypeError` since Ruby 2.7. #   ENV.clone #   ENV.dup # Calling `Env.dup` raises `TypeError` since Ruby 3.1. #   Socket.gethostbyname(host) #   Socket.gethostbyaddr(host) # #   # good #   File.exist?(some_path) #   Dir.exist?(some_path) #   block_given? #   attr_accessor :name #   attr_reader :name #   ENV # `ENV.freeze` cannot prohibit changes to environment variables. #   ENV.to_h #   ENV.to_h # `ENV.dup` cannot dup `ENV`, use `ENV.to_h` to get a copy of `ENV` as a hash. #   Addrinfo.getaddrinfo(nodename, service) #   Addrinfo.tcp(host, port).getnameinfo # # source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#33 class RuboCop::Cop::Lint::DeprecatedClassMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_class_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dir_env_file_const?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">socket_const?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#50 RuboCop::Cop::Lint::DeprecatedClassMethods::DIR_ENV_FILE_CONSTANTS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#36 RuboCop::Cop::Lint::DeprecatedClassMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#41 RuboCop::Cop::Lint::DeprecatedClassMethods::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_class_methods.rb#37 RuboCop::Cop::Lint::DeprecatedClassMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for deprecated constants. # # It has ‘DeprecatedConstants` config. If there is an alternative method, you can set # alternative value as `Alternative`. And you can set the deprecated version as # `DeprecatedVersion`. These options can be omitted if they are not needed. # #   DeprecatedConstants: #     ’DEPRECATED_CONSTANT’: #       Alternative: ‘alternative_value’ #       DeprecatedVersion: ‘deprecated_version’ # # By default, ‘NIL`, `TRUE`, `FALSE`, `Net::HTTPServerException, `Random::DEFAULT`, # `Struct::Group`, and `Struct::Passwd` are configured. # # @example # #   # bad #   NIL #   TRUE #   FALSE #   Net::HTTPServerException #   Random::DEFAULT # Return value of Ruby 2 is `Random` instance, Ruby 3.0 is `Random` class. #   Struct::Group #   Struct::Passwd # #   # good #   nil #   true #   false #   Net::HTTPClientException #   Random.new # `::DEFAULT` has been deprecated in Ruby 3, `.new` is compatible with Ruby 2. #   Etc::Group #   Etc::Passwd # # source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#40 class RuboCop::Cop::Lint::DeprecatedConstants &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_name</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">nested_constant_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_constants</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">good</span>, <span class="ruby-identifier">bad</span>, <span class="ruby-identifier">deprecated_version</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#44 RuboCop::Cop::Lint::DeprecatedConstants::DO_NOT_USE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_constants.rb#43 RuboCop::Cop::Lint::DeprecatedConstants::SUGGEST_GOOD_MSG = T.let(T.unsafe(nil), String)</p>

<p># Algorithmic constants for ‘OpenSSL::Cipher` and `OpenSSL::Digest` # deprecated since OpenSSL version 2.2.0. Prefer passing a string # instead. # # @example # #   # bad #   OpenSSL::Cipher::AES.new(128, :GCM) # #   # good #   OpenSSL::Cipher.new(’aes-128-gcm’) # #   # bad #   OpenSSL::Digest::SHA256.new # #   # good #   OpenSSL::Digest.new(‘SHA256’) # #   # bad #   OpenSSL::Digest::SHA256.digest(‘foo’) # #   # good #   OpenSSL::Digest.digest(‘SHA256’, ‘foo’) # # source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#30 class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algorithm_const</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest_const?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">algorithm_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_cipher_arguments</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">algorithm_name</span>, <span class="ruby-identifier">no_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">openssl_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sanitize_arguments</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#34 RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#37 RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::NO_ARG_ALGORITHM = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/deprecated_open_ssl_constant.rb#36 RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks constructors for disjunctive assignments (‘||=`) that should # be plain assignments. # # So far, this cop is only concerned with disjunctive assignment of # instance variables. # # In ruby, an instance variable is nil until a value is assigned, so the # disjunction is unnecessary. A plain assignment has the same effect. # # @example #   # bad #   def initialize #   @x ||= 1 #   end # #   # good #   def initialize #   @x = 1 #   end # # source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#48 class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @param node [DefNode] a constructor definition</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_body</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param lines [Array] the logical lines of the constructor</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_body_lines</span>(<span class="ruby-identifier">lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add an offense if the LHS of the given disjunctive assignment is</span>
<span class="ruby-comment"># an instance variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># For now, we only care about assignments to instance variables.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node [Node] a disjunctive assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_disjunctive_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/disjunctive_assignment_in_constructor.rb#51 RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that there are no repeated bodies # within ‘if/unless`, `case-when`, `case-in` and `rescue` constructs. # # With `IgnoreLiteralBranches: true`, branches are not registered # as offenses if they return a basic literal value (string, symbol, # integer, float, rational, complex, `true`, `false`, or `nil`), or # return an array, hash, regexp or range that only contains one of # the above basic literal values. # # With `IgnoreConstantBranches: true`, branches are not registered # as offenses if they return a constant value. # # With `IgnoreDuplicateElseBranch: true`, in conditionals with multiple branches, # duplicate ’else’ branches are not registered as offenses. # # @example #   # bad #   if foo #   do_foo #   do_something_else #   elsif bar #   do_foo #   do_something_else #   end # #   # good #   if foo || bar #   do_foo #   do_something_else #   end # #   # bad #   case x #   when foo #   do_foo #   when bar #   do_foo #   else #   do_something_else #   end # #   # good #   case x #   when foo, bar #   do_foo #   else #   do_something_else #   end # #   # bad #   begin #   do_something #   rescue FooError #   handle_error #   rescue BarError #   handle_error #   end # #   # good #   begin #   do_something #   rescue FooError, BarError #   handle_error #   end # @example IgnoreLiteralBranches: true #   # good #   case size #   when “small” then 100 #   when “medium” then 250 #   when “large” then 1000 #   else 250 #   end # @example IgnoreConstantBranches: true #   # good #   case size #   when “small” then SMALL_SIZE #   when “medium” then MEDIUM_SIZE #   when “large” then LARGE_SIZE #   else MEDIUM_SIZE #   end # @example IgnoreDuplicateElseBranch: true #   # good #   if foo #   do_foo #   elsif bar #   do_bar #   else #   do_foo #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#99 class RuboCop::Cop::Lint::DuplicateBranch &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_branching_statement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consider_branch?</span>(<span class="ruby-identifier">branches</span>, <span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_branch?</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicate_else_branch?</span>(<span class="ruby-identifier">branches</span>, <span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_constant_branches?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_duplicate_else_branches?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_literal_branches?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_branch?</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">duplicate_branch</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_branch.rb#100 RuboCop::Cop::Lint::DuplicateBranch::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that there are no repeated conditions # used in case ‘when’ expressions. # # @example # #   # bad #   case x #   when ‘first’ #   do_something #   when ‘first’ #   do_something_else #   end # #   # good #   case x #   when ‘first’ #   do_something #   when ‘second’ #   do_something_else #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#26 class RuboCop::Cop::Lint::DuplicateCaseCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_case_condition.rb#27 RuboCop::Cop::Lint::DuplicateCaseCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that there are no repeated conditions used in if ‘elsif’. # # @example #   # bad #   if x == 1 #   do_something #   elsif x == 1 #   do_something_else #   end # #   # good #   if x == 1 #   do_something #   elsif x == 2 #   do_something_else #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#23 class RuboCop::Cop::Lint::DuplicateElsifCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_elsif_condition.rb#24 RuboCop::Cop::Lint::DuplicateElsifCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for duplicated keys in hash literals. # This cop considers both primitive types and constants for the hash keys. # # This cop mirrors a warning in Ruby 2.2. # # @example # #   # bad #   hash = { food: ‘apple’, food: ‘orange’ } # #   # good #   hash = { food: ‘apple’, other_food: ‘orange’ } # # source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#18 class RuboCop::Cop::Lint::DuplicateHashKey &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Duplication</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_hash_key.rb#21 RuboCop::Cop::Lint::DuplicateHashKey::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for duplicated magic comments. # # @example # #   # bad # #   # encoding: ascii #   # encoding: ascii # #   # good # #   # encoding: ascii # #   # bad # #   # frozen_string_literal: true #   # frozen_string_literal: true # #   # good # #   # frozen_string_literal: true # # source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#28 class RuboCop::Cop::Lint::DuplicateMagicComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magic_comment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_magic_comment.rb#33 RuboCop::Cop::Lint::DuplicateMagicComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that there are no repeated patterns used in ‘in` keywords. # # @example # #   # bad #   case x #   in ’first’ #   do_something #   in ‘first’ #   do_something_else #   end # #   # good #   case x #   in ‘first’ #   do_something #   in ‘second’ #   do_something_else #   end # #   # bad - repeated alternate patterns with the same conditions don’t depend on the order #   case x #   in foo | bar #   first_method #   in bar | foo #   second_method #   end # #   # good #   case x #   in foo | bar #   first_method #   in bar | baz #   second_method #   end # #   # bad - repeated hash patterns with the same conditions don’t depend on the order #   case x #   in foo: a, bar: b #   first_method #   in bar: b, foo: a #   second_method #   end # #   # good #   case x #   in foo: a, bar: b #   first_method #   in bar: b, baz: c #   second_method #   end # #   # bad - repeated array patterns with elements in the same order #   case x #   in [foo, bar] #   first_method #   in [foo, bar] #   second_method #   end # #   # good #   case x #   in [foo, bar] #   first_method #   in [bar, foo] #   second_method #   end # #   # bad - repeated the same patterns and guard conditions #   case x #   in foo if bar #   first_method #   in foo if bar #   second_method #   end # #   # good #   case x #   in foo if bar #   first_method #   in foo if baz #   second_method #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_match_pattern.rb#90 class RuboCop::Cop::Lint::DuplicateMatchPattern &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_match_pattern.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_match_pattern.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern_identity</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_match_pattern.rb#93 RuboCop::Cop::Lint::DuplicateMatchPattern::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for duplicated instance (or singleton) method # definitions. # # NOTE: Aliasing a method to itself is allowed, as it indicates that # the developer intends to suppress Ruby’s method redefinition warnings. # See <a href="https://bugs.ruby-lang.org/issues/13574">bugs.ruby-lang.org/issues/13574</a>. # # @example # #   # bad #   def foo #   1 #   end # #   def foo #   2 #   end # #   # bad #   def foo #   1 #   end # #   alias foo bar # #   # good #   def foo #   1 #   end # #   def bar #   2 #   end # #   # good #   def foo #   1 #   end # #   alias bar foo # #   # good #   alias foo foo #   def foo #   1 #   end # #   # good #   alias_method :foo, :foo #   def foo #   1 #   end # @example AllCops:ActiveSupportExtensionsEnabled: false (default) # #   # good #   def foo #   1 #   end # #   delegate :foo, to: :bar # @example AllCops:ActiveSupportExtensionsEnabled: true # #   # bad #   def foo #   1 #   end # #   delegate :foo, to: :bar # #   # good #   def foo #   1 #   end # #   delegate :baz, to: :bar # #   # good - delegate with splat arguments is ignored #   def foo #   1 #   end # #   delegate :foo, **options # #   # good - delegate inside a condition is ignored #   def foo #   1 #   end # #   if cond #   delegate :foo, to: :bar #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#100 class RuboCop::Cop::Lint::DuplicateMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [DuplicateMethods] a new instance of DuplicateMethods</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alias_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delegate_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_alias?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_alias</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sym_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_const_receiver</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">const_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_self_receiver</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delegate_prefix</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">found_attr</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>, <span class="ruby-value">readable:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">writable:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">found_instance_method</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">found_method</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">found_sclass_method</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_value</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lookup_constant</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">const_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_dup</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_key</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_attr</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">attr_name</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_delegate</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_name</span>(<span class="ruby-identifier">enclosing</span>, <span class="ruby-identifier">namespace</span>, <span class="ruby-identifier">mod_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#101 RuboCop::Cop::Lint::DuplicateMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_methods.rb#102 RuboCop::Cop::Lint::DuplicateMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for duplicate elements in ‘Regexp` character classes. # # @example # #   # bad #   r = /[xyx]/ # #   # bad #   r = /[0-9x0-9]/ # #   # good #   r = /[xy]/ # #   # good #   r = /[0-9x]/ # # source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#21 class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_repeated_character_class_element_loc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escaped_octal?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_expressions</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">expressions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation_locs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">octal?</span>(<span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pop_octal_digits</span>(<span class="ruby-identifier">current_child</span>, <span class="ruby-identifier">expressions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_expression?</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>(<span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Since we blank interpolations with a space for every char of the interpolation, we would</span>
<span class="ruby-comment"># mark every space (except the first) as duplicate if we do not skip regexp_parser nodes</span>
<span class="ruby-comment"># that are within an interpolation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_interpolation?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#25 RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement::MSG_REPEATED_ELEMENT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_regexp_character_class_element.rb#27 RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement::OCTAL_DIGITS_AFTER_ESCAPE = T.let(T.unsafe(nil), Integer)</p>

<p># Checks for duplicate “require“s and “require_relative“s. # # @example #   # bad #   require ‘foo’ #   require ‘bar’ #   require ‘foo’ # #   # good #   require ‘foo’ #   require ‘bar’ # #   # good #   require ‘foo’ #   require_relative ‘foo’ # # source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#26 class RuboCop::Cop::Lint::DuplicateRequire &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#30 RuboCop::Cop::Lint::DuplicateRequire::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#31 RuboCop::Cop::Lint::DuplicateRequire::REQUIRE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_require.rb#32 RuboCop::Cop::Lint::DuplicateRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># Checks that there are no repeated exceptions # used in ‘rescue’ expressions. # # @example #   # bad #   begin #   something #   rescue FirstException #   handle_exception #   rescue FirstException #   handle_other_exception #   end # #   # good #   begin #   something #   rescue FirstException #   handle_exception #   rescue SecondException #   handle_other_exception #   end # # source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#28 class RuboCop::Cop::Lint::DuplicateRescueException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RescueNode</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_rescue_exception.rb#31 RuboCop::Cop::Lint::DuplicateRescueException::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for duplicate literal, constant, or variable elements in ‘Set` and `SortedSet`. # # @example # #   # bad #   Set[:foo, :bar, :foo] # #   # good #   Set[:foo, :bar] # #   # bad #   Set.new([:foo, :bar, :foo]) # #   # good #   Set.new([:foo, :bar]) # #   # bad #   [:foo, :bar, :foo].to_set # #   # good #   [:foo, :bar].to_set # #   # bad #   SortedSet[:foo, :bar, :foo] # #   # good #   SortedSet[:foo, :bar] # #   # bad #   SortedSet.new([:foo, :bar, :foo]) # #   # good #   SortedSet.new([:foo, :bar]) # # source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#39 class RuboCop::Cop::Lint::DuplicateSetElement &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_init_elements</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">current_element</span>, <span class="ruby-identifier">prev_element</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#42 RuboCop::Cop::Lint::DuplicateSetElement::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/duplicate_set_element.rb#43 RuboCop::Cop::Lint::DuplicateSetElement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks if each_with_object is called with an immutable # argument. Since the argument is the object that the given block shall # make calls on to build something based on the enumerable that # each_with_object iterates over, an immutable argument makes no sense. # It’s definitely a bug. # # @example # #   # bad #   sum = numbers.each_with_object(0) { |e, a| a += e } # #   # good #   num = 0 #   sum = numbers.each_with_object(num) { |e, a| a += e } # # source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#20 class RuboCop::Cop::Lint::EachWithObjectArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_with_object?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#21 RuboCop::Cop::Lint::EachWithObjectArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/each_with_object_argument.rb#22 RuboCop::Cop::Lint::EachWithObjectArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for odd ‘else` block layout - like # having an expression on the same line as the `else` keyword, # which is usually a mistake. # # Its autocorrection tweaks layout to keep the syntax. So, this autocorrection # is compatible correction for bad case syntax, but if your code makes a mistake # with `elsif` and `else`, you will have to correct it manually. # # @example # #   # bad # #   if something #   # … #   else do_this #   do_that #   end # #   # good # #   # This code is compatible with the bad case. It will be autocorrected like this. #   if something #   # … #   else #   do_this #   do_that #   end # #   # This code is incompatible with the bad case. #   # If `do_this` is a condition, `elsif` should be used instead of `else`. #   if something #   # … #   elsif do_this #   do_that #   end # # source://rubocop//lib/rubocop/cop/lint/else_layout.rb#41 class RuboCop::Cop::Lint::ElseLayout &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/else_layout.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/else_layout.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">first_else</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/else_layout.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/else_layout.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_else</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/else_layout.rb#46 RuboCop::Cop::Lint::ElseLayout::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for blocks without a body. # Such empty blocks are typically an oversight or we should provide a comment # to clarify what we’re aiming for. # # Empty lambdas and procs are ignored by default. # # NOTE: For backwards compatibility, the configuration that allows/disallows # empty lambdas and procs is called ‘AllowEmptyLambdas`, even though it also # applies to procs. # # @example #   # bad #   items.each { |item| } # #   # good #   items.each { |item| puts item } # @example AllowComments: true (default) #   # good #   items.each do |item| #   # TODO: implement later (inner comment) #   end # #   items.each { |item| } # TODO: implement later (inline comment) # @example AllowComments: false #   # bad #   items.each do |item| #   # TODO: implement later (inner comment) #   end # #   items.each { |item| } # TODO: implement later (inline comment) # @example AllowEmptyLambdas: true (default) #   # good #   allow(subject).to receive(:callable).and_return(-&gt; {}) # #   placeholder = lambda do #   end #   (callable || placeholder).call # #   proc { } # #   Proc.new { } # @example AllowEmptyLambdas: false #   # bad #   allow(subject).to receive(:callable).and_return(-&gt; {}) # #   placeholder = lambda do #   end #   (callable || placeholder).call # #   proc { } # #   Proc.new { } # # source://rubocop//lib/rubocop/cop/lint/empty_block.rb#63 class RuboCop::Cop::Lint::EmptyBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_block.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_block.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_comment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_block.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_empty_lambdas?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_block.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_disables_cop?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_block.rb#64 RuboCop::Cop::Lint::EmptyBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for classes and metaclasses without a body. # Such empty classes and metaclasses are typically an oversight or we should provide a comment # to be clearer what we’re aiming for. # # @example #   # bad #   class Foo #   end # #   class Bar #   class &lt;&lt; self #   end #   end # #   class &lt;&lt; obj #   end # #   # good #   class Foo #   def do_something #   # … code #   end #   end # #   class Bar #   class &lt;&lt; self #   attr_reader :bar #   end #   end # #   class &lt;&lt; obj #   attr_reader :bar #   end # @example AllowComments: false (default) #   # bad #   class Foo #   # TODO: implement later #   end # #   class Bar #   class &lt;&lt; self #   # TODO: implement later #   end #   end # #   class &lt;&lt; obj #   # TODO: implement later #   end # @example AllowComments: true #   # good #   class Foo #   # TODO: implement later #   end # #   class Bar #   class &lt;&lt; self #   # TODO: implement later #   end #   end # #   class &lt;&lt; obj #   # TODO: implement later #   end # # source://rubocop//lib/rubocop/cop/lint/empty_class.rb#72 class RuboCop::Cop::Lint::EmptyClass &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_class.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_class.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_class.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_or_allowed_comment_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_class.rb#73 RuboCop::Cop::Lint::EmptyClass::CLASS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_class.rb#74 RuboCop::Cop::Lint::EmptyClass::METACLASS_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of ‘if`, `elsif` and `unless` branches without a body. # # NOTE: empty `else` branches are handled by `Style/EmptyElse`. # # @example #   # bad #   if condition #   end # #   # bad #   unless condition #   end # #   # bad #   if condition #   do_something #   elsif other_condition #   end # #   # good #   if condition #   do_something #   end # #   # good #   unless condition #   do_something #   end # #   # good #   if condition #   do_something #   elsif other_condition #   nil #   end # #   # good #   if condition #   do_something #   elsif other_condition #   do_something_else #   end # @example AllowComments: true (default) #   # good #   if condition #   do_something #   elsif other_condition #   # noop #   end # @example AllowComments: false #   # bad #   if condition #   do_something #   elsif other_condition #   # noop #   end # # source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#65 class RuboCop::Cop::Lint::EmptyConditionalBody &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_simplify_conditional?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deletion_range</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_if_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flip_orphaned_else</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_empty_branch</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_conditional_body.rb#69 RuboCop::Cop::Lint::EmptyConditionalBody::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for empty ‘ensure` blocks. # # @example # #   # bad #   def some_method #   do_something #   ensure #   end # #   # bad #   begin #   do_something #   ensure #   end # #   # good #   def some_method #   do_something #   ensure #   do_something_else #   end # #   # good #   begin #   do_something #   ensure #   do_something_else #   end # # source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#35 class RuboCop::Cop::Lint::EmptyEnsure &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_ensure.rb#38 RuboCop::Cop::Lint::EmptyEnsure::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of empty expressions. # # @example # #   # bad # #   foo = () #   if () #   bar #   end # #   # good # #   foo = (some_expression) #   if (some_expression) #   bar #   end # # source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#23 class RuboCop::Cop::Lint::EmptyExpression &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_expression?</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_expression.rb#24 RuboCop::Cop::Lint::EmptyExpression::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces that Ruby source files are not empty. # # @example #   # bad #   # Empty file # #   # good #   # File containing non commented source lines # @example AllowComments: true (default) #   # good #   # File consisting only of comments # @example AllowComments: false #   # bad #   # File consisting only of comments # # source://rubocop//lib/rubocop/cop/lint/empty_file.rb#23 class RuboCop::Cop::Lint::EmptyFile &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_file.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_file.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_only_comments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_file.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_file?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_file.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_file.rb#24 RuboCop::Cop::Lint::EmptyFile::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of ‘in` pattern branches without a body. # # @example # #   # bad #   case condition #   in [a] #   do_something #   in [a, b] #   end # #   # good #   case condition #   in [a] #   do_something #   in [a, b] #   nil #   end # @example AllowComments: true (default) # #   # good #   case condition #   in [a] #   do_something #   in [a, b] #   # noop #   end # @example AllowComments: false # #   # bad #   case condition #   in [a] #   do_something #   in [a, b] #   # noop #   end # # source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#45 class RuboCop::Cop::Lint::EmptyInPattern &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_in_pattern.rb#49 RuboCop::Cop::Lint::EmptyInPattern::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for empty interpolation. # # @example # #   # bad #   “result is #{}” # #   # good #   “result is #{some_result}” # # source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#15 class RuboCop::Cop::Lint::EmptyInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_interpolation.rb#19 RuboCop::Cop::Lint::EmptyInterpolation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of ‘when` branches without a body. # # @example # #   # bad #   case foo #   when bar #   do_something #   when baz #   end # #   # good #   case condition #   when foo #   do_something #   when bar #   nil #   end # @example AllowComments: true (default) # #   # good #   case condition #   when foo #   do_something #   when bar #   # noop #   end # @example AllowComments: false # #   # bad #   case condition #   when foo #   do_something #   when bar #   # do nothing #   end # # source://rubocop//lib/rubocop/cop/lint/empty_when.rb#45 class RuboCop::Cop::Lint::EmptyWhen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/empty_when.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/empty_when.rb#48 RuboCop::Cop::Lint::EmptyWhen::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘return` from an `ensure` block. # `return` from an ensure block is a dangerous code smell as it # will take precedence over any exception being raised, # and the exception will be silently thrown away as if it were rescued. # # If you want to rescue some (or all) exceptions, best to do it explicitly # # @example # #   # bad #   def foo #   do_something #   ensure #   cleanup #   return self #   end # #   # good #   def foo #   do_something #   self #   ensure #   cleanup #   end # #   # good #   def foo #   begin #   do_something #   rescue SomeException #   # Let’s ignore this exception #   end #   self #   ensure #   cleanup #   end # # source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#42 class RuboCop::Cop::Lint::EnsureReturn &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ensure_return.rb#43 RuboCop::Cop::Lint::EnsureReturn::MSG = T.let(T.unsafe(nil), String)</p>

<p># Emulates the following Ruby warnings in Ruby 2.6. # # [source,console] # —- # $ cat example.rb # ERB.new(‘hi’, nil, ‘-’, ‘@output_buffer’) # $ ruby -rerb example.rb # example.rb:1: warning: Passing safe_level with the 2nd argument of ERB.new is # deprecated. Do not use it, and specify other arguments as keyword arguments. # example.rb:1: warning: Passing trim_mode with the 3rd argument of ERB.new is # deprecated. Use keyword argument like ERB.new(str, trim_mode:…) instead. # example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new is # deprecated. Use keyword argument like ERB.new(str, eoutvar: …) instead. # —- # # Now non-keyword arguments other than first one are softly deprecated # and will be removed when Ruby 2.5 becomes EOL. # ‘ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0. # Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`. # This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can # be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`. # # @example #   # Target codes supports Ruby 2.6 and higher only #   # bad #   ERB.new(str, nil, ’-‘, ’@output_buffer’) # #   # good #   ERB.new(str, trim_mode: ‘-’, eoutvar: ‘@output_buffer’) # #   # Target codes supports Ruby 2.5 and lower only #   # good #   ERB.new(str, nil, ‘-’, ‘@output_buffer’) # #   # Target codes supports Ruby 2.6, 2.5 and lower #   # bad #   ERB.new(str, nil, ‘-’, ‘@output_buffer’) # #   # good #   # Ruby standard library style #   # <a href="https://github.com/ruby/ruby/commit/3406c5d">github.com/ruby/ruby/commit/3406c5d</a> #   if ERB.instance_method(:initialize).parameters.assoc(:key) # Ruby 2.6+ #   ERB.new(str, trim_mode: ‘-’, eoutvar: ‘@output_buffer’) #   else #   ERB.new(str, nil, ‘-’, ‘@output_buffer’) #   end # #   # good #   # Use ‘RUBY_VERSION` style #   if RUBY_VERSION &gt;= ’2.6’ #   ERB.new(str, trim_mode: ‘-’, eoutvar: ‘@output_buffer’) #   else #   ERB.new(str, nil, ‘-’, ‘@output_buffer’) #   end # # source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#61 class RuboCop::Cop::Lint::ErbNewArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">erb_new_with_non_keyword_arguments</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_kwargs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_arguments?</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">positional_argument_index</span>, <span class="ruby-identifier">arg_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">override_by_legacy_args</span>(<span class="ruby-identifier">kwargs</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#74 RuboCop::Cop::Lint::ErbNewArguments::MESSAGE_EOUTVAR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#68 RuboCop::Cop::Lint::ErbNewArguments::MESSAGE_SAFE_LEVEL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#71 RuboCop::Cop::Lint::ErbNewArguments::MESSAGE_TRIM_MODE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/erb_new_arguments.rb#78 RuboCop::Cop::Lint::ErbNewArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for uses of flip-flop operator # based on the Ruby Style Guide. # # Here is the history of flip-flops in Ruby. # flip-flop operator is deprecated in Ruby 2.6.0 and # the deprecation has been reverted by Ruby 2.7.0 and # backported to Ruby 2.6. # See: <a href="https://bugs.ruby-lang.org/issues/5400">bugs.ruby-lang.org/issues/5400</a> # # @example #   # bad #   (1..20).each do |x| #   puts x if (x == 5) .. (x == 10) #   end # #   # good #   (1..20).each do |x| #   puts x if (x &gt;= 5) &amp;&amp; (x &lt;= 10) #   end # # source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#25 class RuboCop::Cop::Lint::FlipFlop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_eflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_iflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/flip_flop.rb#26 RuboCop::Cop::Lint::FlipFlop::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of precise comparison of floating point numbers. # # Floating point values are inherently inaccurate, and comparing them for exact equality # is almost never the desired semantics. Comparison via the ‘==/!=` operators checks # floating-point value representation to be exactly the same, which is very unlikely # if you perform any arithmetic operations involving precision loss. # # @example #   # bad #   x == 0.1 #   x != 0.1 # #   # bad #   case value #   when 1.0 #   foo #   when 2.0 #   bar #   end # #   # good - using BigDecimal #   x.to_d == 0.1.to_d # #   # good - comparing against zero #   x == 0.0 #   x != 0.0 # #   # good #   (x - 0.1).abs &lt; Float::EPSILON # #   # good #   tolerance = 0.0001 #   (x - 0.1).abs &lt; tolerance # #   # good - comparing against nil #   Float(x, exception: false) == nil # #   # good - using epsilon comparison in case expression #   case #   when (value - 1.0).abs &lt; Float::EPSILON #   foo #   when (value - 2.0).abs &lt; Float::EPSILON #   bar #   end # #   # Or some other epsilon based type of comparison: #   # <a href="https://www.embeddeduse.com/2019/08/26/qt-compare-two-floats">www.embeddeduse.com/2019/08/26/qt-compare-two-floats</a>/ # # source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#54 class RuboCop::Cop::Lint::FloatComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">float?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">float_send?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_safe?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numeric_returning_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#59 RuboCop::Cop::Lint::FloatComparison::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#61 RuboCop::Cop::Lint::FloatComparison::FLOAT_INSTANCE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#60 RuboCop::Cop::Lint::FloatComparison::FLOAT_RETURNING_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#57 RuboCop::Cop::Lint::FloatComparison::MSG_CASE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#55 RuboCop::Cop::Lint::FloatComparison::MSG_EQUALITY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#56 RuboCop::Cop::Lint::FloatComparison::MSG_INEQUALITY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_comparison.rb#63 RuboCop::Cop::Lint::FloatComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies ‘Float` literals which are, like, really really really # really really really really really big. Too big. No-one needs Floats # that big. If you need a float that big, something is wrong with you. # # @example # #   # bad #   float = 3.0e400 # #   # good #   float = 42.9 # # source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#17 class RuboCop::Cop::Lint::FloatOutOfRange &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_float</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/float_out_of_range.rb#18 RuboCop::Cop::Lint::FloatOutOfRange::MSG = T.let(T.unsafe(nil), String)</p>

<p># This lint sees if there is a mismatch between the number of # expected fields for format/sprintf/#% and what is actually # passed as arguments. # # In addition, it checks whether different formats are used in the same # format string. Do not mix numbered, unnumbered, and named formats in # the same format string. # # @example # #   # bad #   format(‘A value: %s and another: %i’, a_value) # #   # good #   format(‘A value: %s and another: %i’, a_value, another) # #   # bad #   format(‘Unnumbered format: %s and numbered: %2$s’, a_value, another) # #   # good #   format(‘Numbered format: %1$s and numbered %2$s’, a_value, another) # # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#27 class RuboCop::Cop::Lint::FormatParameterMismatch &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">called_on_string?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_format_matches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_matches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_percent_matches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">countable_format?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">countable_percent?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_fields_count</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_method?</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_format_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matched_arguments_count?</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">passed</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_with_format_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sprintf?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_type?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#34 RuboCop::Cop::Lint::FormatParameterMismatch::KERNEL = T.let(T.unsafe(nil), String)</p>

<p># <a href="http://rubular.com/r/CvpbxkcTzy">rubular.com/r/CvpbxkcTzy</a> # # source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#29 RuboCop::Cop::Lint::FormatParameterMismatch::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#31 RuboCop::Cop::Lint::FormatParameterMismatch::MSG_INVALID = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#37 RuboCop::Cop::Lint::FormatParameterMismatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#35 RuboCop::Cop::Lint::FormatParameterMismatch::SHOVEL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/format_parameter_mismatch.rb#36 RuboCop::Cop::Lint::FormatParameterMismatch::STRING_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Prefer using ‘Hash#compare_by_identity` rather than using `object_id` # for hash keys. # # This cop looks for hashes being keyed by objects’ ‘object_id`, using # one of these methods: `key?`, `has_key?`, `fetch`, `[]` and `[]=`. # # @example #   # bad #   hash = {} #   <a href="foo.object_id">hash</a> = :bar #   hash.key?(baz.object_id) # #   # good #   hash = {}.compare_by_identity #   <a href="foo">hash</a> = :bar #   hash.key?(baz) # # source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#31 class RuboCop::Cop::Lint::HashCompareByIdentity &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">id_as_hash_key?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#34 RuboCop::Cop::Lint::HashCompareByIdentity::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/hash_compare_by_identity.rb#32 RuboCop::Cop::Lint::HashCompareByIdentity::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the deprecated use of keyword arguments as a default in ‘Hash.new`. # # This usage raises a warning in Ruby 3.3 and results in an error in Ruby 3.4. # In Ruby 3.4, keyword arguments will instead be used to change the behavior of a hash. # For example, the capacity option can be passed to create a hash with a certain size # if you know it in advance, for better performance. # # NOTE: The following corner case may result in a false negative when upgrading from Ruby 3.3 # or earlier, but it is intentionally not detected to respect the expected usage in Ruby 3.4. # # [source,ruby] # —- # Hash.new(capacity: 42) # —- # # @example # #   # bad #   Hash.new(key: :value) # #   # good #   Hash.new({key: :value}) # # source://rubocop//lib/rubocop/cop/lint/hash_new_with_keyword_arguments_as_default.rb#29 class RuboCop::Cop::Lint::HashNewWithKeywordArgumentsAsDefault &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/hash_new_with_keyword_arguments_as_default.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_new</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/hash_new_with_keyword_arguments_as_default.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/hash_new_with_keyword_arguments_as_default.rb#32 RuboCop::Cop::Lint::HashNewWithKeywordArgumentsAsDefault::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/hash_new_with_keyword_arguments_as_default.rb#33 RuboCop::Cop::Lint::HashNewWithKeywordArgumentsAsDefault::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the ordering of a method call where # the receiver of the call is a HEREDOC. # # @example #   # bad #   &lt;&lt;-SQL #   bar #   SQL #   .strip_indent # #   &lt;&lt;-SQL #   bar #   SQL #   .strip_indent #   .trim # #   # good #   &lt;&lt;~SQL #   bar #   SQL # #   &lt;&lt;~SQL.trim #   bar #   SQL # # source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#31 class RuboCop::Cop::Lint::HeredocMethodCallPosition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_on_same_line?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_after_heredoc_range</span>(<span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_end_pos</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_line_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns nil if no range can be safely repositioned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_range_to_safely_reposition</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calls_on_multiple_lines?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">_heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctly_positioned?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_begin_line_range</span>(<span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_end_pos</span>(<span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_node_descendent_receiver</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_comma?</span>(<span class="ruby-identifier">call_source</span>, <span class="ruby-identifier">call_line_source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/heredoc_method_call_position.rb#35 RuboCop::Cop::Lint::HeredocMethodCallPosition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Prefer ‘equal?` over `==` when comparing `object_id`. # # `Object#equal?` is provided to compare objects for identity, and in contrast # `Object#==` is provided for the purpose of doing value comparison. # # @example #   # bad #   foo.object_id == bar.object_id #   foo.object_id != baz.object_id # #   # good #   foo.equal?(bar) #   !foo.equal?(baz) # # source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#20 class RuboCop::Cop::Lint::IdentityComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">object_id_comparison</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#23 RuboCop::Cop::Lint::IdentityComparison::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/identity_comparison.rb#24 RuboCop::Cop::Lint::IdentityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for implicit string concatenation of string literals # which are on the same line. # # @example # #   # bad #   array = [‘Item 1’ ‘Item 2’] # #   # good #   array = [‘Item 1Item 2’] #   array = [‘Item 1’ + ‘Item 2’] #   array = [ #   ‘Item 1’ \ #   ‘Item 2’ #   ] # # source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#21 class RuboCop::Cop::Lint::ImplicitStringConcatenation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_bad_cons</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ending_delimiter</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_content</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literals?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#26 RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_ARRAY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#28 RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_METHOD = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/implicit_string_concatenation.rb#24 RuboCop::Cop::Lint::ImplicitStringConcatenation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘IO.select` that is incompatible with Fiber Scheduler since Ruby 3.0. # # When an array of IO objects waiting for an exception (the third argument of `IO.select`) # is used as an argument, there is no alternative API, so offenses are not registered. # # NOTE: When the method is successful the return value of `IO.select` is `[[IO]]`, # and the return value of `io.wait_readable` and `io.wait_writable` are `self`. # They are not autocorrected when assigning a return value because these types are different. # It’s up to user how to handle the return value. # # @example # #   # bad #   <a href="io">IO.select(</a>, [], [], timeout) # #   # good #   io.wait_readable(timeout) # #   # bad #   IO.select([], [io], [], timeout) # #   # good #   io.wait_writable(timeout) # # source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#34 class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">io_select</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">read</span>, <span class="ruby-identifier">write</span>, <span class="ruby-identifier">timeout</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scheduler_compatible?</span>(<span class="ruby-identifier">io1</span>, <span class="ruby-identifier">io2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#37 RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/incompatible_io_select_with_fiber_scheduler.rb#38 RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘private` or `protected` access modifiers which are # applied to a singleton method. These access modifiers do not make # singleton methods private/protected. `private_class_method` can be # used for that. # # @example # #   # bad #   class C #   private # #   def self.method #   puts ’hi’ #   end #   end # #   # good #   class C #   def self.method #   puts ‘hi’ #   end # #   private_class_method :method #   end # #   # good #   class C #   class &lt;&lt; self #   private # #   def method #   puts ‘hi’ #   end #   end #   end # # source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#41 class RuboCop::Cop::Lint::IneffectiveAccessModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_class_methods</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_visibility?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">modifier</span>, <span class="ruby-identifier">ignored_methods</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">modifier</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ineffective_modifier</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">ignored_methods</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">modifier</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_class_method_names</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#44 RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PRIVATE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#45 RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PROTECTED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/ineffective_access_modifier.rb#42 RuboCop::Cop::Lint::IneffectiveAccessModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for error classes inheriting from ‘Exception`. # It is configurable to suggest using either `StandardError` (default) or # `RuntimeError` instead. # # @example EnforcedStyle: standard_error (default) #   # bad # #   class C &lt; Exception; end # #   C = Class.new(Exception) # #   # good # #   class C &lt; StandardError; end # #   C = Class.new(StandardError) # @example EnforcedStyle: runtime_error #   # bad # #   class C &lt; Exception; end # #   C = Class.new(Exception) # #   # good # #   class C &lt; RuntimeError; end # #   C = Class.new(RuntimeError) # # source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#40 class RuboCop::Cop::Lint::InheritException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_new_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_class?</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherit_exception_class_with_omitted_namespace?</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_base_class</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#44 RuboCop::Cop::Lint::InheritException::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#45 RuboCop::Cop::Lint::InheritException::PREFERRED_BASE_CLASS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/inherit_exception.rb#50 RuboCop::Cop::Lint::InheritException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for interpolation in a single quoted string. # # @example # #   # bad #   foo = ‘something with #{interpolation} inside’ # #   # good #   foo = “something with #{interpolation} inside” # # source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#21 class RuboCop::Cop::Lint::InterpolationCheck &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_syntax?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/interpolation_check.rb#24 RuboCop::Cop::Lint::InterpolationCheck::MSG = T.let(T.unsafe(nil), String)</p>

<p># Emulates the following Ruby warning in Ruby 3.3. # # [source,ruby] # —- # $ ruby -e ‘0.times { it }’ # -e:1: warning: ‘it` calls without arguments will refer to the first block param in Ruby 3.4; # use it() or self.it # —- # # `it` calls without arguments will refer to the first block param in Ruby 3.4. # So use `it()` or `self.it` to ensure compatibility. # # @example # #   # bad #   do_something { it } # #   # good #   do_something { it() } #   do_something { self.it } # # source://rubocop//lib/rubocop/cop/lint/it_without_arguments_in_block.rb#27 class RuboCop::Cop::Lint::ItWithoutArgumentsInBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/it_without_arguments_in_block.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deprecated_it_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/it_without_arguments_in_block.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/it_without_arguments_in_block.rb#33 RuboCop::Cop::Lint::ItWithoutArgumentsInBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/it_without_arguments_in_block.rb#35 RuboCop::Cop::Lint::ItWithoutArgumentsInBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks uses of lambda without a literal block. # It emulates the following warning in Ruby 3.0: # #   $ ruby -vwe ‘lambda(&amp;proc {})’ #   ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19] #   -e:1: warning: lambda without a literal block is deprecated; use the proc without #   lambda instead # # This way, proc object is never converted to lambda. # Autocorrection replaces with compatible proc argument. # # @example # #   # bad #   lambda(&amp;proc { do_something }) #   lambda(&amp;Proc.new { do_something }) # #   # good #   proc { do_something } #   Proc.new { do_something } #   lambda { do_something } # If you use lambda. # # source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#28 class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_with_symbol_proc?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#31 RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/lambda_without_literal_block.rb#32 RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for literals used as the conditions or as # operands in and/or expressions serving as the conditions of # if/while/until/case-when/case-in. # # NOTE: Literals in ‘case-in` condition where the match variable is used in # `in` are accepted as a pattern matching. # # @example # #   # bad #   if 20 #   do_something #   end # #   # bad #   # We’re only interested in the left hand side being a truthy literal, #   # because it affects the evaluation of the &amp;&amp;, whereas the right hand #   # side will be conditionally executed/called and can be a literal. #   if true &amp;&amp; some_var #   do_something #   end # #   # good #   if some_var #   do_something #   end # #   # good #   # When using a boolean value for an infinite loop. #   while true #   break if condition #   end # # source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#38 class RuboCop::Cop::Lint::LiteralAsCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">case_match_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">basic_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_evaluation?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">cond</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_if_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">cond</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">primitive_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">when_conditions_range</span>(<span class="ruby-identifier">when_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#42 RuboCop::Cop::Lint::LiteralAsCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/literal_as_condition.rb#43 RuboCop::Cop::Lint::LiteralAsCondition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for literal assignments in the conditions of ‘if`, `while`, and `until`. # It emulates the following Ruby warning: # # [source,console] # —- # $ ruby -we ’if x = true; end’ # -e:1: warning: found ‘= literal’ in conditional, should be == # —- # # As a lint cop, it cannot be determined if ‘==` is appropriate as intended, # therefore this cop does not provide autocorrection. # # @example # #   # bad #   if x = 42 #   do_something #   end # #   # good #   if x == 42 #   do_something #   end # #   # good #   if x = y #   do_something #   end # # source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#35 class RuboCop::Cop::Lint::LiteralAssignmentInCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_literals?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">asgn_node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parallel_assignment_with_splat_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">traverse_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/literal_assignment_in_condition.rb#36 RuboCop::Cop::Lint::LiteralAssignmentInCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for interpolated literals. # # NOTE: Array literals interpolated in regexps are not handled by this cop, but # by ‘Lint/ArrayLiteralInRegexp` instead. # # @example # #   # bad #   “result is #{10}” # #   # good #   “result is 10” # # source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#18 class RuboCop::Cop::Lint::LiteralInInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_in_regexp?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_for_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_for_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_for_string</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_for_symbol</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_in_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrected_value_in_hash_for_symbol</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_heredoc_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_special_regexp_chars</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_array_percent_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does node print its own source when converted to a string?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prints_as_self?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_keyword?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#25 RuboCop::Cop::Lint::LiteralInInterpolation::COMPOSITE = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/literal_in_interpolation.rb#24 RuboCop::Cop::Lint::LiteralInInterpolation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of ‘begin…end while/until something`. # # @example # #   # bad # #   # using while #   begin #   do_something #   end while some_condition # #   # good # #   # while replacement #   loop do #   do_something #   break unless some_condition #   end # #   # bad # #   # using until #   begin #   do_something #   end until some_condition # #   # good # #   # until replacement #   loop do #   do_something #   break if some_condition #   end # # source://rubocop//lib/rubocop/cop/lint/loop.rb#44 class RuboCop::Cop::Lint::Loop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/loop.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/loop.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/loop.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_break_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/loop.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_and_condition_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/loop.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/loop.rb#47 RuboCop::Cop::Lint::Loop::MSG = T.let(T.unsafe(nil), String)</p>

<p># cop disables on wide ranges of code, that latter contributors to # a file wouldn’t be aware of. # # @example #   # Lint/MissingCopEnableDirective: #   #   MaximumRangeSize: .inf # #   # good #   # rubocop:disable Layout/SpaceAroundOperators #   x= 0 #   # rubocop:enable Layout/SpaceAroundOperators #   # y = 1 #   # EOF # #   # bad #   # rubocop:disable Layout/SpaceAroundOperators #   x= 0 #   # EOF # @example #   # Lint/MissingCopEnableDirective: #   #   MaximumRangeSize: 2 # #   # good #   # rubocop:disable Layout/SpaceAroundOperators #   x= 0 #   # With the previous, there are 2 lines on which cop is disabled. #   # rubocop:enable Layout/SpaceAroundOperators # #   # bad #   # rubocop:disable Layout/SpaceAroundOperators #   x= 0 #   x += 1 #   # Including this, that’s 3 lines on which the cop is disabled. #   # rubocop:enable Layout/SpaceAroundOperators # # source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#45 class RuboCop::Cop::Lint::MissingCopEnableDirective &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_range?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_enabled?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_missing_enable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">comment</span>, <span class="ruby-identifier">type</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#48 RuboCop::Cop::Lint::MissingCopEnableDirective::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_cop_enable_directive.rb#49 RuboCop::Cop::Lint::MissingCopEnableDirective::MSG_BOUND = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of constructors and lifecycle callbacks # without calls to ‘super`. # # This cop does not consider `method_missing` (and `respond_to_missing?`) # because in some cases it makes sense to overtake what is considered a # missing method. In other cases, the theoretical ideal handling could be # challenging or verbose for no actual gain. # # Autocorrection is not supported because the position of `super` cannot be # determined automatically. # # `Object` and `BasicObject` are allowed by this cop because of their # stateless nature. However, sometimes you might want to allow other parent # classes from this cop, for example in the case of an abstract class that is # not meant to be called with `super`. In those cases, you can use the # `AllowedParentClasses` option to specify which classes should be allowed # *in addition to* `Object` and `BasicObject`. # # @example #   # bad #   class Employee &lt; Person #   def initialize(name, salary) #   @salary = salary #   end #   end # #   # good #   class Employee &lt; Person #   def initialize(name, salary) #   super(name) #   @salary = salary #   end #   end # #   # bad #   Employee = Class.new(Person) do #   def initialize(name, salary) #   @salary = salary #   end #   end # #   # good #   Employee = Class.new(Person) do #   def initialize(name, salary) #   super(name) #   @salary = salary #   end #   end # #   # bad #   class Parent #   def self.inherited(base) #   do_something #   end #   end # #   # good #   class Parent #   def self.inherited(base) #   super #   do_something #   end #   end # #   # good #   class ClassWithNoParent #   def initialize #   do_something #   end #   end # @example AllowedParentClasses: [MyAbstractClass] #   # good #   class MyConcreteClass &lt; MyAbstractClass #   def initialize #   do_something #   end #   end # # source://rubocop//lib/rubocop/cop/lint/missing_super.rb#85 class RuboCop::Cop::Lint::MissingSuper &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_new_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_class?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_classes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">callback_method_def?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_super?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_class_with_stateful_parent?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offender?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#96 RuboCop::Cop::Lint::MissingSuper::CALLBACKS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#87 RuboCop::Cop::Lint::MissingSuper::CALLBACK_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#91 RuboCop::Cop::Lint::MissingSuper::CLASS_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#86 RuboCop::Cop::Lint::MissingSuper::CONSTRUCTOR_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#92 RuboCop::Cop::Lint::MissingSuper::METHOD_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/missing_super.rb#89 RuboCop::Cop::Lint::MissingSuper::STATELESS_CLASSES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for mixed-case character ranges since they include likely unintended characters. # # Offenses are registered for regexp character classes like ‘/[A-z]/` # as well as range objects like `(’A’..‘z’)‘. # # NOTE: `Range` objects cannot be autocorrected. # # @example # #   # bad #   r = /[A-z]/ # #   # good #   r = /[A-Za-z]/ # # source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#28 class RuboCop::Cop::Lint::MixedCaseRange &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_unsafe_regexp_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_source_range</span>(<span class="ruby-identifier">range_start</span>, <span class="ruby-identifier">range_end</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for</span>(<span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_pairs</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_range</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_expression?</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_range?</span>(<span class="ruby-identifier">range_start</span>, <span class="ruby-identifier">range_end</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_range?</span>(<span class="ruby-identifier">range_start</span>, <span class="ruby-identifier">range_end</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#32 RuboCop::Cop::Lint::MixedCaseRange::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/mixed_case_range.rb#35 RuboCop::Cop::Lint::MixedCaseRange::RANGES = T.let(T.unsafe(nil), Array)</p>

<p># Do not mix named captures and numbered captures in a ‘Regexp` literal # because numbered capture is ignored if they’re mixed. # Replace numbered captures with non-capturing groupings or # named captures. # # @example #   # bad #   /(?&lt;foo&gt;FOO)(BAR)/ # #   # good #   /(?&lt;foo&gt;FOO)(?&lt;bar&gt;BAR)/ # #   # good #   /(?&lt;foo&gt;FOO)(?:BAR)/ # #   # good #   /(FOO)(BAR)/ # # source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#24 class RuboCop::Cop::Lint::MixedRegexpCaptureTypes &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/mixed_regexp_capture_types.rb#25 RuboCop::Cop::Lint::MixedRegexpCaptureTypes::MSG = T.let(T.unsafe(nil), String)</p>

<p># In math and Python, we can use ‘x &lt; y &lt; z` style comparison to compare # multiple value. However, we can’t use the comparison in Ruby. However, # the comparison is not syntax error. This cop checks the bad usage of # comparison operators. # # @example # #   # bad #   x &lt; y &lt; z #   10 &lt;= x &lt;= 20 # #   # good #   x &lt; y &amp;&amp; y &lt; z #   10 &lt;= x &amp;&amp; x &lt;= 20 # # source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#20 class RuboCop::Cop::Lint::MultipleComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_compare?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#24 RuboCop::Cop::Lint::MultipleComparison::COMPARISON_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#23 RuboCop::Cop::Lint::MultipleComparison::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#26 RuboCop::Cop::Lint::MultipleComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/multiple_comparison.rb#25 RuboCop::Cop::Lint::MultipleComparison::SET_OPERATION_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for nested method definitions. # # @example # #   # bad # #   # ‘bar` definition actually produces methods in the same scope #   # as the outer `foo` method. Furthermore, the `bar` method #   # will be redefined every time `foo` is invoked. #   def foo #   def bar #   end #   end # #   # good # #   def foo #   bar = -&gt; { puts ’hello’ } #   bar.call #   end # #   # good # #   # ‘class_eval`, `instance_eval`, `module_eval`, `class_exec`, `instance_exec`, and #   # `module_exec` blocks are allowed by default. # #   def foo #   self.class.class_eval do #   def bar #   end #   end #   end # #   def foo #   self.class.module_exec do #   def bar #   end #   end #   end # #   # good # #   def foo #   class &lt;&lt; self #   def bar #   end #   end #   end # @example AllowedMethods: [] (default) #   # bad #   def do_something #   has_many :articles do #   def find_or_create_by_name(name) #   end #   end #   end # @example AllowedMethods: [’has_many’] #   # bad #   def do_something #   has_many :articles do #   def find_or_create_by_name(name) #   end #   end #   end # @example AllowedPatterns: [] (default) #   # bad #   def foo(obj) #   obj.do_baz do #   def bar #   end #   end #   end # @example AllowedPatterns: [‘baz’] #   # good #   def foo(obj) #   obj.do_baz do #   def bar #   end #   end #   end # # source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#91 class RuboCop::Cop::Lint::NestedMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eval_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exec_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_subject_type?</span>(<span class="ruby-identifier">subject</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scoping_method_call?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/nested_method_definition.rb#95 RuboCop::Cop::Lint::NestedMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for nested percent literals. # # @example # #   # bad # #   # The percent literal for nested_attributes is parsed as four tokens, #   # yielding the array [:name, :content, :“%i[incorrectly”, :“nested]”]. #   attributes = { #   valid_attributes: %i[name content], #   nested_attributes: %i[name content %i[incorrectly nested]] #   } # #   # good # #   # Neither is incompatible with the bad case, but probably the intended code. #   attributes = { #   valid_attributes: %i[name content], #   nested_attributes: [:name, :content, %i[incorrectly nested]] #   } # #   attributes = { #   valid_attributes: %i[name content], #   nested_attributes: [:name, :content, [:incorrectly, :nested]] #   } # # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#32 class RuboCop::Cop::Lint::NestedPercentLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_percent_literals?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#35 RuboCop::Cop::Lint::NestedPercentLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># The array of regular expressions representing percent literals that, # if found within a percent literal expression, will cause a # NestedPercentLiteral violation to be emitted. # # source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#41 RuboCop::Cop::Lint::NestedPercentLiteral::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/nested_percent_literal.rb#42 RuboCop::Cop::Lint::NestedPercentLiteral::REGEXES = T.let(T.unsafe(nil), Array)</p>

<p># Don’t omit the accumulator when calling ‘next` in a `reduce` block. # # @example # #   # bad #   result = (1..4).reduce(0) do |acc, i| #   next if i.odd? #   acc + i #   end # #   # good #   result = (1..4).reduce(0) do |acc, i| #   next acc if i.odd? #   acc + i #   end # # source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#21 class RuboCop::Cop::Lint::NextWithoutAccumulator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block_body_of_reduce</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_block_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/next_without_accumulator.rb#22 RuboCop::Cop::Lint::NextWithoutAccumulator::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of a ‘return` inside a `begin..end` block # in assignment contexts. # In this situation, the `return` will result in an exit from the current # method, possibly leading to unexpected behavior. # # @example # #   # bad #   @some_variable ||= begin #   return some_value if some_condition_is_met # #   do_something #   end # #   # good #   @some_variable ||= begin #   if some_condition_is_met #   some_value #   else #   do_something #   end #   end # #   # good #   some_variable = if some_condition_is_met #   return if another_condition_is_met # #   some_value #   else #   do_something #   end # # source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#38 class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/no_return_in_begin_end_blocks.rb#39 RuboCop::Cop::Lint::NoReturnInBeginEndBlocks::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for non-atomic file operation. # And then replace it with a nearly equivalent and atomic method. # # These can cause problems that are difficult to reproduce, # especially in cases of frequent file operations in parallel, # such as test runs with parallel_rspec. # # For examples: creating a directory if there is none, has the following problems # # An exception occurs when the directory didn’t exist at the time of ‘exist?`, # but someone else created it before `mkdir` was executed. # # Subsequent processes are executed without the directory that should be there # when the directory existed at the time of `exist?`, # but someone else deleted it shortly afterwards. # # @example #   # bad - race condition with another process may result in an error in `mkdir` #   unless Dir.exist?(path) #   FileUtils.mkdir(path) #   end # #   # good - atomic and idempotent creation #   FileUtils.mkdir_p(path) # #   # bad - race condition with another process may result in an error in `remove` #   if File.exist?(path) #   FileUtils.remove(path) #   end # #   # good - atomic and idempotent removal #   FileUtils.rm_f(path) # # source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#44 class RuboCop::Cop::Lint::NonAtomicFileOperation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_not_force?</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force?</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_and_method_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_exist_node</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowable_use_with_if?</span>(<span class="ruby-identifier">if_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_replace_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_method_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_option?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_node_child?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_change_force_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_remove_file_exist_check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">exist_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_mode_keyword?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#50 RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_FORCE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#51 RuboCop::Cop::Lint::NonAtomicFileOperation::MAKE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#49 RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_CHANGE_FORCE_METHOD = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#47 RuboCop::Cop::Lint::NonAtomicFileOperation::MSG_REMOVE_FILE_EXIST_CHECK = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#54 RuboCop::Cop::Lint::NonAtomicFileOperation::RECURSIVE_REMOVE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#52 RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_FORCE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#53 RuboCop::Cop::Lint::NonAtomicFileOperation::REMOVE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_atomic_file_operation.rb#55 RuboCop::Cop::Lint::NonAtomicFileOperation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># ‘<a href="...">Dir</a>` and `Dir.glob(…)` do not make any guarantees about # the order in which files are returned. The final order is # determined by the operating system and file system. # This means that using them in cases where the order matters, # such as requiring files, can lead to intermittent failures # that are hard to debug. To ensure this doesn’t happen, # always sort the list. # # ‘Dir.glob` and `Dir[]` sort globbed results by default in Ruby 3.0. # So all bad cases are acceptable when Ruby 3.0 or higher are used. # # NOTE: This cop will be deprecated and removed when supporting only Ruby 3.0 and higher. # # @example # #   # bad #   Dir[“./lib/<strong>*/</strong>.rb”].each do |file| #   require file #   end # #   # good #   Dir[“./lib/<strong>*/</strong>.rb”].sort.each do |file| #   require file #   end # #   # bad #   Dir.glob(Rails.root.join(__dir__, ’test’, ‘*.rb’)) do |file| #   require file #   end # #   # good #   Dir.glob(Rails.root.join(__dir__, ‘test’, ‘*.rb’)).sort.each do |file| #   require file #   end # #   # bad #   Dir[‘./lib/<strong>*/</strong>.rb’].each(&amp;method(:require)) # #   # good #   Dir[‘./lib/<strong>*/</strong>.rb’].sort.each(&amp;method(:require)) # #   # bad #   Dir.glob(Rails.root.join(‘test’, ‘*.rb’), &amp;method(:require)) # #   # good #   Dir.glob(Rails.root.join(‘test’, ‘*.rb’)).sort.each(&amp;method(:require)) # #   # good - Respect intent if ‘sort` keyword option is specified in Ruby 3.0 or higher. #   Dir.glob(Rails.root.join(__dir__, ’test’, ‘*.rb’), sort: false).each(&amp;method(:require)) # # source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#60 class RuboCop::Cop::Lint::NonDeterministicRequireOrder &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_variable</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_require?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block_pass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_each?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_each_pass?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_glob_pass?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">var_is_required?</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_block_pass</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns range of last argument including comma and whitespace.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Parser::Source::Range]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_arg_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_loop?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsorted_dir_pass?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_deterministic_require_order.rb#64 RuboCop::Cop::Lint::NonDeterministicRequireOrder::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for non-local exits from iterators without a return # value. It registers an offense under these conditions: # # * No value is returned, # * the block is preceded by a method chain, # * the block has arguments, # * the method which receives the block is not ‘define_method` # or `define_singleton_method`, # * the return is not contained in an inner scope, e.g. a lambda or a # method definition. # # @example # #   class ItemApi #   rescue_from ValidationError do |e| # non-iteration block with arg #   return { message: ’validation error’ } unless e.errors # allowed #   error_array = e.errors.map do |error| # block with method chain #   return if error.suppress? # warned #   return “#{error.param}: invalid” unless error.message # allowed #   “#{error.param}: #{error.message}” #   end #   { message: ‘validation error’, errors: error_array } #   end # #   def update_items #   transaction do # block without arguments #   return unless update_necessary? # allowed #   find_each do |item| # block without method chain #   return if item.stock == 0 # false-negative… #   item.update!(foobar: true) #   end #   end #   end #   end # # source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#41 class RuboCop::Cop::Lint::NonLocalExitFromIterator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_send?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value?</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scoped_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/non_local_exit_from_iterator.rb#42 RuboCop::Cop::Lint::NonLocalExitFromIterator::MSG = T.let(T.unsafe(nil), String)</p>

<p># Warns the usage of unsafe number conversions. Unsafe # number conversion can cause unexpected error if auto type conversion # fails. Cop prefer parsing with number class instead. # # Conversion with ‘Integer`, `Float`, etc. will raise an `ArgumentError` # if given input that is not numeric (eg. an empty string), whereas # `to_i`, etc. will try to convert regardless of input (“”.to_i =&gt; 0“). # As such, this cop is disabled by default because it’s not necessarily # always correct to raise if a value is not numeric. # # NOTE: Some values cannot be converted properly using one of the ‘Kernel` # method (for instance, `Time` and `DateTime` values are allowed by this # cop by default). Similarly, Rails’ duration methods do not work well # with ‘Integer()` and can be allowed with `AllowedMethods`. By default, # there are no methods to allowed. # # @example # #   # bad # #   ’10’.to_i #   ‘10.2’.to_f #   ‘10’.to_c #   ‘1/3’.to_r #   [‘1’, ‘2’, ‘3’].map(&amp;:to_i) #   foo.try(:to_f) #   bar.send(:to_c) # #   # good # #   Integer(‘10’, 10) #   Float(‘10.2’) #   Complex(‘10’) #   Rational(‘1/3’) #   [‘1’, ‘2’, ‘3’].map { |i| Integer(i, 10) } #   foo.try { |i| Float(i) } #   bar.send { |i| Complex(i) } # @example AllowedMethods: [] (default) # #   # bad #   10.minutes.to_i # @example AllowedMethods: [minutes] # #   # good #   10.minutes.to_i # @example AllowedPatterns: [] (default) # #   # bad #   10.minutes.to_i # @example AllowedPatterns: [‘min*’] # #   # good #   10.minutes.to_i # @example IgnoredClasses: [Time, DateTime] (default) # #   # good #   Time.now.to_datetime.to_i # # source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#73 class RuboCop::Cop::Lint::NumberConversion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_method</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_method_symbol</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_receiver?</span>(<span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conversion_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_method</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_sym_method</span>(<span class="ruby-identifier">to_method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_as_symbol</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_conversion_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_class?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_classes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_parentheses</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">top_receiver</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#88 RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#78 RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHOD_CLASS_MAPPING = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#89 RuboCop::Cop::Lint::NumberConversion::METHODS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/number_conversion.rb#84 RuboCop::Cop::Lint::NumberConversion::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of numbered parameter assignment. # It emulates the following warning in Ruby 2.7: # #   $ ruby -ve ‘_1 = :value’ #   ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin19] #   -e:1: warning: ‘_1’ is reserved for numbered parameter; consider another name # # Assigning to a numbered parameter (from ‘_1` to `_9`) causes an error in Ruby 3.0. # #   $ ruby -ve ’_1 = :value’ #   ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19] #   -e:1: _1 is reserved for numbered parameter # # NOTE: The parametered parameters are from ‘_1` to `_9`. This cop checks `_0`, and over `_10` # as well to prevent confusion. # # @example # #   # bad #   _1 = :value # #   # good #   non_numbered_parameter_name = :value # # source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#30 class RuboCop::Cop::Lint::NumberedParameterAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#32 RuboCop::Cop::Lint::NumberedParameterAssignment::LVAR_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#33 RuboCop::Cop::Lint::NumberedParameterAssignment::NUMBERED_PARAMETER_RANGE = T.let(T.unsafe(nil), Range)</p>

<p># source://rubocop//lib/rubocop/cop/lint/numbered_parameter_assignment.rb#31 RuboCop::Cop::Lint::NumberedParameterAssignment::NUM_PARAM_MSG = T.let(T.unsafe(nil), String)</p>

<p># Certain numeric operations have a constant result, usually 0 or 1. # Multiplying a number by 0 will always return 0. # Dividing a number by itself or raising it to the power of 0 will always return 1. # As such, they can be replaced with that result. # These are probably leftover from debugging, or are mistakes. # Other numeric operations that are similarly leftover from debugging or mistakes # are handled by ‘Lint/UselessNumericOperation`. # # NOTE: This cop doesn’t detect offenses for the ‘-` and `%` operator because it # can’t determine the type of ‘x`. If `x` is an `Array` or `String`, it doesn’t perform # a numeric operation. # # @example # #   # bad #   x * 0 # #   # good #   0 # #   # bad #   x *= 0 # #   # good #   x = 0 # #   # bad #   x / x #   x ** 0 # #   # good #   1 # #   # bad #   x /= x #   x **= 0 # #   # good #   x = 1 # # source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#46 class RuboCop::Cop::Lint::NumericOperationWithConstantResult &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">abbreviated_assignment_with_constant_result?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operation_with_constant_result?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_result?</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">operation</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#48 RuboCop::Cop::Lint::NumericOperationWithConstantResult::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/numeric_operation_with_constant_result.rb#49 RuboCop::Cop::Lint::NumericOperationWithConstantResult::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for unintended or-assignment to a constant. # # Constants should always be assigned in the same location. And its value # should always be the same. If constants are assigned in multiple # locations, the result may vary depending on the order of ‘require`. # # @example # #   # bad #   CONST ||= 1 # #   # good #   CONST = 1 # # source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#24 class RuboCop::Cop::Lint::OrAssignmentToConstant &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/or_assignment_to_constant.rb#27 RuboCop::Cop::Lint::OrAssignmentToConstant::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks the proper ordering of magic comments and whether # a magic comment is not placed before a shebang. # # @example #   # bad # #   # frozen_string_literal: true #   # encoding: ascii #   p [”.frozen?, ”.encoding] #=&gt; [true, #<Encoding:UTF-8&gt;] # #   # good # #   # encoding: ascii #   # frozen_string_literal: true #   p [”.frozen?, ”.encoding] #=&gt; [true, #<Encoding:US-ASCII&gt;] # #   # good # #   #!/usr/bin/env ruby #   # encoding: ascii #   # frozen_string_literal: true #   p [”.frozen?, ”.encoding] #=&gt; [true, #<Encoding:US-ASCII&gt;] # # source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#32 class RuboCop::Cop::Lint::OrderedMagicComments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">encoding_line</span>, <span class="ruby-identifier">frozen_string_literal_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magic_comment_lines</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/ordered_magic_comments.rb#36 RuboCop::Cop::Lint::OrderedMagicComments::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for references of ‘Regexp` captures that are out of range # and thus always returns nil. # # @example # #   /(foo)bar/ =~ ’foobar’ # #   # bad - always returns nil # #   puts $2 # =&gt; nil # #   # good # #   puts $1 # =&gt; foo # # source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#38 class RuboCop::Cop::Lint::OutOfRangeRegexpRef &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_with_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nth_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nth_ref_receiver?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_first_argument?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_patterns</span>(<span class="ruby-identifier">in_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_receiver?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#39 RuboCop::Cop::Lint::OutOfRangeRegexpRef::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#42 RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_ARGUMENT_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#44 RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_CAPTURE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#41 RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_RECEIVER_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/out_of_range_regexp_ref.rb#45 RuboCop::Cop::Lint::OutOfRangeRegexpRef::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># Checks for space between the name of a called method and a left # parenthesis. # # @example # #   # bad #   do_something (foo) # #   # good #   do_something(foo) #   do_something (2 + 3) * 4 #   do_something (foo * bar).baz # # source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#18 class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_calls?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compound_range?</span>(<span class="ruby-identifier">first_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_range</span>(<span class="ruby-identifier">expr</span>, <span class="ruby-identifier">space_length</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">spaces_before_left_parenthesis</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_context?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_first_argument?</span>(<span class="ruby-identifier">first_arg</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/parentheses_as_grouped_expression.rb#22 RuboCop::Cop::Lint::ParenthesesAsGroupedExpression::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for quotes and commas in %w, e.g. ‘%w(’foo’, “bar”)‘ # # It is more likely that the additional characters are unintended (for # example, mistranslating an array of literals to percent string notation) # rather than meant to be part of the resulting strings. # # @example # #   # bad #   %w(’foo’, “bar”) # #   # good #   %w(foo bar) # # source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#29 class RuboCop::Cop::Lint::PercentStringArray &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_quotes_or_commas?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#34 RuboCop::Cop::Lint::PercentStringArray::LEADING_QUOTE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#37 RuboCop::Cop::Lint::PercentStringArray::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#33 RuboCop::Cop::Lint::PercentStringArray::QUOTES_AND_COMMAS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/percent_string_array.rb#35 RuboCop::Cop::Lint::PercentStringArray::TRAILING_QUOTE = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for colons and commas in %i, e.g. ‘%i(:foo, :bar)` # # It is more likely that the additional characters are unintended (for # example, mistranslating an array of literals to percent string notation) # rather than meant to be part of the resulting symbols. # # @example # #   # bad #   %i(:foo, :bar) # #   # good #   %i(foo bar) # # source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#19 class RuboCop::Cop::Lint::PercentSymbolArray &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_colons_or_commas?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_alphanumeric_literal?</span>(<span class="ruby-identifier">literal</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/percent_symbol_array.rb#23 RuboCop::Cop::Lint::PercentSymbolArray::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘raise` or `fail` statements which raise `Exception` or # `Exception.new`. Use `StandardError` or a specific exception class instead. # # If you have defined your own namespaced `Exception` class, it is possible # to configure the cop to allow it by setting `AllowedImplicitNamespaces` to # an array with the names of the namespaces to allow. By default, this is set to # `[’Gem’]‘, which allows `Gem::Exception` to be raised without an explicit namespace. # If not allowed, a false positive may be registered if `raise Exception` is called # within the namespace. # # Alternatively, use a fully qualified name with `raise`/`fail` # (eg. `raise Namespace::Exception`). # # @example #   # bad #   raise Exception, ’Error message here’ #   raise Exception.new(‘Error message here’) # #   # good #   raise StandardError, ‘Error message here’ #   raise MyError.new, ‘Error message here’ # @example AllowedImplicitNamespaces: [‘Gem’] (default) #   # bad - ‘Foo` is not an allowed implicit namespace #   module Foo #   def self.foo #   raise Exception # This is qualified to `Foo::Exception`. #   end #   end # #   # good #   module Gem #   def self.foo #   raise Exception # This is qualified to `Gem::Exception`. #   end #   end # #   # good #   module Foo #   def self.foo #   raise Foo::Exception #   end #   end # # source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#53 class RuboCop::Cop::Lint::RaiseException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_new_with_message?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_implicit_namespaces</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_namespace?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#56 RuboCop::Cop::Lint::RaiseException::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/raise_exception.rb#57 RuboCop::Cop::Lint::RaiseException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘rand(1)` calls. # Such calls always return `0`. # # @example # #   # bad #   rand 1 #   Kernel.rand(-1) #   rand 1.0 #   rand(-1.0) # #   # good #   0 # just use 0 instead # # source://rubocop//lib/rubocop/cop/lint/rand_one.rb#19 class RuboCop::Cop::Lint::RandOne &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rand_one.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rand_one.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rand_one?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rand_one.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/rand_one.rb#20 RuboCop::Cop::Lint::RandOne::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/rand_one.rb#21 RuboCop::Cop::Lint::RandOne::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># removed without causing any offenses to be reported. It’s implemented # as a cop in that it inherits from the Cop base class and calls # add_offense. The unusual part of its implementation is that it doesn’t # have any on_* methods or an investigate method. This means that it # doesn’t take part in the investigation phase when the other cops do # their work. Instead, it waits until it’s called in a later stage of the # execution. The reason it can’t be implemented as a normal cop is that # it depends on the results of all other cops to do its work. # # @example #   # bad #   # rubocop:disable Layout/LineLength #   x += 1 #   # rubocop:enable Layout/LineLength # #   # good #   x += 1 # # source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#28 class RuboCop::Cop::Lint::RedundantCopDisableDirective &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [RedundantCopDisableDirective] a new instance of RedundantCopDisableDirective</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">offenses</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offenses_to_check.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_to_check</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute offenses_to_check</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute offenses_to_check to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_to_check=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#323</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_department_marker</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_entire_comment</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_some_cops</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offenses</span>(<span class="ruby-identifier">redundant_cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_disabled?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_range_with_surrounding_space</span>(<span class="ruby-identifier">directive_comment_range</span>, <span class="ruby-identifier">line_comment_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_disabled_line_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_range</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_disabled?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_marker?</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">describe</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_count</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_range_in_list</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">ranges</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_already_disabled</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">line_ranges</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_line_range</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">line_ranges</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_redundant_disable</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_its_line?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_final_disable?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_redundant_all</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">next_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_redundant_cop</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_redundant_department</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">followed_ranges?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">next_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_offense?</span>(<span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leave_free_comment?</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_range</span>(<span class="ruby-identifier">haystack</span>, <span class="ruby-identifier">needle</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_line_blank?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_offense?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">offenses</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_department_marker</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_range?</span>(<span class="ruby-identifier">ranges</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#32 RuboCop::Cop::Lint::RedundantCopDisableDirective::COP_NAME = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#33 RuboCop::Cop::Lint::RedundantCopDisableDirective::DEPARTMENT_MARKER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_cop_disable_directive.rb#287 RuboCop::Cop::Lint::RedundantCopDisableDirective::SIMILAR_COP_NAMES_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># removed. # # that cop checks whether any cop was actually enabled. # # @example # #   # bad #   foo = 1 #   # rubocop:enable Layout/LineLength # #   # good #   foo = 1 # #   # bad #   # rubocop:disable Style/StringLiterals #   foo = “1” #   # rubocop:enable Style/StringLiterals #   baz #   # rubocop:enable all # #   # good #   # rubocop:disable Style/StringLiterals #   foo = “1” #   # rubocop:enable all #   baz # # source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#39 class RuboCop::Cop::Lint::RedundantCopEnableDirective &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_or_name</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_start</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name_indention</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department?</span>(<span class="ruby-identifier">directive</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_offense</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_to_remove</span>(<span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_comma</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the list of cops is comma-separated, but without an empty space after the comma,</span>
<span class="ruby-comment"># we should **not** remove the prepending empty space, thus begin_pos += 1</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_comma_after</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">start</span>, <span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_comma_before</span>(<span class="ruby-identifier">start</span>, <span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">cop_names</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_cop_enable_directive.rb#44 RuboCop::Cop::Lint::RedundantCopEnableDirective::MSG = T.let(T.unsafe(nil), String)</p>

<p># Sort globbed results by default in Ruby 3.0. # This cop checks for redundant ‘sort` method to `Dir.glob` and `Dir[]`. # # @example # #   # bad #   Dir.glob(’./lib/<strong>*/</strong>.rb’).sort.each do |file| #   end # #   Dir[‘./lib/<strong>*/</strong>.rb’].sort.each do |file| #   end # #   # good #   Dir.glob(‘./lib/<strong>*/</strong>.rb’).each do |file| #   end # #   Dir[‘./lib/<strong>*/</strong>.rb’].each do |file| #   end # # source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#30 class RuboCop::Cop::Lint::RedundantDirGlobSort &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_argument?</span>(<span class="ruby-identifier">glob_method</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#38 RuboCop::Cop::Lint::RedundantDirGlobSort::GLOB_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#36 RuboCop::Cop::Lint::RedundantDirGlobSort::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_dir_glob_sort.rb#37 RuboCop::Cop::Lint::RedundantDirGlobSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant quantifiers inside ‘Regexp` literals. # # It is always allowed when interpolation is used in a regexp literal, # because it’s unknown what kind of string will be expanded as a result: # # [source,ruby] # —- # /(?:a*#{interpolation})?/x # —- # # @example #   # bad #   /(?:x+)+/ # #   # good #   /(?:x)+/ # #   # good #   /(?:x+)/ # #   # bad #   /(?:x+)?/ # #   # good #   /(?:x)*/ # #   # good #   /(?:x*)/ # # source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#34 class RuboCop::Cop::Lint::RedundantRegexpQuantifiers &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">character_set?</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_redundantly_quantified_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mergeable_quantifier</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merged_quantifier</span>(<span class="ruby-identifier">exp1</span>, <span class="ruby-identifier">exp2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">group</span>, <span class="ruby-identifier">child</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quantifier_range</span>(<span class="ruby-identifier">group</span>, <span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_group?</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundantly_quantifiable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_regexp_quantifiers.rb#38 RuboCop::Cop::Lint::RedundantRegexpQuantifiers::MSG_REDUNDANT_QUANTIFIER = T.let(T.unsafe(nil), String)</p>

<p># Checks for unnecessary ‘require` statement. # # The following features are unnecessary `require` statement because # they are already loaded. e.g. Ruby 2.2: # #   ruby -ve ’p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }‘ #   ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13] #   [“enumerator.so”, “rational.so”, “complex.so”, “thread.rb”] # # Below are the features that each `TargetRubyVersion` targets. # #   * 2.0+ … `enumerator` #   * 2.1+ … `thread` #   * 2.2+ … Add `rational` and `complex` above #   * 2.7+ … Add `ruby2_keywords` above #   * 3.1+ … Add `fiber` above #   * 3.2+ … `set` # # This cop target those features. # # @example #   # bad #   require ’unloaded_feature’ #   require ‘thread’ # #   # good #   require ‘unloaded_feature’ # # source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#33 class RuboCop::Cop::Lint::RedundantRequireStatement &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_require_statement?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_feature?</span>(<span class="ruby-identifier">feature_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#37 RuboCop::Cop::Lint::RedundantRequireStatement::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#38 RuboCop::Cop::Lint::RedundantRequireStatement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_require_statement.rb#39 RuboCop::Cop::Lint::RedundantRequireStatement::RUBY_22_LOADED_FEATURES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant safe navigation calls. # Use cases where a constant, named in camel case for classes and modules is ‘nil` are rare, # and an offense is not detected when the receiver is a constant. The detection also applies # to `self`, and to literal receivers, except for `nil`. # # For all receivers, the `instance_of?`, `kind_of?`, `is_a?`, `eql?`, `respond_to?`, # and `equal?` methods are checked by default. # These are customizable with `AllowedMethods` option. # # The `AllowedMethods` option specifies nil-safe methods, # in other words, it is a method that is allowed to skip safe navigation. # Note that the `AllowedMethod` option is not an option that specifies methods # for which to suppress (allow) this cop’s check. # # In the example below, the safe navigation operator (‘&amp;.`) is unnecessary # because `NilClass` has methods like `respond_to?` and `is_a?`. # # @example #   # bad #   CamelCaseConst&amp;.do_something # #   # good #   CamelCaseConst.do_something # #   # bad #   do_something if attrs&amp;.respond_to?(:[]) # #   # good #   do_something if attrs.respond_to?(:[]) # #   # bad #   while node&amp;.is_a?(BeginNode) #   node = node.parent #   end # #   # good #   while node.is_a?(BeginNode) #   node = node.parent #   end # #   # good - without `&amp;.` this will always return `true` #   foo&amp;.respond_to?(:to_a) # #   # bad - for `nil`s conversion methods return default values for the type #   foo&amp;.to_h || {} #   foo&amp;.to_h { |k, v| [k, v] } || {} #   foo&amp;.to_a || [] #   foo&amp;.to_i || 0 #   foo&amp;.to_f || 0.0 #   foo&amp;.to_s || ” # #   # good #   foo.to_h #   foo.to_h { |k, v| [k, v] } #   foo.to_a #   foo.to_i #   foo.to_f #   foo.to_s # #   # bad #   self&amp;.foo # #   # good #   self.foo # @example AllowedMethods: [nil_safe_method] #   # bad #   do_something if attrs&amp;.nil_safe_method(:[]) # #   # good #   do_something if attrs.nil_safe_method(:[]) #   do_something if attrs&amp;.not_nil_safe_method(:[]) # # source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#84 class RuboCop::Cop::Lint::RedundantSafeNavigation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conversion_with_default?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">respond_to_nil_specific_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assume_receiver_instance_exists?</span>(<span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition?</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#88 RuboCop::Cop::Lint::RedundantSafeNavigation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#89 RuboCop::Cop::Lint::RedundantSafeNavigation::MSG_LITERAL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#91 RuboCop::Cop::Lint::RedundantSafeNavigation::NIL_SPECIFIC_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_safe_navigation.rb#93 RuboCop::Cop::Lint::RedundantSafeNavigation::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for unneeded usages of splat expansion. # # @example # #   # bad #   a = *[1, 2, 3] #   a = *‘a’ #   a = *1 #   [‘a’, ‘b’, *%w(c d e), ‘f’, ‘g’] # #   # good #   c = [1, 2, 3] #   a = *c #   a, b = *c #   a, *b = *c #   a = *1..10 #   a = [‘a’] #   [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’] # #   # bad #   do_something(*[‘foo’, ‘bar’, ‘baz’]) # #   # good #   do_something(‘foo’, ‘bar’, ‘baz’) # #   # bad #   begin #   foo #   rescue *[StandardError, ApplicationError] #   bar #   end # #   # good #   begin #   foo #   rescue StandardError, ApplicationError #   bar #   end # #   # bad #   case foo #   when *[1, 2, 3] #   bar #   else #   baz #   end # #   # good #   case foo #   when 1, 2, 3 #   bar #   else #   baz #   end # @example AllowPercentLiteralArrayArgument: true (default) # #   # good #   do_something(*%w[foo bar baz]) # @example AllowPercentLiteralArrayArgument: false # #   # bad #   do_something(*%w[foo bar baz]) # # source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#71 class RuboCop::Cop::Lint::RedundantSplatExpansion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_new?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_expansion</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_splat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_percent_literal_array_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_new_inside_array_literal?</span>(<span class="ruby-identifier">array_new_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_splat?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">part_of_an_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_brackets?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_splat_expansion</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_brackets</span>(<span class="ruby-identifier">array</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_range_and_content</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_percent_literal_array_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#75 RuboCop::Cop::Lint::RedundantSplatExpansion::ARRAY_PARAM_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#80 RuboCop::Cop::Lint::RedundantSplatExpansion::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#74 RuboCop::Cop::Lint::RedundantSplatExpansion::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#79 RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_I = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#77 RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_W = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#78 RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_I = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_splat_expansion.rb#76 RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_W = T.let(T.unsafe(nil), String)</p>

<p># Checks for string conversion in string interpolation, ‘print`, `puts`, and `warn` arguments, # which is redundant. # # @example # #   # bad #   “result is #{something.to_s}” #   print something.to_s #   puts something.to_s #   warn something.to_s # #   # good #   “result is #{something}” #   print something #   puts something #   warn something # # source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#23 class RuboCop::Cop::Lint::RedundantStringCoercion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s_without_args?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">context</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#27 RuboCop::Cop::Lint::RedundantStringCoercion::MSG_DEFAULT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#28 RuboCop::Cop::Lint::RedundantStringCoercion::MSG_SELF = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_string_coercion.rb#29 RuboCop::Cop::Lint::RedundantStringCoercion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant uses of ‘to_s`, `to_sym`, `to_i`, `to_f`, `to_d`, `to_r`, `to_c`, # `to_a`, `to_h`, and `to_set`. # # When one of these methods is called on an object of the same type, that object # is returned, making the call unnecessary. The cop detects conversion methods called # on object literals, class constructors, class `[]` methods, and the `Kernel` methods # `String()`, `Integer()`, `Float()`, BigDecimal(), `Rational()`, `Complex()`, and `Array()`. # # Specifically, these cases are detected for each conversion method: # # * `to_s` when called on a string literal, interpolated string, heredoc, #   or with `String.new` or `String()`. # * `to_sym` when called on a symbol literal or interpolated symbol. # * `to_i` when called on an integer literal or with `Integer()`. # * `to_f` when called on a float literal of with `Float()`. # * `to_r` when called on a rational literal or with `Rational()`. # * `to_c` when called on a complex literal of with `Complex()`. # * `to_a` when called on an array literal, or with `Array.new`, `Array()` or `Array[]`. # * `to_h` when called on a hash literal, or with `Hash.new`, `Hash()` or `Hash[]`. # * `to_set` when called on `Set.new` or `Set[]`. # # In all cases, chaining one same `to_*` conversion methods listed above is redundant. # # The cop can also register an offense for chaining conversion methods on methods that are # expected to return a specific type regardless of receiver (eg. `foo.inspect.to_s` and # `foo.to_json.to_s`). # # @example #   # bad #   “text”.to_s #   :sym.to_sym #   42.to_i #   8.5.to_f #   12r.to_r #   1i.to_c #   [].to_a #   {}.to_h #   Set.new.to_set # #   # good #   “text” #   :sym #   42 #   8.5 #   12r #   1i #   [] #   {} #   Set.new # #   # bad #   Integer(var).to_i # #   # good #   Integer(var) # #   # good - chaining to a type constructor with exceptions suppressed #   # in this case, `Integer()` could return `nil` #   Integer(var, exception: false).to_i # #   # bad - chaining the same conversion #   foo.to_s.to_s # #   # good #   foo.to_s # #   # bad - chaining a conversion to a method that is expected to return the same type #   foo.inspect.to_s #   foo.to_json.to_s # #   # good #   foo.inspect #   foo.to_json # # source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#80 class RuboCop::Cop::Lint::RedundantTypeConversion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bigdecimal_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_false_keyword_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">float_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integer_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rational_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_conversion?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_to_typed_method?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constructor?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constructor_suppresses_exceptions?</span>(<span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_receiver</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_or_set_with_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_receiver?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Maps each conversion method to the pattern matcher for that type’s constructors # Not every type has a constructor, for instance Symbol. # # source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#100 RuboCop::Cop::Lint::RedundantTypeConversion::CONSTRUCTOR_MAPPING = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#116 RuboCop::Cop::Lint::RedundantTypeConversion::CONVERSION_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># Maps conversion methods to the node types for the literals of that type # # source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#86 RuboCop::Cop::Lint::RedundantTypeConversion::LITERAL_NODE_TYPES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#83 RuboCop::Cop::Lint::RedundantTypeConversion::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#117 RuboCop::Cop::Lint::RedundantTypeConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># Methods that already are expected to return a given type, which makes a further # conversion redundant. # # source://rubocop//lib/rubocop/cop/lint/redundant_type_conversion.rb#114 RuboCop::Cop::Lint::RedundantTypeConversion::TYPED_METHODS = T.let(T.unsafe(nil), Hash)</p>

<p># Checks for redundant ‘with_index`. # # @example #   # bad #   ary.each_with_index do |v| #   v #   end # #   # good #   ary.each do |v| #   v #   end # #   # bad #   ary.each.with_index do |v| #   v #   end # #   # good #   ary.each do |v| #   v #   end # # source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#29 class RuboCop::Cop::Lint::RedundantWithIndex &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_with_index?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_index_range</span>(<span class="ruby-identifier">send</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#33 RuboCop::Cop::Lint::RedundantWithIndex::MSG_EACH_WITH_INDEX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_with_index.rb#34 RuboCop::Cop::Lint::RedundantWithIndex::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant ‘with_object`. # # @example #   # bad #   ary.each_with_object([]) do |v| #   v #   end # #   # good #   ary.each do |v| #   v #   end # #   # bad #   ary.each.with_object([]) do |v| #   v #   end # #   # good #   ary.each do |v| #   v #   end # # source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#29 class RuboCop::Cop::Lint::RedundantWithObject &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_with_object?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_object_range</span>(<span class="ruby-identifier">send</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#33 RuboCop::Cop::Lint::RedundantWithObject::MSG_EACH_WITH_OBJECT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/redundant_with_object.rb#34 RuboCop::Cop::Lint::RedundantWithObject::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)</p>

<p># Checks if ‘include` or `prepend` is called in `refine` block. # These methods are deprecated and should be replaced with `Refinement#import_methods`. # # It emulates deprecation warnings in Ruby 3.1. Functionality has been removed in Ruby 3.2. # # @example # #   # bad #   refine Foo do #   include Bar #   end # #   # bad #   refine Foo do #   prepend Bar #   end # #   # good #   refine Foo do #   import_methods Bar #   end # # source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#34 class RuboCop::Cop::Lint::RefinementImportMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#37 RuboCop::Cop::Lint::RefinementImportMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/refinement_import_methods.rb#38 RuboCop::Cop::Lint::RefinementImportMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for regexp literals used as ‘match-current-line`. # If a regexp literal is in condition, the regexp matches `$_` implicitly. # # @example #   # bad #   if /foo/ #   do_something #   end # #   # good #   if /foo/ =~ $_ #   do_something #   end # # source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#19 class RuboCop::Cop::Lint::RegexpAsCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_current_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/regexp_as_condition.rb#22 RuboCop::Cop::Lint::RegexpAsCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for expressions where there is a call to a predicate # method with at least one argument, where no parentheses are used around # the parameter list, and a boolean operator, &amp;&amp; or ||, is used in the # last argument. # # The idea behind warning for these constructs is that the user might # be under the impression that the return value from the method call is # an operand of &amp;&amp;/||. # # @example # #   # bad #   if day.is? :tuesday &amp;&amp; month == :jan #   # … #   end # #   # good #   if day.is?(:tuesday) &amp;&amp; month == :jan #   # … #   end # # source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#26 class RuboCop::Cop::Lint::RequireParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_predicate</span>(<span class="ruby-identifier">predicate</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ternary</span>(<span class="ruby-identifier">ternary</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/require_parentheses.rb#29 RuboCop::Cop::Lint::RequireParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that a range literal is enclosed in parentheses when the end of the range is # at a line break. # # NOTE: The following is maybe intended for ‘(42..)`. But, compatible is `42..do_something`. # So, this cop does not provide autocorrection because it is left to user. # # [source,ruby] # —- # case condition # when 42.. #   do_something # end # —- # # @example # #   # bad - Represents `(1..42)`, not endless range. #   1.. #   42 # #   # good - It’s incompatible, but your intentions when using endless range may be: #   (1..) #   42 # #   # good #   1..42 # #   # good #   (1..42) # #   # good #   (1.. #   42) # # source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#40 class RuboCop::Cop::Lint::RequireRangeParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/require_range_parentheses.rb#41 RuboCop::Cop::Lint::RequireRangeParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses a file requiring itself with ‘require_relative`. # # @example # #   # bad # #   # foo.rb #   require_relative ’foo’ #   require_relative ‘bar’ # #   # good # #   # foo.rb #   require_relative ‘bar’ # # source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#21 class RuboCop::Cop::Lint::RequireRelativeSelfPath &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_ext</span>(<span class="ruby-identifier">file_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_file?</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-identifier">required_feature</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#25 RuboCop::Cop::Lint::RequireRelativeSelfPath::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/require_relative_self_path.rb#26 RuboCop::Cop::Lint::RequireRelativeSelfPath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘rescue` blocks targeting the `Exception` class. # # @example # #   # bad #   begin #   do_something #   rescue Exception #   handle_exception #   end # #   # good #   begin #   do_something #   rescue ArgumentError #   handle_exception #   end # # source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#23 class RuboCop::Cop::Lint::RescueException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">targets_exception?</span>(<span class="ruby-identifier">rescue_arg_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/rescue_exception.rb#24 RuboCop::Cop::Lint::RescueException::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check for arguments to ‘rescue` that will result in a `TypeError` # if an exception is raised. # # @example #   # bad #   begin #   bar #   rescue nil #   baz #   end # #   # bad #   def foo #   bar #   rescue 1, ’a’, “#{b}”, 0.0, [], {} #   baz #   end # #   # good #   begin #   bar #   rescue #   baz #   end # #   # good #   def foo #   bar #   rescue NameError #   baz #   end # # source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#37 class RuboCop::Cop::Lint::RescueType &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">exceptions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_exceptions</span>(<span class="ruby-identifier">exceptions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_exceptions</span>(<span class="ruby-identifier">exceptions</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#42 RuboCop::Cop::Lint::RescueType::INVALID_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/rescue_type.rb#40 RuboCop::Cop::Lint::RescueType::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of a return with a value in a context # where the value will be ignored. (initialize and setter methods) # # @example # #   # bad #   def initialize #   foo #   return :qux if bar? #   baz #   end # #   def foo=(bar) #   return 42 #   end # #   # good #   def initialize #   foo #   return if bar? #   baz #   end # #   def foo=(bar) #   return #   end # # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#32 class RuboCop::Cop::Lint::ReturnInVoidContext &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#33 RuboCop::Cop::Lint::ReturnInVoidContext::MSG = T.let(T.unsafe(nil), String)</p>

<p># Returning out of these methods only exits the block itself. # # source://rubocop//lib/rubocop/cop/lint/return_in_void_context.rb#36 RuboCop::Cop::Lint::ReturnInVoidContext::SCOPE_CHANGING_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># The safe navigation operator returns nil if the receiver is # nil. If you chain an ordinary method call after a safe # navigation operator, it raises NoMethodError. We should use a # safe navigation operator after a safe navigation operator. # This cop checks for the problem outlined above. # # @example # #   # bad #   x&amp;.foo.bar #   x&amp;.foo + bar #   <a href="bar">x&amp;.foo</a> # #   # good #   x&amp;.foo&amp;.bar #   x&amp;.foo || bar # # source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#22 class RuboCop::Cop::Lint::SafeNavigationChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NilMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @param offense_range [Parser::Source::Range]</span>
<span class="ruby-comment"># @param send_node [RuboCop::AST::SendNode]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_safe_navigation_operator</span>(<span class="ruby-value">offense_range:</span>, <span class="ruby-value">send_node:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param corrector [RuboCop::Cop::Corrector]</span>
<span class="ruby-comment"># @param offense_range [Parser::Source::Range]</span>
<span class="ruby-comment"># @param send_node [RuboCop::AST::SendNode]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-value">offense_range:</span>, <span class="ruby-value">send_node:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brackets?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_inside_collection_literal?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_safe_navigation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#29 RuboCop::Cop::Lint::SafeNavigationChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/safe_navigation_chain.rb#30 RuboCop::Cop::Lint::SafeNavigationChain::PLUS_MINUS_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Check to make sure that if safe navigation is used in an ‘&amp;&amp;` or `||` condition, # consistent and appropriate safe navigation, without excess or deficiency, # is used for all method calls on the same object. # # @example #   # bad #   foo&amp;.bar &amp;&amp; foo&amp;.baz # #   # good #   foo&amp;.bar &amp;&amp; foo.baz # #   # bad #   foo.bar &amp;&amp; foo&amp;.baz # #   # good #   foo.bar &amp;&amp; foo.baz # #   # bad #   foo&amp;.bar || foo.baz # #   # good #   foo&amp;.bar || foo&amp;.baz # #   # bad #   foo.bar || foo&amp;.baz # #   # good #   foo.bar || foo.baz # #   # bad #   foo&amp;.bar &amp;&amp; (foobar.baz || foo&amp;.baz) # #   # good #   foo&amp;.bar &amp;&amp; (foobar.baz || foo.baz) # # source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#41 class RuboCop::Cop::Lint::SafeNavigationConsistency &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NilMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">already_appropriate_call?</span>(<span class="ruby-identifier">operand</span>, <span class="ruby-identifier">dot_op</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_operands</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">operand_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_consistent_parts</span>(<span class="ruby-identifier">grouped_operands</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">most_left_indices</span>(<span class="ruby-identifier">grouped_operands</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nilable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operand_in_and?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operand_in_or?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operand_nodes</span>(<span class="ruby-identifier">operand</span>, <span class="ruby-identifier">operand_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_name_as_key</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">fully_receivers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">operand</span>, <span class="ruby-identifier">dot_operator</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#45 RuboCop::Cop::Lint::SafeNavigationConsistency::USE_DOT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/safe_navigation_consistency.rb#46 RuboCop::Cop::Lint::SafeNavigationConsistency::USE_SAFE_NAVIGATION_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks to make sure safe navigation isn’t used with ‘empty?` in # a conditional. # # While the safe navigation operator is generally a good idea, when # checking `foo&amp;.empty?` in a conditional, `foo` being `nil` will actually # do the opposite of what the author intends. # # @example #   # bad #   return if foo&amp;.empty? #   return unless foo&amp;.empty? # #   # good #   return if foo &amp;&amp; foo.empty? #   return unless foo &amp;&amp; foo.empty? # # source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#22 class RuboCop::Cop::Lint::SafeNavigationWithEmpty &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_navigation_empty_in_conditional?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/safe_navigation_with_empty.rb#25 RuboCop::Cop::Lint::SafeNavigationWithEmpty::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if a file which has a shebang line as # its first line is granted execute permission. # # @example #   # bad # #   # A file which has a shebang line as its first line is not #   # granted execute permission. # #   #!/usr/bin/env ruby #   puts ‘hello, world’ # #   # good # #   # A file which has a shebang line as its first line is #   # granted execute permission. # #   #!/usr/bin/env ruby #   puts ‘hello, world’ # #   # good # #   # A file which has not a shebang line as its first line is not #   # granted execute permission. # #   puts ‘hello, world’ # # source://rubocop//lib/rubocop/cop/lint/script_permission.rb#33 class RuboCop::Cop::Lint::ScriptPermission &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">executable?</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message_from</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#36 RuboCop::Cop::Lint::ScriptPermission::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/script_permission.rb#37 RuboCop::Cop::Lint::ScriptPermission::SHEBANG = T.let(T.unsafe(nil), String)</p>

<p># Checks for self-assignments. # # @example #   # bad #   foo = foo #   foo, bar = foo, bar #   Foo = Foo #   <a href="&#39;foo&#39;">hash</a> = <a href="&#39;foo&#39;">hash</a> #   obj.attr = obj.attr # #   # good #   foo = bar #   foo, bar = bar, foo #   Foo = Bar #   <a href="&#39;foo&#39;">hash</a> = <a href="&#39;bar&#39;">hash</a> #   obj.attr = obj.attr2 # #   # good (method calls possibly can return different results) #   <a href="foo">hash</a> = <a href="foo">hash</a> # @example AllowRBSInlineAnnotation:true #   # good #   foo = foo #: Integer #   foo, bar = foo, bar #: Integer #   Foo = Foo #: Integer #   <a href="&#39;foo&#39;">hash</a> = <a href="&#39;foo&#39;">hash</a> #: Integer #   obj.attr = obj.attr #: Integer # # source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#34 class RuboCop::Cop::Lint::SelfAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_rbs_inline_annotation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_attribute_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_key_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_self_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rbs_inline_annotation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs_matches_lhs?</span>(<span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">lhs</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#37 RuboCop::Cop::Lint::SelfAssignment::ASSIGNMENT_TYPE_TO_RHS_TYPE = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/lint/self_assignment.rb#35 RuboCop::Cop::Lint::SelfAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘send`, `public_send`, and `__send__` methods # when using mix-in. # # `include` and `prepend` methods were private methods until Ruby 2.0, # they were mixed-in via `send` method. This cop uses Ruby 2.1 or # higher style that can be called by public methods. # And `extend` method that was originally a public method is also targeted # for style unification. # # @example #   # bad #   Foo.send(:include, Bar) #   Foo.send(:prepend, Bar) #   Foo.send(:extend, Bar) # #   # bad #   Foo.public_send(:include, Bar) #   Foo.public_send(:prepend, Bar) #   Foo.public_send(:extend, Bar) # #   # bad #   Foo.__send__(:include, Bar) #   Foo.__send__(:prepend, Bar) #   Foo.__send__(:extend, Bar) # #   # good #   Foo.include Bar #   Foo.prepend Bar #   Foo.extend Bar # # source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#36 class RuboCop::Cop::Lint::SendWithMixinArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_with_mixin_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">module_name</span>, <span class="ruby-identifier">bad_method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixin_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#41 RuboCop::Cop::Lint::SendWithMixinArgument::MIXIN_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#40 RuboCop::Cop::Lint::SendWithMixinArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#43 RuboCop::Cop::Lint::SendWithMixinArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/send_with_mixin_argument.rb#42 RuboCop::Cop::Lint::SendWithMixinArgument::SEND_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for shadowed arguments. # # This cop has ‘IgnoreImplicitReferences` configuration option. # It means argument shadowing is used in order to pass parameters # to zero arity `super` when `IgnoreImplicitReferences` is `true`. # # @example # #   # bad #   do_something do |foo| #   foo = 42 #   puts foo #   end # #   def do_something(foo) #   foo = 42 #   puts foo #   end # #   # good #   do_something do |foo| #   foo = foo + 42 #   puts foo #   end # #   def do_something(foo) #   foo = foo + 42 #   puts foo #   end # #   def do_something(foo) #   puts foo #   end # @example IgnoreImplicitReferences: false (default) # #   # bad #   def do_something(foo) #   foo = 42 #   super #   end # #   def do_something(foo) #   foo = super #   bar #   end # @example IgnoreImplicitReferences: true # #   # good #   def do_something(foo) #   foo = 42 #   super #   end # #   def do_something(foo) #   foo = super #   bar #   end # # source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#66 class RuboCop::Cop::Lint::ShadowedArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uses_var?</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Get argument references without assignments&#39; references</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_references</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Find the first argument assignment, which doesn&#39;t reference the</span>
<span class="ruby-comment"># argument at the rhs. If the assignment occurs inside a branch or</span>
<span class="ruby-comment"># block, it is impossible to tell whether it&#39;s executed, so precise</span>
<span class="ruby-comment"># shadowing location is not known.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_without_argument_usage</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_argument</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_implicit_references?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Check whether the given node is nested into block or conditional.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_within_block_or_conditional?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">stop_search_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference_pos</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shadowing_assignment</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#72</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/shadowed_argument.rb#67 RuboCop::Cop::Lint::ShadowedArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for a rescued exception that get shadowed by a # less specific exception being rescued before a more specific # exception is rescued. # # An exception is considered shadowed if it is rescued after its # ancestor is, or if it and its ancestor are both rescued in the # same ‘rescue` statement. In both cases, the more specific rescue is # unnecessary because it is covered by rescuing the less specific # exception. (ie. `rescue Exception, StandardError` has the same behavior # whether `StandardError` is included or not, because all “StandardError“s # are rescued by `rescue Exception`). # # @example # #   # bad # #   begin #   something #   rescue Exception #   handle_exception #   rescue StandardError #   handle_standard_error #   end # #   # bad #   begin #   something #   rescue Exception, StandardError #   handle_error #   end # #   # good # #   begin #   something #   rescue StandardError #   handle_standard_error #   rescue Exception #   handle_exception #   end # #   # good, however depending on runtime environment. #   # #   # This is a special case for system call errors. #   # System dependent error code depends on runtime environment. #   # For example, whether `Errno::EAGAIN` and `Errno::EWOULDBLOCK` are #   # the same error code or different error code depends on environment. #   # This good case is for `Errno::EAGAIN` and `Errno::EWOULDBLOCK` with #   # the same error code. #   begin #   something #   rescue Errno::EAGAIN, Errno::EWOULDBLOCK #   handle_standard_error #   end # # source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#61 class RuboCop::Cop::Lint::ShadowedException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RescueNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compare_exceptions</span>(<span class="ruby-identifier">exception</span>, <span class="ruby-identifier">other_exception</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_multiple_levels_of_exceptions?</span>(<span class="ruby-identifier">group</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_exceptions</span>(<span class="ruby-identifier">group</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_shadowing_rescue</span>(<span class="ruby-identifier">rescues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">rescues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescued_groups_for</span>(<span class="ruby-identifier">rescues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sorted?</span>(<span class="ruby-identifier">rescued_groups</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">system_call_err?</span>(<span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/shadowed_exception.rb#65 RuboCop::Cop::Lint::ShadowedException::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of local variable names from an outer scope # in block arguments or block-local variables. This mirrors the warning # given by ‘ruby -cw` prior to Ruby 2.6: # “shadowing outer local variable - foo”. # # The cop is now disabled by default to match the upstream Ruby behavior. # It’s useful, however, if you’d like to avoid shadowing variables from outer # scopes, which some people consider an anti-pattern that makes it harder # to keep track of what’s going on in a program. # # NOTE: Shadowing of variables in block passed to ‘Ractor.new` is allowed # because `Ractor` should not access outer variables. # eg. following style is encouraged: # # [source,ruby] # —- # worker_id, pipe = env # Ractor.new(worker_id, pipe) do |worker_id, pipe| # end # —- # # @example # #   # bad #   def some_method #   foo = 1 # #   2.times do |foo| # shadowing outer `foo` #   do_something(foo) #   end #   end # #   # good #   def some_method #   foo = 1 # #   2.times do |bar| #   do_something(bar) #   end #   end # # source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#46 class RuboCop::Cop::Lint::ShadowingOuterLocalVariable &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_declaring_variable</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ractor_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_conditional_node_from_ascendant</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_or_its_ascendant_conditional?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_conditions_node_different_branch?</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">outer_local_variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_node</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_used_in_declaration_of_outer?</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">outer_local_variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/shadowing_outer_local_variable.rb#47 RuboCop::Cop::Lint::ShadowingOuterLocalVariable::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘Hash` creation with a mutable default value. # Creating a `Hash` in such a way will share the default value # across all keys, causing unexpected behavior when modifying it. # # For example, when the `Hash` was created with an `Array` as the argument, # calling `<a href=":foo">hash</a> &lt;&lt; ’bar’‘ will also change the value of all # other keys that have not been explicitly assigned to. # # @example #   # bad #   Hash.new([]) #   Hash.new({}) #   Hash.new(Array.new) #   Hash.new(Hash.new) # #   # okay – In rare cases that intentionally have this behavior, #   #   without disabling the cop, you can set the default explicitly. #   h = Hash.new #   h.default = [] #   <a href=":a">h</a> &lt;&lt; 1 #   <a href=":b">h</a> &lt;&lt; 2 #   h # =&gt; {:a =&gt; [1, 2], :b =&gt; [1, 2]} # #   # okay – beware this will discard mutations and only remember assignments #   Hash.new { Array.new } #   Hash.new { Hash.new } #   Hash.new { {} } #   Hash.new { [] } # #   # good - frozen solution will raise an error when mutation attempted #   Hash.new([].freeze) #   Hash.new({}.freeze) # #   # good - using a proc will create a new object for each key #   h = Hash.new #   h.default_proc = -&gt;(h, k) { [] } #   h.default_proc = -&gt;(h, k) { {} } # #   # good - using a block will create a new object for each key #   Hash.new { |h, k| <a href="k">h</a> = [] } #   Hash.new { |h, k| <a href="k">h</a> = {} } # # source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#47 class RuboCop::Cop::Lint::SharedMutableDefault &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">capacity_keyword_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_initialized_with_mutable_shared_object?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#48 RuboCop::Cop::Lint::SharedMutableDefault::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/shared_mutable_default.rb#50 RuboCop::Cop::Lint::SharedMutableDefault::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks unexpected overrides of the ‘Struct` built-in methods # via `Struct.new`. # # @example #   # bad #   Bad = Struct.new(:members, :clone, :count) #   b = Bad.new([], true, 1) #   b.members #=&gt; [] (overriding `Struct#members`) #   b.clone #=&gt; true (overriding `Object#clone`) #   b.count #=&gt; 1 (overriding `Enumerable#count`) # #   # good #   Good = Struct.new(:id, :name) #   g = Good.new(1, “foo”) #   g.members #=&gt; [:id, :name] #   g.clone #=&gt; #<struct Good id=1, name=“foo”&gt; #   g.count #=&gt; 2 # # source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#24 class RuboCop::Cop::Lint::StructNewOverride &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">struct_new</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#25 RuboCop::Cop::Lint::StructNewOverride::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#27 RuboCop::Cop::Lint::StructNewOverride::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#30 RuboCop::Cop::Lint::StructNewOverride::STRUCT_MEMBER_NAME_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/struct_new_override.rb#29 RuboCop::Cop::Lint::StructNewOverride::STRUCT_METHOD_NAMES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘rescue` blocks with no body. # # @example # #   # bad #   def some_method #   do_something #   rescue #   end # #   # bad #   begin #   do_something #   rescue #   end # #   # good #   def some_method #   do_something #   rescue #   handle_exception #   end # #   # good #   begin #   do_something #   rescue #   handle_exception #   end # @example AllowComments: true (default) # #   # good #   def some_method #   do_something #   rescue #   # do nothing #   end # #   # good #   begin #   do_something #   rescue #   # do nothing #   end # @example AllowComments: false # #   # bad #   def some_method #   do_something #   rescue #   # do nothing #   end # #   # bad #   begin #   do_something #   rescue #   # do nothing #   end # @example AllowNil: true (default) # #   # good #   def some_method #   do_something #   rescue #   nil #   end # #   # good #   begin #   do_something #   rescue #   # do nothing #   end # #   # good #   do_something rescue nil # @example AllowNil: false # #   # bad #   def some_method #   do_something #   rescue #   nil #   end # #   # bad #   begin #   do_something #   rescue #   nil #   end # #   # bad #   do_something rescue nil # # source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#105 class RuboCop::Cop::Lint::SuppressedException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_between_rescue_and_end?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_body?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/suppressed_exception.rb#106 RuboCop::Cop::Lint::SuppressedException::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for cases where exceptions unrelated to the numeric constructors ‘Integer()`, # `Float()`, `BigDecimal()`, `Complex()`, and `Rational()` may be unintentionally swallowed. # # @example # #   # bad #   Integer(arg) rescue nil # #   # bad #   begin #   Integer(arg) #   rescue #   nil #   end # #   # bad #   begin #   Integer(arg) #   rescue #   end # #   # good #   Integer(arg, exception: false) # # source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#41 class RuboCop::Cop::Lint::SuppressedExceptionInNumberConversion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_numeric_constructor_rescue_nil</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constructor_receiver?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numeric_constructor_rescue_nil</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numeric_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_exception_classes_only?</span>(<span class="ruby-identifier">exception_classes</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#46 RuboCop::Cop::Lint::SuppressedExceptionInNumberConversion::EXPECTED_EXCEPTION_CLASSES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/suppressed_exception_in_number_conversion.rb#45 RuboCop::Cop::Lint::SuppressedExceptionInNumberConversion::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of literal strings converted to # a symbol where a literal symbol could be used instead. # # There are two possible styles for this cop. # ‘strict` (default) will register an offense for any incorrect usage. # `consistent` additionally requires hashes to use the same style for # every symbol key (ie. if any symbol key needs to be quoted it requires # all keys to be quoted). # # @example #   # bad #   ’string’.to_sym #   :symbol.to_sym #   ‘underscored_string’.to_sym #   :‘underscored_symbol’ #   ‘hyphenated-string’.to_sym #   “string_#{interpolation}”.to_sym # #   # good #   :string #   :symbol #   :underscored_string #   :underscored_symbol #   :‘hyphenated-string’ #   :“string_#{interpolation}” # @example EnforcedStyle: strict (default) # #   # bad #   { #   ‘a’: 1, #   “b”: 2, #   ‘c-d’: 3 #   } # #   # good (don’t quote keys that don’t require quoting) #   { #   a: 1, #   b: 2, #   ‘c-d’: 3 #   } # @example EnforcedStyle: consistent # #   # bad #   { #   a: 1, #   ‘b-c’: 2 #   } # #   # good (quote all keys if any need quoting) #   { #   ‘a’: 1, #   ‘b-c’: 2 #   } # #   # good (no quoting required) #   { #   a: 1, #   b: 2 #   } # # source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#68 class RuboCop::Cop::Lint::SymbolConversion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SymbolHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_hash_key</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_inconsistent_hash_keys</span>(<span class="ruby-identifier">keys</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_alias?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_percent_literal_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">properly_quoted?</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">correction:</span>, <span class="ruby-value">message:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_quotes?</span>(<span class="ruby-identifier">sym_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#73 RuboCop::Cop::Lint::SymbolConversion::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#74 RuboCop::Cop::Lint::SymbolConversion::MSG_CONSISTENCY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/symbol_conversion.rb#76 RuboCop::Cop::Lint::SymbolConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Repacks Parser’s diagnostics/errors # into RuboCop’s offenses. # # source://rubocop//lib/rubocop/cop/lint/syntax.rb#8 class RuboCop::Cop::Lint::Syntax &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/syntax.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_other_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/syntax.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_from_diagnostic</span>(<span class="ruby-identifier">diagnostic</span>, <span class="ruby-identifier">ruby_version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/syntax.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_from_error</span>(<span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/syntax.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">beautify_message</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/syntax.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_severity</span>(<span class="ruby-identifier">_range</span>, <span class="ruby-identifier">_severity</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/syntax.rb#9 RuboCop::Cop::Lint::Syntax::LEVELS = T.let(T.unsafe(nil), Array)</p>

<p># Ensures that ‘to_enum`/`enum_for`, called for the current method, # has correct arguments. # # @example #   # bad #   def foo(x, y = 1) #   return to_enum(__callee__, x) # `y` is missing #   end # #   # good #   def foo(x, y = 1) #   # Alternatives to `__callee__` are `__method__` and `:foo`. #   return to_enum(__callee__, x, y) #   end # #   # good #   def foo(x, y = 1) #   # It is also allowed if it is wrapped in some method like Sorbet. #   return to_enum(T.must(__callee__), x, y) #   end # # source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#27 class RuboCop::Cop::Lint::ToEnumArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enum_conversion_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">passing_keyword_arg?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_match?</span>(<span class="ruby-identifier">send_arg</span>, <span class="ruby-identifier">def_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_match?</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">def_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#28 RuboCop::Cop::Lint::ToEnumArguments::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/to_enum_arguments.rb#30 RuboCop::Cop::Lint::ToEnumArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks to make sure ‘#to_json` includes an optional argument. # When overriding `#to_json`, callers may invoke JSON # generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows # for an optional argument, your method should too. # # @example #   class Point #   attr_reader :x, :y # #   # bad, incorrect arity #   def to_json #   JSON.generate([x, y]) #   end # #   # good, preserving args #   def to_json(*args) #   JSON.generate([x, y], *args) #   end # #   # good, discarding args #   def to_json(*_args) #   JSON.generate([x, y]) #   end #   end # # source://rubocop//lib/rubocop/cop/lint/to_json.rb#31 class RuboCop::Cop::Lint::ToJSON &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/to_json.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/to_json.rb#34 RuboCop::Cop::Lint::ToJSON::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for top level return with arguments. If there is a # top-level return statement with an argument, then the argument is # always ignored. This is detected automatically since Ruby 2.7. # # @example #   # bad #   return 1 # #   # good #   return # # source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#16 class RuboCop::Cop::Lint::TopLevelReturnWithArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_arguments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This cop works by validating the ancestors of the return node. A</span>
<span class="ruby-comment"># top-level return node&#39;s ancestors should not be of block, def, or</span>
<span class="ruby-comment"># defs type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">top_level_return?</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">top_level_return_with_any_argument?</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/top_level_return_with_argument.rb#19 RuboCop::Cop::Lint::TopLevelReturnWithArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing commas in attribute declarations, such as # ‘#attr_reader`. Leaving a trailing comma will nullify the next method # definition by overriding it with a getter method. # # @example # #   # bad #   class Foo #   attr_reader :foo, # #   def bar #   puts “Unreachable.” #   end #   end # #   # good #   class Foo #   attr_reader :foo # #   def bar #   puts “No problem!” #   end #   end # # source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#30 class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_comma_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/trailing_comma_in_attribute_declaration.rb#34 RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for “triple quotes” (strings delimited by any odd number # of quotes greater than 1). # # Ruby allows multiple strings to be implicitly concatenated by just # being adjacent in a statement (ie. ‘“foo”“bar” == “foobar”`). This sometimes # gives the impression that there is something special about triple quotes, but # in fact it is just extra unnecessary quotes and produces the same string. Each # pair of quotes produces an additional concatenated empty string, so the result # is still only the “actual” string within the delimiters. # # NOTE: Although this cop is called triple quotes, the same behavior is present # for strings delimited by 5, 7, etc. quotation marks. # # @example #   # bad #   “”“ #   A string #   ”“” # #   # bad #   ”’ #   A string #   ”‘ # #   # good #   “ #   A string #   ” # #   # good #   &lt;&lt;STRING #   A string #   STRING # #   # good (but not the same spacing as the bad case) #   ’A string’ # # source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#42 class RuboCop::Cop::Lint::TripleQuotes &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_str_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/triple_quotes.rb#45 RuboCop::Cop::Lint::TripleQuotes::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for underscore-prefixed variables that are actually # used. # # Since block keyword arguments cannot be arbitrarily named at call # sites, the ‘AllowKeywordBlockArguments` will allow use of underscore- # prefixed block keyword arguments. # # @example AllowKeywordBlockArguments: false (default) # #   # bad # #   [1, 2, 3].each do |_num| #   do_something(_num) #   end # #   query(:sales) do |_id:, revenue:, cost:| #   {_id: _id, profit: revenue - cost} #   end # #   # good # #   [1, 2, 3].each do |num| #   do_something(num) #   end # #   [1, 2, 3].each do |_num| #   do_something # not using `_num` #   end # @example AllowKeywordBlockArguments: true # #   # good # #   query(:sales) do |_id:, revenue:, cost:| #   {_id: _id, profit: revenue - cost} #   end # # source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#43 class RuboCop::Cop::Lint::UnderscorePrefixedVariableName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_variable</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_keyword_block_argument?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#46</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/underscore_prefixed_variable_name.rb#44 RuboCop::Cop::Lint::UnderscorePrefixedVariableName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for Regexpes (both literals and via ‘Regexp.new` / `Regexp.compile`) # that contain unescaped `]` characters. # # It emulates the following Ruby warning: # # [source,ruby] # —- # $ ruby -e ’/abc]123/‘ # -e:1: warning: regular expression has ’]‘ without escape: /abc]123/ # —- # # @example #   # bad #   /abc]123/ #   %r{abc]123} #   Regexp.new(’abc]123’) #   Regexp.compile(‘abc]123’) # #   # good #   /abc]123/ #   %r{abc]123} #   Regexp.new(‘abc]123’) #   Regexp.compile(‘abc]123’) # # source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#30 class RuboCop::Cop::Lint::UnescapedBracketInRegexp &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_constructor</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_at_index</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">offset</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#33 RuboCop::Cop::Lint::UnescapedBracketInRegexp::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/unescaped_bracket_in_regexp.rb#34 RuboCop::Cop::Lint::UnescapedBracketInRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for a block that is known to need more positional # block arguments than are given (by default this is configured for # ‘Enumerable` methods needing 2 arguments). Optional arguments are allowed, # although they don’t generally make sense as the default value will # be used. Blocks that have no receiver, or take splatted arguments # (ie. ‘*args`) are always accepted. # # Keyword arguments (including `**kwargs`) do not get counted towards # this, as they are not used by the methods in question. # # Method names and their expected arity can be configured like this: # # [source,yaml] # —- # Methods: #   inject: 2 #   reduce: 2 # —- # # @example #   # bad #   values.reduce {} #   values.min { |a| a } #   values.sort { |a; b| a + b } # #   # good #   values.reduce { |memo, obj| memo &lt;&lt; obj } #   values.min { |a, b| a &lt;=&gt; b } #   values.sort { |*x| <a href="0">x</a> &lt;=&gt; <a href="1">x</a> } # # source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#41 class RuboCop::Cop::Lint::UnexpectedBlockArity &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_count</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_arity</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included_method?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">methods</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unexpected_block_arity.rb#42 RuboCop::Cop::Lint::UnexpectedBlockArity::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for using Fixnum or Bignum constant. # # @example # #   # bad #   1.is_a?(Fixnum) #   1.is_a?(Bignum) # #   # good #   1.is_a?(Integer) # # source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#16 class RuboCop::Cop::Lint::UnifiedInteger &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixnum_or_bignum_const</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unified_integer.rb#19 RuboCop::Cop::Lint::UnifiedInteger::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for ‘reduce` or `inject` blocks where the value returned (implicitly or # explicitly) does not include the accumulator. A block is considered valid as # long as at least one return value includes the accumulator. # # If the accumulator is not included in the return value, then the entire # block will just return a transformation of the last element value, and # could be rewritten as such without a loop. # # Also catches instances where an index of the accumulator is returned, as # this may change the type of object being retained. # # NOTE: For the purpose of reducing false positives, this cop only flags # returns in `reduce` blocks where the element is the only variable in # the expression (since we will not be able to tell what other variables # relate to via static analysis). # # @example # #   # bad #   (1..4).reduce(0) do |acc, el| #   el * 2 #   end # #   # bad, may raise a NoMethodError after the first iteration #   %w(a b c).reduce({}) do |acc, letter| #   <a href="letter">acc</a> = true #   end # #   # good #   (1..4).reduce(0) do |acc, el| #   acc + el * 2 #   end # #   # good, element is returned but modified using the accumulator #   values.reduce do |acc, el| #   el &lt;&lt; acc #   el #   end # #   # good, returns the accumulator instead of the index #   %w(a b c).reduce({}) do |acc, letter| #   <a href="letter">acc</a> = true #   acc #   end # #   # good, at least one branch returns the accumulator #   values.reduce(nil) do |result, value| #   break result if something? #   value #   end # #   # good, recursive #   keys.reduce(self) { |result, key| <a href="key">result</a> } # #   # ignored as the return value cannot be determined #   enum.reduce do |acc, el| #   x = foo(acc, el) #   bar(x) #   end # # source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#65 class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accumulator_index?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">element_modified?</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression_values</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lvar_used?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reduce_with_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Determine if a return value is acceptable for the purposes of this cop</span>
<span class="ruby-comment"># If it is an expression containing the accumulator, it is acceptable</span>
<span class="ruby-comment"># Otherwise, it is only unacceptable if it contains the iterated element, since we</span>
<span class="ruby-comment"># otherwise do not have enough information to prevent false positives.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_return?</span>(<span class="ruby-identifier">return_val</span>, <span class="ruby-identifier">element_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Exclude `begin` nodes inside a `dstr` from being collected by `return_values`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_type?</span>(<span class="ruby-identifier">parent_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_arg_name</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_return_values</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">potential_offense?</span>(<span class="ruby-identifier">return_values</span>, <span class="ruby-identifier">block_body</span>, <span class="ruby-identifier">element_name</span>, <span class="ruby-identifier">accumulator_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return values in a block are either the value given to next,</span>
<span class="ruby-comment"># the last line of a multiline block, or the only line of the block</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_values</span>(<span class="ruby-identifier">block_body_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Look for an index of the accumulator being returned, except where the index</span>
<span class="ruby-comment"># is the element.</span>
<span class="ruby-comment"># This is always an offense, in order to try to catch potential exceptions</span>
<span class="ruby-comment"># due to type mismatches</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">returned_accumulator_index</span>(<span class="ruby-identifier">return_values</span>, <span class="ruby-identifier">accumulator_name</span>, <span class="ruby-identifier">element_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the accumulator is used in any return value, the node is acceptable since</span>
<span class="ruby-comment"># the accumulator has a chance to change each iteration</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">returns_accumulator_anywhere?</span>(<span class="ruby-identifier">return_values</span>, <span class="ruby-identifier">accumulator_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#66 RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/unmodified_reduce_accumulator.rb#67 RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG_INDEX = T.let(T.unsafe(nil), String)</p>

<p># Checks for unreachable code. # The check are based on the presence of flow of control # statement in non-final position in ‘begin` (implicit) blocks. # # @example # #   # bad #   def some_method #   return #   do_something #   end # #   # bad #   def some_method #   if cond #   return #   else #   return #   end #   do_something #   end # #   # good #   def some_method #   do_something #   end # # source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#32 class RuboCop::Cop::Lint::UnreachableCode &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [UnreachableCode] a new instance of UnreachableCode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flow_command?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flow_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">instance_eval_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redefinable_flow_method?</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_redefinition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_on_flow_command?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unreachable_code.rb#33 RuboCop::Cop::Lint::UnreachableCode::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for loops that will have at most one iteration. # # A loop that can never reach the second iteration is a possible error in the code. # In rare cases where only one iteration (or at most one iteration) is intended behavior, # the code should be refactored to use ‘if` conditionals. # # NOTE: Block methods that are used with “Enumerable“s are considered to be loops. # # `AllowedPatterns` can be used to match against the block receiver in order to allow # code that would otherwise be registered as an offense (eg. `times` used not in an # `Enumerable` context). # # @example #   # bad #   while node #   do_something(node) #   node = node.parent #   break #   end # #   # good #   while node #   do_something(node) #   node = node.parent #   end # #   # bad #   def verify_list(head) #   item = head #   begin #   if verify(item) #   return true #   else #   return false #   end #   end while(item) #   end # #   # good #   def verify_list(head) #   item = head #   begin #   if verify(item) #   item = item.next #   else #   return false #   end #   end while(item) # #   true #   end # #   # bad #   def find_something(items) #   items.each do |item| #   if something?(item) #   return item #   else #   raise NotFoundError #   end #   end #   end # #   # good #   def find_something(items) #   items.each do |item| #   if something?(item) #   return item #   end #   end #   raise NotFoundError #   end # #   # bad #   2.times { raise ArgumentError } # @example AllowedPatterns: [’(exactly|at_least|at_most)(d+).times’] (default) # #   # good #   exactly(2).times { raise StandardError } # # source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#86 class RuboCop::Cop::Lint::UnreachableLoop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_command?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_statement?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_continue_keyword?</span>(<span class="ruby-identifier">break_statement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceded_by_continue_statement?</span>(<span class="ruby-identifier">break_statement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">statements</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#90 RuboCop::Cop::Lint::UnreachableLoop::CONTINUE_KEYWORDS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/unreachable_loop.rb#89 RuboCop::Cop::Lint::UnreachableLoop::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for cops handling unused arguments. # # source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#7 module RuboCop::Cop::Lint::UnusedArgument</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/unused_argument.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_argument</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for unused block arguments. # # @example #   # bad #   do_something do |used, unused| #   puts used #   end # #   do_something do |bar| #   puts :foo #   end # #   define_method(:foo) do |bar| #   puts :baz #   end # #   # good #   do_something do |used, _unused| #   puts used #   end # #   do_something do #   puts :foo #   end # #   define_method(:foo) do |_bar| #   puts :baz #   end # @example IgnoreEmptyBlocks: true (default) #   # good #   do_something { |unused| } # @example IgnoreEmptyBlocks: false #   # bad #   do_something { |unused| } # @example AllowUnusedKeywordArguments: false (default) #   # bad #   do_something do |unused: 42| #   foo #   end # @example AllowUnusedKeywordArguments: true #   # good #   do_something do |unused: 42| #   foo #   end # # source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#55 class RuboCop::Cop::Lint::UnusedBlockArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Lint</span><span class="ruby-operator">::</span><span class="ruby-constant">UnusedArgument</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_unused_keyword_arguments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_block?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_keyword_argument?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">augment_message</span>(<span class="ruby-identifier">message</span>, <span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_argument</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method_call?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_block?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_empty_blocks?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_lambda</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">all_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_normal_block</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">all_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_underscore_prefix</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used_block_local?</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_type</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_block_argument.rb#59</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for unused method arguments. # # @example IgnoreNotImplementedMethods: false #   # bad #   def do_something(unused) #   raise NotImplementedError #   end # #   def do_something_else(unused) #   fail “TODO” #   end # @example AllowUnusedKeywordArguments: false (default) #   # bad #   def do_something(used, unused: 42) #   used #   end # @example AllowUnusedKeywordArguments: true #   # good #   def do_something(used, unused: 42) #   used #   end # @example IgnoreEmptyMethods: true (default) #   # good #   def do_something(unused) #   end # @example IgnoreEmptyMethods: false #   # bad #   def do_something(unused) #   end # @example IgnoreNotImplementedMethods: true (default) #   # with default value of ‘NotImplementedExceptions: [’NotImplementedError’]‘ # #   # good #   def do_something(unused) #   raise NotImplementedError #   end # #   def do_something_else(unused) #   fail “TODO” #   end # @example IgnoreNotImplementedMethods: true #   # with `NotImplementedExceptions: [’AbstractMethodError’]‘ # #   # good #   def do_something(unused) #   raise AbstractMethodError #   end # @example #   # bad #   def some_method(used, unused, _unused_but_allowed) #   puts used #   end # #   # good #   def some_method(used, _unused, _unused_but_allowed) #   puts used #   end # # source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#70 class RuboCop::Cop::Lint::UnusedMethodArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Lint</span><span class="ruby-operator">::</span><span class="ruby-constant">UnusedArgument</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_implemented?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_exception_class?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_argument</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_method?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#80</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/unused_method_argument.rb#84</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Identifies places where ‘URI.escape` can be replaced by # `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component` # depending on your specific use case. # Also this cop identifies places where `URI.unescape` can be replaced by # `CGI.unescape`, `URI.decode_www_form`, # or `URI.decode_www_form_component` depending on your specific use case. # # @example #   # bad #   URI.escape(’<a href="http://example.com">example.com</a>’) #   URI.encode(‘<a href="http://example.com">example.com</a>’) # #   # good #   CGI.escape(‘<a href="http://example.com">example.com</a>’) #   URI.encode_www_form([[‘example’, ‘param’], [‘lang’, ‘en’]]) #   URI.encode_www_form(page: 10, locale: ‘en’) #   URI.encode_www_form_component(‘<a href="http://example.com">example.com</a>’) # #   # bad #   URI.unescape(enc_uri) #   URI.decode(enc_uri) # #   # good #   CGI.unescape(enc_uri) #   URI.decode_www_form(enc_uri) #   URI.decode_www_form_component(enc_uri) # # source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#32 class RuboCop::Cop::Lint::UriEscapeUnescape &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uri_escape_unescape?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#33 RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_ESCAPE = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#38 RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_UNESCAPE = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#47 RuboCop::Cop::Lint::UriEscapeUnescape::METHOD_NAMES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#44 RuboCop::Cop::Lint::UriEscapeUnescape::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_escape_unescape.rb#48 RuboCop::Cop::Lint::UriEscapeUnescape::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies places where ‘URI.regexp` is obsolete and should not be used. # # For Ruby 3.3 or lower, use `URI::DEFAULT_PARSER.make_regexp`. # For Ruby 3.4 or higher, use `URI::RFC2396_PARSER.make_regexp`. # # NOTE: If you need to support both Ruby 3.3 and lower as well as Ruby 3.4 and higher, # consider manually changing the code as follows: # # [source,ruby] # —- # defined?(URI::RFC2396_PARSER) ? URI::RFC2396_PARSER : URI::DEFAULT_PARSER # —- # # @example #   # bad #   URI.regexp(’<a href="http://example.com">example.com</a>’) # #   # good - Ruby 3.3 or lower #   URI::DEFAULT_PARSER.make_regexp(‘<a href="http://example.com">example.com</a>’) # #   # good - Ruby 3.4 or higher #   URI::RFC2396_PARSER.make_regexp(‘<a href="http://example.com">example.com</a>’) # # source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#29 class RuboCop::Cop::Lint::UriRegexp &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uri_constant?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#32 RuboCop::Cop::Lint::UriRegexp::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/uri_regexp.rb#33 RuboCop::Cop::Lint::UriRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant access modifiers, including those with no # code, those which are repeated, those which are on top-level, and # leading ‘public` modifiers in a class or module body. # Conditionally-defined methods are considered as always being defined, # and thus access modifiers guarding such methods are not redundant. # # This cop has `ContextCreatingMethods` option. The default setting value # is an empty array that means no method is specified. # This setting is an array of methods which, when called, are known to # create its own context in the module’s current access context. # # It also has ‘MethodCreatingMethods` option. The default setting value # is an empty array that means no method is specified. # This setting is an array of methods which, when called, are known to # create other methods in the module’s current access context. # # @example #   # bad #   class Foo #   public # this is redundant (default access is public) # #   def method #   end #   end # #   # bad #   class Foo #   # The following is redundant (methods defined on the class’ #   # singleton class are not affected by the private modifier) #   private # #   def self.method3 #   end #   end # #   # bad #   class Foo #   protected # #   define_method(:method2) do #   end # #   protected # this is redundant (repeated from previous modifier) # #   [1,2,3].each do |i| #   define_method(“foo#{i}”) do #   end #   end #   end # #   # bad #   class Foo #   private # this is redundant (no following methods are defined) #   end # #   # bad #   private # this is useless (access modifiers have no effect on top-level) # #   def method #   end # #   # good #   class Foo #   private # this is not redundant (a method is defined) # #   def method2 #   end #   end # #   # good #   class Foo #   # The following is not redundant (conditionally defined methods are #   # considered as always defining a method) #   private # #   if condition? #   def method #   end #   end #   end # #   # good #   class Foo #   protected # this is not redundant (a method is defined) # #   define_method(:method2) do #   end #   end # @example ContextCreatingMethods: concerning #   # Lint/UselessAccessModifier: #   #   ContextCreatingMethods: #   #     - concerning # #   # good #   require ‘active_support/concern’ #   class Foo #   concerning :Bar do #   def some_public_method #   end # #   private # #   def some_private_method #   end #   end # #   # this is not redundant because ‘concerning` created its own context #   private # #   def some_other_private_method #   end #   end # @example MethodCreatingMethods: delegate #   # Lint/UselessAccessModifier: #   #   MethodCreatingMethods: #   #     - delegate # #   # good #   require ’active_support/core_ext/module/delegation’ #   class Foo #   # this is not redundant because ‘delegate` creates methods #   private # #   delegate :method_a, to: :method_b #   end # # source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#133 class RuboCop::Cop::Lint::UselessAccessModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_or_instance_eval?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dynamic_method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">static_method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_context_creating_methods?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_method_definition?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_child_nodes</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">unused</span>, <span class="ruby-identifier">cur_vis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_new_visibility</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">unused</span>, <span class="ruby-identifier">new_vis</span>, <span class="ruby-identifier">cur_vis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_scope</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_send_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">cur_vis</span>, <span class="ruby-identifier">unused</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eval_call?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included_block?</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_definition?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_of_new_scope?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_access_modifier.rb#137 RuboCop::Cop::Lint::UselessAccessModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for every useless assignment to local variable in every # scope. # The basic idea for this cop was from the warning of ‘ruby -cw`: # # [source,console] # —- # assigned but unused variable - foo # —- # # Currently this cop has advanced logic that detects unreferenced # reassignments and properly handles varied cases such as branch, loop, # rescue, ensure, etc. # # This cop’s autocorrection avoids cases like ‘a ||= 1` because removing assignment from # operator assignment can cause `NameError` if this assignment has been used to declare # a local variable. For example, replacing `a ||= 1` with `a || 1` may cause # “undefined local variable or method `a’ for main:Object (NameError)”. # # NOTE: Given the assignment ‘foo = 1, bar = 2`, removing unused variables # can lead to a syntax error, so this case is not autocorrected. # # @example # #   # bad #   def some_method #   some_var = 1 #   do_something #   end # #   # good #   def some_method #   some_var = 1 #   do_something(some_var) #   end # # source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#40 class RuboCop::Cop::Lint::UselessAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_unused_assignments</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_variable_like_names</span>(<span class="ruby-identifier">scope</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_for_useless_assignment</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_specification</span>(<span class="ruby-identifier">assignment</span>, <span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_assignment_message</span>(<span class="ruby-identifier">variable_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_assignment_message</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_exception_assignment_part</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_local_variable_assignment_part</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_trailing_character_from_operator</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rename_variable_with_underscore</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_named_capture_group_with_non_capturing_group</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">variable_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># TODO: More precise handling (rescue, ensure, nested begin, etc.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value_node_of_scope</span>(<span class="ruby-identifier">scope</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sequential_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">similar_name_message</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_like_method_invocation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_assignment.rb#45 RuboCop::Cop::Lint::UselessAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for useless constant scoping. Private constants must be defined using # ‘private_constant`. Even if `private` access modifier is used, it is public scope despite # its appearance. # # It does not support autocorrection due to behavior change and multiple ways to fix it. # Or a public constant may be intended. # # @example # #   # bad #   class Foo #   private #   PRIVATE_CONST = 42 #   end # #   # good #   class Foo #   PRIVATE_CONST = 42 #   private_constant :PRIVATE_CONST #   end # #   # good #   class Foo #   PUBLIC_CONST = 42 # If private scope is not intended. #   end # # source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#32 class RuboCop::Cop::Lint::UselessConstantScoping &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_constants</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_private_modifier?</span>(<span class="ruby-identifier">left_siblings</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_constantize?</span>(<span class="ruby-identifier">right_siblings</span>, <span class="ruby-identifier">const_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_constant_scoping.rb#33 RuboCop::Cop::Lint::UselessConstantScoping::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for usage of method ‘fetch` or `Array.new` with default value argument # and block. In such cases, block will always be used as default value. # # This cop emulates Ruby warning “block supersedes default value argument” which # applies to `Array.new`, `Array#fetch`, `Hash#fetch`, `ENV.fetch` and # `Thread#fetch`. # # A `fetch` call without a receiver is considered a custom method and does not register # an offense. # # @example #   # bad #   x.fetch(key, default_value) { block_value } #   Array.new(size, default_value) { block_value } # #   # good #   x.fetch(key) { block_value } #   Array.new(size) { block_value } # #   # also good - in case default value argument is desired instead #   x.fetch(key, default_value) #   Array.new(size, default_value) # #   # good - keyword arguments aren’t registered as offenses #   x.fetch(key, keyword: :arg) { block_value } # @example AllowedReceivers: [‘Rails.cache’] #   # good #   Rails.cache.fetch(name, options) { block } # # source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#50 class RuboCop::Cop::Lint::UselessDefaultValueArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedReceivers</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_value_argument_and_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_without_braces?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#54 RuboCop::Cop::Lint::UselessDefaultValueArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_default_value_argument.rb#56 RuboCop::Cop::Lint::UselessDefaultValueArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for calls to ‘defined?` with strings or symbols as the argument. # Such calls will always return `’expression’‘, you probably meant to # check for the existence of a constant, method, or variable instead. # # `defined?` is part of the Ruby syntax and doesn’t behave like normal methods. # You can safely pass in what you are checking for directly, without encountering # a ‘NameError`. # # When interpolation is used, oftentimes it is not possible to write the # code with `defined?`. In these cases, switch to one of the more specific methods: # # * `class_variable_defined?` # * `const_defined?` # * `method_defined?` # * `instance_variable_defined?` # * `binding.local_variable_defined?` # # @example # #   # bad #   defined?(’FooBar’) #   defined?(:FooBar) #   defined?(:foo_bar) #   defined?(‘foo_bar’) # #   # good #   defined?(FooBar) #   defined?(foo_bar) # #   # bad - interpolation #   bar = ‘Bar’ #   defined?(“Foo::#{bar}::Baz”) # #   # good #   bar = ‘Bar’ #   defined?(Foo) &amp;&amp; Foo.const_defined?(bar) &amp;&amp; Foo.const_get(bar).const_defined?(:Baz) # # source://rubocop//lib/rubocop/cop/lint/useless_defined.rb#42 class RuboCop::Cop::Lint::UselessDefined &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_defined.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_defined.rb#43 RuboCop::Cop::Lint::UselessDefined::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_defined.rb#44 RuboCop::Cop::Lint::UselessDefined::TYPES = T.let(T.unsafe(nil), Hash)</p>

<p># Checks for useless ‘else` in `begin..end` without `rescue`. # # NOTE: This syntax is no longer valid on Ruby 2.6 or higher. # # @example # #   # bad #   begin #   do_something #   else #   do_something_else # This will never be run. #   end # #   # good #   begin #   do_something #   rescue #   handle_errors #   else #   do_something_else #   end # # source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#27 class RuboCop::Cop::Lint::UselessElseWithoutRescue &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_else_without_rescue.rb#30 RuboCop::Cop::Lint::UselessElseWithoutRescue::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for useless method definitions, specifically: empty constructors # and methods just delegating to ‘super`. # # @example #   # bad #   def initialize #   super #   end # #   def method #   super #   end # #   # good - with default arguments #   def initialize(x = Object.new) #   super #   end # #   # good #   def initialize #   super #   initialize_internals #   end # #   def method(*args) #   super(:extra_arg, *args) #   end # # source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#38 class RuboCop::Cop::Lint::UselessMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delegating?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_definition_with_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_rest_or_optional_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_method_definition.rb#41 RuboCop::Cop::Lint::UselessMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Certain numeric operations have no impact, being: # Adding or subtracting 0, multiplying or dividing by 1 or raising to the power of 1. # These are probably leftover from debugging, or are mistakes. # # @example # #   # bad #   x + 0 #   x - 0 #   x * 1 #   x / 1 #   x ** 1 # #   # good #   x # #   # bad #   x += 0 #   x -= 0 #   x *= 1 #   x /= 1 #   x **= 1 # #   # good #   x = x # # source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#32 class RuboCop::Cop::Lint::UselessNumericOperation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">useless_abbreviated_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">useless_operation?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">useless?</span>(<span class="ruby-identifier">operation</span>, <span class="ruby-identifier">number</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#34 RuboCop::Cop::Lint::UselessNumericOperation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_numeric_operation.rb#35 RuboCop::Cop::Lint::UselessNumericOperation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for useless OR (‘||` and `or`) expressions. # # Some methods always return a truthy value, even when called # on `nil` (e.g. `nil.to_i` evaluates to `0`). Therefore, OR expressions # appended after these methods will never evaluate. # # @example # #   # bad #   x.to_a || fallback #   x.to_c || fallback #   x.to_d || fallback #   x.to_i || fallback #   x.to_f || fallback #   x.to_h || fallback #   x.to_r || fallback #   x.to_s || fallback #   x.to_sym || fallback #   x.intern || fallback #   x.inspect || fallback #   x.hash || fallback #   x.object_id || fallback #   x.__id__ || fallback # #   x.to_s or fallback # #   # good - if fallback is same as return value of method called on nil #   x.to_a # nil.to_a returns [] #   x.to_c # nil.to_c returns (0+0i) #   x.to_d # nil.to_d returns 0.0 #   x.to_i # nil.to_i returns 0 #   x.to_f # nil.to_f returns 0.0 #   x.to_h # nil.to_h returns {} #   x.to_r # nil.to_r returns (0/1) #   x.to_s # nil.to_s returns ” #   x.to_sym # nil.to_sym raises an error #   x.intern # nil.intern raises an error #   x.inspect # nil.inspect returns “nil” #   x.hash # nil.hash returns an Integer #   x.object_id # nil.object_id returns an Integer #   x.__id__ # nil.object_id returns an Integer # #   # good - if the intention is not to call the method on nil #   x&amp;.to_a || fallback #   x&amp;.to_c || fallback #   x&amp;.to_d || fallback #   x&amp;.to_i || fallback #   x&amp;.to_f || fallback #   x&amp;.to_h || fallback #   x&amp;.to_r || fallback #   x&amp;.to_s || fallback #   x&amp;.to_sym || fallback #   x&amp;.intern || fallback #   x&amp;.inspect || fallback #   x&amp;.hash || fallback #   x&amp;.object_id || fallback #   x&amp;.__id__ || fallback # #   x&amp;.to_s or fallback # # source://rubocop//lib/rubocop/cop/lint/useless_or.rb#66 class RuboCop::Cop::Lint::UselessOr &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_or.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_or.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_return_value_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_or.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_offense</span>(<span class="ruby-identifier">or_node</span>, <span class="ruby-identifier">truthy_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_or.rb#67 RuboCop::Cop::Lint::UselessOr::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_or.rb#69 RuboCop::Cop::Lint::UselessOr::TRUTHY_RETURN_VALUE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># Checks for useless “rescue“s, which only reraise rescued exceptions. # # @example #   # bad #   def foo #   do_something #   rescue #   raise #   end # #   # bad #   def foo #   do_something #   rescue =&gt; e #   raise # or ‘raise e’, or ‘raise $!’, or ‘raise $ERROR_INFO’ #   end # #   # good #   def foo #   do_something #   rescue #   do_cleanup #   raise #   end # #   # bad (latest rescue) #   def foo #   do_something #   rescue ArgumentError #   # noop #   rescue #   raise #   end # #   # good (not the latest rescue) #   def foo #   do_something #   rescue ArgumentError #   raise #   rescue #   # noop #   end # # source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#49 class RuboCop::Cop::Lint::UselessRescue &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_objects</span>(<span class="ruby-identifier">resbody_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_reraising?</span>(<span class="ruby-identifier">resbody_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_exception_variable_in_ensure?</span>(<span class="ruby-identifier">resbody_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_rescue.rb#50 RuboCop::Cop::Lint::UselessRescue::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for ‘ruby2_keywords` calls for methods that do not need it. # # `ruby2_keywords` should only be called on methods that accept an argument splat # (`*args`) but do not explicit keyword arguments (`k:` or `k: true`) or # a keyword splat (`**kwargs`). # # @example #   # good (splat argument without keyword arguments) #   ruby2_keywords def foo(*args); end # #   # bad (no arguments) #   ruby2_keywords def foo; end # #   # good #   def foo; end # #   # bad (positional argument) #   ruby2_keywords def foo(arg); end # #   # good #   def foo(arg); end # #   # bad (double splatted argument) #   ruby2_keywords def foo(**args); end # #   # good #   def foo(**args); end # #   # bad (keyword arguments) #   ruby2_keywords def foo(i:, j:); end # #   # good #   def foo(i:, j:); end # #   # bad (splat argument with keyword arguments) #   ruby2_keywords def foo(*args, i:, j:); end # #   # good #   def foo(*args, i:, j:); end # #   # bad (splat argument with double splat) #   ruby2_keywords def foo(*args, **kwargs); end # #   # good #   def foo(*args, **kwargs); end # #   # bad (ruby2_keywords given a symbol) #   def foo; end #   ruby2_keywords :foo # #   # good #   def foo; end # #   # bad (ruby2_keywords with dynamic method) #   define_method(:foo) { |arg| } #   ruby2_keywords :foo # #   # good #   define_method(:foo) { |arg| } # # source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#66 class RuboCop::Cop::Lint::UselessRuby2Keywords &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># Looks for statically or dynamically defined methods with a given name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_definition</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># `ruby2_keywords` is only allowed if there&#39;s a `restarg` and no keyword arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_arguments?</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_method_definition</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_def</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_sym</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sym_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#67 RuboCop::Cop::Lint::UselessRuby2Keywords::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_ruby2_keywords.rb#68 RuboCop::Cop::Lint::UselessRuby2Keywords::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for setter call to local variable as the final # expression of a function definition. # # @example # #   # bad #   def something #   x = Something.new #   x.attr = 5 #   end # #   # good #   def something #   x = Something.new #   x.attr = 5 #   x #   end # # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#31 class RuboCop::Cop::Lint::UselessSetterCall &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setter_call_to_local_variable?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_expression</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#35 RuboCop::Cop::Lint::UselessSetterCall::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#34 RuboCop::Cop::Lint::UselessSetterCall::MSG = T.let(T.unsafe(nil), String)</p>

<p># This class tracks variable assignments in a method body # and if a variable contains object passed as argument at the end of # the method. # # source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#72 class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker</p>

<pre class="ruby"><span class="ruby-comment"># @return [MethodVariableTracker] a new instance of MethodVariableTracker</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">body_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constructor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contain_local_object?</span>(<span class="ruby-identifier">variable_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_assignment</span>(<span class="ruby-identifier">asgn_node</span>, <span class="ruby-identifier">rhs_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_assignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_binary_operator_assignment</span>(<span class="ruby-identifier">op_asgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_logical_operator_assignment</span>(<span class="ruby-identifier">asgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_multiple_assignment</span>(<span class="ruby-identifier">masgn_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_setter_call.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for uses of ‘Integer#times` that will never yield # (when the integer “&lt;= 0“) or that will only ever yield once # (`1.times`). # # @example #   # bad #   -5.times { do_something } #   0.times { do_something } #   1.times { do_something  } #   1.times { |i| do_something(i) } # #   # good #   do_something #   do_something(1) # # source://rubocop//lib/rubocop/cop/lint/useless_times.rb#24 class RuboCop::Cop::Lint::UselessTimes &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_arg</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_reassigns_arg?</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">times_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">count</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">proc_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_block_pass</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">proc_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_indentation</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">never_process?</span>(<span class="ruby-identifier">count</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">own_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#28 RuboCop::Cop::Lint::UselessTimes::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/useless_times.rb#29 RuboCop::Cop::Lint::UselessTimes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for operators, variables, literals, lambda, proc and nonmutating # methods used in void context. # # ‘each` blocks are allowed to prevent false positives. # For example, the expression inside the `each` block below. # It’s not void, especially when the receiver is an ‘Enumerator`: # # [source,ruby] # —- # enumerator = [1, 2, 3].filter # enumerator.each { |item| item &gt;= 2 } #=&gt; [2, 3] # —- # # @example CheckForMethodsWithNoSideEffects: false (default) #   # bad #   def some_method #   some_num * 10 #   do_something #   end # #   def some_method(some_var) #   some_var #   do_something #   end # @example CheckForMethodsWithNoSideEffects: true #   # bad #   def some_method(some_array) #   some_array.sort #   do_something(some_array) #   end # #   # good #   def some_method #   do_something #   some_num * 10 #   end # #   def some_method(some_var) #   do_something #   some_var #   end # #   def some_method(some_array) #   some_array.sort! #   do_something(some_array) #   end # # source://rubocop//lib/rubocop/cop/lint/void.rb#53 class RuboCop::Cop::Lint::Void &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_keys_entirely_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_values_entirely_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_nonmutating_send</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">suggestion</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_void_expression</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_void_op</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_expression</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_nonmutating</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_self</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_var</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_void_expression</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_void_op</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">entirely_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/lint/void.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_void_context?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#66 RuboCop::Cop::Lint::Void::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#60 RuboCop::Cop::Lint::Void::CONST_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#63 RuboCop::Cop::Lint::Void::EXPRESSION_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#61 RuboCop::Cop::Lint::Void::LIT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#76 RuboCop::Cop::Lint::Void::METHODS_REPLACEABLE_BY_EACH = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#78 RuboCop::Cop::Lint::Void::NONMUTATING_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#69 RuboCop::Cop::Lint::Void::NONMUTATING_METHODS_WITH_BANG_VERSION = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#64 RuboCop::Cop::Lint::Void::NONMUTATING_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#68 RuboCop::Cop::Lint::Void::OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#58 RuboCop::Cop::Lint::Void::OP_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#62 RuboCop::Cop::Lint::Void::SELF_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#67 RuboCop::Cop::Lint::Void::UNARY_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/lint/void.rb#59 RuboCop::Cop::Lint::Void::VAR_MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for obtaining source ranges from regexp matches # # source://rubocop//lib/rubocop/cop/mixin/match_range.rb#6 module RuboCop::Cop::MatchRange</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Return a new `Range` covering the first matching group number for each</span>
<span class="ruby-comment"># match of `regex` inside `range`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/match_range.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_match_range</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">regex</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For a `match` inside `range`, return a new `Range` covering the match</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/match_range.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_range</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Message Annotator class annotates a basic offense message # based on params passed into initializer. # #  #=&gt; ‘Cop/CopName: message (<a href="http://example.org/styleguide">example.org/styleguide</a>)’ # # @example #   RuboCop::Cop::MessageAnnotator.new( #   config, cop_name, cop_config, @options #   ).annotate(‘message’) # @see #initialize # # source://rubocop//lib/rubocop/cop/message_annotator.rb#15 class RuboCop::Cop::MessageAnnotator</p>

<pre class="ruby"><span class="ruby-comment"># @option cop_config</span>
<span class="ruby-comment"># @option cop_config</span>
<span class="ruby-comment"># @option cop_config</span>
<span class="ruby-comment"># @option options</span>
<span class="ruby-comment"># @option options</span>
<span class="ruby-comment"># @option options</span>
<span class="ruby-comment"># @option options</span>
<span class="ruby-comment"># @param config [RuboCop::Config] Check configs for all cops</span>
<span class="ruby-comment">#   @note Message Annotator specifically checks the</span>
<span class="ruby-comment">#   following config options for_all_cops</span>
<span class="ruby-comment">#   :StyleGuideBaseURL [String] URL for styleguide</span>
<span class="ruby-comment">#   :DisplayStyleGuide [Boolean] Include styleguide and reference URLs</span>
<span class="ruby-comment">#   :ExtraDetails [Boolean] Include cop details</span>
<span class="ruby-comment">#   :DisplayCopNames [Boolean] Include cop name</span>
<span class="ruby-comment"># @param cop_name [String] for specific cop name</span>
<span class="ruby-comment"># @param cop_config [Hash] configs for specific cop, from config#for_cop</span>
<span class="ruby-comment"># @param options [Hash, nil] optional</span>
<span class="ruby-comment"># @return [MessageAnnotator] a new instance of MessageAnnotator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">cop_name</span>, <span class="ruby-identifier">cop_config</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the annotated message,</span>
<span class="ruby-comment"># based on params passed into initializer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] annotated message</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotate</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop_config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop_name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">urls</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">details</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_cop_names?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">display_style_guide?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_details?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference_urls</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the base style guide URL from AllCops or the specific department</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] style guide URL</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_guide_base_url</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_guide_url</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute style_guide_urls.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/message_annotator.rb#21</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_guide_urls</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module handles measurement and reporting of complexity in methods. # # @api private # # source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#8 module RuboCop::Cop::MethodComplexity</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">RepeatedCsendDiscount</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">ExcludeLimit</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_complexity</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complexity</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_complexity.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common code for cops that deal with preferred methods. # # source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#6 module RuboCop::Cop::MethodPreference</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_cop_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/method_preference.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_methods</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#5 module RuboCop::Cop::Metrics; end</p>

<p># Checks that the ABC size of methods is not higher than the # configured maximum. The ABC size is based on assignments, branches # (method calls), and conditions. See <a href="http://c2.com/cgi/wiki?AbcMetric">c2.com/cgi/wiki?AbcMetric</a> # and <a href="https://en.wikipedia.org/wiki/ABC_Software_Metric">en.wikipedia.org/wiki/ABC_Software_Metric</a>. # # Interpreting ABC size: # # * “&lt;= 17“ satisfactory # * ‘18..30` unsatisfactory # * `&gt;` 30 dangerous # # You can have repeated “attributes” calls count as a single “branch”. # For this purpose, attributes are any method with no argument; no attempt # is meant to distinguish actual `attr_reader` from other methods. # # This cop also takes into account `AllowedMethods` (defaults to `[]`) # And `AllowedPatterns` (defaults to `[]`) # # @example CountRepeatedAttributes: false (default is true) # #   # `model` and `current_user`, referenced 3 times each, #   # are each counted as only 1 branch each if #   # `CountRepeatedAttributes` is set to ’false’ # #   def search #   @posts = model.active.visible_by(current_user) #   .<a href=":q">search(params</a>) #   @posts = model.some_process(@posts, current_user) #   @posts = model.another_process(@posts, current_user) # #   render ‘pages/search/page’ #   end # # source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#39 class RuboCop::Cop::Metrics::AbcSize &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">RepeatedCsendDiscount</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodComplexity</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complexity</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/abc_size.rb#42 RuboCop::Cop::Metrics::AbcSize::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if the length of a block exceeds some maximum value. # Comment lines can optionally be ignored. # The maximum allowed length is configurable. # The cop can be configured to ignore blocks passed to certain methods. # # You can set constructs you want to fold with ‘CountAsOne`. # # Available are: ’array’, ‘hash’, ‘heredoc’, and ‘method_call’. # Each construct will be counted as one line regardless of its actual size. # # NOTE: This cop does not apply for ‘Struct` definitions. # # NOTE: The `ExcludedMethods` configuration is deprecated and only kept # for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns` # instead. By default, there are no methods to allowed. # # @example CountAsOne: [’array’, ‘hash’, ‘heredoc’, ‘method_call’] # #   something do #   array = [         # +1 #   1, #   2 #   ] # #   hash = {          # +1 #   key: ‘value’ #   } # #   msg = &lt;&lt;~HEREDOC  # +1 #   Heredoc #   content. #   HEREDOC # #   foo(              # +1 #   1, #   2 #   ) #   end                 # 4 points # # source://rubocop//lib/rubocop/cop/metrics/block_length.rb#45 class RuboCop::Cop::Metrics::BlockLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CodeLength</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_label</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_receiver_excluded?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/block_length.rb#50 RuboCop::Cop::Metrics::BlockLength::LABEL = T.let(T.unsafe(nil), String)</p>

<p># Checks for excessive nesting of conditional and looping constructs. # # You can configure if blocks are considered using the ‘CountBlocks` and `CountModifierForms` # options. When both are set to `false` (the default) blocks and modifier forms are not # counted towards the nesting level. Set them to `true` to include these in the nesting level # calculation as well. # # The maximum level of nesting allowed is configurable. # # source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#14 class RuboCop::Cop::Metrics::BlockNesting &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_nesting_level</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">max</span>, <span class="ruby-identifier">current_level</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consider_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_blocks?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_if_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_modifier_forms?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">max</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/block_nesting.rb#15 RuboCop::Cop::Metrics::BlockNesting::NESTING_BLOCKS = T.let(T.unsafe(nil), Array)</p>

<p># Checks if the length of a class exceeds some maximum value. # Comment lines can optionally be ignored. # The maximum allowed length is configurable. # # You can set constructs you want to fold with ‘CountAsOne`. # # Available are: ’array’, ‘hash’, ‘heredoc’, and ‘method_call’. # Each construct will be counted as one line regardless of its actual size. # # NOTE: This cop also applies for ‘Struct` definitions. # # @example CountAsOne: [’array’, ‘hash’, ‘heredoc’, ‘method_call’] # #   class Foo #   ARRAY = [         # +1 #   1, #   2 #   ] # #   HASH = {          # +1 #   key: ‘value’ #   } # #   MSG = &lt;&lt;~HEREDOC  # +1 #   Heredoc #   content. #   HEREDOC # #   foo(              # +1 #   1, #   2 #   ) #   end                 # 4 points # # source://rubocop//lib/rubocop/cop/metrics/class_length.rb#40 class RuboCop::Cop::Metrics::ClassLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CodeLength</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/class_length.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/class_length.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/class_length.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/class_length.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_expression_within_parent</span>(<span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/class_length.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">length</span>, <span class="ruby-identifier">max_length</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for literals with extremely many entries. This is indicative of # configuration or data that may be better extracted somewhere else, like # a database, fetched from an API, or read from a non-code file (CSV, # JSON, YAML, etc.). # # @example #   # bad #   # Huge Array literal #   [1, 2, ‘…’, 999_999_999] # #   # bad #   # Huge Hash literal #   { 1 =&gt; 1, 2 =&gt; 2, ‘…’ =&gt; ‘…’, 999_999_999 =&gt; 999_999_999} # #   # bad #   # Huge Set “literal” #   Set[1, 2, ‘…’, 999_999_999] # #   # good #   # Reasonably sized Array literal #   [1, 2, ‘…’, 10] # #   # good #   # Reading huge Array from external data source #   # File.readlines(‘numbers.txt’, chomp: true).map!(&amp;:to_i) # #   # good #   # Reasonably sized Hash literal #   { 1 =&gt; 1, 2 =&gt; 2, ‘…’ =&gt; ‘…’, 10 =&gt; 10} # #   # good #   # Reading huge Hash from external data source #   CSV.foreach(‘numbers.csv’, headers: true).each_with_object({}) do |row, hash| #   <a href="&quot;key&quot;">hash[row</a>.to_i] = <a href="&quot;value&quot;">row</a>.to_i #   end # #   # good #   # Reasonably sized Set “literal” #   Set[1, 2, ‘…’, 10] # #   # good #   # Reading huge Set from external data source #   <a href=":numbers">SomeFramework.config_for(:something)</a>.to_set # # source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#50 class RuboCop::Cop::Metrics::CollectionLiteralLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_index</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_const?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_threshold</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#51 RuboCop::Cop::Metrics::CollectionLiteralLength::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/collection_literal_length.rb#53 RuboCop::Cop::Metrics::CollectionLiteralLength::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks that the cyclomatic complexity of methods is not higher # than the configured maximum. The cyclomatic complexity is the number of # linearly independent paths through a method. The algorithm counts # decision points and adds one. # # An if statement (or unless or ?:) increases the complexity by one. An # else branch does not, since it doesn’t add a decision point. The &amp;&amp; # operator (or keyword and) can be converted to a nested if statement, # and ||/or is shorthand for a sequence of ifs, so they also add one. # Loops can be said to have an exit condition, so they add one. # Blocks that are calls to builtin iteration methods # (e.g. ‘ary.map{…}`) also add one, others are ignored. # # @example # #   def each_child_node(*types)               # count begins: 1 #   unless block_given?                     # unless: +1 #   return to_enum(__method__, *types) #   end # #   children.each do |child|                # each{}: +1 #   next unless child.is_a?(Node)         # unless: +1 # #   yield child if types.empty? ||        # if: +1, ||: +1 #   types.include?(child.type) #   end # #   self #   end                                       # total: 6 # # source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#35 class RuboCop::Cop::Metrics::CyclomaticComplexity &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">RepeatedCsendDiscount</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodComplexity</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">IteratingBlock</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complexity_score_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_block?</span>(<span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#40 RuboCop::Cop::Metrics::CyclomaticComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/cyclomatic_complexity.rb#39 RuboCop::Cop::Metrics::CyclomaticComplexity::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if the length of a method exceeds some maximum value. # Comment lines can optionally be allowed. # The maximum allowed length is configurable. # # You can set constructs you want to fold with ‘CountAsOne`. # # Available are: ’array’, ‘hash’, ‘heredoc’, and ‘method_call’. # Each construct will be counted as one line regardless of its actual size. # # NOTE: The ‘ExcludedMethods` and `IgnoredMethods` configuration is # deprecated and only kept for backwards compatibility. # Please use `AllowedMethods` and `AllowedPatterns` instead. # By default, there are no methods to allowed. # # @example CountAsOne: [’array’, ‘hash’, ‘heredoc’, ‘method_call’] # #   def m #   array = [       # +1 #   1, #   2 #   ] # #   hash = {        # +1 #   key: ‘value’ #   } # #   &lt;&lt;~HEREDOC      # +1 #   Heredoc #   content. #   HEREDOC # #   foo(            # +1 #   1, #   2 #   ) #   end               # 4 points # # source://rubocop//lib/rubocop/cop/metrics/method_length.rb#43 class RuboCop::Cop::Metrics::MethodLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CodeLength</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_label</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/method_length.rb#48 RuboCop::Cop::Metrics::MethodLength::LABEL = T.let(T.unsafe(nil), String)</p>

<p># Checks if the length of a module exceeds some maximum value. # Comment lines can optionally be ignored. # The maximum allowed length is configurable. # # You can set constructs you want to fold with ‘CountAsOne`. # # Available are: ’array’, ‘hash’, ‘heredoc’, and ‘method_call’. # Each construct will be counted as one line regardless of its actual size. # # @example CountAsOne: [‘array’, ‘hash’, ‘heredoc’, ‘method_call’] # #   module M #   ARRAY = [         # +1 #   1, #   2 #   ] # #   HASH = {          # +1 #   key: ‘value’ #   } # #   MSG = &lt;&lt;~HEREDOC  # +1 #   Heredoc #   content. #   HEREDOC # #   foo(              # +1 #   1, #   2 #   ) #   end                 # 4 points # # source://rubocop//lib/rubocop/cop/metrics/module_length.rb#38 class RuboCop::Cop::Metrics::ModuleLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CodeLength</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/module_length.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/module_length.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/module_length.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/module_length.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">length</span>, <span class="ruby-identifier">max_length</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for methods with too many parameters. # # The maximum number of parameters is configurable. # Keyword arguments can optionally be excluded from the total count, # as they add less complexity than positional or optional parameters. # # Any number of arguments for ‘initialize` method inside a block of # `Struct.new` and `Data.define` like this is always allowed: # # [source,ruby] # —- # Struct.new(:one, :two, :three, :four, :five, keyword_init: true) do #   def initialize(one:, two:, three:, four:, five:) #   end # end # —- # # This is because checking the number of arguments of the `initialize` method # does not make sense. # # NOTE: Explicit block argument `&amp;block` is not counted to prevent # erroneous change that is avoided by making block argument implicit. # # This cop also checks for the maximum number of optional parameters. # This can be configured using the `MaxOptionalParameters` config option. # # @example Max: 3 #   # good #   def foo(a, b, c = 1) #   end # @example Max: 2 #   # bad #   def foo(a, b, c = 1) #   end # @example CountKeywordArgs: true (default) #   # counts keyword args towards the maximum # #   # bad (assuming Max is 3) #   def foo(a, b, c, d: 1) #   end # #   # good (assuming Max is 3) #   def foo(a, b, c: 1) #   end # @example CountKeywordArgs: false #   # don’t count keyword args towards the maximum # #   # good (assuming Max is 3) #   def foo(a, b, c, d: 1) #   end # @example MaxOptionalParameters: 3 (default) #   # good #   def foo(a = 1, b = 2, c = 3) #   end # @example MaxOptionalParameters: 2 #   # bad #   def foo(a = 1, b = 2, c = 3) #   end # # source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#70 class RuboCop::Cop::Metrics::ParameterLists &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_to_lambda_or_proc?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_optional_parameters=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">struct_new_or_data_define_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_count</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_keyword_args?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_optional_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_params</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#74 RuboCop::Cop::Metrics::ParameterLists::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#77 RuboCop::Cop::Metrics::ParameterLists::NAMED_KEYWORD_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/parameter_lists.rb#75 RuboCop::Cop::Metrics::ParameterLists::OPTIONAL_PARAMETERS_MSG = T.let(T.unsafe(nil), String)</p>

<p># Tries to produce a complexity score that’s a measure of the # complexity the reader experiences when looking at a method. For that # reason it considers ‘when` nodes as something that doesn’t add as much # complexity as an ‘if` or a `&amp;&amp;`. Except if it’s one of those special # ‘case`/`when` constructs where there’s no expression after ‘case`. Then # the cop treats it as an `if`/`elsif`/`elsif`… and lets all the `when` # nodes count. In contrast to the CyclomaticComplexity cop, this cop # considers `else` nodes as adding complexity. # # @example # #   def my_method                   # 1 #   if cond                       # 1 #   case var                    # 2 (0.8 + 4 * 0.2, rounded) #   when 1 then func_one #   when 2 then func_two #   when 3 then func_three #   when 4..10 then func_other #   end #   else                          # 1 #   do_something until a &amp;&amp; b   # 2 #   end                           # === #   end                             # 7 complexity points # # source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#29 class RuboCop::Cop::Metrics::PerceivedComplexity &lt; ::RuboCop::Cop::Metrics::CyclomaticComplexity</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complexity_score_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#32 RuboCop::Cop::Metrics::PerceivedComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/perceived_complexity.rb#30 RuboCop::Cop::Metrics::PerceivedComplexity::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#6 module RuboCop::Cop::Metrics::Utils; end</p>

<p># &gt; ABC is .. a software size metric .. computed by counting the number # &gt; of assignments, branches and conditions for a section of code. # &gt; <a href="http://c2.com/cgi/wiki?AbcMetric">c2.com/cgi/wiki?AbcMetric</a> # # We separate the <strong>calculator</strong> from the <strong>cop</strong> so that the calculation, # the formula itself, is easier to test. # # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#13 class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">RepeatedAttributeDiscount</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">IteratingBlock</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Metrics</span><span class="ruby-operator">::</span><span class="ruby-constant">Utils</span><span class="ruby-operator">::</span><span class="ruby-constant">RepeatedCsendDiscount</span>

<span class="ruby-comment"># @return [AbcSizeCalculator] a new instance of AbcSizeCalculator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">discount_repeated_attributes:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_branch_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_condition_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">capturing_variable?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compound_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_depth_last</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">discount_repeated_attributes:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># &gt; Branch – an explicit forward program branch out of scope – a # &gt; function call, class method call .. # &gt; <a href="http://c2.com/cgi/wiki?AbcMetric">c2.com/cgi/wiki?AbcMetric</a> # # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#21 RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::BRANCH_NODES = T.let(T.unsafe(nil), Array)</p>

<p># &gt; Condition – a logical/Boolean test, == != &lt;= &gt;= &lt; &gt; else case # &gt; default try catch ? and unary conditionals. # &gt; <a href="http://c2.com/cgi/wiki?AbcMetric">c2.com/cgi/wiki?AbcMetric</a> # # source://rubocop//lib/rubocop/cop/metrics/utils/abc_size_calculator.rb#26 RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::CONDITION_NODES = T.let(T.unsafe(nil), Array)</p>

<p># Helps to calculate code length for the provided node. # # source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#8 class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [CodeLengthCalculator] a new instance of CodeLengthCalculator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">processed_source</span>, <span class="ruby-value">count_comments:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">foldable_types:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">another_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_foldable_checks</span>(<span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classlike_code_length</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classlike_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">code_length</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_comments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_top_level_descendant</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">types</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_body</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foldable_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_length</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true for lines that shall not be included in the count.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">irrelevant_line?</span>(<span class="ruby-identifier">source_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_numbers_of_inner_nodes</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace_module?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_with_heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">normalize_foldable_types</span>(<span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">omit_length</span>(<span class="ruby-identifier">descendant</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_from_node_with_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#13 RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::CLASSLIKE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/metrics/utils/code_length_calculator.rb#12 RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::FOLDABLE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Used to identify iterating blocks like ‘.map{}` and `.map(&amp;:…)` # # source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#8 module RuboCop::Cop::Metrics::Utils::IteratingBlock</p>

<pre class="ruby"><span class="ruby-comment"># Returns the name of the method called with a block</span>
<span class="ruby-comment"># if node is a block node, or a block-pass node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_method_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns nil if node is neither a block node or a block-pass node.</span>
<span class="ruby-comment"># Otherwise returns true/false if method call is a known iterating call</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iterating_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true iff name is a known iterating type (e.g. :each, :transform_values)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iterating_method?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/metrics/utils/iterating_block.rb#33 RuboCop::Cop::Metrics::Utils::IteratingBlock::KNOWN_ITERATING_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># Identifies repetitions ‘{c}send` calls with no arguments: # #   foo.bar #   foo.bar # =&gt; repeated #   foo.bar.baz.qux # =&gt; inner send repeated #   foo.bar.baz.other # =&gt; both inner send repeated #   foo.bar(2) # =&gt; not repeated # # It also invalidates sequences if a receiver is reassigned: # #   xx.foo.bar #   xx.foo.baz      # =&gt; inner send repeated #   self.xx = any   # =&gt; invalidates everything so far #   xx.foo.baz      # =&gt; no repetition #   self.xx.foo.baz # =&gt; all repeated # # @api private # # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#25 module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># Plug into the calculator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">discount_repeated_attributes:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">discount_repeated_attributes?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evaluate_branch_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">discount_repeated_attribute?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the &quot;known_attributes&quot; for the `node` by walking the receiver tree</span>
<span class="ruby-comment"># If at any step the subdirectory does not exist, it is yielded with the</span>
<span class="ruby-comment"># associated key (method_name)</span>
<span class="ruby-comment"># If the node is not a series of `(c)send` calls with no arguments,</span>
<span class="ruby-comment"># then `nil` is yielded</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_attributes</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># or `nil` if it is not a setter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setter_to_getter</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_repeated_attribute</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_attribute_discount.rb#29 RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount::VAR_SETTER_TO_GETTER = T.let(T.unsafe(nil), Hash)</p>

<p># Identifies repetitions ‘&amp;.` on the same variable: # #  my_var&amp;.foo #  my_var&amp;.bar # =&gt; repeated #  my_var = baz # =&gt; reset #  my_var&amp;.qux # =&gt; not repeated # # @api private # # source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#15 module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">discount_for_repeated_csend?</span>(<span class="ruby-identifier">csend_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/metrics/utils/repeated_csend_discount.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_repeated_csend</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/migration/department_name.rb#5 module RuboCop::Cop::Migration; end</p>

<p># department name. # # source://rubocop//lib/rubocop/cop/migration/department_name.rb#8 class RuboCop::Cop::Migration::DepartmentName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_cop_name</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">comment</span>, <span class="ruby-identifier">offset</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contain_unexpected_character_for_department_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_comment_offset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_legacy_cop_name</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/migration/department_name.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_content_token?</span>(<span class="ruby-identifier">content_token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/migration/department_name.rb#14 RuboCop::Cop::Migration::DepartmentName::DISABLE_COMMENT_FORMAT = T.let(T.unsafe(nil), Regexp)</p>

<p># The token that makes up a disable comment. # ‘DepartmentName/CopName` or` all`. # # source://rubocop//lib/rubocop/cop/migration/department_name.rb#19 RuboCop::Cop::Migration::DepartmentName::DISABLING_COPS_CONTENT_TOKEN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/migration/department_name.rb#12 RuboCop::Cop::Migration::DepartmentName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking minimum body length. # # source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#6 module RuboCop::Cop::MinBodyLength</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_body_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/min_body_length.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_body_length?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking minimum branches count. # # source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#6 module RuboCop::Cop::MinBranchesCount</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_conditional_branches</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">branches</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_branches_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/min_branches_count.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_branches_count?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common code for indenting the first elements in multiline # array literals, hash literals, and method definitions. # # source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#7 module RuboCop::Cop::MultilineElementIndentation</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_expected_style</span>(<span class="ruby-identifier">styles</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_first</span>(<span class="ruby-identifier">first</span>, <span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">left_parenthesis</span>, <span class="ruby-identifier">offset</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_styles</span>(<span class="ruby-identifier">actual_column</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">left_parenthesis</span>, <span class="ruby-identifier">left_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_styles_for_column</span>(<span class="ruby-identifier">column</span>, <span class="ruby-identifier">left_parenthesis</span>, <span class="ruby-identifier">left_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_argument_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_pair_where_value_beginning_with</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">first</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_style_detected</span>(<span class="ruby-identifier">styles</span>, <span class="ruby-identifier">first</span>, <span class="ruby-identifier">base_column_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent_base</span>(<span class="ruby-identifier">left_brace</span>, <span class="ruby-identifier">first</span>, <span class="ruby-identifier">left_parenthesis</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_and_value_begin_on_same_line?</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_indentation.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_sibling_begins_on_subsequent_line?</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking for a line break before each # element in a multi-line collection. # # source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#7 module RuboCop::Cop::MultilineElementLineBreaks</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_on_same_line?</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-value">ignore_last:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_element_line_breaks.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_line_breaks</span>(<span class="ruby-identifier">_node</span>, <span class="ruby-identifier">children</span>, <span class="ruby-value">ignore_last:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking multiline method calls and binary # operations. # # source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#7 module RuboCop::Cop::MultilineExpressionIndentation</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_in_method_call</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The correct indentation of `node` is usually `IndentationWidth`, with</span>
<span class="ruby-comment"># one exception: prefix keywords.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment"># while foo &amp;&amp;  # Here, `while` is called a &quot;prefix keyword&quot;</span>
<span class="ruby-comment">#     bar       # This is called &quot;special indentation&quot;</span>
<span class="ruby-comment">#   baz</span>
<span class="ruby-comment"># end</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note that *postfix conditionals* do *not* get &quot;special indentation&quot;.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment"># next if foo &amp;&amp;</span>
<span class="ruby-comment">#   bar # normal indentation, not special</span>
<span class="ruby-comment"># ```</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disqualified_rhs?</span>(<span class="ruby-identifier">candidate</span>, <span class="ruby-identifier">ancestor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grouped_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_style_detected</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_keyword_expression</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_arg_list_parentheses?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">ancestor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_message_tail</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kw_node_with_special_indentation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># In a chain of method calls, we regard the top call node as the base</span>
<span class="ruby-comment"># for indentation of all lines following the first. For example:</span>
<span class="ruby-comment"># a.</span>
<span class="ruby-comment">#   b c { block }.            &lt;-- b is indented relative to a</span>
<span class="ruby-comment">#   d                         &lt;-- d is indented relative to a</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_hand_side</span>(<span class="ruby-identifier">lhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_for_this_cop?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operation_description</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">part_of_assignment_rhs</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">candidate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">part_of_block_body?</span>(<span class="ruby-identifier">candidate</span>, <span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if `node` is a conditional whose `body` and `condition`</span>
<span class="ruby-comment"># begin on the same line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">postfix_conditional?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The []= operator and setters (a.b = c) are parsed as :send nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_method_rhs_candidate?</span>(<span class="ruby-identifier">candidate</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_rhs?</span>(<span class="ruby-identifier">candidate</span>, <span class="ruby-identifier">ancestor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_rhs_candidate?</span>(<span class="ruby-identifier">candidate</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_node?</span>(<span class="ruby-identifier">inner</span>, <span class="ruby-identifier">outer</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#11 RuboCop::Cop::MultilineExpressionIndentation::ASSIGNMENT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#10 RuboCop::Cop::MultilineExpressionIndentation::DEFAULT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#8 RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#12 RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_MESSAGE_TAIL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/multiline_expression_indentation.rb#9 RuboCop::Cop::MultilineExpressionIndentation::UNALIGNED_RHS_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Autocorrection logic for the closing brace of a literal either # on the same line as the last contained elements, or a new line. # # source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#7 class RuboCop::Cop::MultilineLiteralBraceCorrector</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MultilineLiteralBraceLayout</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># @return [MultilineLiteralBraceCorrector] a new instance of MultilineLiteralBraceCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">content_if_comment_present</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_heredoc_argument_method_chain</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">end_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_next_line_brace</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">end_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_same_line_brace</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute corrector.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_element_range_with_trailing_comma</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_element_trailing_comma_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute processed_source.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_trailing_content_of_comment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_content_to_be_inserted_after_last_element</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_heredoc_argument_method_chain?</span>(<span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/multiline_literal_brace_corrector.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking the closing brace of a literal is # either on the same line as the last contained elements or a new line. # # source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#7 module RuboCop::Cop::MultilineLiteralBraceLayout</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_brace_layout</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_new_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_same_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_symmetrical</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This method depends on the fact that we have guarded</span>
<span class="ruby-comment"># against implicit and empty literals.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_brace_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Starting with the parent node and recursively for the parent node&#39;s</span>
<span class="ruby-comment"># children, check if the node is a HEREDOC and if the HEREDOC ends below</span>
<span class="ruby-comment"># or on the last line of the parent node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Example:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # node is `b: ...` parameter</span>
<span class="ruby-comment">#   # last_line_heredoc?(node) =&gt; false</span>
<span class="ruby-comment">#   foo(a,</span>
<span class="ruby-comment">#     b: {</span>
<span class="ruby-comment">#       a: 1,</span>
<span class="ruby-comment">#       c: &lt;&lt;-EOM</span>
<span class="ruby-comment">#         baz</span>
<span class="ruby-comment">#       EOM</span>
<span class="ruby-comment">#     }</span>
<span class="ruby-comment">#   )</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # node is `b: ...` parameter</span>
<span class="ruby-comment">#   # last_line_heredoc?(node) =&gt; true</span>
<span class="ruby-comment">#   foo(a,</span>
<span class="ruby-comment">#     b: &lt;&lt;-EOM</span>
<span class="ruby-comment">#       baz</span>
<span class="ruby-comment">#     EOM</span>
<span class="ruby-comment">#   )</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line_heredoc?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">parent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true for the case</span>
<span class="ruby-comment">#   [a,</span>
<span class="ruby-comment">#    b # comment</span>
<span class="ruby-comment">#   ].some_method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_line_needed_before_closing_brace?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This method depends on the fact that we have guarded</span>
<span class="ruby-comment"># against implicit and empty literals.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/multiline_literal_brace_layout.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opening_brace_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#5 module RuboCop::Cop::Naming; end</p>

<p># Avoid prefixing accessor method names with ‘get_` or `set_`. # Applies to both instance and class methods. # # NOTE: Method names starting with `get_` or `set_` only register an offense # when the methods match the expected arity for getters and setters respectively. # Getters (`get_attribute`) must have no arguments to be registered, # and setters (`set_attribute(value)`) must have exactly one. # # @example #   # bad #   def set_attribute(value) #   end # #   # good #   def attribute=(value) #   end # #   # bad #   def get_attribute #   end # #   # good #   def attribute #   end # #   # accepted, incorrect arity for getter #   def get_value(attr) #   end # #   # accepted, incorrect arity for setter #   def set_value #   end # # source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#38 class RuboCop::Cop::Naming::AccessorMethodName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_reader_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_writer_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_attribute_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#39 RuboCop::Cop::Naming::AccessorMethodName::MSG_READER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/accessor_method_name.rb#40 RuboCop::Cop::Naming::AccessorMethodName::MSG_WRITER = T.let(T.unsafe(nil), String)</p>

<p># Checks for non-ascii characters in identifier and constant names. # Identifiers are always checked and whether constants are checked # can be controlled using AsciiConstants config. # # @example #   # bad #   def καλημερα # Greek alphabet (non-ascii) #   end # #   # bad #   def こんにちはと言う # Japanese character (non-ascii) #   end # #   # bad #   def hello_🍣 # Emoji (non-ascii) #   end # #   # good #   def say_hello #   end # #   # bad #   신장 = 10 # Hangul character (non-ascii) # #   # good #   height = 10 # #   # bad #   <a href=":عرض_gteq">params</a> # Arabic character (non-ascii) # #   # good #   <a href=":width_gteq">params</a> # @example AsciiConstants: true (default) #   # bad #   class Foö #   end # #   FOÖ = “foo” # @example AsciiConstants: false #   # good #   class Foö #   end # #   FOÖ = “foo” # # source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#53 class RuboCop::Cop::Naming::AsciiIdentifiers &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_non_ascii_chars</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_offense_range</span>(<span class="ruby-identifier">identifier</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_check?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#57 RuboCop::Cop::Naming::AsciiIdentifiers::CONSTANT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/ascii_identifiers.rb#56 RuboCop::Cop::Naming::AsciiIdentifiers::IDENTIFIER_MSG = T.let(T.unsafe(nil), String)</p>

<p># Makes sure that certain binary operator methods have their # sole  parameter named ‘other`. # # @example # #   # bad #   def +(amount); end # #   # good #   def +(other); end # # source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#16 class RuboCop::Cop::Naming::BinaryOperatorParameterName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">op_method_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">op_method?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#22 RuboCop::Cop::Naming::BinaryOperatorParameterName::EXCLUDED = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#19 RuboCop::Cop::Naming::BinaryOperatorParameterName::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/binary_operator_parameter_name.rb#21 RuboCop::Cop::Naming::BinaryOperatorParameterName::OP_LIKE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># In Ruby 3.1, anonymous block forwarding has been added. # # This cop identifies places where ‘do_something(&amp;block)` can be replaced # by `do_something(&amp;)`. # # It also supports the opposite style by alternative `explicit` option. # You can specify the block variable name for autocorrection with `BlockForwardingName`. # The default variable name is `block`. If the name is already in use, it will not be # autocorrected. # # [NOTE] # ==== # Because of a bug in Ruby 3.3.0, when a block is referenced inside of another block, # no offense will be registered until Ruby 3.4: # # [source,ruby] # —- # def foo(&amp;block) #   # Using an anonymous block would be a syntax error on Ruby 3.3.0 #   block_method { bar(&amp;block) } # end # —- # ==== # # @example EnforcedStyle: anonymous (default) # #   # bad #   def foo(&amp;block) #   bar(&amp;block) #   end # #   # good #   def foo(&amp;) #   bar(&amp;) #   end # @example EnforcedStyle: explicit # #   # bad #   def foo(&amp;) #   bar(&amp;) #   end # #   # good #   def foo(&amp;block) #   bar(&amp;block) #   end # # source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#54 class RuboCop::Cop::Naming::BlockForwarding &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">anonymous_block_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_argument_name_matched?</span>(<span class="ruby-identifier">block_pass_node</span>, <span class="ruby-identifier">last_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_forwarding_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_block_forwarding_style?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">last_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_block_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Ruby 3.3.0 had a bug where accessing an anonymous block argument inside of a block</span>
<span class="ruby-comment"># was a syntax error in unambiguous cases: https://bugs.ruby-lang.org/issues/20090</span>
<span class="ruby-comment"># We disallow this also for earlier Ruby versions so that code is forwards compatible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalidates_syntax?</span>(<span class="ruby-identifier">block_pass_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">block_argument</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_block_argument_as_local_variable?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">last_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_kwarg_in_method_definition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#64</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/block_forwarding.rb#62 RuboCop::Cop::Naming::BlockForwarding::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks block parameter names for how descriptive they # are. It is highly configurable. # # The ‘MinNameLength` config option takes an integer. It represents # the minimum amount of characters the name must be. Its default is 1. # The `AllowNamesEndingInNumbers` config option takes a boolean. When # set to false, this cop will register offenses for names ending with # numbers. Its default is false. The `AllowedNames` config option # takes an array of permitted names that will never register an # offense. The `ForbiddenNames` config option takes an array of # restricted names that will always register an offense. # # @example #   # bad #   bar do |varOne, varTwo| #   varOne + varTwo #   end # #   # With `AllowNamesEndingInNumbers` set to false #   foo { |num1, num2| num1 * num2 } # #   # With `MinNameLength` set to number greater than 1 #   baz { |a, b, c| do_stuff(a, b, c) } # #   # good #   bar do |thud, fred| #   thud + fred #   end # #   foo { |speed, distance| speed * distance } # #   baz { |age, height, gender| do_stuff(age, height, gender) } # # source://rubocop//lib/rubocop/cop/naming/block_parameter_name.rb#38 class RuboCop::Cop::Naming::BlockParameterName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">UncommunicativeName</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/block_parameter_name.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for class and module names with # an underscore in them. # # ‘AllowedNames` config takes an array of permitted names. # Its default value is `[’module_parent’]‘. # These names can be full class/module names or part of the name. # eg. Adding `my_class` to the `AllowedNames` config will allow names like # `my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc. # # @example #   # bad #   class My_Class #   end #   module My_Module #   end # #   # good #   class MyClass #   end #   module MyModule #   end #   class module_parent::MyModule #   end # # source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#29 class RuboCop::Cop::Naming::ClassAndModuleCamelCase &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/class_and_module_camel_case.rb#30 RuboCop::Cop::Naming::ClassAndModuleCamelCase::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether constant names are written using # SCREAMING_SNAKE_CASE. # # To avoid false positives, it ignores cases in which we cannot know # for certain the type of value that would be assigned to a constant. # # @example #   # bad #   InchInCm = 2.54 #   INCHinCM = 2.54 #   Inch_In_Cm = 2.54 # #   # good #   INCH_IN_CM = 2.54 # # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#20 class RuboCop::Cop::Naming::ConstantName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_or_struct_return_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_receiver?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_assignment?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_conditional_expression_on_rhs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_call_on_rhs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_constant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/constant_name.rb#21 RuboCop::Cop::Naming::ConstantName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Use POSIX character classes, so we allow accented characters rather # than just standard ASCII characters # # source://rubocop//lib/rubocop/cop/naming/constant_name.rb#24 RuboCop::Cop::Naming::ConstantName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)</p>

<p># Makes sure that Ruby source files have snake_case # names. Ruby scripts (i.e. source files with a shebang in the # first line) are ignored. # # The cop also ignores ‘.gemspec` files, because Bundler # recommends using dashes to separate namespaces in nested gems # (i.e. `bundler-console` becomes `Bundler::Console`). As such, the # gemspec is supposed to be named `bundler-console.gemspec`. # # When `ExpectMatchingDefinition` (default: `false`) is `true`, the cop requires # each file to have a class, module or `Struct` defined in it that matches # the filename. This can be further configured using # `CheckDefinitionPathHierarchy` (default: `true`) to determine whether the # path should match the namespace of the above definition. # # When `IgnoreExecutableScripts` (default: `true`) is `true`, files that start # with a shebang line are not considered by the cop. # # When `Regex` is set, the cop will flag any filename that does not match # the regular expression. # # @example #   # bad #   lib/layoutManager.rb # #   anything/usingCamelCase # #   # good #   lib/layout_manager.rb # #   anything/using_snake_case.rake # # source://rubocop//lib/rubocop/cop/naming/file_name.rb#39 class RuboCop::Cop::Naming::FileName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">struct_definition</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_acronyms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_filename_allowed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_definition_path_hierarchy?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_struct</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">definition_path_hierarchy_roots</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expect_matching_definition?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filename_good?</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_class_or_module</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">namespace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_definition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_bad_filename</span>(<span class="ruby-identifier">file_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_executable_scripts?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">expected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_acronym?</span>(<span class="ruby-identifier">expected</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_class?</span>(<span class="ruby-identifier">file_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_definition?</span>(<span class="ruby-identifier">file_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace_matches?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">namespace</span>, <span class="ruby-identifier">expected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_definition_message</span>(<span class="ruby-identifier">basename</span>, <span class="ruby-identifier">file_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">other_message</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">partial_matcher!</span>(<span class="ruby-identifier">expected</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">perform_class_and_module_naming_checks</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regex</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_module_name</span>(<span class="ruby-identifier">basename</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/file_name.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_namespace</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/file_name.rb#41 RuboCop::Cop::Naming::FileName::MSG_NO_DEFINITION = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/file_name.rb#42 RuboCop::Cop::Naming::FileName::MSG_REGEX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/file_name.rb#40 RuboCop::Cop::Naming::FileName::MSG_SNAKE_CASE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/file_name.rb#44 RuboCop::Cop::Naming::FileName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks that your heredocs are using the configured case. # By default it is configured to enforce uppercase heredocs. # # @example EnforcedStyle: uppercase (default) #   # bad #   &lt;&lt;-sql #   SELECT * FROM foo #   sql # #   # good #   &lt;&lt;-SQL #   SELECT * FROM foo #   SQL # @example EnforcedStyle: lowercase #   # bad #   &lt;&lt;-SQL #   SELECT * FROM foo #   SQL # #   # good #   &lt;&lt;-sql #   SELECT * FROM foo #   sql # # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#30 class RuboCop::Cop::Naming::HeredocDelimiterCase &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_case_delimiters?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_delimiters</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_case.rb#35 RuboCop::Cop::Naming::HeredocDelimiterCase::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that your heredocs are using meaningful delimiters. # By default it disallows ‘END` and `EO*`, and can be configured through # forbidden listing additional delimiters. # # @example # #   # good #   &lt;&lt;-SQL #   SELECT * FROM foo #   SQL # #   # bad #   &lt;&lt;-END #   SELECT * FROM foo #   END # #   # bad #   &lt;&lt;-EOS #   SELECT * FROM foo #   EOS # # source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#26 class RuboCop::Cop::Naming::HeredocDelimiterNaming &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">meaningful_delimiters?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/heredoc_delimiter_naming.rb#29 RuboCop::Cop::Naming::HeredocDelimiterNaming::MSG = T.let(T.unsafe(nil), String)</p>

<p># Recommends the use of inclusive language instead of problematic terms. # The cop can check the following locations for offenses: # # - identifiers # - constants # - variables # - strings # - symbols # - comments # - file paths # # Each of these locations can be individually enabled/disabled via configuration, # for example CheckIdentifiers = true/false. # # Flagged terms are configurable for the cop. For each flagged term an optional # Regex can be specified to identify offenses. Suggestions for replacing a flagged term can # be configured and will be displayed as part of the offense message. # An AllowedRegex can be specified for a flagged term to exempt allowed uses of the term. # ‘WholeWord: true` can be set on a flagged term to indicate the cop should only match when # a term matches the whole word (partial matches will not be offenses). # # The cop supports autocorrection when there is only one suggestion. When there are multiple # suggestions, the best suggestion cannot be identified and will not be autocorrected. # # @example FlaggedTerms: { whitelist: { Suggestions: [’allowlist’] } } #   # Suggest replacing identifier whitelist with allowlist # #   # bad #   whitelist_users = %w(user1 user1) # #   # good #   allowlist_users = %w(user1 user2) # @example FlaggedTerms: { master: { Suggestions: [‘main’, ‘primary’, ‘leader’] } } #   # Suggest replacing master in an instance variable name with main, primary, or leader # #   # bad #   @master_node = ‘node1.example.com’ # #   # good #   @primary_node = ‘node1.example.com’ # @example FlaggedTerms: { whitelist: { Regex: !ruby/regexp ‘/<a href="-_\s">white</a>?list’ } } #   # Identify problematic terms using a Regexp # #   # bad #   white_list = %w(user1 user2) # #   # good #   allow_list = %w(user1 user2) # @example FlaggedTerms: { master: { AllowedRegex: ‘master&#39;?s degree’ } } #   # Specify allowed uses of the flagged term as a string or regexp. # #   # bad #   # They had a masters # #   # good #   # They had a master’s degree # @example FlaggedTerms: { slave: { WholeWord: true } } #   # Specify that only terms that are full matches will be flagged. # #   # bad #   Slave # #   # good (won’t be flagged despite containing ‘slave`) #   TeslaVehicle # # source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#74 class RuboCop::Cop::Naming::InclusiveLanguage &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [InclusiveLanguage] a new instance of InclusiveLanguage</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offenses_for_token</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">word_locations</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_to_flagged_term_hash</span>(<span class="ruby-identifier">regex_string</span>, <span class="ruby-identifier">term</span>, <span class="ruby-identifier">term_definition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_to_ignorecase_regex</span>(<span class="ruby-identifier">strings</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_token?</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_message</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">message</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_multiple_word_message_for_file</span>(<span class="ruby-identifier">words</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_single_word_message_for_file</span>(<span class="ruby-identifier">word</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_regex_string</span>(<span class="ruby-identifier">regex</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_regexp</span>(<span class="ruby-identifier">term</span>, <span class="ruby-identifier">term_definition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_flagged_term</span>(<span class="ruby-identifier">word</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_suggestions</span>(<span class="ruby-identifier">suggestions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate_filepath</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate_tokens</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mask_input</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">word</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_sole_term</span>(<span class="ruby-identifier">suggestions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preprocess_check_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preprocess_flagged_terms</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preprocess_suggestions</span>(<span class="ruby-identifier">suggestions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_allowed_regex</span>(<span class="ruby-identifier">allowed</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan_for_words</span>(<span class="ruby-identifier">input</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_regexes</span>(<span class="ruby-identifier">flagged_term_strings</span>, <span class="ruby-identifier">allowed_strings</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#78 RuboCop::Cop::Naming::InclusiveLanguage::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#79 RuboCop::Cop::Naming::InclusiveLanguage::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#80 RuboCop::Cop::Naming::InclusiveLanguage::MSG_FOR_FILE_PATH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82 class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute position</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of position</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">position</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute position</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute position to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">position=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute word</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of word</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">word</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute word</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute word to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">word=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/inclusive_language.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for memoized methods whose instance variable name # does not match the method name. Applies to both regular methods # (defined with ‘def`) and dynamic methods (defined with # `define_method` or `define_singleton_method`). # # This cop can be configured with the EnforcedStyleForLeadingUnderscores # directive. It can be configured to allow for memoized instance variables # prefixed with an underscore. Prefixing ivars with an underscore is a # convention that is used to implicitly indicate that an ivar should not # be set or referenced outside of the memoization method. # # @example EnforcedStyleForLeadingUnderscores: disallowed (default) #   # bad #   # Method foo is memoized using an instance variable that is #   # not `@foo`. This can cause confusion and bugs. #   def foo #   @something ||= calculate_expensive_thing #   end # #   def foo #   return @something if defined?(@something) #   @something = calculate_expensive_thing #   end # #   # good #   def _foo #   @foo ||= calculate_expensive_thing #   end # #   # good #   def foo #   @foo ||= calculate_expensive_thing #   end # #   # good #   def foo #   @foo ||= begin #   calculate_expensive_thing #   end #   end # #   # good #   def foo #   helper_variable = something_we_need_to_calculate_foo #   @foo ||= calculate_expensive_thing(helper_variable) #   end # #   # good #   define_method(:foo) do #   @foo ||= calculate_expensive_thing #   end # #   # good #   define_method(:foo) do #   return @foo if defined?(@foo) #   @foo = calculate_expensive_thing #   end # @example EnforcedStyleForLeadingUnderscores: required #   # bad #   def foo #   @something ||= calculate_expensive_thing #   end # #   # bad #   def foo #   @foo ||= calculate_expensive_thing #   end # #   def foo #   return @foo if defined?(@foo) #   @foo = calculate_expensive_thing #   end # #   # good #   def foo #   @_foo ||= calculate_expensive_thing #   end # #   # good #   def _foo #   @_foo ||= calculate_expensive_thing #   end # #   def foo #   return @_foo if defined?(@_foo) #   @_foo = calculate_expensive_thing #   end # #   # good #   define_method(:foo) do #   @_foo ||= calculate_expensive_thing #   end # #   # good #   define_method(:foo) do #   return @_foo if defined?(@_foo) #   @_foo = calculate_expensive_thing #   end # @example EnforcedStyleForLeadingUnderscores :optional #   # bad #   def foo #   @something ||= calculate_expensive_thing #   end # #   # good #   def foo #   @foo ||= calculate_expensive_thing #   end # #   # good #   def foo #   @_foo ||= calculate_expensive_thing #   end # #   # good #   def _foo #   @_foo ||= calculate_expensive_thing #   end # #   # good #   def foo #   return @_foo if defined?(@_foo) #   @_foo = calculate_expensive_thing #   end # #   # good #   define_method(:foo) do #   @foo ||= calculate_expensive_thing #   end # #   # good #   define_method(:foo) do #   @_foo ||= calculate_expensive_thing #   end # # source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#148 class RuboCop::Cop::Naming::MemoizedInstanceVariableName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_memoized?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_definition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches?</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">ivar_assign</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suggested_var</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_name_candidates</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#157 RuboCop::Cop::Naming::MemoizedInstanceVariableName::DYNAMIC_DEFINE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#158 RuboCop::Cop::Naming::MemoizedInstanceVariableName::INITIALIZE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#153 RuboCop::Cop::Naming::MemoizedInstanceVariableName::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/memoized_instance_variable_name.rb#155 RuboCop::Cop::Naming::MemoizedInstanceVariableName::UNDERSCORE_REQUIRED = T.let(T.unsafe(nil), String)</p>

<p># Makes sure that all methods use the configured style, # snake_case or camelCase, for their names. # # Method names matching patterns are always allowed. # # The cop can be configured with ‘AllowedPatterns` to allow certain regexp patterns: # # [source,yaml] # —- # Naming/MethodName: #   AllowedPatterns: #     - ’AonSelectionBulkChangez‘ #     - ’AonSelectionClearedz‘ # —- # # As well, you can also forbid specific method names or regexp patterns # using `ForbiddenIdentifiers` or `ForbiddenPatterns`: # # [source,yaml] # —- # Naming/MethodName: #   ForbiddenIdentifiers: #     - ’def’ #     - ‘super’ #   ForbiddenPatterns: #     - ‘_v1z’ #     - ‘_gen1z’ # —- # # @example EnforcedStyle: snake_case (default) #   # bad #   def fooBar; end # #   # good #   def foo_bar; end # #   # bad #   define_method :fooBar do #   end # #   # good #   define_method :foo_bar do #   end # #   # bad #   Struct.new(:fooBar) # #   # good #   Struct.new(:foo_bar) # @example EnforcedStyle: camelCase #   # bad #   def foo_bar; end # #   # good #   def fooBar; end # #   # bad #   define_method :foo_bar do #   end # #   # good #   define_method :fooBar do #   end # #   # bad #   Struct.new(:foo_bar) # #   # good #   Struct.new(:fooBar) # @example ForbiddenIdentifiers: [‘def’, ‘super’] #   # bad #   def def; end #   def super; end # @example ForbiddenPatterns: [‘_v1z’, ‘_gen1z’] #   # bad #   def release_v1; end #   def api_gen1; end # # source://rubocop//lib/rubocop/cop/naming/method_name.rb#87 class RuboCop::Cop::Naming::MethodName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableFormatting</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableNaming</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbiddenIdentifiers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbiddenPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_struct?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sym_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attr_name</span>(<span class="ruby-identifier">name_item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_attr_accessor</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_define_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_method_name</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_new_struct</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_position</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_name.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forbidden_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/method_name.rb#94 RuboCop::Cop::Naming::MethodName::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/method_name.rb#95 RuboCop::Cop::Naming::MethodName::MSG_FORBIDDEN = T.let(T.unsafe(nil), String)</p>

<p># Checks method parameter names for how descriptive they # are. It is highly configurable. # # The ‘MinNameLength` config option takes an integer. It represents # the minimum amount of characters the name must be. Its default is 3. # The `AllowNamesEndingInNumbers` config option takes a boolean. When # set to false, this cop will register offenses for names ending with # numbers. Its default is false. The `AllowedNames` config option # takes an array of permitted names that will never register an # offense. The `ForbiddenNames` config option takes an array of # restricted names that will always register an offense. # # @example #   # bad #   def bar(varOne, varTwo) #   varOne + varTwo #   end # #   # With `AllowNamesEndingInNumbers` set to false #   def foo(num1, num2) #   num1 * num2 #   end # #   # With `MinNameLength` set to number greater than 1 #   def baz(a, b, c) #   do_stuff(a, b, c) #   end # #   # good #   def bar(thud, fred) #   thud + fred #   end # #   def foo(speed, distance) #   speed * distance #   end # #   def baz(age_a, height_b, gender_c) #   do_stuff(age_a, height_b, gender_c) #   end # # source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#46 class RuboCop::Cop::Naming::MethodParameterName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">UncommunicativeName</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/method_parameter_name.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks that predicate methods end with ‘?` and non-predicate methods do not. # # The names of predicate methods (methods that return a boolean value) should end # in a question mark. Methods that don’t return a boolean, shouldn’t # end in a question mark. # # The cop assesses a predicate method as one that returns boolean values. Likewise, # a method that only returns literal values is assessed as non-predicate. Other predicate # method calls are assumed to return boolean values. The cop does not make an assessment # if the return type is unknown (non-predicate method calls, variables, etc.). # # NOTE: Operator methods (‘def ==`, etc.) are ignored. # # By default, the cop runs in `conservative` mode, which allows a method to be named # with a question mark as long as at least one return value is boolean. In `aggressive` # mode, methods with a question mark will register an offense if any known non-boolean # return values are detected. # # The cop also has `AllowedMethods` configuration in order to prevent the cop from # registering an offense from a method name that does not confirm to the naming # guidelines. By default, `call` is allowed. The cop also has `AllowedPatterns` # configuration to allow method names by regular expression. # # Although returning a call to another predicate method is treated as a boolean value, # certain method names can be known to not return a boolean, despite ending in a `?` # (for example, `Numeric#nonzero?` returns `self` or `nil`). These methods can be # configured using `NonBooleanPredicates`. # # The cop can furthermore be configured to allow all bang methods (method names # ending with `!`), with `AllowBangMethods: true` (default false). # # @example Mode: conservative (default) #   # bad #   def foo #   bar == baz #   end # #   # good #   def foo? #   bar == baz #   end # #   # bad #   def foo? #   5 #   end # #   # good #   def foo #   5 #   end # #   # bad #   def foo #   x == y #   end # #   # good #   def foo? #   x == y #   end # #   # bad #   def foo #   !x #   end # #   # good #   def foo? #   !x #   end # #   # bad - returns the value of another predicate method #   def foo #   bar? #   end # #   # good #   def foo? #   bar? #   end # #   # good - operator method #   def ==(other) #   hash == other.hash #   end # #   # good - at least one return value is boolean #   def foo? #   return unless bar? #   true #   end # #   # ok - return type is not known #   def foo? #   bar #   end # #   # ok - return type is not known #   def foo #   bar? #   end # @example Mode: aggressive #   # bad - the method returns nil in some cases #   def foo? #   return unless bar? #   true #   end # @example AllowBangMethods: false (default) #   # bad #   def save! #   true #   end # @example AllowBangMethods: true #   # good #   def save! #   true #   end # # source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#128 class RuboCop::Cop::Naming::PredicateMethod &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable?</span>(<span class="ruby-identifier">return_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_return_values_boolean?</span>(<span class="ruby-identifier">return_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_bang_methods?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_bang_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_or?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">boolean_return?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conservative?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_and_or_clauses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_conditional_branches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_return_value</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_value</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_returning_boolean?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">potential_non_predicate?</span>(<span class="ruby-identifier">return_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_return_values</span>(<span class="ruby-identifier">return_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_values</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unknown_method_call?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If a method ending in `?` is known to not return a boolean value,</span>
<span class="ruby-comment"># (for example, `Numeric#nonzero?`) it should be treated as a non-boolean</span>
<span class="ruby-comment"># value, despite the method naming.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wayward_predicate?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wayward_predicates</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#133 RuboCop::Cop::Naming::PredicateMethod::MSG_NON_PREDICATE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/predicate_method.rb#132 RuboCop::Cop::Naming::PredicateMethod::MSG_PREDICATE = T.let(T.unsafe(nil), String)</p>

<p># Checks that predicate method names end with a question mark and # do not start with a forbidden prefix. # # A method is determined to be a predicate method if its name starts with # one of the prefixes listed in the ‘NamePrefix` configuration. The list # defaults to `is_`, `has_`, and `have_` but may be overridden. # # Predicate methods must end with a question mark. # # When `ForbiddenPrefixes` is also set (as it is by default), predicate # methods which begin with a forbidden prefix are not allowed, even if # they end with a `?`. These methods should be changed to remove the # prefix. # # When `UseSorbetSigs` set to true (optional), the cop will only report # offenses if the method has a Sorbet `sig` with a return type of # `T::Boolean`. Dynamic methods are not supported with this configuration. # # @example MethodDefinitionMacros: [’def_node_matcher’] #   # bad #   def_node_matcher(:is_even) { |value| } # #   # good #   def_node_matcher(:even?) { |value| } # @example NamePrefix: [‘seems_to_be_’] #   # bad #   def seems_to_be_even(value) #   end # #   # When ForbiddenPrefixes: [‘seems_to_be_’] #   # good #   def even?(value) #   end # #   # When ForbiddenPrefixes: [] #   # good #   def seems_to_be_even?(value) #   end # @example AllowedMethods: [‘is_a?’] (default) #   # Despite starting with the ‘is_` prefix, this method is allowed #   # good #   def is_a?(value) #   end # @example AllowedMethods: [’is_even?‘] #   # good #   def is_even?(value) #   end # @example UseSorbetSigs: false (default) #   # bad #   sig { returns(String) } #   def is_this_thing_on #   “yes” #   end # #   # good - Sorbet signature is not evaluated #   sig { returns(String) } #   def is_this_thing_on? #   “yes” #   end # @example UseSorbetSigs: true #   # bad #   sig { returns(T::Boolean) } #   def odd(value) #   end # #   # good #   sig { returns(T::Boolean) } #   def odd?(value) #   end # @example MethodDefinitionMacros: [’define_method’, ‘define_singleton_method’] (default) #   # bad #   define_method(:is_even) { |value| } # #   # good #   define_method(:even?) { |value| } # @example NamePrefix: [‘is_’, ‘has_’, ‘have_’] (default) #   # bad #   def is_even(value) #   end # #   # When ForbiddenPrefixes: [‘is_’, ‘has_’, ‘have_’] (default) #   # good #   def even?(value) #   end # #   # When ForbiddenPrefixes: [] #   # good #   def is_even?(value) #   end # # source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#103 class RuboCop::Cop::Naming::PredicatePrefix &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dynamic_method_define</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sorbet_return_type</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">prefix</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_name</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">prefix</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_prefixes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">new_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_definition_macro?</span>(<span class="ruby-identifier">macro_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">predicate_prefixes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sorbet_sig?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">return_type:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/predicate_prefix.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_sorbet_sigs?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Makes sure that rescued exceptions variables are named as # expected. # # The ‘PreferredName` config option takes a `String`. It represents # the required name of the variable. Its default is `e`. # # NOTE: This cop does not consider nested rescues because it cannot # guarantee that the variable from the outer rescue is not used within # the inner rescue (in which case, changing the inner variable would # shadow the outer variable). # # @example PreferredName: e (default) #   # bad #   begin #   # do something #   rescue MyException =&gt; exception #   # do something #   end # #   # good #   begin #   # do something #   rescue MyException =&gt; e #   # do something #   end # #   # good #   begin #   # do something #   rescue MyException =&gt; _e #   # do something #   end # @example PreferredName: exception #   # bad #   begin #   # do something #   rescue MyException =&gt; e #   # do something #   end # #   # good #   begin #   # do something #   rescue MyException =&gt; exception #   # do something #   end # #   # good #   begin #   # do something #   rescue MyException =&gt; _exception #   # do something #   end # # source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#61 class RuboCop::Cop::Naming::RescuedExceptionsVariableName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">offending_name</span>, <span class="ruby-identifier">preferred_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">offending_name</span>, <span class="ruby-identifier">preferred_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the exception variable is reassigned, that assignment needs to be corrected.</span>
<span class="ruby-comment"># Further `lvar` nodes will not be corrected though since they now refer to a</span>
<span class="ruby-comment"># different variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_reassignment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">offending_name</span>, <span class="ruby-identifier">preferred_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">resbody</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_name</span>(<span class="ruby-identifier">variable_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shadowed_variable_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_name_matches?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/rescued_exceptions_variable_name.rb#64 RuboCop::Cop::Naming::RescuedExceptionsVariableName::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that the configured style (snake_case or camelCase) is used for all variable names. # This includes local variables, instance variables, class variables, method arguments # (positional, keyword, rest or block), and block arguments. # # The cop can also be configured to forbid using specific names for variables, using # ‘ForbiddenIdentifiers` or `ForbiddenPatterns`. In addition to the above, this applies # to global variables as well. # # Method definitions and method calls are not affected by this cop. # # @example EnforcedStyle: snake_case (default) #   # bad #   fooBar = 1 # #   # good #   foo_bar = 1 # @example EnforcedStyle: camelCase #   # bad #   foo_bar = 1 # #   # good #   fooBar = 1 # @example AllowedIdentifiers: [’fooBar’] #   # good (with EnforcedStyle: snake_case) #   fooBar = 1 # @example AllowedPatterns: [‘_vd+z’] #   # good (with EnforcedStyle: camelCase) #   release_v1 = true # @example ForbiddenIdentifiers: [‘fooBar’] #   # bad (in all cases) #   fooBar = 1 #   @fooBar = 1 #   @@fooBar = 1 #   $fooBar = 1 # @example ForbiddenPatterns: [‘_vd+z’] #   # bad (in all cases) #   release_v1 = true #   @release_v1 = true #   @@release_v1 = true #   $release_v1 = true # # source://rubocop//lib/rubocop/cop/naming/variable_name.rb#52 class RuboCop::Cop::Naming::VariableName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedIdentifiers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableFormatting</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableNaming</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbiddenIdentifiers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbiddenPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_blockarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Only forbidden names are checked for global variable assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwrestarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_optarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_restarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_name?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">given_style</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forbidden_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#59 RuboCop::Cop::Naming::VariableName::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/naming/variable_name.rb#60 RuboCop::Cop::Naming::VariableName::MSG_FORBIDDEN = T.let(T.unsafe(nil), String)</p>

<p># Makes sure that all numbered variables use the # configured style, snake_case, normalcase, or non_integer, # for their numbering. # # Additionally, ‘CheckMethodNames` and `CheckSymbols` configuration options # can be used to specify whether method names and symbols should be checked. # Both are enabled by default. # # @example AllowedPatterns: [’_vd+z‘] #   # good #   :some_sym_v1 # @example EnforcedStyle: snake_case #   # bad #   :some_sym1 #   variable1 = 1 # #   def some_method1; end # #   def some_method_1(arg1); end # #   # good #   :some_sym_1 #   variable_1 = 1 # #   def some_method_1; end # #   def some_method_1(arg_1); end # @example EnforcedStyle: non_integer #   # bad #   :some_sym1 #   :some_sym_1 # #   variable1 = 1 #   variable_1 = 1 # #   def some_method1; end # #   def some_method_1; end # #   def some_methodone(arg1); end #   def some_methodone(arg_1); end # #   # good #   :some_symone #   :some_sym_one # #   variableone = 1 #   variable_one = 1 # #   def some_methodone; end # #   def some_method_one; end # #   def some_methodone(argone); end #   def some_methodone(arg_one); end # #   # In the following examples, we assume `EnforcedStyle: normalcase` (default). # @example CheckMethodNames: true (default) #   # bad #   def some_method_1; end # @example CheckMethodNames: false #   # good #   def some_method_1; end # @example CheckSymbols: true (default) #   # bad #   :some_sym_1 # @example CheckSymbols: false #   # good #   :some_sym_1 # @example AllowedIdentifiers: [capture3] #   # good #   expect(Open3).to receive(:capture3) # @example EnforcedStyle: normalcase (default) #   # bad #   :some_sym_1 #   variable_1 = 1 # #   def some_method_1; end # #   def some_method1(arg_1); end # #   # good #   :some_sym1 #   variable1 = 1 # #   def some_method1; end # #   def some_method1(arg1); end # # source://rubocop//lib/rubocop/cop/naming/variable_number.rb#103 class RuboCop::Cop::Naming::VariableNumber &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedIdentifiers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableFormatting</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableNumbering</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_name?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">given_style</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/naming/variable_number.rb#108 RuboCop::Cop::Naming::VariableNumber::MSG = T.let(T.unsafe(nil), String)</p>

<p># Some common code shared between ‘NegatedIf` and # `NegatedWhile` cops. # # source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#7 module RuboCop::Cop::NegativeConditional</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_condition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_negative?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_negative_conditional</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">message:</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/negative_conditional.rb#10 RuboCop::Cop::NegativeConditional::MSG = T.let(T.unsafe(nil), String)</p>

<p># This module provides a list of methods that are: # 1. In the NilClass by default # 2. Added to NilClass by explicitly requiring any standard libraries # 3. Cop’s configuration parameter AllowedMethods. # # source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#9 module RuboCop::Cop::NilMethods</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/nil_methods.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">other_stdlib_methods</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An offense represents a style violation detected by RuboCop. # # source://rubocop//lib/rubocop/cop/offense.rb#6 class RuboCop::Cop::Offense</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Offense] a new instance of Offense</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">severity</span>, <span class="ruby-identifier">location</span>, <span class="ruby-identifier">message</span>, <span class="ruby-identifier">cop_name</span>, <span class="ruby-identifier">status</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">corrector</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns `-1`, `0`, or `+1`</span>
<span class="ruby-comment"># if this offense is less than, equal to, or greater than `other`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Integer] comparison result</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] returns `true` if two offenses contain same attributes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   &#39;Layout/LineLength&#39;</span>
<span class="ruby-comment"># @return [String] the cop name as a String for which this offense is for.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] whether this offense can be automatically corrected via autocorrect.</span>
<span class="ruby-comment">#   This includes todo comments, for example when requested with `--disable-uncorrectable`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] whether this offense is automatically corrected via</span>
<span class="ruby-comment">#   autocorrect or a todo.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] whether this offense is automatically disabled via a todo.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_with_todo?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Corrector | nil] the autocorrection for this offense, or `nil` when not available</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] whether this offense was locally disabled with a</span>
<span class="ruby-comment">#   disable or todo where it occurred.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Boolean] returns `true` if two offenses contain same attributes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eql?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Parser::Source::Range] the range of the code that is highlighted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">highlighted_area</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Parser::Source::Range] the location where the violation is detected.</span>
<span class="ruby-comment"># @see https://www.rubydoc.info/gems/parser/Parser/Source/Range Parser::Source::Range</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#   &#39;Line is too long. [90/80]&#39;</span>
<span class="ruby-comment"># @return [String] human-readable message</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Internally we use column number that start at 0, but when</span>
<span class="ruby-comment"># outputting column numbers, we want them to start at 1. One</span>
<span class="ruby-comment"># reason is that editors, such as Emacs, expect this.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">real_column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [RuboCop::Cop::Severity]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">severity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">status</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is just for debugging purpose.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/offense.rb#10 RuboCop::Cop::Offense::COMPARISON_ATTRIBUTES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/offense.rb#80 RuboCop::Cop::Offense::NO_LOCATION = T.let(T.unsafe(nil), RuboCop::Cop::Offense::PseudoSourceRange)</p>

<p># source://rubocop//lib/rubocop/cop/offense.rb#63 class RuboCop::Cop::Offense::PseudoSourceRange &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute begin_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of begin_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute begin_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute begin_pos to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute column</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of column</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute column</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute column to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute end_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of end_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute end_pos</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute end_pos to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_pos=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute column</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of column</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute line to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute source_line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of source_line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute source_line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute source_line to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_line=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/offense.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for cops checking if and unless expressions. # # source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#6 module RuboCop::Cop::OnNormalIfUnless</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/on_normal_if_unless.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This autocorrects gem dependency order # # source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#6 class RuboCop::Cop::OrderedGemCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OrderedGemNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute comments_as_separators.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_as_separators</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">previous_declaration</span>, <span class="ruby-identifier">comments_as_separators</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute processed_source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/ordered_gem_corrector.rb#26</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">declaration_with_comment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for Bundler/OrderedGems and # Gemspec/OrderedDependencies. # # source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#7 module RuboCop::Cop::OrderedGemNode</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_insensitive_out_of_order?</span>(<span class="ruby-identifier">string_a</span>, <span class="ruby-identifier">string_b</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consecutive_lines?</span>(<span class="ruby-identifier">previous</span>, <span class="ruby-identifier">current</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_gem_name</span>(<span class="ruby-identifier">gem_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_canonical_name</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_name</span>(<span class="ruby-identifier">declaration_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_source_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comments_as_separators</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">previous</span>, <span class="ruby-identifier">current</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/ordered_gem_node.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">treat_comments_as_separators</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for handling parentheses. # # source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#6 module RuboCop::Cop::Parentheses</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/parentheses.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parens_required?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This autocorrects parentheses # # source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#6 class RuboCop::Cop::ParenthesesCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># Add a comma back after the heredoc identifier</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#77</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_heredoc_comma</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># If the node contains a heredoc, remove the comma too</span>
  <span class="ruby-comment"># It&#39;ll be added back in the right place later</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#67</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extend_range_for_heredoc</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># If removing parentheses leaves a comma on its own line, remove all the whitespace</span>
  <span class="ruby-comment"># preceding it to prevent a syntax error.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_orphaned_comma</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#83</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_char_is_question_mark?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#35</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_closing_paren_before_comma?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Get a range for the closing parenthesis and all whitespace to the left of it</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#54</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parens_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/parentheses_corrector.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for handling percent arrays. # # source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#6 module RuboCop::Cop::PercentArray</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_bracket_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::ArrayNode]</span>
<span class="ruby-comment"># @param elements [Array&lt;String&gt;]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_bracketed_array_with_appropriate_whitespace</span>(<span class="ruby-value">elements:</span>, <span class="ruby-value">node:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param preferred_array_code [String]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_message_for_bracketed_array</span>(<span class="ruby-identifier">preferred_array_code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_bracketed_array</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">literal_prefix</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_percent_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_in_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Override to determine values that are invalid in a percent array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_percent_array_contents?</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Ruby does not allow percent arrays in an ambiguous block context.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   foo %i[bar baz] { qux }</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_percent_array_context?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Provides whitespace between elements for building a bracketed array.</span>
<span class="ruby-comment">#   %w[  a   b   c    ]</span>
<span class="ruby-comment">#         ^^^</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node [RuboCop::AST::ArrayNode]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_between</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Provides leading whitespace for building a bracketed array.</span>
<span class="ruby-comment">#   %w[  a   b   c    ]</span>
<span class="ruby-comment">#      ^^</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node [RuboCop::AST::ArrayNode]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_leading</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Provides trailing whitespace for building a bracketed array.</span>
<span class="ruby-comment">#   %w[  a   b   c    ]</span>
<span class="ruby-comment">#                 ^^^^</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param node [RuboCop::AST::ArrayNode]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_array.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_trailing</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for handling percent literals. # # source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#6 module RuboCop::Cop::PercentLiteral</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_source</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/percent_literal.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This autocorrects percent literals # # source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#6 class RuboCop::Cop::PercentLiteralCorrector</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>

<span class="ruby-comment"># @return [PercentLiteralCorrector] a new instance of PercentLiteralCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">preferred_delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute preferred_delimiters.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_multiline_words</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">escape</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_words</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">escape</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiters_for</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_content</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape_words?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_line?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">previous_line_num</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_escaped_content</span>(<span class="ruby-identifier">word_node</span>, <span class="ruby-identifier">escape</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_breaks</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">source</span>, <span class="ruby-identifier">previous_line_num</span>, <span class="ruby-identifier">base_line_num</span>, <span class="ruby-identifier">node_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_contents</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">escape</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_lines</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">previous_line_num</span>, <span class="ruby-identifier">base_line_num</span>, <span class="ruby-identifier">source_in_lines</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_multiline_words</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">escape</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">substitute_escaped_delimiters</span>(<span class="ruby-identifier">content</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/percent_literal_corrector.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap_contents</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">contents</span>, <span class="ruby-identifier">char</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking whether an AST node/token is aligned # with something on a preceding or following line # # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#8 module RuboCop::Cop::PrecedingFollowingAlignment</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_comment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_equals_operator?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">lineno</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_identical?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_operator?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">lineno</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_token?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">lineno</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_adjacent_line?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">predicate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_any_line?</span>(<span class="ruby-identifier">line_ranges</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">indent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">predicate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_any_line_range?</span>(<span class="ruby-identifier">line_ranges</span>, <span class="ruby-identifier">range</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">predicate</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_append_operator?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_equals_sign</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_line?</span>(<span class="ruby-identifier">line_nos</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">indent</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_operator?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_preceding_equals?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Allows alignment with a preceding operator that ends with an `=`,</span>
<span class="ruby-comment"># including assignment and comparison operators.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_preceding_equals_operator</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_something?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Allows alignment with a subsequent operator that ends with an `=`,</span>
<span class="ruby-comment"># including assignment and comparison operators.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_with_subsequent_equals_operator</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aligned_words?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_for_alignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_tokens</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_assignment_lines</span>(<span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_equals_in_def</span>(<span class="ruby-identifier">asgn_tokens</span>, <span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Tokens that end with an ‘=`, as well as `&lt;&lt;`, that can be aligned together: # `=`, `==`, `===`, `!=`, `&lt;=`, `&gt;=`, `&lt;&lt;` and operator assignment (`+=`, etc). # # source://rubocop//lib/rubocop/cop/mixin/preceding_following_alignment.rb#11 RuboCop::Cop::PrecedingFollowingAlignment::ASSIGNMENT_OR_COMPARISON_TOKENS = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for handling percent literal delimiters. # # source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#6 class RuboCop::Cop::PreferredDelimiters</p>

<pre class="ruby"><span class="ruby-comment"># @return [PreferredDelimiters] a new instance of PreferredDelimiters</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">config</span>, <span class="ruby-identifier">preferred_delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_valid_preferred_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters_config</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/preferred_delimiters.rb#9 RuboCop::Cop::PreferredDelimiters::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># This autocorrects punctuation # # source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#6 class RuboCop::Cop::PunctuationCorrector</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_space</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_space</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">space_before</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/punctuation_corrector.rb#16</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_comma</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Methods that calculate and return Parser::Source::Ranges # # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#6 module RuboCop::Cop::RangeHelp</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_range</span>(<span class="ruby-identifier">range1</span>, <span class="ruby-identifier">range2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A range containing the first to the last argument</span>
<span class="ruby-comment"># of a method call or method definition.</span>
<span class="ruby-comment"># def foo(a, b:)</span>
<span class="ruby-comment">#         ^^^^^</span>
<span class="ruby-comment"># bar(1, 2, 3, &amp;blk)</span>
<span class="ruby-comment">#     ^^^^^^^^^^^^^</span>
<span class="ruby-comment"># baz { |x, y:, z:| }</span>
<span class="ruby-comment">#        ^^^^^^^^^</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_offset_between</span>(<span class="ruby-identifier">base_range</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A range containing only the contents of a literal with delimiters (e.g. in</span>
<span class="ruby-comment"># `%i{1 2 3}` this will be the range covering `1 2 3` only).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contents_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directions</span>(<span class="ruby-identifier">side</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the column attribute of the range, except if the range is on</span>
<span class="ruby-comment"># the first line and there&#39;s a byte order mark at the beginning of that</span>
<span class="ruby-comment"># line, in which case 1 is subtracted from the column value. This gives</span>
<span class="ruby-comment"># the column as it appears when viewing the file in an editor.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">effective_column</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">final_pos</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">increment</span>, <span class="ruby-identifier">continuations</span>, <span class="ruby-identifier">newlines</span>, <span class="ruby-identifier">whitespace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_pos</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">step</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">regexp</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_pos_str</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">step</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">needle</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_between</span>(<span class="ruby-identifier">start_pos</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_by_whole_lines</span>(<span class="ruby-identifier">range</span>, <span class="ruby-value">include_final_newline:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">buffer:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_comments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_comments_and_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_surrounding_comma</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">side</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_with_surrounding_space</span>(<span class="ruby-identifier">range_positional</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">range:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">side:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">newlines:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">whitespace:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">continuations:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">buffer:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>(<span class="ruby-identifier">source_buffer</span>, <span class="ruby-identifier">line_number</span>, <span class="ruby-identifier">column</span>, <span class="ruby-identifier">length</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The Unicode codepoint # # source://rubocop//lib/rubocop/cop/mixin/range_help.rb#7 RuboCop::Cop::RangeHelp::BYTE_ORDER_MARK = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/range_help.rb#8 module RuboCop::Cop::RangeHelp::NOT_GIVEN; end</p>

<p># Common functionality for handling Rational literals. # # source://rubocop//lib/rubocop/cop/mixin/rational_literal.rb#6 module RuboCop::Cop::RationalLiteral</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/rational_literal.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rational_literal?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Registry that tracks all cops by their badge and department. # # source://rubocop//lib/rubocop/cop/registry.rb#19 class RuboCop::Cop::Registry</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>

<span class="ruby-comment"># @return [Registry] a new instance of Registry</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">cops</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_cop_matching?</span>(<span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops_for_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] Checks if given name is department</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_missing?</span>(<span class="ruby-identifier">badge</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;Symbol&gt;] list of departments for current cops.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">departments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dismiss</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled?</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled_pending_cop?</span>(<span class="ruby-identifier">cop_cfg</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enlist</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param cop_name [String]</span>
<span class="ruby-comment"># @return [Class, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_by_cop_name</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When a cop name is given returns a single-element array with the cop class.</span>
<span class="ruby-comment"># When a department name is given returns an array with all the cop classes</span>
<span class="ruby-comment"># for that department.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_cops_by_directive</span>(<span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">freeze</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">names_for_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute options.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">print_warning</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Convert a user provided cop name into a properly namespaced name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example gives back a correctly qualified cop name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   registry = RuboCop::Cop::Registry</span>
<span class="ruby-comment">#   registry.qualified_cop_name(&#39;Layout/EndOfLine&#39;, &#39;&#39;) # =&gt; &#39;Layout/EndOfLine&#39;</span>
<span class="ruby-comment"># @example fixes incorrect namespaces</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   registry = RuboCop::Cop::Registry</span>
<span class="ruby-comment">#   registry.qualified_cop_name(&#39;Lint/EndOfLine&#39;, &#39;&#39;) # =&gt; &#39;Layout/EndOfLine&#39;</span>
<span class="ruby-comment"># @example namespaces bare cop identifiers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   registry = RuboCop::Cop::Registry</span>
<span class="ruby-comment">#   registry.qualified_cop_name(&#39;EndOfLine&#39;, &#39;&#39;) # =&gt; &#39;Layout/EndOfLine&#39;</span>
<span class="ruby-comment"># @example passes back unrecognized cop names</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   registry = RuboCop::Cop::Registry</span>
<span class="ruby-comment">#   registry.qualified_cop_name(&#39;NotACop&#39;, &#39;&#39;) # =&gt; &#39;NotACop&#39;</span>
<span class="ruby-comment"># @note Emits a warning if the provided name has an incorrect namespace</span>
<span class="ruby-comment"># @param name [String] Cop name extracted from config</span>
<span class="ruby-comment"># @param path [String, nil] Path of file that `name` was extracted from</span>
<span class="ruby-comment"># @param warn [Boolean] Print a warning if no department given for `name`</span>
<span class="ruby-comment"># @raise [AmbiguousCopName] if a bare identifier with two possible namespaces is provided</span>
<span class="ruby-comment"># @return [String] Qualified cop name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_cop_name</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">path</span>, <span class="ruby-value">warn:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualify_badge</span>(<span class="ruby-identifier">badge</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Hash{String =&gt; Array&lt;Class&gt;}]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unqualified_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Registry] Cops for that specific department.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Registry] Cops not for a specific department.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear_enrollment_queue</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">reg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registered?</span>(<span class="ruby-identifier">badge</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_badge</span>(<span class="ruby-identifier">given_badge</span>, <span class="ruby-identifier">real_badge</span>, <span class="ruby-identifier">source_path</span>, <span class="ruby-value">warn:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute global.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#274</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_cop?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#26</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualified_cop_name</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">origin</span>, <span class="ruby-value">warn:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset!</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Changes momentarily the global registry</span>
  <span class="ruby-comment"># Intended for testing purposes</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/registry.rb#32</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_temporary_global</span>(<span class="ruby-identifier">temp_global</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Ensure a require statement is present for a standard library determined # by variable library_name # # source://rubocop//lib/rubocop/cop/mixin/require_library.rb#7 module RuboCop::Cop::RequireLibrary</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_required</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">library_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_subsequent_requires</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">library_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_any_library?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_library_name?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/require_library.rb#10 RuboCop::Cop::RequireLibrary::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># This class ensures a require statement is present for a standard library # determined by the variable library_name # # source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#7 class RuboCop::Cop::RequireLibraryCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">library_name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/require_library_corrector.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_statement</span>(<span class="ruby-identifier">library_name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking ‘rescue` nodes. # # source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#6 module RuboCop::Cop::RescueNode</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_locations</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use ResbodyNode#exceptions instead</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/rescue_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescued_exceptions</span>(<span class="ruby-identifier">resbody</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for safe assignment. By safe assignment we mean # putting parentheses around an assignment to indicate “I know I’m using an # assignment as a condition. It’s not a mistake.” # # source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#8 module RuboCop::Cop::SafeAssignment</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_condition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setter_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/safe_assignment.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_assignment_allowed?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#5 module RuboCop::Cop::Security; end</p>

<p># Checks for implementations of the ‘hash` method which combine # values using custom logic instead of delegating to `Array#hash`. # # Manually combining hashes is error prone and hard to follow, especially # when there are many values. Poor implementations may also introduce # performance or security concerns if they are prone to collisions. # Delegating to `Array#hash` is clearer and safer, although it might be slower # depending on the use case. # # @example # #   # bad #   def hash #   @foo ^ @bar #   end # #   # good #   def hash #   [@foo, @bar].hash #   end # # source://rubocop//lib/rubocop/cop/security/compound_hash.rb#30 class RuboCop::Cop::Security::CompoundHash &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_hash_combinator?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contained_in_hash_method?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dynamic_hash_method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">monuple_hash?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">outer_bad_hash_combinator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_hash?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">static_hash_method_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#31 RuboCop::Cop::Security::CompoundHash::COMBINATOR_IN_HASH_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#32 RuboCop::Cop::Security::CompoundHash::MONUPLE_HASH_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#34 RuboCop::Cop::Security::CompoundHash::REDUNDANT_HASH_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/compound_hash.rb#35 RuboCop::Cop::Security::CompoundHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of ‘Kernel#eval` and `Binding#eval`. # # @example # #   # bad # #   eval(something) #   binding.eval(something) #   Kernel.eval(something) # # source://rubocop//lib/rubocop/cop/security/eval.rb#15 class RuboCop::Cop::Security::Eval &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/eval.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eval?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/eval.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/eval.rb#16 RuboCop::Cop::Security::Eval::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/eval.rb#17 RuboCop::Cop::Security::Eval::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the first argument to ‘IO.read`, `IO.binread`, `IO.write`, `IO.binwrite`, # `IO.foreach`, and `IO.readlines`. # # If argument starts with a pipe character (`’|‘`) and the receiver is the `IO` class, # a subprocess is created in the same way as `Kernel#open`, and its output is returned. # `Kernel#open` may allow unintentional command injection, which is the reason these # `IO` methods are a security risk. # Consider to use `File.read` to disable the behavior of subprocess invocation. # # @example # #   # bad #   IO.read(path) #   IO.read(’path’) # #   # good #   File.read(path) #   File.read(‘path’) #   IO.read(‘| command’) # Allow intentional command invocation. # # source://rubocop//lib/rubocop/cop/security/io_methods.rb#30 class RuboCop::Cop::Security::IoMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/io_methods.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/io_methods.rb#33 RuboCop::Cop::Security::IoMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/io_methods.rb#34 RuboCop::Cop::Security::IoMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of JSON class methods which have potential # security issues. # # @example #   # bad #   JSON.load(“{}”) #   JSON.restore(“{}”) # #   # good #   JSON.parse(“{}”) # # source://rubocop//lib/rubocop/cop/security/json_load.rb#26 class RuboCop::Cop::Security::JSONLoad &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/json_load.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">json_load</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/json_load.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/json_load.rb#29 RuboCop::Cop::Security::JSONLoad::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/json_load.rb#30 RuboCop::Cop::Security::JSONLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of Marshal class methods which have # potential security issues leading to remote code execution when # loading from an untrusted source. # # @example #   # bad #   Marshal.load(“{}”) #   Marshal.restore(“{}”) # #   # good #   Marshal.dump(“{}”) # #   # okish - deep copy hack #   Marshal.load(Marshal.dump({})) # # source://rubocop//lib/rubocop/cop/security/marshal_load.rb#21 class RuboCop::Cop::Security::MarshalLoad &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/marshal_load.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marshal_load</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/marshal_load.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/marshal_load.rb#22 RuboCop::Cop::Security::MarshalLoad::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/marshal_load.rb#23 RuboCop::Cop::Security::MarshalLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of ‘Kernel#open` and `URI.open` with dynamic # data. # # `Kernel#open` and `URI.open` enable not only file access but also process # invocation by prefixing a pipe symbol (e.g., `open(“| ls”)`). # So, it may lead to a serious security risk by using variable input to # the argument of `Kernel#open` and `URI.open`. It would be better to use # `File.open`, `IO.popen` or `URI.parse#open` explicitly. # # NOTE: `open` and `URI.open` with literal strings are not flagged by this # cop. # # @example #   # bad #   open(something) #   open(“| #{something}”) #   open(“| foo”) #   URI.open(something) # #   # good #   File.open(something) #   IO.popen(something) #   URI.parse(something).open # #   # good (literal strings) #   open(“foo.text”) #   URI.open(“<a href="http://example.com">example.com</a>”) #   URI.parse(url).open # # source://rubocop//lib/rubocop/cop/security/open.rb#38 class RuboCop::Cop::Security::Open &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">composite_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">concatenated_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolated_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_argument?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/open.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/open.rb#39 RuboCop::Cop::Security::Open::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/open.rb#40 RuboCop::Cop::Security::Open::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of YAML class methods which have # potential security issues leading to remote code execution when # loading from an untrusted source. # # NOTE: Ruby 3.1+ (Psych 4) uses ‘Psych.load` as `Psych.safe_load` by default. # # @example #   # bad #   YAML.load(“— !ruby/object:Foo {}”) # Psych 3 is unsafe by default # #   # good #   YAML.safe_load(“— !ruby/object:Foo {}”, [Foo])                    # Ruby 2.5  (Psych 3) #   YAML.safe_load(“— !ruby/object:Foo {}”, permitted_classes: [Foo]) # Ruby 3.0- (Psych 3) #   YAML.load(“— !ruby/object:Foo {}”, permitted_classes: [Foo])      # Ruby 3.1+ (Psych 4) #   YAML.dump(foo) # # source://rubocop//lib/rubocop/cop/security/yaml_load.rb#26 class RuboCop::Cop::Security::YAMLLoad &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/yaml_load.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/security/yaml_load.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yaml_load</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/security/yaml_load.rb#30 RuboCop::Cop::Security::YAMLLoad::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/security/yaml_load.rb#31 RuboCop::Cop::Security::YAMLLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Severity class is simple value object about severity # # source://rubocop//lib/rubocop/cop/severity.rb#6 class RuboCop::Cop::Severity</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [Severity] a new instance of Severity</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">name_or_code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">code</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">level</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Symbol] severity.</span>
<span class="ruby-comment">#   any of `:info`, `:refactor`, `:convention`, `:warning`, `:error` or `:fatal`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/severity.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name_from_code</span>(<span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/severity.rb#12 RuboCop::Cop::Severity::CODE_TABLE = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/severity.rb#9 RuboCop::Cop::Severity::NAMES = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for cops checking for missing space after # punctuation. # # source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#7 module RuboCop::Cop::SpaceAfterPunctuation</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_type?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_missing_space</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The normal offset, i.e., the distance from the punctuation</span>
<span class="ruby-comment"># token where a space should be, is 1.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_forbidden_before_rcurly?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_missing?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_required_before?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/space_after_punctuation.rb#8 RuboCop::Cop::SpaceAfterPunctuation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for cops checking for space before # punctuation. # # source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#7 module RuboCop::Cop::SpaceBeforePunctuation</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_missing_space</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_missing?</span>(<span class="ruby-identifier">token1</span>, <span class="ruby-identifier">token2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_required_after?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_required_after_lcurly?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/space_before_punctuation.rb#10 RuboCop::Cop::SpaceBeforePunctuation::MSG = T.let(T.unsafe(nil), String)</p>

<p># This autocorrects whitespace # # source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#6 class RuboCop::Cop::SpaceCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_space</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_corrections</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">empty_config</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute processed_source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/space_corrector.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_space</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for modifier cops. # # source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#6 module RuboCop::Cop::StatementModifier</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">code_after</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_disables_cop?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_line_comment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_body_source</span>(<span class="ruby-identifier">if_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length_in_modifier_form</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_source</span>(<span class="ruby-identifier">if_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_fits_on_single_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_eligible_body?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_eligible_condition?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_eligible_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">omitted_value_in_last_hash_arg?</span>(<span class="ruby-identifier">if_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesize?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_as_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/statement_modifier.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_modifier_form</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Classes that include this module just implement functions to determine # what is an offense and how to do autocorrection. They get help with # adding offenses for the faulty string nodes, and with filtering out # nodes. # # source://rubocop//lib/rubocop/cop/mixin/string_help.rb#9 module RuboCop::Cop::StringHelp</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_help.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_help.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_help.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This autocorrects string literals # # source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#6 class RuboCop::Cop::StringLiteralCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Util</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/string_literal_corrector.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for cops checking single/double quotes. # # source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#6 module RuboCop::Cop::StringLiteralsHelp</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_double_quotes?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_string_literal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literals_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/string_literals_help.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrong_quotes?</span>(<span class="ruby-identifier">src_or_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#5 module RuboCop::Cop::Style; end</p>

<p># Access modifiers should be declared to apply to a group of methods # or inline before each method, depending on configuration. # EnforcedStyle config covers only method definitions. # Applications of visibility methods to symbols can be controlled # using AllowModifiersOnSymbols config. # Also, the visibility of ‘attr*` methods can be controlled using # AllowModifiersOnAttrs config. # # In Ruby 3.0, `attr*` methods now return an array of defined method names # as symbols. So we can write the modifier and `attr*` in inline style. # AllowModifiersOnAttrs config allows `attr*` methods to be written in # inline style without modifying applications that have been maintained # for a long time in group style. Furthermore, developers who are not very # familiar with Ruby may know that the modifier applies to `def`, but they # may not know that it also applies to `attr*` methods. It would be easier # to understand if we could write `attr*` methods in inline style. # # @example AllowModifiersOnAliasMethod: false #   # bad #   class Foo # #   public alias_method :bar, :foo #   protected alias_method :baz, :foo #   private alias_method :qux, :foo # #   end # @example EnforcedStyle: inline #   # bad #   class Foo # #   private # #   def bar; end #   def baz; end # #   end # #   # good #   class Foo # #   private def bar; end #   private def baz; end # #   end # @example AllowModifiersOnSymbols: true (default) #   # good #   class Foo # #   private :bar, :baz #   private *%i[qux quux] #   private *METHOD_NAMES #   private *private_methods # #   end # @example AllowModifiersOnSymbols: false #   # bad #   class Foo # #   private :bar, :baz #   private *%i[qux quux] #   private *METHOD_NAMES #   private *private_methods # #   end # @example AllowModifiersOnAttrs: true (default) #   # good #   class Foo # #   public attr_reader :bar #   protected attr_writer :baz #   private attr_accessor :qux #   private attr :quux # #   def public_method; end # #   private # #   def private_method; end # #   end # @example AllowModifiersOnAttrs: false #   # bad #   class Foo # #   public attr_reader :bar #   protected attr_writer :baz #   private attr_accessor :qux #   private attr :quux # #   end # @example AllowModifiersOnAliasMethod: true (default) #   # good #   class Foo # #   public alias_method :bar, :foo #   protected alias_method :baz, :foo #   private alias_method :qux, :foo # #   end # @example EnforcedStyle: group (default) #   # bad #   class Foo # #   private def bar; end #   private def baz; end # #   end # #   # good #   class Foo # #   private # #   def bar; end #   def baz; end # #   end # # source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#135 class RuboCop::Cop::Style::AccessModifierDeclarations &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_with_alias_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_with_attr?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_with_symbol?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#263</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_is_inlined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier_is_not_inlined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_modifiers_on_alias_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_modifiers_on_attrs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_modifiers_on_symbols?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_group_style</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_inline_style</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable_group_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#356</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_source</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">def_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_argument_less_modifier_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#291</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_corresponding_def_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inline_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_inline_modifier</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">modifier_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_symbol_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_modifier_node_within_begin</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">modifier_node</span>, <span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#344</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_nodes</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_defs</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">def_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_siblings_same_inline_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_grouped_def_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#141 RuboCop::Cop::Style::AccessModifierDeclarations::GROUP_STYLE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#146 RuboCop::Cop::Style::AccessModifierDeclarations::INLINE_STYLE_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/access_modifier_declarations.rb#151 RuboCop::Cop::Style::AccessModifierDeclarations::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for grouping of accessors in ‘class` and `module` bodies. # By default it enforces accessors to be placed in grouped declarations, # but it can be configured to enforce separating them in multiple declarations. # # NOTE: If there is a method call before the accessor method it is always allowed # as it might be intended like Sorbet. # # NOTE: If there is a RBS::Inline annotation comment just after the accessor method # it is always allowed. # # @example EnforcedStyle: grouped (default) #   # bad #   class Foo #   attr_reader :bar #   attr_reader :bax #   attr_reader :baz #   end # #   # good #   class Foo #   attr_reader :bar, :bax, :baz #   end # #   # good #   class Foo #   # may be intended comment for bar. #   attr_reader :bar # #   sig { returns(String) } #   attr_reader :bax # #   may_be_intended_annotation :baz #   attr_reader :baz #   end # @example EnforcedStyle: separated #   # bad #   class Foo #   attr_reader :bar, :baz #   end # #   # good #   class Foo #   attr_reader :bar #   attr_reader :baz #   end # # source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#53 class RuboCop::Cop::Style::AccessorGrouping &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_send_elements</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_accessors</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">accessors</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">groupable_accessor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">groupable_sibling_accessor?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sibling</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">groupable_sibling_accessors</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grouped_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_accessors</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">previous_line_comment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separate_accessors</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separated_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Group after constants</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_for_grouping?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#59 RuboCop::Cop::Style::AccessorGrouping::GROUPED_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/accessor_grouping.rb#60 RuboCop::Cop::Style::AccessorGrouping::SEPARATED_MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of either ‘#alias` or `#alias_method` # depending on configuration. # It also flags uses of `alias :symbol` rather than `alias bareword`. # # However, it will always enforce `method_alias` when used `alias` # in an instance method definition and in a singleton method definition. # If used in a block, always enforce `alias_method` # unless it is an `instance_eval` block. # # @example EnforcedStyle: prefer_alias (default) #   # bad #   alias_method :bar, :foo #   alias :bar :foo # #   # good #   alias bar foo # @example EnforcedStyle: prefer_alias_method #   # bad #   alias :bar :foo #   alias bar foo # #   # good #   alias_method :bar, :foo # # source://rubocop//lib/rubocop/cop/style/alias.rb#31 class RuboCop::Cop::Style::Alias &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_alias</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_args</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alias_keyword_possible?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alias_method_possible?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bareword?</span>(<span class="ruby-identifier">sym_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_alias_method_to_alias</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_alias_to_alias_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_alias_with_symbol_args</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identifier</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lexical_scope_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># In this expression, will `self` be the same as the innermost enclosing</span>
<span class="ruby-comment"># class or module block (:lexical)? Or will it be something else</span>
<span class="ruby-comment"># (:dynamic)? If we&#39;re in an instance_eval block, return that.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/alias.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/alias.rb#35 RuboCop::Cop::Style::Alias::MSG_ALIAS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/alias.rb#36 RuboCop::Cop::Style::Alias::MSG_ALIAS_METHOD = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/alias.rb#37 RuboCop::Cop::Style::Alias::MSG_SYMBOL_ARGS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/alias.rb#39 RuboCop::Cop::Style::Alias::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for endless methods inside operations of lower precedence (‘and`, `or`, and # modifier forms of `if`, `unless`, `while`, `until`) that are ambiguous due to # lack of parentheses. This may lead to unexpected behavior as the code may appear # to use these keywords as part of the method but in fact they modify # the method definition itself. # # In these cases, using a normal method definition is more clear. # # @example # #   # bad #   def foo = true if bar # #   # good - using a non-endless method is more explicit #   def foo #   true #   end if bar # #   # ok - method body is explicit #   def foo = (true if bar) # #   # ok - method definition is explicit #   (def foo = true) if bar # # source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#29 class RuboCop::Cop::Style::AmbiguousEndlessMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndlessMethodRewriter</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_endless_method_body</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>(<span class="ruby-identifier">operation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_form?</span>(<span class="ruby-identifier">operation</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/ambiguous_endless_method_definition.rb#37 RuboCop::Cop::Style::AmbiguousEndlessMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of ‘and` and `or`, and suggests using `&amp;&amp;` and # `||` instead. It can be configured to check only in conditions or in # all contexts. # # @example EnforcedStyle: conditionals (default) #   # bad #   if foo and bar #   end # #   # good #   foo.save &amp;&amp; return # #   # good #   foo.save and return # #   # good #   if foo &amp;&amp; bar #   end # @example EnforcedStyle: always #   # bad #   foo.save and return # #   # bad #   if foo and bar #   end # #   # good #   foo.save &amp;&amp; return # #   # good #   if foo &amp;&amp; bar #   end # # source://rubocop//lib/rubocop/cop/style/and_or.rb#44 class RuboCop::Cop::Style::AndOr &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># ! is a special case:</span>
<span class="ruby-comment"># &#39;x and !obj.method arg&#39; can be autocorrected if we</span>
<span class="ruby-comment"># recurse down a level and add parens to &#39;obj.method arg&#39;</span>
<span class="ruby-comment"># however, &#39;not x&#39; also parses as (send x :!)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_not</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_other</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_send</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_setter</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable_send?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_operator_precedence</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_conditionals</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_logical_operator</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/and_or.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_before_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/and_or.rb#49 RuboCop::Cop::Style::AndOr::MSG = T.let(T.unsafe(nil), String)</p>

<p># In Ruby 2.7, arguments forwarding has been added. # # This cop identifies places where ‘do_something(*args, &amp;block)` # can be replaced by `do_something(…)`. # # In Ruby 3.1, anonymous block forwarding has been added. # # This cop identifies places where `do_something(&amp;block)` can be replaced # by `do_something(&amp;)`; if desired, this functionality can be disabled # by setting `UseAnonymousForwarding: false`. # # In Ruby 3.2, anonymous args/kwargs forwarding has been added. # # This cop also identifies places where `+use_args(*args)+`/`+use_kwargs(**kwargs)+` can be # replaced by `+use_args(*)+`/`+use_kwargs(**)+`; if desired, this functionality can be # disabled by setting `UseAnonymousForwarding: false`. # # And this cop has `RedundantRestArgumentNames`, `RedundantKeywordRestArgumentNames`, # and `RedundantBlockArgumentNames` options. This configuration is a list of redundant names # that are sufficient for anonymizing meaningless naming. # # Meaningless names that are commonly used can be anonymized by default: # e.g., `+*args+`, `+**options+`, `&amp;block`, and so on. # # Names not on this list are likely to be meaningful and are allowed by default. # # This cop handles not only method forwarding but also forwarding to `super`. # # [NOTE] # ==== # Because of a bug in Ruby 3.3.0, when a block is referenced inside of another block, # no offense will be registered until Ruby 3.4: # # [source,ruby] # —- # def foo(&amp;block) #   # Using an anonymous block would be a syntax error on Ruby 3.3.0 #   block_method { bar(&amp;block) } # end # —- # ==== # # @example RedundantBlockArgumentNames: [’blk’, ‘block’, ‘proc’] (default) #   # bad - But it is good with ‘EnforcedStyle: explicit` set for `Naming/BlockForwarding`. #   def foo(&amp;block) #   bar(&amp;block) #   end # #   # good #   def foo(&amp;) #   bar(&amp;) #   end # @example UseAnonymousForwarding: true (default, only relevant for Ruby &gt;= 3.2) #   # bad #   def foo(*args, **kwargs, &amp;block) #   args_only(*args) #   kwargs_only(**kwargs) #   block_only(&amp;block) #   end # #   # good #   def foo(*, **, &amp;) #   args_only(*) #   kwargs_only(**) #   block_only(&amp;) #   end # @example UseAnonymousForwarding: false (only relevant for Ruby &gt;= 3.2) #   # good #   def foo(*args, **kwargs, &amp;block) #   args_only(*args) #   kwargs_only(**kwargs) #   block_only(&amp;block) #   end # @example AllowOnlyRestArgument: true (default, only relevant for Ruby &lt; 3.2) #   # good #   def foo(*args) #   bar(*args) #   end # #   def foo(**kwargs) #   bar(**kwargs) #   end # @example AllowOnlyRestArgument: false (only relevant for Ruby &lt; 3.2) #   # bad #   # The following code can replace the arguments with `…`, #   # but it will change the behavior. Because `…` forwards block also. #   def foo(*args) #   bar(*args) #   end # #   def foo(**kwargs) #   bar(**kwargs) #   end # @example RedundantRestArgumentNames: [’args’, ‘arguments’] (default) #   # bad #   def foo(*args) #   bar(*args) #   end # #   # good #   def foo(*) #   bar(*) #   end # @example RedundantKeywordRestArgumentNames: [‘kwargs’, ‘options’, ‘opts’] (default) #   # bad #   def foo(**kwargs) #   bar(**kwargs) #   end # #   # good #   def foo(**) #   bar(**) #   end # @example #   # bad #   def foo(*args, &amp;block) #   bar(*args, &amp;block) #   end # #   # bad #   def foo(*args, **kwargs, &amp;block) #   bar(*args, **kwargs, &amp;block) #   end # #   # good #   def foo(…) #   bar(…) #   end # # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#141 class RuboCop::Cop::Style::ArgumentsForwarding &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_forward_all_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">send_classifications</span>, <span class="ruby-identifier">forwardable_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parens_if_missing</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_post_ruby_32_offenses</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">send_classifications</span>, <span class="ruby-identifier">forwardable_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if forwarding is uses both in blocks and outside of blocks.</span>
<span class="ruby-comment"># On Ruby 3.3.0, anonymous block forwarding in blocks can be is a syntax</span>
<span class="ruby-comment"># error, so we only want to register an offense if we can change all occurrences.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#309</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_forwarding_offenses_correctable?</span>(<span class="ruby-identifier">send_classifications</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Ruby 3.3.0 had a bug where accessing an anonymous block argument inside of a block</span>
<span class="ruby-comment"># was a syntax error in unambiguous cases: https://bugs.ruby-lang.org/issues/20090</span>
<span class="ruby-comment"># We disallow this also for earlier Ruby versions so that code is forwards compatible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_anonymous_forwarding_in_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_only_rest_arguments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">first_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classification_and_forwards</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">referenced_lvars</span>, <span class="ruby-identifier">forwardable_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classify_send_nodes</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">send_nodes</span>, <span class="ruby-identifier">referenced_lvars</span>, <span class="ruby-identifier">forwardable_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#564</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_block_name?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_forwardable_args</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_splat_or_block_pass_lvar_references</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_forwards_all?</span>(<span class="ruby-identifier">send_classifications</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_forwardable_named_args</span>(<span class="ruby-identifier">restarg</span>, <span class="ruby-identifier">kwrestarg</span>, <span class="ruby-identifier">blockarg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_named_arg</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">config_name</span>, <span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#354</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forward_all_offense</span>(<span class="ruby-identifier">def_or_send</span>, <span class="ruby-identifier">send_or_arguments</span>, <span class="ruby-identifier">rest_or_splat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forward_args_offense</span>(<span class="ruby-identifier">def_arguments_or_send</span>, <span class="ruby-identifier">rest_arg_or_splat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#343</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forward_block_arg_offense</span>(<span class="ruby-identifier">add_parens</span>, <span class="ruby-identifier">def_arguments_or_send</span>, <span class="ruby-identifier">block_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_forward_kwargs_offense</span>(<span class="ruby-identifier">add_parens</span>, <span class="ruby-identifier">def_arguments_or_send</span>, <span class="ruby-identifier">kwrest_arg_or_splat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_anonymous_forwarding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#156</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#149 RuboCop::Cop::Style::ArgumentsForwarding::ADDITIONAL_ARG_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#152 RuboCop::Cop::Style::ArgumentsForwarding::ARGS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#154 RuboCop::Cop::Style::ArgumentsForwarding::BLOCK_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#148 RuboCop::Cop::Style::ArgumentsForwarding::FORWARDING_LVAR_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#151 RuboCop::Cop::Style::ArgumentsForwarding::FORWARDING_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#153 RuboCop::Cop::Style::ArgumentsForwarding::KWARGS_MSG = T.let(T.unsafe(nil), String)</p>

<p># Classifies send nodes for possible rest/kwrest/all (including block) forwarding. # # source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#393 class RuboCop::Cop::Style::ArgumentsForwarding::SendNodeClassifier</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [SendNodeClassifier] a new instance of SendNodeClassifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#422</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">send_node</span>, <span class="ruby-identifier">referenced_lvars</span>, <span class="ruby-identifier">forwardable_args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#450</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classification</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_all_anonymous_args?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_forwarded_kwrest_arg</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_block_arg</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_block_arg?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#438</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_kwrest_arg</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#432</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_rest_arg</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#397</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_rest_arg?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_all_anonymous_args?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#535</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">additional_kwargs?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#531</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">additional_kwargs_or_forwarded_kwargs?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#545</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_offense_for_no_block?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#516</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_arg_referenced?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#500</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#465</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_forward_all?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#539</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward_additional_kwargs?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#496</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_rest_and_kwrest_args</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#558</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_rest_arg_or_kwrest_arg?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#549</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_additional_args?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#524</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_post_splat_args?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#492</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive_block_forwarding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#512</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced_block_arg?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#508</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced_kwrest_arg?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#504</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced_rest_arg?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># def foo(a = 41, ...) is a syntax error in 3.0.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#477</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_30_or_lower_optarg?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_32_only_anonymous_forwarding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#488</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_32_or_higher_missing_rest_or_kwest?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/arguments_forwarding.rb#520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby_version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Enforces the use of ‘Array()` instead of explicit `Array` check or `[*var]`. # # The cop is disabled by default due to safety concerns. # # @example #   # bad #   paths = [paths] unless paths.is_a?(Array) #   paths.each { |path| do_something(path) } # #   # bad (always creates a new Array instance) #   [*paths].each { |path| do_something(path) } # #   # good (and a bit more readable) #   Array(paths).each { |path| do_something(path) } # # source://rubocop//lib/rubocop/cop/style/array_coercion.rb#41 class RuboCop::Cop::Style::ArrayCoercion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_splat?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_array?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#45 RuboCop::Cop::Style::ArrayCoercion::CHECK_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_coercion.rb#44 RuboCop::Cop::Style::ArrayCoercion::SPLAT_MSG = T.let(T.unsafe(nil), String)</p>

<p># Identifies usages of ‘<a href="0">arr</a>` and `<a href="-1">arr</a>` and suggests to change # them to use `arr.first` and `arr.last` instead. # # The cop is disabled by default due to safety concerns. # # @example #   # bad #   <a href="0">arr</a> #   <a href="-1">arr</a> # #   # good #   arr.first #   arr.last #   <a href="0">arr</a> = 2 #   <a href="0">arr</a>[-2] # # source://rubocop//lib/rubocop/cop/style/array_first_last.rb#28 class RuboCop::Cop::Style::ArrayFirstLast &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brace_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">innermost_braces_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_value</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#31 RuboCop::Cop::Style::ArrayFirstLast::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_first_last.rb#32 RuboCop::Cop::Style::ArrayFirstLast::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># In Ruby 3.1, ‘Array#intersect?` has been added. # # This cop identifies places where `(array1 &amp; array2).any?` # or `(array1.intersection(array2)).any?` can be replaced by # `array1.intersect?(array2)`. # # The `array1.intersect?(array2)` method is faster than # `(array1 &amp; array2).any?` and is more readable. # # In cases like the following, compatibility is not ensured, # so it will not be detected when using block argument. # # [source,ruby] # —- # ([1] &amp; [1,2]).any? { |x| false }    # =&gt; false # [<a href="1,2">1].intersect?(</a>) { |x| false } # =&gt; true # —- # # NOTE: Although `Array#intersection` can take zero or multiple arguments, # only cases where exactly one argument is provided can be replaced with # `Array#intersect?` and are handled by this cop. # # @example #   # bad #   (array1 &amp; array2).any? #   (array1 &amp; array2).empty? #   (array1 &amp; array2).none? # #   # bad #   array1.intersection(array2).any? #   array1.intersection(array2).empty? #   array1.intersection(array2).none? # #   # good #   array1.intersect?(array2) #   !array1.intersect?(array2) # @example AllCops:ActiveSupportExtensionsEnabled: false (default) #   # good #   (array1 &amp; array2).present? #   (array1 &amp; array2).blank? # @example AllCops:ActiveSupportExtensionsEnabled: true #   # bad #   (array1 &amp; array2).present? #   (array1 &amp; array2).blank? # #   # good #   array1.intersect?(array2) #   !array1.intersect?(array2) # # source://rubocop//lib/rubocop/cop/style/array_intersect.rb#60 class RuboCop::Cop::Style::ArrayIntersect &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_intersection_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_intersection?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">receiver</span>, <span class="ruby-identifier">argument</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">dot</span>, <span class="ruby-identifier">existing</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">straight?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#67 RuboCop::Cop::Style::ArrayIntersect::ACTIVE_SUPPORT_PREDICATES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#80 RuboCop::Cop::Style::ArrayIntersect::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#83 RuboCop::Cop::Style::ArrayIntersect::NEGATED_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#66 RuboCop::Cop::Style::ArrayIntersect::PREDICATES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#84 RuboCop::Cop::Style::ArrayIntersect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_intersect.rb#82 RuboCop::Cop::Style::ArrayIntersect::STRAIGHT_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of “*” as a substitute for <em>join</em>. # # Not all cases can reliably checked, due to Ruby’s dynamic # types, so we consider only cases when the first argument is an # array literal or the second is a string literal. # # @example # #   # bad #   %w(foo bar baz) * “,” # #   # good #   %w(foo bar baz).join(“,”) # # source://rubocop//lib/rubocop/cop/style/array_join.rb#20 class RuboCop::Cop::Style::ArrayJoin &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_join.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">join_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/array_join.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/array_join.rb#23 RuboCop::Cop::Style::ArrayJoin::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/array_join.rb#24 RuboCop::Cop::Style::ArrayJoin::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#16 class RuboCop::Cop::Style::AsciiComments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_non_ascii_chars</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_non_ascii_chars</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_offense_range</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_allowed_non_ascii_chars?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/ascii_comments.rb#19 RuboCop::Cop::Style::AsciiComments::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of Module#attr. # # @example #   # bad - creates a single attribute accessor (deprecated in Ruby 1.9) #   attr :something, true #   attr :one, :two, :three # behaves as attr_reader # #   # good #   attr_accessor :something #   attr_reader :one, :two, :three # # source://rubocop//lib/rubocop/cop/style/attr.rb#17 class RuboCop::Cop::Style::Attr &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_eval?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_context?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_attr_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/attr.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/attr.rb#21 RuboCop::Cop::Style::Attr::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/attr.rb#22 RuboCop::Cop::Style::Attr::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for cases when you could use a block # accepting version of a method that does automatic # resource cleanup. # # @example # #   # bad #   f = File.open(‘file’) # #   # good #   File.open(‘file’) do |f| #   # … #   end # #   # bad #   f = Tempfile.open(‘temp’) # #   # good #   Tempfile.open(‘temp’) do |f| #   # … #   end # # source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#27 class RuboCop::Cop::Style::AutoResourceCleanup &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cleanup?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#28 RuboCop::Cop::Style::AutoResourceCleanup::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/auto_resource_cleanup.rb#29 RuboCop::Cop::Style::AutoResourceCleanup::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks if usage of %() or %Q() matches configuration. # # @example EnforcedStyle: bare_percent (default) #   # bad #   %Q(He said: “#{greeting}”) #   %q{She said: ‘Hi’} # #   # good #   %(He said: “#{greeting}”) #   %{She said: ‘Hi’} # @example EnforcedStyle: percent_q #   # bad #   %|He said: “#{greeting}”| #   %/She said: ‘Hi’/ # #   # good #   %Q|He said: “#{greeting}”| #   %q/She said: ‘Hi’/ # # source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#26 class RuboCop::Cop::Style::BarePercentLiterals &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_wrong_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">good</span>, <span class="ruby-identifier">bad</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_bare_percent?</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_percent_q?</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/bare_percent_literals.rb#30 RuboCop::Cop::Style::BarePercentLiterals::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for BEGIN blocks. # # @example #   # bad #   BEGIN { test } # # source://rubocop//lib/rubocop/cop/style/begin_block.rb#12 class RuboCop::Cop::Style::BeginBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/begin_block.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_preexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/begin_block.rb#13 RuboCop::Cop::Style::BeginBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for places where ‘attr_reader` and `attr_writer` # for the same method can be combined into single `attr_accessor`. # # @example #   # bad #   class Foo #   attr_reader :bar #   attr_writer :bar #   end # #   # good #   class Foo #   attr_accessor :bar #   end # # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#21 class RuboCop::Cop::Style::BisectedAttrAccessor &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># Each offending macro is captured and registered in `on_class` but correction</span>
<span class="ruby-comment"># happens in `after_class` because a macro might have multiple attributes</span>
<span class="ruby-comment"># rewritten from it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_class</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Each offending macro is captured and registered in `on_class` but correction</span>
<span class="ruby-comment"># happens in `after_class` because a macro might have multiple attributes</span>
<span class="ruby-comment"># rewritten from it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_module</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Each offending macro is captured and registered in `on_class` but correction</span>
<span class="ruby-comment"># happens in `after_class` because a macro might have multiple attributes</span>
<span class="ruby-comment"># rewritten from it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_sclass</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_reader</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">macro</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_writer</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">macro</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_bisection</span>(<span class="ruby-identifier">macros</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_macros</span>(<span class="ruby-identifier">class_def</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">attr</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor.rb#27 RuboCop::Cop::Style::BisectedAttrAccessor::MSG = T.let(T.unsafe(nil), String)</p>

<p># Representation of an ‘attr_reader`, `attr_writer` or `attr` macro # for use by `Style/BisectedAttrAccessor`. # # @api private # # source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#10 class RuboCop::Cop::Style::BisectedAttrAccessor::Macro</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Macro] a new instance of Macro</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_bisected?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attr_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attrs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bisect</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bisected_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bisection</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reader?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">writer?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bisected_attr_accessor/macro.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">macro?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Prefer bitwise predicate methods over direct comparison operations. # # @example # #   # bad - checks any set bits #   (variable &amp; flags).positive? # #   # good #   variable.anybits?(flags) # #   # bad - checks all set bits #   (variable &amp; flags) == flags # #   # good #   variable.allbits?(flags) # #   # bad - checks no set bits #   (variable &amp; flags).zero? # #   # good #   variable.nobits?(flags) # # source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#32 class RuboCop::Cop::Style::BitwisePredicate &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allbits?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">anybits?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bit_operation?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nobits?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#36 RuboCop::Cop::Style::BitwisePredicate::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/bitwise_predicate.rb#37 RuboCop::Cop::Style::BitwisePredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for uses of block comments (=begin…=end). # # @example #   # bad #   =begin #   Multiple lines #   of comments… #   =end # #   # good #   # Multiple lines #   # of comments… # # source://rubocop//lib/rubocop/cop/style/block_comments.rb#19 class RuboCop::Cop::Style::BlockComments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_comments.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_comments.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eq_end_part</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_comments.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parts</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/block_comments.rb#24 RuboCop::Cop::Style::BlockComments::BEGIN_LENGTH = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/style/block_comments.rb#25 RuboCop::Cop::Style::BlockComments::END_LENGTH = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/style/block_comments.rb#23 RuboCop::Cop::Style::BlockComments::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check for uses of braces or do/end around single line or # multi-line blocks. # # Methods that can be either procedural or functional and cannot be # categorised from their usage alone is ignored. # ‘lambda`, `proc`, and `it` are their defaults. # Additional methods can be added to the `AllowedMethods`. # # @example AllowedPatterns: [’map’] # #   # good #   things.map { |thing| #   something = thing.some_method #   process(something) #   } # @example EnforcedStyle: semantic #   # Prefer ‘do…end` over `{…}` for procedural blocks. # #   # return value is used/assigned #   # bad #   foo = map do |x| #   x #   end #   puts (map do |x| #   x #   end) # #   # return value is not used out of scope #   # good #   map do |x| #   x #   end # #   # Prefer `{…}` over `do…end` for functional blocks. # #   # return value is not used out of scope #   # bad #   each { |x| #   x #   } # #   # return value is used/assigned #   # good #   foo = map { |x| #   x #   } #   map { |x| #   x #   }.inspect # #   # The AllowBracesOnProceduralOneLiners option is allowed unless the #   # EnforcedStyle is set to `semantic`. If so: # #   # If the AllowBracesOnProceduralOneLiners option is unspecified, or #   # set to `false` or any other falsey value, then semantic purity is #   # maintained, so one-line procedural blocks must use do-end, not #   # braces. # #   # bad #   collection.each { |element| puts element } # #   # good #   collection.each do |element| puts element end # #   # If the AllowBracesOnProceduralOneLiners option is set to `true`, or #   # any other truthy value, then one-line procedural blocks may use #   # either style. (There is no setting for requiring braces on them.) # #   # good #   collection.each { |element| puts element } # #   # also good #   collection.each do |element| puts element end # @example EnforcedStyle: braces_for_chaining #   # bad #   words.each do |word| #   word.flip.flop #   end.join(“-”) # #   # good #   words.each { |word| #   word.flip.flop #   }.join(“-”) # @example EnforcedStyle: always_braces #   # bad #   words.each do |word| #   word.flip.flop #   end # #   # good #   words.each { |word| #   word.flip.flop #   } # @example BracesRequiredMethods: [’sig’] # #   # Methods listed in the BracesRequiredMethods list, such as ‘sig’ #   # in this example, will require ‘{…}` braces. This option takes #   # precedence over all other configurations except AllowedMethods. # #   # bad #   sig do #   params( #   foo: string, #   ).void #   end #   def bar(foo) #   puts foo #   end # #   # good #   sig { #   params( #   foo: string, #   ).void #   } #   def bar(foo) #   puts foo #   end # @example AllowedMethods: [’lambda’, ‘proc’, ‘it’ ] (default) # #   # good #   foo = lambda do |x| #   puts “Hello, #{x}” #   end # #   foo = lambda do |x| #   x * 100 #   end # @example AllowedPatterns: [] (default) # #   # bad #   things.map { |thing| #   something = thing.some_method #   process(something) #   } # @example EnforcedStyle: line_count_based (default) #   # bad - single line block #   items.each do |item| item / 5 end # #   # good - single line block #   items.each { |item| item / 5 } # #   # bad - multi-line block #   things.map { |thing| #   something = thing.some_method #   process(something) #   } # #   # good - multi-line block #   things.map do |thing| #   something = thing.some_method #   process(something) #   end # # source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#168 class RuboCop::Cop::Style::BlockDelimiters &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#484</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_or_range?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#488</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_required?</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_for_chaining_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#429</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_for_chaining_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_required_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_required_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#410</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_required_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#439</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#443</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_would_break_code?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_of_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#453</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">functional_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">functional_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_blocks</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#414</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_count_based_block_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_count_based_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_comment_before_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">comment</span>, <span class="ruby-identifier">block_node</span>, <span class="ruby-identifier">closing_brace</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#461</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">procedural_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#457</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">procedural_oneliners_may_have_braces?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_block_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_trailing_whitespace</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_braces_with_do_end</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_do_end_with_braces</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#386</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_do_end?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#477</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value_of_scope?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#465</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value_used?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantic_block_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantic_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#494</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_argument_operator_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#321</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range_before_comment</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#393</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#399</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_method_proper_block_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_after?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">length</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_before?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#344</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#179</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#175 RuboCop::Cop::Style::BlockDelimiters::ALWAYS_BRACES_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/block_delimiters.rb#177 RuboCop::Cop::Style::BlockDelimiters::BRACES_REQUIRED_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># Corrector to correct conditional assignment in ‘case` statements. # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#618 class RuboCop::Cop::Style::CaseCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalAssignmentHelper</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalCorrectorHelper</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#623</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">cop</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#633</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_assignment_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#653</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_branches</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#647</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_tail_branches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#663</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_branch_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branch</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">assignment</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># If ‘AllowOnSelfClass` option is enabled, the cop will ignore violations when the receiver of # the case equality operator is `self.class`. Note intermediate variables are not accepted. # # @example #   # bad #   (1..100) === 7 #   /something/ === some_string # #   # good #   something.is_a?(Array) #   (1..100).include?(7) #   /something/.match?(some_string) # @example AllowOnConstant: false (default) #   # bad #   Array === something # @example AllowOnConstant: true #   # good #   Array === something # @example AllowOnSelfClass: false (default) #   # bad #   self.class === something # @example AllowOnSelfClass: true #   # good #   self.class === something # # source://rubocop//lib/rubocop/cop/style/case_equality.rb#40 class RuboCop::Cop::Style::CaseEquality &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_equality?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">self_class?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_replacement</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_replacement</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_receiver?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_equality.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_replacement</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/case_equality.rb#43 RuboCop::Cop::Style::CaseEquality::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/case_equality.rb#44 RuboCop::Cop::Style::CaseEquality::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies places where ‘if-elsif` constructions # can be replaced with `case-when`. # # @example MinBranchesCount: 3 (default) #   # bad #   if status == :active #   perform_action #   elsif status == :inactive || status == :hibernating #   check_timeout #   elsif status == :invalid #   report_invalid #   else #   final_action #   end # #   # good #   case status #   when :active #   perform_action #   when :inactive, :hibernating #   check_timeout #   when :invalid #   report_invalid #   else #   final_action #   end # @example MinBranchesCount: 4 #   # good #   if status == :active #   perform_action #   elsif status == :inactive || status == :hibernating #   check_timeout #   elsif status == :invalid #   report_invalid #   else #   final_action #   end # # source://rubocop//lib/rubocop/cop/style/case_like_if.rb#50 class RuboCop::Cop::Style::CaseLikeIf &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MinBranchesCount</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_conditions</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_reference?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_conditions</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>, <span class="ruby-identifier">conditions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_from_binary_op</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_from_equality_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_from_include_or_cover_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_from_match_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_from_send_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_reference?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deparenthesize</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_in_equality_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_in_include_or_cover_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_in_match_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_in_send_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_with_named_captures?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Named captures work with `=~` (if regexp is on lhs) and with `match` (both sides)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_with_working_captures?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_check?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/case_like_if.rb#55 RuboCop::Cop::Style::CaseLikeIf::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of the character literal ?x. # Starting with Ruby 1.9 character literals are # essentially one-character strings, so this syntax # is mostly redundant at this point. # # ? character literal can be used to express meta and control character. # That’s a good use case of ? literal so it doesn’t count it as an offense. # # @example #   # bad #   ?x # #   # good #   ‘x’ # #   # good - control &amp; meta escapes #   ?C-M-d #   “C-M-d” # same as above # # source://rubocop//lib/rubocop/cop/style/character_literal.rb#24 class RuboCop::Cop::Style::CharacterLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/character_literal.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dummy implementation of method in ConfigurableEnforcedStyle that is</span>
<span class="ruby-comment"># called from StringHelp.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/character_literal.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/character_literal.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dummy implementation of method in ConfigurableEnforcedStyle that is</span>
<span class="ruby-comment"># called from StringHelp.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/character_literal.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite_style_detected</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/character_literal.rb#28 RuboCop::Cop::Style::CharacterLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that namespaced classes and modules are defined with a consistent style. # # With ‘nested` style, classes and modules should be defined separately (one constant # on each line, without `::`). With `compact` style, classes and modules should be # defined with fully qualified names (using `::` for namespaces). # # NOTE: The style chosen will affect `Module.nesting` for the class or module. Using # `nested` style will result in each level being added, whereas `compact` style will # only include the fully qualified class or module name. # # By default, `EnforcedStyle` applies to both classes and modules. If desired, separate # styles can be defined for classes and modules by using `EnforcedStyleForClasses` and # `EnforcedStyleForModules` respectively. If not set, or set to nil, the `EnforcedStyle` # value will be used. # # The compact style is only forced for classes/modules with one child. # # @example EnforcedStyle: nested (default) #   # good #   # have each child on its own line #   class Foo #   class Bar #   end #   end # @example EnforcedStyle: compact #   # good #   # combine definitions as much as possible #   class Foo::Bar #   end # # source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#45 class RuboCop::Cop::Style::ClassAndModuleChildren &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_trailing_end</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">padding</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_compact_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_nested_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_definition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_identifier_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_node_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_spaces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needs_compacting?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nest_definition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nest_or_compact</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_end</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_namespace_keyword</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">spaces_size</span>(<span class="ruby-identifier">spaces_string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">split_on_double_colon</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">padding</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_for_classes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_for_modules</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tab_indentation_width</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unindent</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#52 RuboCop::Cop::Style::ClassAndModuleChildren::COMPACT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_and_module_children.rb#51 RuboCop::Cop::Style::ClassAndModuleChildren::NESTED_MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces consistent use of ‘Object#is_a?` or `Object#kind_of?`. # # @example EnforcedStyle: is_a? (default) #   # bad #   var.kind_of?(Date) #   var.kind_of?(Integer) # #   # good #   var.is_a?(Date) #   var.is_a?(Integer) # @example EnforcedStyle: kind_of? #   # bad #   var.is_a?(Time) #   var.is_a?(String) # #   # good #   var.kind_of?(Time) #   var.kind_of?(String) # # source://rubocop//lib/rubocop/cop/style/class_check.rb#26 class RuboCop::Cop::Style::ClassCheck &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_check.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_check.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_check.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_check.rb#30 RuboCop::Cop::Style::ClassCheck::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_check.rb#31 RuboCop::Cop::Style::ClassCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use of ‘Object#instance_of?` instead of class comparison # for equality. # `==`, `equal?`, and `eql?` custom method definitions are allowed by default. # These are customizable with `AllowedMethods` option. # # @example #   # bad #   var.class == Date #   var.class.equal?(Date) #   var.class.eql?(Date) #   var.class.name == ’Date’ # #   # good #   var.instance_of?(Date) # @example AllowedMethods: [‘==’, ‘equal?’, ‘eql?’] (default) #   # good #   def ==(other) #   self.class == other.class &amp;&amp; name == other.name #   end # #   def equal?(other) #   self.class.equal?(other.class) &amp;&amp; name.equal?(other.name) #   end # #   def eql?(other) #   self.class.eql?(other.class) &amp;&amp; name.eql?(other.name) #   end # @example AllowedPatterns: [] (default) #   # bad #   def eq(other) #   self.class.eq(other.class) &amp;&amp; name.eq(other.name) #   end # @example AllowedPatterns: [‘eq’] #   # good #   def eq(other) #   self.class.eq(other.class) &amp;&amp; name.eq(other.name) #   end # # source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#52 class RuboCop::Cop::Style::ClassEqualityComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_comparison_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_name</span>(<span class="ruby-identifier">class_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_name_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">receiver_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_cbase?</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trim_string_quotes</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unable_to_determine_type?</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#61 RuboCop::Cop::Style::ClassEqualityComparison::CLASS_NAME_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#58 RuboCop::Cop::Style::ClassEqualityComparison::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_equality_comparison.rb#60 RuboCop::Cop::Style::ClassEqualityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of the class/module name instead of # self, when defining class/module methods. # # @example #   # bad #   class SomeClass #   def SomeClass.class_method #   # … #   end #   end # #   # good #   class SomeClass #   def self.class_method #   # … #   end #   end # # source://rubocop//lib/rubocop/cop/style/class_methods.rb#23 class RuboCop::Cop::Style::ClassMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_defs</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_methods.rb#26 RuboCop::Cop::Style::ClassMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces using ‘def self.method_name` or `class &lt;&lt; self` to define class methods. # # @example EnforcedStyle: def_self (default) #   # bad #   class SomeClass #   class &lt;&lt; self #   attr_accessor :class_accessor # #   def class_method #   # … #   end #   end #   end # #   # good #   class SomeClass #   def self.class_method #   # … #   end # #   class &lt;&lt; self #   attr_accessor :class_accessor #   end #   end # #   # good - contains private method #   class SomeClass #   class &lt;&lt; self #   attr_accessor :class_accessor # #   private # #   def private_class_method #   # … #   end #   end #   end # @example EnforcedStyle: self_class #   # bad #   class SomeClass #   def self.class_method #   # … #   end #   end # #   # good #   class SomeClass #   class &lt;&lt; self #   def class_method #   # … #   end #   end #   end # # source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#61 class RuboCop::Cop::Style::ClassMethodsDefinitions &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_methods_public?</span>(<span class="ruby-identifier">sclass_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_sclass</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_nodes</span>(<span class="ruby-identifier">sclass_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_self_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_def_from_sclass</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">sclass_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_diff</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sclass_only_has_methods?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#68 RuboCop::Cop::Style::ClassMethodsDefinitions::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_methods_definitions.rb#69 RuboCop::Cop::Style::ClassMethodsDefinitions::MSG_SCLASS = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of class variables. Offenses # are signaled only on assignment to class variables to # reduce the number of offenses that would be reported. # # You have to be careful when setting a value for a class # variable; if a class has been inherited, changing the # value of a class variable also affects the inheriting # classes. This means that it’s almost always better to # use a class instance variable instead. # # @example #   # bad #   class A #   @@test = 10 #   end # #   class A #   def self.test(name, value) #   class_variable_set(“@@#{name}”, value) #   end #   end # #   class A; end #   A.class_variable_set(:@@test, 10) # #   # good #   class A #   @test = 10 #   end # #   class A #   def test #   @@test # you can access class variable without offense #   end #   end # #   class A #   def self.test(name) #   class_variable_get(“@@#{name}”) # you can access without offense #   end #   end # # source://rubocop//lib/rubocop/cop/style/class_vars.rb#48 class RuboCop::Cop::Style::ClassVars &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_vars.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/class_vars.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/class_vars.rb#49 RuboCop::Cop::Style::ClassVars::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/class_vars.rb#50 RuboCop::Cop::Style::ClassVars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where custom logic on rejection nils from arrays # and hashes can be replaced with ‘{Array,Hash}#{compact,compact!}`. # # @example #   # bad #   array.reject(&amp;:nil?) #   array.reject { |e| e.nil? } #   array.select { |e| !e.nil? } #   array.filter { |e| !e.nil? } #   array.grep_v(nil) #   array.grep_v(NilClass) # #   # good #   array.compact # #   # bad #   hash.reject!(&amp;:nil?) #   hash.reject! { |k, v| v.nil? } #   hash.select! { |k, v| !v.nil? } #   hash.filter! { |k, v| !v.nil? } # #   # good #   hash.compact! # @example AllowedReceivers: [’params’] #   # good #   params.reject(&amp;:nil?) # # source://rubocop//lib/rubocop/cop/style/collection_compact.rb#44 class RuboCop::Cop::Style::CollectionCompact &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedReceivers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grep_v_with_nil?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject_method_with_block_pass?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">good_method_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range</span>(<span class="ruby-identifier">begin_pos_node</span>, <span class="ruby-identifier">end_pos_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_enum_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#53 RuboCop::Cop::Style::CollectionCompact::FILTER_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#50 RuboCop::Cop::Style::CollectionCompact::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#51 RuboCop::Cop::Style::CollectionCompact::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_compact.rb#52 RuboCop::Cop::Style::CollectionCompact::TO_ENUM_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use of consistent method names # from the Enumerable module. # # You can customize the mapping from undesired method to desired method. # # e.g. to use ‘detect` over `find`: # #   Style/CollectionMethods: #     PreferredMethods: #       find: detect # # @example #   # These examples are based on the default mapping for `PreferredMethods`. # #   # bad #   items.collect #   items.collect! #   items.collect_concat #   items.inject #   items.detect #   items.find_all #   items.member? # #   # good #   items.map #   items.map! #   items.flat_map #   items.reduce #   items.find #   items.select #   items.include? # # source://rubocop//lib/rubocop/cop/style/collection_methods.rb#43 class RuboCop::Cop::Style::CollectionMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodPreference</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_method_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Some enumerable methods accept a bare symbol (ie. _not_ Symbol#to_proc) instead</span>
<span class="ruby-comment"># of a block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">methods_accepting_symbol</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_methods.rb#47 RuboCop::Cop::Style::CollectionMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># Prefer ‘Enumerable` predicate methods over expressions with `count`. # # The cop checks calls to `count` without arguments, or with a # block. It doesn’t register offenses for ‘count` with a positional # argument because its behavior differs from predicate methods (`count` # matches the argument using `==`, while `any?`, `none?` and `one?` use # `===`). # # NOTE: This cop doesn’t check ‘length` and `size` methods because they # would yield false positives. For example, `String` implements `length` # and `size`, but it doesn’t include ‘Enumerable`. # # @example # #   # bad #   x.count.positive? #   x.count &gt; 0 #   x.count != 0 # #   x.count(&amp;:foo?).positive? #   x.count { |item| item.foo? }.positive? # #   # good #   x.any? # #   x.any?(&amp;:foo?) #   x.any? { |item| item.foo? } # #   # bad #   x.count.zero? #   x.count == 0 # #   # good #   x.none? # #   # bad #   x.count == 1 #   x.one? # @example AllCops:ActiveSupportExtensionsEnabled: false (default) # #   # good #   x.count &gt; 1 # @example AllCops:ActiveSupportExtensionsEnabled: true # #   # bad #   x.count &gt; 1 # #   # good #   x.many? # # source://rubocop//lib/rubocop/cop/style/collection_querying.rb#96 class RuboCop::Cop::Style::CollectionQuerying &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_predicate</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">removal_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_supported?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#100 RuboCop::Cop::Style::CollectionQuerying::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#104 RuboCop::Cop::Style::CollectionQuerying::REPLACEMENTS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/collection_querying.rb#102 RuboCop::Cop::Style::CollectionQuerying::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for methods invoked via the ‘::` operator instead # of the `.` operator (like `FileUtils::rmdir` instead of `FileUtils.rmdir`). # # @example #   # bad #   Timeout::timeout(500) { do_something } #   FileUtils::rmdir(dir) #   Marshal::dump(obj) # #   # good #   Timeout.timeout(500) { do_something } #   FileUtils.rmdir(dir) #   Marshal.dump(obj) # # source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#20 class RuboCop::Cop::Style::ColonMethodCall &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">java_type_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/colon_method_call.rb#23 RuboCop::Cop::Style::ColonMethodCall::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for class methods that are defined using the ‘::` # operator instead of the `.` operator. # # @example #   # bad #   class Foo #   def self::bar #   end #   end # #   # good #   class Foo #   def self.bar #   end #   end # # source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#22 class RuboCop::Cop::Style::ColonMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/colon_method_definition.rb#25 RuboCop::Cop::Style::ColonMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for multiple ‘defined?` calls joined by `&amp;&amp;` that can be combined # into a single `defined?`. # # When checking that a nested constant or chained method is defined, it is # not necessary to check each ancestor or component of the chain. # # @example #   # bad #   defined?(Foo) &amp;&amp; defined?(Foo::Bar) &amp;&amp; defined?(Foo::Bar::Baz) # #   # good #   defined?(Foo::Bar::Baz) # #   # bad #   defined?(foo) &amp;&amp; defined?(foo.bar) &amp;&amp; defined?(foo.bar.baz) # #   # good #   defined?(foo.bar.baz) # # source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#24 class RuboCop::Cop::Style::CombinableDefined &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_calls</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the redundant `defined?` node is the LHS of an `and` node,</span>
<span class="ruby-comment"># the term as well as the subsequent `&amp;&amp;`/`and` operator will be removed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs_range_to_remove</span>(<span class="ruby-identifier">term</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespaces</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_term</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">term</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the redundant `defined?` node is the RHS of an `and` node,</span>
<span class="ruby-comment"># the term as well as the preceding `&amp;&amp;`/`and` operator will be removed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs_range_to_remove</span>(<span class="ruby-identifier">term</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">terms</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#28 RuboCop::Cop::Style::CombinableDefined::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/combinable_defined.rb#29 RuboCop::Cop::Style::CombinableDefined::OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where multiple consecutive loops over the same data # can be combined into a single loop. It is very likely that combining them # will make the code more efficient and more concise. # # NOTE: Autocorrection is not applied when the block variable names differ in separate loops, # as it is impossible to determine which variable name should be prioritized. # # @example #   # bad #   def method #   items.each do |item| #   do_something(item) #   end # #   items.each do |item| #   do_something_else(item) #   end #   end # #   # good #   def method #   items.each do |item| #   do_something(item) #   do_something_else(item) #   end #   end # #   # bad #   def method #   for item in items do #   do_something(item) #   end # #   for item in items do #   do_something_else(item) #   end #   end # #   # good #   def method #   for item in items do #   do_something(item) #   do_something_else(item) #   end #   end # #   # good #   def method #   each_slice(2) { |slice| do_something(slice) } #   each_slice(3) { |slice| do_something(slice) } #   end # # source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#62 class RuboCop::Cop::Style::CombinableLoops &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection_looping_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">combine_with_left_sibling</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_end_of_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_collection_looping_block?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sibling</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_collection_looping_for?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sibling</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/combinable_loops.rb#65 RuboCop::Cop::Style::CombinableLoops::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces using “ or %x around command literals. # # @example EnforcedStyle: backticks (default) #   # bad #   folders = %x(find . -type d).split # #   # bad #   %x( #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ) # #   # good #   folders = ‘find . -type d`.split # #   # good #   ` #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ` # @example EnforcedStyle: mixed #   # bad #   folders = %x(find . -type d).split # #   # bad #   ` #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ` # #   # good #   folders = `find . -type d`.split # #   # good #   %x( #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ) # @example EnforcedStyle: percent_x #   # bad #   folders = `find . -type d`.split # #   # bad #   ` #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ` # #   # good #   folders = %x(find . -type d).split # #   # good #   %x( #   ln -s foo.example.yml foo.example #   ln -s bar.example.yml bar.example #   ) # @example AllowInnerBackticks: false (default) #   # If `false`, the cop will always recommend using `%x` if one or more #   # backticks are found in the command string. # #   # bad #   `echo `ls`` # #   # good #   %x(echo `ls`) # @example AllowInnerBackticks: true #   # good #   `echo `ls`` # # source://rubocop//lib/rubocop/cop/style/command_literal.rb#78 class RuboCop::Cop::Style::CommandLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_inner_backticks?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_backtick_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_percent_x_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">backtick_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_backtick_literal</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_percent_x_literal</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_delimiter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_backtick?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_disallowed_backtick?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_delimiter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_body</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/command_literal.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters_config</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/command_literal.rb#82 RuboCop::Cop::Style::CommandLiteral::MSG_USE_BACKTICKS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/command_literal.rb#83 RuboCop::Cop::Style::CommandLiteral::MSG_USE_PERCENT_X = T.let(T.unsafe(nil), String)</p>

<p># Checks that comment annotation keywords are written according # to guidelines. # # Annotation keywords can be specified by overriding the cop’s ‘Keywords` # configuration. Keywords are allowed to be single words or phrases. # # NOTE: With a multiline comment block (where each line is only a # comment), only the first line will be able to register an offense, even # if an annotation keyword starts another line. This is done to prevent # incorrect registering of keywords (eg. `review`) inside a paragraph as an # annotation. # # @example RequireColon: true (default) #   # bad #   # TODO make better # #   # good #   # TODO: make better # #   # bad #   # TODO:make better # #   # good #   # TODO: make better # #   # bad #   # fixme: does not work # #   # good #   # FIXME: does not work # #   # bad #   # Optimize does not work # #   # good #   # OPTIMIZE: does not work # @example RequireColon: false #   # bad #   # TODO: make better # #   # good #   # TODO make better # #   # bad #   # fixme does not work # #   # good #   # FIXME does not work # #   # bad #   # Optimize does not work # #   # good #   # OPTIMIZE does not work # # source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#61 class RuboCop::Cop::Style::CommentAnnotation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotation_range</span>(<span class="ruby-identifier">annotation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_offense</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_comment_line?</span>(<span class="ruby-identifier">comments</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inline_comment?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keywords</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">annotation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_colon?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#71 RuboCop::Cop::Style::CommentAnnotation::MISSING_NOTE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#65 RuboCop::Cop::Style::CommentAnnotation::MSG_COLON_STYLE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/comment_annotation.rb#68 RuboCop::Cop::Style::CommentAnnotation::MSG_SPACE_STYLE = T.let(T.unsafe(nil), String)</p>

<p># Checks for comments put on the same line as some keywords. # These keywords are: ‘class`, `module`, `def`, `begin`, `end`. # # Note that some comments # RBS::Inline annotation, and Steep annotation (`steep:ignore`) are allowed. # # Autocorrection removes comments from `end` keyword and keeps comments # for `class`, `module`, `def` and `begin` above the keyword. # # @example #   # bad #   if condition #   statement #   end # end if # #   # bad #   class X # comment #   statement #   end # #   # bad #   def x; end # comment # #   # good #   if condition #   statement #   end # #   # good #   class X # :nodoc: #   y #   end # # source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#45 class RuboCop::Cop::Style::CommentedKeyword &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rbs_inline_annotation?</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">matched_keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_line</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">steep_annotation?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#54 RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENTS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#55 RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENT_REGEXES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#51 RuboCop::Cop::Style::CommentedKeyword::KEYWORDS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#52 RuboCop::Cop::Style::CommentedKeyword::KEYWORD_REGEXES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#61 RuboCop::Cop::Style::CommentedKeyword::METHOD_OR_END_DEFINITIONS = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#49 RuboCop::Cop::Style::CommentedKeyword::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#58 RuboCop::Cop::Style::CommentedKeyword::REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#63 RuboCop::Cop::Style::CommentedKeyword::STEEP_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/commented_keyword.rb#60 RuboCop::Cop::Style::CommentedKeyword::SUBCLASS_DEFINITION = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for logical comparison which can be replaced with ‘Comparable#between?`. # # NOTE: `Comparable#between?` is on average slightly slower than logical comparison, # although the difference generally isn’t observable. If you require maximum # performance, consider using logical comparison. # # @example # #   # bad #   x &gt;= min &amp;&amp; x &lt;= max # #   # bad #   x &lt;= max &amp;&amp; x &gt;= min # #   # good #   x.between?(min, max) # # source://rubocop//lib/rubocop/cop/style/comparable_between.rb#26 class RuboCop::Cop::Style::ComparableBetween &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_between.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logical_comparison_between_by_max_first?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_between.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logical_comparison_between_by_min_first?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_between.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_between.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">min_and_value</span>, <span class="ruby-identifier">max_and_value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/comparable_between.rb#29 RuboCop::Cop::Style::ComparableBetween::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of ‘Comparable#clamp` instead of comparison by minimum and maximum. # # This cop supports autocorrection for `if/elsif/else` bad style only. # Because `ArgumentError` occurs if the minimum and maximum of `clamp` arguments are reversed. # When these are variables, it is not possible to determine which is the minimum and maximum: # # [source,ruby] # —- # [1, [2, 3].max].min # =&gt; 1 # 1.clamp(3, 1)       # =&gt; min argument must be smaller than max argument (ArgumentError) # —- # # @example # #   # bad #   [[x, low].max, high].min # #   # bad #   if x &lt; low #   low #   elsif high &lt; x #   high #   else #   x #   end # #   # good #   x.clamp(low, high) # # source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#35 class RuboCop::Cop::Style::ComparableClamp &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_min_max?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_elsif_else_condition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">prefer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_condition?</span>(<span class="ruby-identifier">if_condition</span>, <span class="ruby-identifier">else_body</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#42 RuboCop::Cop::Style::ComparableClamp::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#43 RuboCop::Cop::Style::ComparableClamp::MSG_MIN_MAX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/comparable_clamp.rb#44 RuboCop::Cop::Style::ComparableClamp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use of ‘Array#push(item)` instead of `<a href="item">Array#concat(</a>)` # to avoid redundant array literals. # # @example # #   # bad #   <a href="foo">list.concat(</a>) #   list.concat([bar, baz]) #   list.concat([qux, quux], [corge]) # #   # good #   list.push(foo) #   list.push(bar, baz) #   list.push(qux, quux, corge) # # source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#25 class RuboCop::Cop::Style::ConcatArrayLiterals &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_literals_includes_only_basic_literals?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#28 RuboCop::Cop::Style::ConcatArrayLiterals::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#29 RuboCop::Cop::Style::ConcatArrayLiterals::MSG_FOR_PERCENT_LITERALS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/concat_array_literals.rb#31 RuboCop::Cop::Style::ConcatArrayLiterals::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Check for ‘if` and `case` statements where each branch is used for # both the assignment and comparison of the same variable # when using the return of the condition can be used instead. # # @example EnforcedStyle: assign_to_condition (default) #   # bad #   if foo #   bar = 1 #   else #   bar = 2 #   end # #   case foo #   when ’a’ #   bar += 1 #   else #   bar += 2 #   end # #   if foo #   some_method #   bar = 1 #   else #   some_other_method #   bar = 2 #   end # #   # good #   bar = if foo #   1 #   else #   2 #   end # #   bar += case foo #   when ‘a’ #   1 #   else #   2 #   end # #   bar &lt;&lt; if foo #   some_method #   1 #   else #   some_other_method #   2 #   end # @example EnforcedStyle: assign_inside_condition #   # bad #   bar = if foo #   1 #   else #   2 #   end # #   bar += case foo #   when ‘a’ #   1 #   else #   2 #   end # #   bar &lt;&lt; if foo #   some_method #   1 #   else #   some_other_method #   2 #   end # #   # good #   if foo #   bar = 1 #   else #   bar = 2 #   end # #   case foo #   when ‘a’ #   bar += 1 #   else #   bar += 2 #   end # #   if foo #   some_method #   bar = 1 #   else #   some_other_method #   bar = 2 #   end # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#207 class RuboCop::Cop::Style::ConditionalAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalAssignmentHelper</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># The shovel operator `&lt;&lt;` does not have its own type. It is a `send`</span>
<span class="ruby-comment"># type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_type?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">candidate_condition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#311</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_single_line?</span>(<span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_statements?</span>(<span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_ternary?</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#362</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_types_match?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#300</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">candidate_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_assignment_to_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#368</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If `Layout/LineLength` is enabled, we do not want to introduce an</span>
<span class="ruby-comment"># offense by autocorrecting this cop. Find the max configured line</span>
<span class="ruby-comment"># length. Find the longest line of condition. Remove the assignment</span>
<span class="ruby-comment"># from lines that contain the offending assignment because after</span>
<span class="ruby-comment"># correcting, this will not be on the line anymore. Check if the length</span>
<span class="ruby-comment"># of the longest line + the length of the corrected assignment is</span>
<span class="ruby-comment"># greater than the max configured line length</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#401</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_exceeds_line_limit?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#432</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_ternary?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#355</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs_all_match?</span>(<span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length_cop_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">longest_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#409</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">longest_line_exceeds_line_limit?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#339</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_assignment_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_assignment_outside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#428</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_conditions_only?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#215 RuboCop::Cop::Style::ConditionalAssignment::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#213 RuboCop::Cop::Style::ConditionalAssignment::ASSIGN_TO_CONDITION_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#217 RuboCop::Cop::Style::ConditionalAssignment::ENABLED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#216 RuboCop::Cop::Style::ConditionalAssignment::LINE_LENGTH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#218 RuboCop::Cop::Style::ConditionalAssignment::MAX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#212 RuboCop::Cop::Style::ConditionalAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#219 RuboCop::Cop::Style::ConditionalAssignment::SINGLE_LINE_CONDITIONS_ONLY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#214 RuboCop::Cop::Style::ConditionalAssignment::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Helper module to provide common methods to classes needed for the # ConditionalAssignment Cop. # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#8 module RuboCop::Cop::Style::ConditionalAssignmentHelper</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_with_eq?</span>(<span class="ruby-identifier">sym</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># `elsif` branches show up in the `node` as an `else`. We need</span>
<span class="ruby-comment"># to recursively iterate over all `else` branches and consider all</span>
<span class="ruby-comment"># but the last `node` an `elsif` branch and consider the last `node`</span>
<span class="ruby-comment"># the actual `else` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_elses</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># `when` nodes contain the entire branch including the condition.</span>
<span class="ruby-comment"># We only need the contents of the branch, not the condition.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_when_branches</span>(<span class="ruby-identifier">when_branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent</span>(<span class="ruby-identifier">cop</span>, <span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tail</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_rhs_exist?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_elsif</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elsif_branches</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs_for_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs_for_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setter_method?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#13 RuboCop::Cop::Style::ConditionalAssignmentHelper::ALIGN_WITH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#12 RuboCop::Cop::Style::ConditionalAssignmentHelper::END_ALIGNMENT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#11 RuboCop::Cop::Style::ConditionalAssignmentHelper::EQUAL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#14 RuboCop::Cop::Style::ConditionalAssignmentHelper::KEYWORD = T.let(T.unsafe(nil), String)</p>

<p># Helper module to provide common methods to ConditionalAssignment # correctors # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#439 module RuboCop::Cop::Style::ConditionalCorrectorHelper</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#473</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#502</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_branches</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#479</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_if_branches</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">cop</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#441</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_whitespace_in_branches</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branch</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#489</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_branch_assignment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#462</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#466</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">white_space_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks that constants defined in classes and modules have # an explicit visibility declaration. By default, Ruby makes all class- # and module constants public, which litters the public API of the # class or module. Explicitly declaring a visibility makes intent more # clear, and prevents outside actors from touching private state. # # @example # #   # bad #   class Foo #   BAR = 42 #   BAZ = 43 #   end # #   # good #   class Foo #   BAR = 42 #   private_constant :BAR # #   BAZ = 43 #   public_constant :BAZ #   end # @example IgnoreModules: false (default) #   # bad #   class Foo #   MyClass = Struct.new() #   end # #   # good #   class Foo #   MyClass = Struct.new() #   public_constant :MyClass #   end # @example IgnoreModules: true #   # good #   class Foo #   MyClass = Struct.new() #   end # # source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#47 class RuboCop::Cop::Style::ConstantVisibility &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility_declaration_for?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_or_module_scope?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_modules?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_name?</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">constant_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility_declaration?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/constant_visibility.rb#48 RuboCop::Cop::Style::ConstantVisibility::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/copyright.rb#21 class RuboCop::Cop::Style::Copyright &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_notice</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding_token?</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">token_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_notice_before</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notice</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">notice_found?</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shebang_token?</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">token_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [Warning]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/copyright.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verify_autocorrect_notice!</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/copyright.rb#26 RuboCop::Cop::Style::Copyright::AUTOCORRECT_EMPTY_WARNING = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/copyright.rb#25 RuboCop::Cop::Style::Copyright::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for inheritance from ‘Data.define` to avoid creating the anonymous parent class. # Inheriting from `Data.define` adds a superfluous level in inheritance tree. # # @example #   # bad #   class Person &lt; Data.define(:first_name, :last_name) #   def age #   42 #   end #   end # #   Person.ancestors #   # =&gt; [Person, #<Class:0x000000010b4e14a0&gt;, Data, (…)] # #   # good #   Person = Data.define(:first_name, :last_name) do #   def age #   42 #   end #   end # #   Person.ancestors #   # =&gt; [Person, Data, (…)] # # source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#33 class RuboCop::Cop::Style::DataInheritance &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">data_define?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_parent</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_empty_class_body</span>(<span class="ruby-identifier">class_node</span>, <span class="ruby-identifier">data_define</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/data_inheritance.rb#38 RuboCop::Cop::Style::DataInheritance::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for consistent usage of the ‘DateTime` class over the # `Time` class. This cop is disabled by default since these classes, # although highly overlapping, have particularities that make them not # replaceable in certain situations when dealing with multiple timezones # and/or DST. # # @example # #   # bad - uses `DateTime` for current time #   DateTime.now # #   # good - uses `Time` for current time #   Time.now # #   # bad - uses `DateTime` for modern date #   DateTime.iso8601(’2016-06-29’) # #   # good - uses ‘Time` for modern date #   Time.iso8601(’2016-06-29’) # #   # good - uses ‘DateTime` with start argument for historical date #   DateTime.iso8601(’1751-04-23’, Date::ENGLAND) # @example AllowCoercion: false (default) # #   # bad - coerces to ‘DateTime` #   something.to_datetime # #   # good - coerces to `Time` #   something.to_time # @example AllowCoercion: true # #   # good #   something.to_datetime # #   # good #   something.to_time # # source://rubocop//lib/rubocop/cop/style/date_time.rb#49 class RuboCop::Cop::Style::DateTime &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">date_time?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">historic_date?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_datetime?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/date_time.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disallow_coercion?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/date_time.rb#52 RuboCop::Cop::Style::DateTime::CLASS_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/date_time.rb#53 RuboCop::Cop::Style::DateTime::COERCION_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for parentheses in the definition of a method, # that does not take any arguments. Both instance and # class/singleton methods are checked. # # @example # #   # bad #   def foo() #   do_something #   end # #   # good #   def foo #   do_something #   end # #   # bad #   def foo() = do_something # #   # good #   def foo = do_something # #   # good - without parentheses it’s a syntax error #   def foo() do_something end #   def foo()=do_something # #   # bad #   def Baz.foo() #   do_something #   end # #   # good #   def Baz.foo #   do_something #   end # # source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#41 class RuboCop::Cop::Style::DefWithParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parentheses_required?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">arguments_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/def_with_parentheses.rb#45 RuboCop::Cop::Style::DefWithParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check for chained ‘dig` calls that can be collapsed into a single `dig`. # # @example #   # bad #   x.dig(:foo).dig(:bar).dig(:baz) #   x.dig(:foo, :bar).dig(:baz) #   x.dig(:foo, :bar)&amp;.dig(:baz) # #   # good #   x.dig(:foo, :bar, :baz) # #   # good - `dig`s cannot be combined #   x.dig(:foo).bar.dig(:baz) # # source://rubocop//lib/rubocop/cop/style/dig_chain.rb#25 class RuboCop::Cop::Style::DigChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DigHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Walk up the method chain while the receiver is `dig` with arguments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_arguments?</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#30 RuboCop::Cop::Style::DigChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/dig_chain.rb#31 RuboCop::Cop::Style::DigChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where the ‘#_<em>dir</em>_` method can replace more # complex constructs to retrieve a canonicalized absolute path to the # current file. # # @example #   # bad #   path = File.expand_path(File.dirname(__FILE__)) # #   # bad #   path = File.dirname(File.realpath(__FILE__)) # #   # good #   path = __dir__ # # source://rubocop//lib/rubocop/cop/style/dir.rb#19 class RuboCop::Cop::Style::Dir &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dir_replacement?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_keyword?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/dir.rb#25 RuboCop::Cop::Style::Dir::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/dir.rb#26 RuboCop::Cop::Style::Dir::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Prefer to use ‘Dir.empty?(’path/to/dir’)‘ when checking if a directory is empty. # # @example #   # bad #   Dir.entries(’path/to/dir’).size == 2 #   Dir.children(‘path/to/dir’).empty? #   Dir.children(‘path/to/dir’).size == 0 #   Dir.each_child(‘path/to/dir’).none? # #   # good #   Dir.empty?(‘path/to/dir’) # # source://rubocop//lib/rubocop/cop/style/dir_empty.rb#18 class RuboCop::Cop::Style::DirEmpty &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir_empty.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir_empty.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/dir_empty.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bang</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/dir_empty.rb#22 RuboCop::Cop::Style::DirEmpty::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/dir_empty.rb#23 RuboCop::Cop::Style::DirEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Detects comments to enable/disable RuboCop. # This is useful if want to make sure that every RuboCop error gets fixed # and not quickly disabled with a comment. # # Specific cops can be allowed with the ‘AllowedCops` configuration. Note that # # @example #   # bad #   # rubocop:disable Metrics/AbcSize #   def foo #   end #   # rubocop:enable Metrics/AbcSize # #   # good #   def foo #   end # @example AllowedCops: [Metrics/AbcSize] #   # good #   # rubocop:disable Metrics/AbcSize #   def foo #   end #   # rubocop:enable Metrics/AbcSize # # source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#33 class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_cops_allowed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_cops</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">directive_cops</span>, <span class="ruby-identifier">disallowed_cops</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#37 RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/disable_cops_within_source_code_directive.rb#38 RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG_FOR_COPS = T.let(T.unsafe(nil), String)</p>

<p># When using ‘class_eval` (or other `eval`) with string interpolation, # add a comment block showing its appearance if interpolated (a practice used in Rails code). # # @example #   # from activesupport/lib/active_support/core_ext/string/output_safety.rb # #   # bad #   UNSAFE_STRING_METHODS.each do |unsafe_method| #   if ’String’.respond_to?(unsafe_method) #   class_eval &lt;&lt;-EOT, __FILE__, __LINE__ + 1 #   def #{unsafe_method}(*params, &amp;block) #   to_str.#{unsafe_method}(*params, &amp;block) #   end # #   def #{unsafe_method}!(*params) #   @dirty = true #   super #   end #   EOT #   end #   end # #   # good, inline comments in heredoc #   UNSAFE_STRING_METHODS.each do |unsafe_method| #   if ‘String’.respond_to?(unsafe_method) #   class_eval &lt;&lt;-EOT, __FILE__, __LINE__ + 1 #   def #{unsafe_method}(*params, &amp;block)       # def capitalize(*params, &amp;block) #   to_str.#{unsafe_method}(*params, &amp;block)  #   to_str.capitalize(*params, &amp;block) #   end                                         # end # #   def #{unsafe_method}!(*params)              # def capitalize!(*params) #   @dirty = true                             #   @dirty = true #   super                                     #   super #   end                                         # end #   EOT #   end #   end # #   # good, block comments in heredoc #   class_eval &lt;&lt;-EOT, __FILE__, __LINE__ + 1 #   # def capitalize!(*params) #   #   @dirty = true #   #   super #   # end # #   def #{unsafe_method}!(*params) #   @dirty = true #   super #   end #   EOT # #   # good, block comments before heredoc #   class_eval( #   # def capitalize!(*params) #   #   @dirty = true #   #   super #   # end # #   &lt;&lt;-EOT, __FILE__, __LINE__ + 1 #   def #{unsafe_method}!(*params) #   @dirty = true #   super #   end #   EOT #   ) # #   # bad - interpolated string without comment #   class_eval(“def #{unsafe_method}!(*params); end”) # #   # good - with inline comment or replace it with block comment using heredoc #   class_eval(“def #{unsafe_method}!(*params); end # def capitalize!(*params); end”) # # source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#77 class RuboCop::Cop::Style::DocumentDynamicEvalDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_block_docs?</span>(<span class="ruby-identifier">arg_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_regexp</span>(<span class="ruby-identifier">arg_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_comment_blocks</span>(<span class="ruby-identifier">heredoc_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inline_comment_docs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolated?</span>(<span class="ruby-identifier">arg_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_adjacent_comments</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_comment_blocks</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_to_regexp</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#78 RuboCop::Cop::Style::DocumentDynamicEvalDefinition::BLOCK_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#79 RuboCop::Cop::Style::DocumentDynamicEvalDefinition::COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#80 RuboCop::Cop::Style::DocumentDynamicEvalDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/document_dynamic_eval_definition.rb#82 RuboCop::Cop::Style::DocumentDynamicEvalDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for missing top-level documentation of classes and # modules. Classes with no body are exempt from the check and so are # namespace modules - modules that have nothing in their bodies except # classes, other modules, constant definitions or constant visibility # declarations. # # The documentation requirement is annulled if the class or module has # same for all its children. # # @example #   # bad #   class Person #   # … #   end # #   module Math #   end # #   # good #   # Description/Explanation of Person class #   class Person #   # … #   end # #   # allowed #   # Class without body #   class Person #   end # #   # Namespace - A namespace can be a class or a module #   # Containing a class #   module Namespace #   # Description/Explanation of Person class #   class Person #   # … #   end #   end # #   # Containing constant visibility declaration #   module Namespace #   class Private #   end # #   private_constant :Private #   end # #   # Containing constant definition #   module Namespace #   Public = Class.new #   end # #   # Macro calls #   module Namespace #   extend Foo #   end # @example AllowedConstants: [‘ClassMethods’] # #   # good #   module A #   module ClassMethods #   # … #   end #   end # # source://rubocop//lib/rubocop/cop/style/documentation.rb#72 class RuboCop::Cop::Style::Documentation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DocumentationComment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_visibility_declaration?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_statement?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">outer_module</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_constants</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_namespace?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_declaration?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identifier</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_statement_only?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nodoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nodoc?</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-value">require_all:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Note: How end-of-line comments are associated with code changed in</span>
<span class="ruby-comment"># parser-2.2.0.4.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nodoc_comment?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">require_all:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nodoc_self_or_outer_module?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualify_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/documentation.rb#76 RuboCop::Cop::Style::Documentation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for missing documentation comment for public methods. # It can optionally be configured to also require documentation for # non-public methods. # # NOTE: This cop allows ‘initialize` method because `initialize` is # a special method called from `new`. In some programming languages # they are called constructor to distinguish it from method. # # @example # #   # bad # #   class Foo #   def bar #   puts baz #   end #   end # #   module Foo #   def bar #   puts baz #   end #   end # #   def foo.bar #   puts baz #   end # #   # good # #   class Foo #   # Documentation #   def bar #   puts baz #   end #   end # #   module Foo #   # Documentation #   def bar #   puts baz #   end #   end # #   # Documentation #   def foo.bar #   puts baz #   end # @example RequireForNonPublicMethods: false (default) #   # good #   class Foo #   protected #   def do_something #   end #   end # #   class Foo #   private #   def do_something #   end #   end # @example RequireForNonPublicMethods: true #   # bad #   class Foo #   protected #   def do_something #   end #   end # #   class Foo #   private #   def do_something #   end #   end # #   # good #   class Foo #   protected #   # Documentation #   def do_something #   end #   end # #   class Foo #   private #   # Documentation #   def do_something #   end #   end # @example AllowedMethods: [’method_missing’, ‘respond_to_missing?’] # #   # good #   class Foo #   def method_missing(name, *args) #   end # #   def respond_to_missing?(symbol, include_private) #   end #   end # # source://rubocop//lib/rubocop/cop/style/documentation_method.rb#109 class RuboCop::Cop::Style::DocumentationMethod &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DocumentationComment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DefNode</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_for_non_public_methods?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/documentation_method.rb#113 RuboCop::Cop::Style::DocumentationMethod::MSG = T.let(T.unsafe(nil), String)</p>

<p># Detects double disable comments on one line. This is mostly to catch # automatically generated comments that need to be regenerated. # # @example #   # bad #   def f # rubocop:disable Style/For # rubocop:disable Metrics/AbcSize #   end # #   # good #   # rubocop:disable Metrics/AbcSize #   def f # rubocop:disable Style/For #   end #   # rubocop:enable Metrics/AbcSize # #   # if both fit on one line #   def f # rubocop:disable Style/For, Metrics/AbcSize #   end # # source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#27 class RuboCop::Cop::Style::DoubleCopDisableDirective &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/double_cop_disable_directive.rb#32 RuboCop::Cop::Style::DoubleCopDisableDirective::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of double negation (‘!!`) to convert something to a boolean value. # # When using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts # that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation # should be forbidden always. # # NOTE: when `something` is a boolean value # `!!something` and `!something.nil?` are not the same thing. # As you’re unlikely to write code that can accept values of any type # this is rarely a problem in practice. # # @example #   # bad #   !!something # #   # good #   !something.nil? # @example EnforcedStyle: allowed_in_returns (default) #   # good #   def foo? #   !!return_value #   end # #   define_method :foo? do #   !!return_value #   end # #   define_singleton_method :foo? do #   !!return_value #   end # @example EnforcedStyle: forbidden #   # bad #   def foo? #   !!return_value #   end # #   define_method :foo? do #   !!return_value #   end # #   define_singleton_method :foo? do #   !!return_value #   end # # source://rubocop//lib/rubocop/cop/style/double_negation.rb#61 class RuboCop::Cop::Style::DoubleNegation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_negative?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_in_returns?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_negative_condition_return_value?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">last_child</span>, <span class="ruby-identifier">conditional_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_of_method_definition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_conditional_node_from_ascendant</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_def_node_from_ascendant</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_last_child</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/double_negation.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_parent_not_enumerable</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/double_negation.rb#65 RuboCop::Cop::Style::DoubleNegation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/double_negation.rb#66 RuboCop::Cop::Style::DoubleNegation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for loops which iterate a constant number of times, # using a ‘Range` literal and `#each`. This can be done more readably using # `Integer#times`. # # This check only applies if the block takes no parameters. # # @example #   # bad #   (1..5).each { } # #   # good #   5.times { } # #   # bad #   (0…10).each {} # #   # good #   10.times {} # # source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#24 class RuboCop::Cop::Style::EachForSimpleLoop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_range</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_range_with_zero_origin?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_range_without_block_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/each_for_simple_loop.rb#27 RuboCop::Cop::Style::EachForSimpleLoop::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for inject / reduce calls where the passed in object is # returned at the end and so could be replaced by each_with_object without # the need to return the object at the end. # # However, we can’t replace with each_with_object if the accumulator # parameter is assigned to within the block. # # @example #   # bad #   [1, 2].inject({}) { |a, e| <a href="e">a</a> = e; a } # #   # good #   [1, 2].each_with_object({}) { |e, a| <a href="e">a</a> = e } # # source://rubocop//lib/rubocop/cop/style/each_with_object.rb#19 class RuboCop::Cop::Style::EachWithObject &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_with_object_block_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_with_object_numblock_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># if the accumulator parameter is assigned to in the block,</span>
<span class="ruby-comment"># then we can&#39;t convert to each_with_object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accumulator_param_assigned_to?</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">return_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_numblock</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_returned?</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">return_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value_occupies_whole_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_method_arg?</span>(<span class="ruby-identifier">method_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whole_line_expression</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#24 RuboCop::Cop::Style::EachWithObject::METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/each_with_object.rb#23 RuboCop::Cop::Style::EachWithObject::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for pipes for empty block parameters. Pipes for empty # block parameters do not cause syntax errors, but they are redundant. # # @example #   # bad #   a do || #   do_something #   end # #   # bad #   a { || do_something } # #   # good #   a do #   end # #   # good #   a { do_something } # # source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#24 class RuboCop::Cop::Style::EmptyBlockParameter &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyParameter</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_block_parameter.rb#29 RuboCop::Cop::Style::EmptyBlockParameter::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for case statements with an empty condition. # # @example # #   # bad: #   case #   when x == 0 #   puts ‘x is 0’ #   when y == 0 #   puts ‘y is 0’ #   else #   puts ‘neither is 0’ #   end # #   # good: #   if x == 0 #   puts ‘x is 0’ #   elsif y == 0 #   puts ‘y is 0’ #   else #   puts ‘neither is 0’ #   end # #   # good: (the case condition node is not empty) #   case n #   when 0 #   puts ‘zero’ #   when 1 #   puts ‘one’ #   else #   puts ‘more’ #   end # # source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#38 class RuboCop::Cop::Style::EmptyCaseCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">case_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_case_when</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">case_node</span>, <span class="ruby-identifier">when_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_when_conditions</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">when_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_first_when_comment</span>(<span class="ruby-identifier">case_range</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_then_with_line_break</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">when_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#42 RuboCop::Cop::Style::EmptyCaseCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_case_condition.rb#43 RuboCop::Cop::Style::EmptyCaseCondition::NOT_SUPPORTED_PARENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for empty else-clauses, possibly including comments and/or an # explicit ‘nil` depending on the EnforcedStyle. # # @example EnforcedStyle: both (default) #   # warn on empty else and else with nil in it # #   # bad #   if condition #   statement #   else #   nil #   end # #   # bad #   if condition #   statement #   else #   end # #   # good #   if condition #   statement #   else #   statement #   end # #   # good #   if condition #   statement #   end # @example EnforcedStyle: empty #   # warn only on empty else # #   # bad #   if condition #   statement #   else #   end # #   # good #   if condition #   statement #   else #   nil #   end # #   # good #   if condition #   statement #   else #   statement #   end # #   # good #   if condition #   statement #   end # @example EnforcedStyle: nil #   # warn on else with nil in it # #   # bad #   if condition #   statement #   else #   nil #   end # #   # good #   if condition #   statement #   else #   end # #   # good #   if condition #   statement #   else #   statement #   end # #   # good #   if condition #   statement #   end # @example AllowComments: false (default) # #   # bad #   if condition #   statement #   else #   # something comment #   nil #   end # #   # bad #   if condition #   statement #   else #   # something comment #   end # @example AllowComments: true # #   # good #   if condition #   statement #   else #   # something comment #   nil #   end # #   # good #   if condition #   statement #   else #   # something comment #   end # # source://rubocop//lib/rubocop/cop/style/empty_else.rb#127 class RuboCop::Cop::Style::EmptyElse &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OnNormalIfUnless</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_normal_if_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_forbidden?</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_in_else?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_else_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_else.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_style?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_else.rb#135 RuboCop::Cop::Style::EmptyElse::EMPTY_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_else.rb#133 RuboCop::Cop::Style::EmptyElse::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_else.rb#134 RuboCop::Cop::Style::EmptyElse::NIL_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for using empty heredoc to reduce redundancy. # # @example # #   # bad #   &lt;&lt;~EOS #   EOS # #   &lt;&lt;-EOS #   EOS # #   &lt;&lt;EOS #   EOS # #   # good #   ” # #   # bad #   do_something(&lt;&lt;~EOS) #   EOS # #   do_something(&lt;&lt;-EOS) #   EOS # #   do_something(&lt;&lt;EOS) #   EOS # #   # good #   do_something(”) # # source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#36 class RuboCop::Cop::Style::EmptyHeredoc &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_heredoc.rb#42 RuboCop::Cop::Style::EmptyHeredoc::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for parentheses for empty lambda parameters. Parentheses # for empty lambda parameters do not cause syntax errors, but they are # redundant. # # @example #   # bad #   -&gt; () { do_something } # #   # good #   -&gt; { do_something } # #   # good #   -&gt; (arg) { do_something(arg) } # # source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#19 class RuboCop::Cop::Style::EmptyLambdaParameter &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EmptyParameter</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_lambda_parameter.rb#24 RuboCop::Cop::Style::EmptyLambdaParameter::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of a method, the result of which # would be a literal, like an empty array, hash, or string. # # NOTE: When frozen string literals are enabled, ‘String.new` # isn’t corrected to an empty string since the former is # mutable and the latter would be frozen. # # @example #   # bad #   a = Array.new #   a = Array[] #   h = Hash.new #   h = Hash[] #   s = String.new # #   # good #   a = [] #   h = {} #   s = ” # # source://rubocop//lib/rubocop/cop/style/empty_literal.rb#25 class RuboCop::Cop::Style::EmptyLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_node</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_with_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_with_index</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_node</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_with_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_with_index</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_node</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_unparenthesized?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_strings?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_array_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_hash_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#31 RuboCop::Cop::Style::EmptyLiteral::ARR_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#32 RuboCop::Cop::Style::EmptyLiteral::HASH_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#35 RuboCop::Cop::Style::EmptyLiteral::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_literal.rb#33 RuboCop::Cop::Style::EmptyLiteral::STR_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the formatting of empty method definitions. # By default it enforces empty method definitions to go on a single # line (compact style), but it can be configured to enforce the ‘end` # to go on its own line (expanded style). # # NOTE: A method definition is not considered empty if it contains # comments. # # NOTE: Autocorrection will not be applied for the `compact` style # if the resulting code is longer than the `Max` configuration for # `Layout/LineLength`, but an offense will still be registered. # # @example EnforcedStyle: compact (default) #   # bad #   def foo(bar) #   end # #   def self.foo(bar) #   end # #   # good #   def foo(bar); end # #   def foo(bar) #   # baz #   end # #   def self.foo(bar); end # @example EnforcedStyle: expanded #   # bad #   def foo(bar); end # #   def self.foo(bar); end # #   # good #   def foo(bar) #   end # #   def self.foo(bar) #   end # # source://rubocop//lib/rubocop/cop/style/empty_method.rb#47 class RuboCop::Cop::Style::EmptyMethod &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expanded?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expanded_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joint</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_method.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_method.rb#51 RuboCop::Cop::Style::EmptyMethod::MSG_COMPACT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_method.rb#52 RuboCop::Cop::Style::EmptyMethod::MSG_EXPANDED = T.let(T.unsafe(nil), String)</p>

<p># Checks for empty strings being assigned inside string interpolation. # # Empty strings are a meaningless outcome inside of string interpolation, so we remove them. # Alternatively, when configured to do so, we prioritise using empty strings. # # While this cop would also apply to variables that are only going to be used as strings, # RuboCop can’t detect that, so we only check inside of string interpolation. # # @example EnforcedStyle: trailing_conditional (default) #   # bad #   “#{condition ? ‘foo’ : ”}” # #   # good #   “#{‘foo’ if condition}” # #   # bad #   “#{condition ? ” : ‘foo’}” # #   # good #   “#{‘foo’ unless condition}” # @example EnforcedStyle: ternary #   # bad #   “#{‘foo’ if condition}” # #   # good #   “#{condition ? ‘foo’ : ”}” # #   # bad #   “#{‘foo’ unless condition}” # #   # good #   “#{condition ? ” : ‘foo’}” # # source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#40 class RuboCop::Cop::Style::EmptyStringInsideInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_interpolation</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_branch_outcome?</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_else_outcome?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_if_outcome?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_style_autocorrect</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">outcome</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#46 RuboCop::Cop::Style::EmptyStringInsideInterpolation::MSG_TERNARY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/empty_string_inside_interpolation.rb#45 RuboCop::Cop::Style::EmptyStringInsideInterpolation::MSG_TRAILING_CONDITIONAL = T.let(T.unsafe(nil), String)</p>

<p># Checks ensures source files have no utf-8 encoding comments. # # @example #   # bad #   # encoding: UTF-8 #   # coding: UTF-8 #   # -*- coding: UTF-8 -*- # # source://rubocop//lib/rubocop/cop/style/encoding.rb#12 class RuboCop::Cop::Style::Encoding &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/encoding.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/encoding.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/encoding.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/encoding.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">line_number</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/encoding.rb#17 RuboCop::Cop::Style::Encoding::ENCODING_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/encoding.rb#16 RuboCop::Cop::Style::Encoding::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/encoding.rb#18 RuboCop::Cop::Style::Encoding::SHEBANG = T.let(T.unsafe(nil), String)</p>

<p># Checks for END blocks. # # @example #   # bad #   END { puts ‘Goodbye!’ } # #   # good #   at_exit { puts ‘Goodbye!’ } # # source://rubocop//lib/rubocop/cop/style/end_block.rb#15 class RuboCop::Cop::Style::EndBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/end_block.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_postexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/end_block.rb#18 RuboCop::Cop::Style::EndBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for endless methods. # # It can enforce endless method definitions whenever possible or with single line methods. # It can also disallow multiline endless method definitions or all endless definitions. # # ‘require_single_line` style enforces endless method definitions for single line methods. # `require_always` style enforces endless method definitions for single statement methods. # # Other method definition types are not considered by this cop. # # The supported styles are: # # * allow_single_line (default) - only single line endless method definitions are allowed. # * allow_always - all endless method definitions are allowed. # * disallow - all endless method definitions are disallowed. # * require_single_line - endless method definitions are required for single line methods. # * require_always - all endless method definitions are required. # # NOTE: Incorrect endless method definitions will always be # corrected to a multi-line definition. # # @example EnforcedStyle: allow_single_line (default) #   # bad, multi-line endless method #   def my_method = x.foo #   .bar #   .baz # #   # good #   def my_method #   x #   end # #   # good #   def my_method = x # #   # good #   def my_method #   x.foo #   .bar #   .baz #   end # @example EnforcedStyle: allow_always #   # good #   def my_method #   x #   end # #   # good #   def my_method = x # #   # good #   def my_method = x.foo #   .bar #   .baz # #   # good #   def my_method #   x.foo #   .bar #   .baz #   end # @example EnforcedStyle: disallow #   # bad #   def my_method = x # #   # bad #   def my_method = x.foo #   .bar #   .baz # #   # good #   def my_method #   x #   end # #   # good #   def my_method #   x.foo #   .bar #   .baz #   end # @example EnforcedStyle: require_single_line #   # bad #   def my_method #   x #   end # #   # bad #   def my_method = x.foo #   .bar #   .baz # #   # good #   def my_method = x # #   # good #   def my_method #   x.foo #   .bar #   .baz #   end # @example EnforcedStyle: require_always #   # bad #   def my_method #   x #   end # #   # bad #   def my_method #   x.foo #   .bar #   .baz #   end # #   # good #   def my_method = x # #   # good #   def my_method = x.foo #   .bar #   .baz # # source://rubocop//lib/rubocop/cop/style/endless_method.rb#132 class RuboCop::Cop::Style::EndlessMethod &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">EndlessMethodRewriter</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">missing</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">can_be_made_endless?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_multiline</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">endless_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_allow_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_disallow_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_require_always_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_require_single_line_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/endless_method.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_when_made_endless?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/endless_method.rb#140 RuboCop::Cop::Style::EndlessMethod::CORRECTION_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/endless_method.rb#141 RuboCop::Cop::Style::EndlessMethod::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/endless_method.rb#142 RuboCop::Cop::Style::EndlessMethod::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/endless_method.rb#144 RuboCop::Cop::Style::EndlessMethod::MSG_REQUIRE_ALWAYS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/endless_method.rb#143 RuboCop::Cop::Style::EndlessMethod::MSG_REQUIRE_SINGLE = T.let(T.unsafe(nil), String)</p>

<p># Checks for consistent usage of ‘<a href="&#39;HOME&#39;">ENV</a>`. If `nil` is used as # the second argument of `ENV.fetch`, it is treated as a bad case like `ENV[]`. # # @example # #   # bad #   <a href="&#39;HOME&#39;">ENV</a> #   ENV.fetch(’HOME’, nil) # #   # good #   Dir.home # #   # good #   ENV.fetch(‘HOME’, default) # # source://rubocop//lib/rubocop/cop/style/env_home.rb#31 class RuboCop::Cop::Style::EnvHome &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/env_home.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">env_home?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/env_home.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/env_home.rb#34 RuboCop::Cop::Style::EnvHome::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/env_home.rb#35 RuboCop::Cop::Style::EnvHome::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Ensures that eval methods (‘eval`, `instance_eval`, `class_eval` # and `module_eval`) are given filename and line number values (`<code>__FILE__</code>` # and `<code>__LINE__</code>`). This data is used to ensure that any errors raised # within the evaluated code will be given the correct identification # in a backtrace. # # The cop also checks that the line number given relative to `<code>__LINE__</code>` is # correct. # # This cop will autocorrect incorrect or missing filename and line number # values. However, if `eval` is called without a binding argument, the cop # will not attempt to automatically add a binding, or add filename and # line values. # # NOTE: This cop works only when a string literal is given as a code string. # No offense is reported if a string variable is given as below: # # [source,ruby] # —- # code = &lt;&lt;-RUBY #   def do_something #   end # RUBY # eval code # not checked. # —- # # @example #   # bad #   eval &lt;&lt;-RUBY #   def do_something #   end #   RUBY # #   # bad #   C.class_eval &lt;&lt;-RUBY #   def do_something #   end #   RUBY # #   # good #   eval &lt;&lt;-RUBY, binding, __FILE__, __LINE__ + 1 #   def do_something #   end #   RUBY # #   # good #   C.class_eval &lt;&lt;-RUBY, __FILE__, __LINE__ + 1 #   def do_something #   end #   RUBY # # source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#57 class RuboCop::Cop::Style::EvalWithLocation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_with_offset?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>, <span class="ruby-identifier">param2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_eval_receiver?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_different_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">line_node</span>, <span class="ruby-identifier">line_diff</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_incorrect_line</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">line_node</span>, <span class="ruby-identifier">sign</span>, <span class="ruby-identifier">line_diff</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_missing_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_missing_location</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_offense_for_same_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">line_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_file</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">file_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_location</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_line</span>(<span class="ruby-identifier">sign</span>, <span class="ruby-identifier">line_diff</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_and_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_difference</span>(<span class="ruby-identifier">line_node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_line</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_file_keyword?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_line_keyword?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_first_line</span>(<span class="ruby-identifier">str_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_binding?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#60 RuboCop::Cop::Style::EvalWithLocation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#61 RuboCop::Cop::Style::EvalWithLocation::MSG_EVAL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#62 RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_FILE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#64 RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_LINE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/eval_with_location.rb#67 RuboCop::Cop::Style::EvalWithLocation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where ‘Integer#even?` or `Integer#odd?` # can be used. # # @example # #   # bad #   if x % 2 == 0 #   end # #   # good #   if x.even? #   end # # source://rubocop//lib/rubocop/cop/style/even_odd.rb#18 class RuboCop::Cop::Style::EvenOdd &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/even_odd.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">even_odd_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/even_odd.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/even_odd.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_method</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/even_odd.rb#21 RuboCop::Cop::Style::EvenOdd::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/even_odd.rb#22 RuboCop::Cop::Style::EvenOdd::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for exact regexp match inside ‘Regexp` literals. # # @example # #   # bad #   string =~ /Astringz/ #   string === /Astringz/ #   string.match(/Astringz/) #   string.match?(/Astringz/) # #   # good #   string == ’string’ # #   # bad #   string !~ /Astringz/ # #   # good #   string != ‘string’ # # source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#25 class RuboCop::Cop::Style::ExactRegexpMatch &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exact_regexp_match</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exact_match_pattern?</span>(<span class="ruby-identifier">parsed_regexp</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#28 RuboCop::Cop::Style::ExactRegexpMatch::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/exact_regexp_match.rb#29 RuboCop::Cop::Style::ExactRegexpMatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for use of the ‘File.expand_path` arguments. # Likewise, it also checks for the `Pathname.new` argument. # # Contrastive bad case and good case are alternately shown in # the following examples. # # @example #   # bad #   File.expand_path(’..‘, __FILE__) # #   # good #   File.expand_path(__dir__) # #   # bad #   File.expand_path(’../..‘, __FILE__) # #   # good #   File.expand_path(’..‘, __dir__) # #   # bad #   File.expand_path(’.‘, __FILE__) # #   # good #   File.expand_path(__FILE__) # #   # bad #   Pathname(__FILE__).parent.expand_path # #   # good #   Pathname(__dir__).expand_path # #   # bad #   Pathname.new(__FILE__).parent.expand_path # #   # good #   Pathname.new(__dir__).expand_path # # source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#43 class RuboCop::Cop::Style::ExpandPathArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_expand_path</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pathname_new_parent_expand_path</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pathname_parent_expand_path</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_expand_path</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">current_path</span>, <span class="ruby-identifier">default_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">depth</span>(<span class="ruby-identifier">current_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_offense_for_expand_path</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">current_path</span>, <span class="ruby-identifier">default_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_path</span>(<span class="ruby-identifier">current_path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_parent_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">default_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strip_surrounded_quotes!</span>(<span class="ruby-identifier">path_string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unrecommended_argument?</span>(<span class="ruby-identifier">default_dir</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#47 RuboCop::Cop::Style::ExpandPathArguments::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#49 RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#51 RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_NEW_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/expand_path_arguments.rb#55 RuboCop::Cop::Style::ExpandPathArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use of explicit block argument to avoid writing # block literal that just passes its arguments to another block. # # NOTE: This cop only registers an offense if the block args match the # yield args exactly. # # @example #   # bad #   def with_tmp_dir #   Dir.mktmpdir do |tmp_dir| #   Dir.chdir(tmp_dir) { |dir| yield dir } # block just passes arguments #   end #   end # #   # bad #   def nine_times #   9.times { yield } #   end # #   # good #   def with_tmp_dir(&amp;block) #   Dir.mktmpdir do |tmp_dir| #   Dir.chdir(tmp_dir, &amp;block) #   end #   end # #   with_tmp_dir do |dir| #   puts “dir is accessible as a parameter and pwd is set: #{dir}” #   end # #   # good #   def nine_times(&amp;block) #   9.times(&amp;block) #   end # # source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#41 class RuboCop::Cop::Style::ExplicitBlockArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [ExplicitBlockArgument] a new instance of ExplicitBlockArgument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yielding_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_block_argument</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">block_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_body_range</span>(<span class="ruby-identifier">block_node</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_new_arguments_for_zsuper</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_like?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_call_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">block_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_block_name</span>(<span class="ruby-identifier">def_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_argument</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">block_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yielding_arguments?</span>(<span class="ruby-identifier">block_args</span>, <span class="ruby-identifier">yield_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#53</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/explicit_block_argument.rb#45 RuboCop::Cop::Style::ExplicitBlockArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces consistency when using exponential notation # for numbers in the code (eg 1.2e4). Different styles are supported: # # * ‘scientific` which enforces a mantissa between 1 (inclusive) and 10 (exclusive). # * `engineering` which enforces the exponent to be a multiple of 3 and the mantissa #   to be between 0.1 (inclusive) and 1000 (exclusive). # * `integral` which enforces the mantissa to always be a whole number without #   trailing zeroes. # # @example EnforcedStyle: scientific (default) #   # Enforces a mantissa between 1 (inclusive) and 10 (exclusive). # #   # bad #   10e6 #   0.3e4 #   11.7e5 #   3.14e0 # #   # good #   1e7 #   3e3 #   1.17e6 #   3.14 # @example EnforcedStyle: engineering #   # Enforces using multiple of 3 exponents, #   # mantissa should be between 0.1 (inclusive) and 1000 (exclusive) # #   # bad #   3.2e7 #   0.1e5 #   12e5 #   1232e6 # #   # good #   32e6 #   10e3 #   1.2e6 #   1.232e9 # @example EnforcedStyle: integral #   # Enforces the mantissa to have no decimal part and no #   # trailing zeroes. # #   # bad #   3.2e7 #   0.1e5 #   120e4 # #   # good #   32e6 #   1e4 #   12e5 # # source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#60 class RuboCop::Cop::Style::ExponentialNotation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_float</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">engineering?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integral?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scientific?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/exponential_notation.rb#62 RuboCop::Cop::Style::ExponentialNotation::MESSAGES = T.let(T.unsafe(nil), Hash)</p>

<p># Suggests ‘ENV.fetch` for the replacement of `ENV[]`. # `ENV[]` silently fails and returns `nil` when the environment variable is unset, # which may cause unexpected behaviors when the developer forgets to set it. # On the other hand, `ENV.fetch` raises `KeyError` or returns the explicitly # specified default value. # # @example DefaultToNil: true (default) #   # bad #   <a href="&#39;X&#39;">ENV</a> #   x = <a href="&#39;X&#39;">ENV</a> # #   # good #   ENV.fetch(’X’, nil) #   x = ENV.fetch(‘X’, nil) # #   # also good #   !<a href="&#39;X&#39;">ENV</a> #   <a href="&#39;X&#39;">ENV</a>.some_method # (e.g. ‘.nil?`) # @example DefaultToNil: false #   # bad #   <a href="&#39;X&#39;">ENV</a> #   x = <a href="&#39;X&#39;">ENV</a> # #   # good #   ENV.fetch(’X’) #   x = ENV.fetch(‘X’) # #   # also good #   !<a href="&#39;X&#39;">ENV</a> #   <a href="&#39;X&#39;">ENV</a>.some_method # (e.g. ‘.nil?`) # # source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#38 class RuboCop::Cop::Style::FetchEnvVar &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">env_with_bracket?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># The following are allowed cases:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Used as a flag (e.g., `if ENV[&#39;X&#39;]` or `!ENV[&#39;X&#39;]`) because</span>
<span class="ruby-comment">#   it simply checks whether the variable is set.</span>
<span class="ruby-comment"># - Receiving a message with dot syntax, e.g. `ENV[&#39;X&#39;].nil?`.</span>
<span class="ruby-comment"># - `ENV[&#39;key&#39;]` assigned by logical AND/OR assignment.</span>
<span class="ruby-comment"># - `ENV[&#39;key&#39;]` is the LHS of a `||`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowable_use?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_var?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The following are allowed cases:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - `ENV[&#39;key&#39;]` is a receiver of `||=`, e.g. `ENV[&#39;X&#39;] ||= y`.</span>
<span class="ruby-comment"># - `ENV[&#39;key&#39;]` is a receiver of `&amp;&amp;=`, e.g. `ENV[&#39;X&#39;] &amp;&amp;= y`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_to_nil?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Check if the node is a receiver and receives a message with dot syntax.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_chained_with_dot?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_code</span>(<span class="ruby-identifier">name_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">or_lhs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Avoid offending in the following cases:</span>
<span class="ruby-comment"># `ENV[&#39;key&#39;] if ENV[&#39;key&#39;] = x`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">partial_matched?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used_as_flag?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used_if_condition_in_body?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used_in_condition?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#42 RuboCop::Cop::Style::FetchEnvVar::MSG_WITHOUT_NIL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#41 RuboCop::Cop::Style::FetchEnvVar::MSG_WITH_NIL = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/fetch_env_var.rb#43 RuboCop::Cop::Style::FetchEnvVar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Prefer to use ‘File.empty?(’path/to/file’)‘ when checking if a file is empty. # # @example #   # bad #   File.zero?(’path/to/file’) #   File.size(‘path/to/file’) == 0 #   File.size(‘path/to/file’) &gt;= 0 #   File.size(‘path/to/file’).zero? #   File.read(‘path/to/file’).empty? #   File.binread(‘path/to/file’) == ” #   FileTest.zero?(‘path/to/file’) # #   # good #   File.empty?(‘path/to/file’) #   FileTest.empty?(‘path/to/file’) # # source://rubocop//lib/rubocop/cop/style/file_empty.rb#27 class RuboCop::Cop::Style::FileEmpty &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_empty.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_empty.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_empty.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bang</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/file_empty.rb#31 RuboCop::Cop::Style::FileEmpty::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_empty.rb#32 RuboCop::Cop::Style::FileEmpty::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Use ‘File::NULL` instead of hardcoding the null device (`/dev/null` on Unix-like # OSes, `NUL` or `NUL:` on Windows), so that code is platform independent. # Only looks for full string matches, substrings within a longer string are not # considered. # # However, only files that use the string `’/dev/null’‘ are targeted for detection. # This is because the string `’NUL’‘ is not limited to the null device. # This behavior results in false negatives when the `’/dev/null’‘ string is not used, # but it is a trade-off to avoid false positives. `NULL:` # Unlike `’NUL’‘, `’NUL:‘` is regarded as something like `C:` and is always detected. # # NOTE: Uses inside arrays and hashes are ignored. # # @example #   # bad #   ’/dev/null’ #   ‘NUL’ #   ‘NUL:’ # #   # good #   File::NULL # #   # ok - inside an array #   null_devices = %w[/dev/null nul] # #   # ok - inside a hash #   { unix: “/dev/null”, windows: “nul” } # # source://rubocop//lib/rubocop/cop/style/file_null.rb#45 class RuboCop::Cop::Style::FileNull &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_null.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_null.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_null.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_null.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_string?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/file_null.rb#49 RuboCop::Cop::Style::FileNull::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_null.rb#48 RuboCop::Cop::Style::FileNull::REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># Favor ‘File.(bin)read` convenience methods. # # @example #   # bad - text mode #   File.open(filename).read #   File.open(filename, &amp;:read) #   File.open(filename) { |f| f.read } #   File.open(filename) do |f| #   f.read #   end #   File.open(filename, ’r’).read #   File.open(filename, ‘r’, &amp;:read) #   File.open(filename, ‘r’) do |f| #   f.read #   end # #   # good #   File.read(filename) # #   # bad - binary mode #   File.open(filename, ‘rb’).read #   File.open(filename, ‘rb’, &amp;:read) #   File.open(filename, ‘rb’) do |f| #   f.read #   end # #   # good #   File.binread(filename) # # source://rubocop//lib/rubocop/cop/style/file_read.rb#35 class RuboCop::Cop::Style::FileRead &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_read?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_read?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evidence</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open_read?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_method</span>(<span class="ruby-identifier">mode</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_read.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_node?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_pass</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/file_read.rb#39 RuboCop::Cop::Style::FileRead::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_read.rb#43 RuboCop::Cop::Style::FileRead::READ_FILE_START_TO_FINISH_MODES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_read.rb#41 RuboCop::Cop::Style::FileRead::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for usage of ‘File.open` in append mode with empty block. # # Such a usage only creates a new file, but it doesn’t update # timestamps for an existing file, which might have been the intention. # # For example, for an existing file ‘foo.txt`: # #   ruby -e “puts File.mtime(’foo.txt’)” #   # 2024-11-26 12:17:23 +0100 # #   ruby -e “File.open(‘foo.txt’, ‘a’) {}” # #   ruby -e “puts File.mtime(‘foo.txt’)” #   # 2024-11-26 12:17:23 +0100 -&gt; unchanged # # If the intention was to update timestamps, ‘FileUtils.touch(’foo.txt’)‘ # should be used instead. # # @example #   # bad #   File.open(filename, ’a’) {} #   File.open(filename, ‘a+’) {} # #   # good #   FileUtils.touch(filename) # # source://rubocop//lib/rubocop/cop/style/file_touch.rb#36 class RuboCop::Cop::Style::FileTouch &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_touch.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_touch.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_touch.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/file_touch.rb#44 RuboCop::Cop::Style::FileTouch::APPEND_FILE_MODES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_touch.rb#39 RuboCop::Cop::Style::FileTouch::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_touch.rb#42 RuboCop::Cop::Style::FileTouch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Favor ‘File.(bin)write` convenience methods. # # NOTE: There are different method signatures between `File.write` (class method) # and `File#write` (instance method). The following case will be allowed because # static analysis does not know the contents of the splat argument: # # [source,ruby] # —- # File.open(filename, ’w’) do |f| #   f.write(*objects) # end # —- # # @example #   # bad - text mode #   File.open(filename, ‘w’).write(content) #   File.open(filename, ‘w’) do |f| #   f.write(content) #   end # #   # good #   File.write(filename, content) # #   # bad - binary mode #   File.open(filename, ‘wb’).write(content) #   File.open(filename, ‘wb’) do |f| #   f.write(content) #   end # #   # good #   File.binwrite(filename, content) # # source://rubocop//lib/rubocop/cop/style/file_write.rb#38 class RuboCop::Cop::Style::FileWrite &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_write?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">evidence</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_write?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment"># @yield [content]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_open_write?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">write_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_range</span>(<span class="ruby-identifier">first_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">filename</span>, <span class="ruby-identifier">content</span>, <span class="ruby-identifier">write_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/file_write.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_method</span>(<span class="ruby-identifier">mode</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/file_write.rb#42 RuboCop::Cop::Style::FileWrite::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_write.rb#44 RuboCop::Cop::Style::FileWrite::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/file_write.rb#46 RuboCop::Cop::Style::FileWrite::TRUNCATING_WRITE_MODES = T.let(T.unsafe(nil), Set)</p>

<p># Checks for division with integers coerced to floats. # It is recommended to either always use ‘fdiv` or coerce one side only. # This cop also provides other options for code consistency. # # @example EnforcedStyle: single_coerce (default) #   # bad #   a.to_f / b.to_f # #   # good #   a.to_f / b #   a / b.to_f # @example EnforcedStyle: left_coerce #   # bad #   a / b.to_f #   a.to_f / b.to_f # #   # good #   a.to_f / b # @example EnforcedStyle: right_coerce #   # bad #   a.to_f / b #   a.to_f / b.to_f # #   # good #   a / b.to_f # @example EnforcedStyle: fdiv #   # bad #   a / b.to_f #   a.to_f / b #   a.to_f / b.to_f # #   # good #   a.fdiv(b) # # source://rubocop//lib/rubocop/cop/style/float_division.rb#53 class RuboCop::Cop::Style::FloatDivision &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_coerce?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">both_coerce?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_coerce?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_coerce?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_f_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_to_f_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_from_slash_to_fdiv</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>, <span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_receiver_source</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/float_division.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_to_f_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/float_division.rb#57 RuboCop::Cop::Style::FloatDivision::MESSAGES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/float_division.rb#64 RuboCop::Cop::Style::FloatDivision::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for uses of the ‘for` keyword or `each` method. The # preferred alternative is set in the EnforcedStyle configuration # parameter. An `each` call with a block on a single line is always # allowed. # # @example EnforcedStyle: each (default) #   # bad #   def foo #   for n in [1, 2, 3] do #   puts n #   end #   end # #   # good #   def foo #   [1, 2, 3].each do |n| #   puts n #   end #   end # @example EnforcedStyle: for #   # bad #   def foo #   [1, 2, 3].each do |n| #   puts n #   end #   end # #   # good #   def foo #   for n in [1, 2, 3] do #   puts n #   end #   end # # source://rubocop//lib/rubocop/cop/style/for.rb#45 class RuboCop::Cop::Style::For &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/for.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/for.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/for.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/for.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/for.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suspect_enumerable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/for.rb#49 RuboCop::Cop::Style::For::EACH_LENGTH = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/style/for.rb#50 RuboCop::Cop::Style::For::PREFER_EACH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/for.rb#51 RuboCop::Cop::Style::For::PREFER_FOR = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of a single string formatting utility. # Valid options include ‘Kernel#format`, `Kernel#sprintf`, and `String#%`. # # The detection of `String#%` cannot be implemented in a reliable # manner for all cases, so only two scenarios are considered - # if the first argument is a string literal and if the second # argument is an array literal. # # Autocorrection will be applied when using argument is a literal or known built-in conversion # methods such as `to_d`, `to_f`, `to_h`, `to_i`, `to_r`, `to_s`, and `to_sym` on variables, # provided that their return value is not an array. For example, when using `to_s`, # `’%s’ % [1, 2, 3].to_s` can be autocorrected without any incompatibility: # # [source,ruby] # —- # ‘%s’ % [1, 2, 3]        #=&gt; ‘1’ # format(‘%s’, [1, 2, 3]) #=&gt; ‘[1, 2, 3]’ # ‘%s’ % [1, 2, 3].to_s   #=&gt; ‘[1, 2, 3]’ # —- # # @example EnforcedStyle: format (default) #   # bad #   puts sprintf(‘%10s’, ‘foo’) #   puts ‘%10s’ % ‘foo’ # #   # good #   puts format(‘%10s’, ‘foo’) # @example EnforcedStyle: sprintf #   # bad #   puts format(‘%10s’, ‘foo’) #   puts ‘%10s’ % ‘foo’ # #   # good #   puts sprintf(‘%10s’, ‘foo’) # @example EnforcedStyle: percent #   # bad #   puts format(‘%10s’, ‘foo’) #   puts sprintf(‘%10s’, ‘foo’) # #   # good #   puts ‘%10s’ % ‘foo’ # # source://rubocop//lib/rubocop/cop/style/format_string.rb#50 class RuboCop::Cop::Style::FormatString &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">formatter</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_from_percent</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_to_percent</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrectable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_single_parameter</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">detected_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>(<span class="ruby-identifier">style_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Known conversion methods whose return value is not an array. # # source://rubocop//lib/rubocop/cop/style/format_string.rb#58 RuboCop::Cop::Style::FormatString::AUTOCORRECTABLE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/format_string.rb#54 RuboCop::Cop::Style::FormatString::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/format_string.rb#55 RuboCop::Cop::Style::FormatString::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Use a consistent style for tokens within a format string. # # By default, all strings are evaluated. In some cases, this may be undesirable, # as they could be used as arguments to a method that does not consider # them to be tokens, but rather other identifiers or just part of the string. # # ‘AllowedMethods` or `AllowedPatterns` can be configured with in order to mark specific # methods as always allowed, thereby avoiding an offense from the cop. By default, there # are no allowed methods. # # Additionally, the cop can be made conservative by configuring it with # `Mode: conservative` (default `aggressive`). In this mode, tokens (regardless # of `EnforcedStyle`) are only considered if used in the format string argument to the # methods `printf`, `sprintf`, `format` and `%`. # # NOTE: Tokens in the `unannotated` style (eg. `%s`) are always treated as if # configured with `Conservative: true`. This is done in order to prevent false positives, # because this format is very similar to encoded URLs or Date/Time formatting strings. # # It is allowed to contain unannotated token # if the number of them is less than or equals to # `MaxUnannotatedPlaceholdersAllowed`. # # @example Mode: conservative, EnforcedStyle: annotated #   # In `conservative` mode, offenses are only registered for strings #   # given to a known formatting method. # #   # good #   “%{greeting}” #   foo(“%{greeting}”) # #   # bad #   format(“%{greeting}”, greeting: ’Hello’) #   printf(“%{greeting}”, greeting: ‘Hello’) #   sprintf(“%{greeting}”, greeting: ‘Hello’) #   “%{greeting}” % { greeting: ‘Hello’ } # @example EnforcedStyle: template # #   # bad #   format(‘%&lt;greeting&gt;s’, greeting: ‘Hello’) #   format(‘%s’, ‘Hello’) # #   # good #   format(‘%{greeting}’, greeting: ‘Hello’) # @example EnforcedStyle: unannotated # #   # bad #   format(‘%&lt;greeting&gt;s’, greeting: ‘Hello’) #   format(‘%{greeting}’, greeting: ‘Hello’) # #   # good #   format(‘%s’, ‘Hello’) # @example MaxUnannotatedPlaceholdersAllowed: 0 # #   # bad #   format(‘%06d’, 10) #   format(‘%s %s.’, ‘Hello’, ‘world’) # #   # good #   format(‘%&lt;number&gt;06d’, number: 10) # @example MaxUnannotatedPlaceholdersAllowed: 1 (default) # #   # bad #   format(‘%s %s.’, ‘Hello’, ‘world’) # #   # good #   format(‘%06d’, 10) # @example AllowedMethods: [] (default) # #   # bad #   redirect(‘foo/%{bar_id}’) # @example AllowedMethods: [redirect] # #   # good #   redirect(‘foo/%{bar_id}’) # @example AllowedPatterns: [] (default) # #   # bad #   redirect(‘foo/%{bar_id}’) # @example AllowedPatterns: [‘redirect’] # #   # good #   redirect(‘foo/%{bar_id}’) # @example EnforcedStyle: annotated (default) # #   # bad #   format(‘%{greeting}’, greeting: ‘Hello’) #   format(‘%s’, ‘Hello’) # #   # good #   format(‘%&lt;greeting&gt;s’, greeting: ‘Hello’) # # source://rubocop//lib/rubocop/cop/style/format_string_token.rb#107 class RuboCop::Cop::Style::FormatStringToken &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_string_in_typical_context?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_string?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">detected_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_unannotated?</span>(<span class="ruby-identifier">detections</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_sequence</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">detected_sequence</span>, <span class="ruby-identifier">token_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_sequence</span>(<span class="ruby-identifier">detected_sequence</span>, <span class="ruby-identifier">token_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_detections</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conservative?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable_sequence?</span>(<span class="ruby-identifier">detected_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_string_token?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#245</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_unannotated_placeholders_allowed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">detected_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_text</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_contents</span>(<span class="ruby-identifier">source_map</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">token_ranges</span>(<span class="ruby-identifier">contents</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>(<span class="ruby-identifier">str_node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/format_string_token.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_allowed_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Helps you transition from mutable string literals # to frozen string literals. # of files to enable frozen string literals. Frozen string literals may be # default in future Ruby. The comment will be added below a shebang and # encoding comment. The frozen string literal comment is only valid in Ruby 2.3+. # # Note that the cop will accept files where the comment exists but is set # to ‘false` instead of `true`. # # To require a blank line after this comment, please see # `Layout/EmptyLineAfterMagicComment` cop. # # @example EnforcedStyle: always (default) #   # The `always` style will always add the frozen string literal comment #   # to a file, regardless of the Ruby version or if `freeze` or `&lt;&lt;` are #   # called on a string literal. #   # bad #   module Bar #   # … #   end # #   # good #   # frozen_string_literal: true # #   module Bar #   # … #   end # #   # good #   # frozen_string_literal: false # #   module Bar #   # … #   end # @example EnforcedStyle: never #   # The `never` will enforce that the frozen string literal comment does #   # not exist in a file. #   # bad #   # frozen_string_literal: true # #   module Baz #   # … #   end # #   # good #   module Baz #   # … #   end # @example EnforcedStyle: always_true #   # The `always_true` style enforces that the frozen string literal #   # comment is set to `true`. This is a stricter option than `always` #   # and forces projects to use frozen string literals. #   # bad #   # frozen_string_literal: false # #   module Baz #   # … #   end # #   # bad #   module Baz #   # … #   end # #   # good #   # frozen_string_literal: true # #   module Bar #   # … #   end # # source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#84 class RuboCop::Cop::Style::FrozenStringLiteralComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled_offense</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_comment</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_comment</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_enabled_comment</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_no_comment</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">following_comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal_comment</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_comment</span>(<span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_special_comment</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_range</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_offense</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_true_offense</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_comment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unnecessary_comment_offense</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#96 RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_DISABLED = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#94 RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#93 RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING_TRUE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#95 RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/frozen_string_literal_comment.rb#97 RuboCop::Cop::Style::FrozenStringLiteralComment::SHEBANG = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of ‘$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`. # `STDOUT/STDERR/STDIN` are constants, and while you can actually # reassign (possibly to redirect some stream) constants in Ruby, you’ll get # an interpreter warning if you do so. # # Additionally, ‘$stdout/$stderr/$stdin` can safely be accessed in a Ractor because they # are ractor-local, while `STDOUT/STDERR/STDIN` will raise `Ractor::IsolationError`. # # @example #   # bad #   STDOUT.puts(’hello’) # #   hash = { out: STDOUT, key: value } # #   def m(out = STDOUT) #   out.puts(‘hello’) #   end # #   # good #   $stdout.puts(‘hello’) # #   hash = { out: $stdout, key: value } # #   def m(out = $stdout) #   out.puts(‘hello’) #   end # # source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#37 class RuboCop::Cop::Style::GlobalStdStream &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_to_gvar_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gvar_name</span>(<span class="ruby-identifier">const_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">const_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespaced?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#40 RuboCop::Cop::Style::GlobalStdStream::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/global_std_stream.rb#42 RuboCop::Cop::Style::GlobalStdStream::STD_STREAMS = T.let(T.unsafe(nil), Set)</p>

<p># Looks for uses of global variables. # It does not report offenses for built-in global variables. # Built-in global variables are allowed by default. Additionally # users can allow additional variables via the AllowedVariables option. # # Note that backreferences like $1, $2, etc are not global variables. # # @example #   # bad #   $foo = 2 #   bar = $foo + 5 # #   # good #   FOO = 2 #   foo = 2 #   $stdin.read # # source://rubocop//lib/rubocop/cop/style/global_vars.rb#22 class RuboCop::Cop::Style::GlobalVars &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_vars.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_var?</span>(<span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_vars.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_vars.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_vars.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/global_vars.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">user_vars</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># built-in global variables and their English aliases # <a href="https://www.zenspider.com/ruby/quickref.html">www.zenspider.com/ruby/quickref.html</a> # # source://rubocop//lib/rubocop/cop/style/global_vars.rb#27 RuboCop::Cop::Style::GlobalVars::BUILT_IN_VARS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/global_vars.rb#23 RuboCop::Cop::Style::GlobalVars::MSG = T.let(T.unsafe(nil), String)</p>

<p># Use a guard clause instead of wrapping the code inside a conditional # expression # # A condition with an ‘elsif` or `else` branch is allowed unless # one of `return`, `break`, `next`, `raise`, or `fail` is used # in the body of the conditional expression. # # NOTE: Autocorrect works in most cases except with if-else statements #   that contain logical operators such as `foo || raise(’exception’)‘ # # @example #   # bad #   def test #   if something #   work #   end #   end # #   # good #   def test #   return unless something # #   work #   end # #   # also good #   def test #   work if something #   end # #   # bad #   if something #   raise ’exception’ #   else #   ok #   end # #   # good #   raise ‘exception’ if something #   ok # #   # bad #   if something #   foo || raise(‘exception’) #   else #   ok #   end # #   # good #   foo || raise(‘exception’) if something #   ok # #   # bad #   define_method(:test) do #   if something #   work #   end #   end # #   # good #   define_method(:test) do #   return unless something # #   work #   end # #   # also good #   define_method(:test) do #   work if something #   end # @example AllowConsecutiveConditionals: false (default) #   # bad #   def test #   if foo? #   work #   end # #   if bar?  # &lt;- reports an offense #   work #   end #   end # @example AllowConsecutiveConditionals: true #   # good #   def test #   if foo? #   work #   end # #   if bar? #   work #   end #   end # #   # bad #   def test #   if foo? #   work #   end # #   do_something # #   if bar?  # &lt;- reports an offense #   work #   end #   end # # source://rubocop//lib/rubocop/cop/style/guard_clause.rb#114 class RuboCop::Cop::Style::GuardClause &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MinBodyLength</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementModifier</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accepted_form?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">ending:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accepted_if?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">ending</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_consecutive_conditionals?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_or_guard_clause?</span>(<span class="ruby-identifier">guard_clause</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned_lvar_used_in_if_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">replacement</span>, <span class="ruby-identifier">guard</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_heredoc_argument</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">heredoc_branch</span>, <span class="ruby-identifier">leave_branch</span>, <span class="ruby-identifier">guard</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ending_body</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ending_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consecutive_conditionals?</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">guard_clause_source</span>(<span class="ruby-identifier">guard_clause</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_branch_to_remove</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">guard</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">scope_exiting_keyword</span>, <span class="ruby-identifier">conditional_keyword</span>, <span class="ruby-identifier">guard</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#309</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_whole_lines</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_for_single_line?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">example</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trivial?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/guard_clause.rb#120 RuboCop::Cop::Style::GuardClause::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for presence or absence of braces around hash literal as a last # array item depending on configuration. # # NOTE: This cop will ignore arrays where all items are hashes, regardless of # EnforcedStyle. # # @example EnforcedStyle: braces (default) #   # bad #   [1, 2, one: 1, two: 2] # #   # good #   [1, 2, { one: 1, two: 2 }] # #   # good #   [{ one: 1 }, { two: 2 }] # @example EnforcedStyle: no_braces #   # bad #   [1, 2, { one: 1, two: 2 }] # #   # good #   [1, 2, one: 1, two: 2] # #   # good #   [{ one: 1 }, { two: 2 }] # # source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#31 class RuboCop::Cop::Style::HashAsLastArrayItem &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_braces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_no_braces</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">containing_array</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_array?</span>(<span class="ruby-identifier">array</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_array_item?</span>(<span class="ruby-identifier">array</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_as_last_array_item.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_last_element_trailing_comma</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks the usage of pre-2.1 ‘<a href="args">Hash</a>` method of converting enumerables and # sequences of values to hashes. # # Correction code from splat argument (`<a href="*ary">Hash</a>`) is not simply determined. For example, # `<a href="*ary">Hash</a>` can be replaced with `ary.each_slice(2).to_h` but it will be complicated. # So, `AllowSplatArgument` option is true by default to allow splat argument for simple code. # # @example #   # bad #   <a href="ary">Hash</a> # #   # good #   ary.to_h # #   # bad #   Hash[key1, value1, key2, value2] # #   # good #   {key1 =&gt; value1, key2 =&gt; value2} # @example AllowSplatArgument: true (default) #   # good #   <a href="*ary">Hash</a> # @example AllowSplatArgument: false #   # bad #   <a href="*ary">Hash</a> # # source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#44 class RuboCop::Cop::Style::HashConversion &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_from_array?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_splat_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_to_hash</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multi_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense_for_hash</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">hash_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense_for_zip_method</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">zip_method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parens?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_zip_method_without_argument?</span>(<span class="ruby-identifier">first_argument</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#49 RuboCop::Cop::Style::HashConversion::MSG_LITERAL_HASH_ARG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#48 RuboCop::Cop::Style::HashConversion::MSG_LITERAL_MULTI_ARG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#50 RuboCop::Cop::Style::HashConversion::MSG_SPLAT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#47 RuboCop::Cop::Style::HashConversion::MSG_TO_H = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_conversion.rb#51 RuboCop::Cop::Style::HashConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of ‘each_key` and `each_value` `Hash` methods. # # NOTE: If you have an array of two-element arrays, you can put #   parentheses around the block arguments to indicate that you’re not #   working with a hash, and suppress RuboCop offenses. # # @example #   # bad #   hash.keys.each { |k| p k } #   hash.each { |k, unused_value| p k } # #   # good #   hash.each_key { |k| p k } # #   # bad #   hash.values.each { |v| p v } #   hash.each { |unused_key, v| p v } # #   # good #   hash.each_value { |v| p v } # @example AllowedReceivers: [‘execute’] #   # good #   execute(sql).keys.each { |v| p v } #   execute(sql).values.each { |v| p v } # # source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#36 class RuboCop::Cop::Style::HashEachMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedReceivers</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Lint</span><span class="ruby-operator">::</span><span class="ruby-constant">UnusedArgument</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_unused_block_args</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_arguments</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_mutated?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kv_each</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kv_each_with_block_pass</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block_pass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_argument</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_args</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_implicit</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_key_value_each</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">current</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handleable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kv_range</span>(<span class="ruby-identifier">outer_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">prefer</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">unused_code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_each_args_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>, <span class="ruby-identifier">prefer</span>, <span class="ruby-identifier">unused_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_kv_offense</span>(<span class="ruby-identifier">target</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_kv_with_block_pass_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_receiver</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unused_block_arg_exist?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_array_converter_method_as_preceding?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used?</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#43 RuboCop::Cop::Style::HashEachMethods::ARRAY_CONVERTER_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#41 RuboCop::Cop::Style::HashEachMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_each_methods.rb#42 RuboCop::Cop::Style::HashEachMethods::UNUSED_BLOCK_ARG_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for usages of ‘Hash#reject`, `Hash#select`, and `Hash#filter` methods # that can be replaced with `Hash#except` method. # # This cop should only be enabled on Ruby version 3.0 or higher. # (`Hash#except` was added in Ruby 3.0.) # # For safe detection, it is limited to commonly used string and symbol comparisons # when using `==` or `!=`. # # This cop doesn’t check for ‘Hash#delete_if` and `Hash#keep_if` because they # modify the receiver. # # @example # #   # bad #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| k == :bar } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| k != :bar } #   {foo: 1, bar: 2, baz: 3}.filter {|k, v| k != :bar } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| k.eql?(:bar) } # #   # bad #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| %<a href="bar">i</a>.include?(k) } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| !%<a href="bar">i</a>.include?(k) } #   {foo: 1, bar: 2, baz: 3}.filter {|k, v| !%<a href="bar">i</a>.include?(k) } # #   # good #   {foo: 1, bar: 2, baz: 3}.except(:bar) # @example AllCops:ActiveSupportExtensionsEnabled: false (default) # #   # good #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| !%<a href="bar">i</a>.exclude?(k) } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| %<a href="bar">i</a>.exclude?(k) } # #   # good #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| <a href="bar">k.in?(%i</a>) } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| !<a href="bar">k.in?(%i</a>) } # @example AllCops:ActiveSupportExtensionsEnabled: true # #   # bad #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| !%<a href="bar">i</a>.exclude?(k) } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| %<a href="bar">i</a>.exclude?(k) } # #   # bad #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| <a href="bar">k.in?(%i</a>) } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| !<a href="bar">k.in?(%i</a>) } # #   # good #   {foo: 1, bar: 2, baz: 3}.except(:bar) # # source://rubocop//lib/rubocop/cop/style/hash_except.rb#61 class RuboCop::Cop::Style::HashExcept &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashSubset</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_except.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_except.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantically_subset_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Use ‘Hash#dig` instead of chaining potentially null `fetch` calls. # # When `fetch(identifier, nil)` calls are chained on a hash, the expectation # is that each step in the chain returns either `nil` or another hash, # and in both cases, these can be simplified with a single call to `dig` with # multiple arguments. # # If the 2nd parameter is `{}` or `Hash.new`, an offense will also be registered, # as long as the final call in the chain is a nil value. If a non-nil value is given, # the chain will not be registered as an offense, as the default value cannot be safely # given with `dig`. # # NOTE: See `Style/DigChain` for replacing chains of `dig` calls with # a single method call. # # @example #   # bad #   hash.fetch(’foo’, nil)&amp;.fetch(‘bar’, nil) # #   # bad #   # earlier members of the chain can return ‘{}` as long as the final `fetch` #   # has `nil` as a default value #   hash.fetch(’foo’, {}).fetch(‘bar’, nil) # #   # good #   hash.dig(‘foo’, ‘bar’) # #   # ok - not handled by the cop since the final ‘fetch` value is non-nil #   hash.fetch(’foo’, {}).fetch(‘bar’, {}) # # source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#40 class RuboCop::Cop::Style::HashFetchChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">diggable?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_fetch_non_nil?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#44 RuboCop::Cop::Style::HashFetchChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_fetch_chain.rb#45 RuboCop::Cop::Style::HashFetchChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where ‘case-when` represents a simple 1:1 # mapping and can be replaced with a hash lookup. # # @example MinBranchesCount: 3 (default) #   # bad #   case country #   when ’europe’ #   ‘<a href="http://eu.example.com">eu.example.com</a>’ #   when ‘america’ #   ‘<a href="http://us.example.com">us.example.com</a>’ #   when ‘australia’ #   ‘<a href="http://au.example.com">au.example.com</a>’ #   end # #   # good #   SITES = { #   ‘europe’    =&gt; ‘<a href="http://eu.example.com">eu.example.com</a>’, #   ‘america’   =&gt; ‘<a href="http://us.example.com">us.example.com</a>’, #   ‘australia’ =&gt; ‘<a href="http://au.example.com">au.example.com</a>’ #   } #   <a href="country">SITES</a> # @example MinBranchesCount: 4 #   # good #   case country #   when ‘europe’ #   ‘<a href="http://eu.example.com">eu.example.com</a>’ #   when ‘america’ #   ‘<a href="http://us.example.com">us.example.com</a>’ #   when ‘australia’ #   ‘<a href="http://au.example.com">au.example.com</a>’ #   end # # source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#39 class RuboCop::Cop::Style::HashLikeCase &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MinBranchesCount</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_like_case?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nodes_of_same_type?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_like_case.rb#42 RuboCop::Cop::Style::HashLikeCase::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for usages of ‘Hash#reject`, `Hash#select`, and `Hash#filter` methods # that can be replaced with `Hash#slice` method. # # This cop should only be enabled on Ruby version 2.5 or higher. # (`Hash#slice` was added in Ruby 2.5.) # # For safe detection, it is limited to commonly used string and symbol comparisons # when using `==` or `!=`. # # This cop doesn’t check for ‘Hash#delete_if` and `Hash#keep_if` because they # modify the receiver. # # @example # #   # bad #   {foo: 1, bar: 2, baz: 3}.select {|k, v| k == :bar } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| k != :bar } #   {foo: 1, bar: 2, baz: 3}.filter {|k, v| k == :bar } #   {foo: 1, bar: 2, baz: 3}.select {|k, v| k.eql?(:bar) } # #   # bad #   {foo: 1, bar: 2, baz: 3}.select {|k, v| %<a href="bar">i</a>.include?(k) } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| !%<a href="bar">i</a>.include?(k) } #   {foo: 1, bar: 2, baz: 3}.filter {|k, v| %<a href="bar">i</a>.include?(k) } # #   # good #   {foo: 1, bar: 2, baz: 3}.slice(:bar) # @example AllCops:ActiveSupportExtensionsEnabled: false (default) # #   # good #   {foo: 1, bar: 2, baz: 3}.select {|k, v| !%<a href="bar">i</a>.exclude?(k) } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| %<a href="bar">i</a>.exclude?(k) } # #   # good #   {foo: 1, bar: 2, baz: 3}.select {|k, v| <a href="bar">k.in?(%i</a>) } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| !<a href="bar">k.in?(%i</a>) } # @example AllCops:ActiveSupportExtensionsEnabled: true # #   # bad #   {foo: 1, bar: 2, baz: 3}.select {|k, v| !%<a href="bar">i</a>.exclude?(k) } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| %<a href="bar">i</a>.exclude?(k) } # #   # bad #   {foo: 1, bar: 2, baz: 3}.select {|k, v| <a href="bar">k.in?(%i</a>) } #   {foo: 1, bar: 2, baz: 3}.reject {|k, v| !<a href="bar">k.in?(%i</a>) } # #   # good #   {foo: 1, bar: 2, baz: 3}.slice(:bar) # # source://rubocop//lib/rubocop/cop/style/hash_slice.rb#61 class RuboCop::Cop::Style::HashSlice &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashSubset</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_slice.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_slice.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantically_subset_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks hash literal syntax. # # It can enforce either the use of the class hash rocket syntax or # the use of the newer Ruby 1.9 syntax (when applicable). # # A separate offense is registered for each problematic pair. # # The supported styles are: # # * ruby19 - forces use of the 1.9 syntax (e.g. ‘{a: 1}`) when hashes have # all symbols for keys # * hash_rockets - forces use of hash rockets for all hashes # * no_mixed_keys - simply checks for hashes with mixed syntaxes # * ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed # syntax hashes # # This cop has `EnforcedShorthandSyntax` option. # It can enforce either the use of the explicit hash value syntax or # the use of Ruby 3.1’s hash value shorthand syntax. # # The supported styles are: # # * always - forces use of the 3.1 syntax (e.g. {foo:}) # * never - forces use of explicit hash literal value # * either - accepts both shorthand and explicit use of hash literal value # * consistent - forces use of the 3.1 syntax only if all values can be omitted in the hash # * either_consistent - accepts both shorthand and explicit use of hash literal value, #                       but they must be consistent # # @example EnforcedShorthandSyntax: either_consistent # #   # good - ‘foo` and `bar` values can be omitted, but they are consistent, so it’s accepted #   {foo: foo, bar: bar} # #   # bad - ‘bar` value can be omitted #   {foo:, bar: bar} # #   # bad - mixed syntaxes #   {foo:, bar: baz} # #   # good #   {foo:, bar:} # #   # good - can’t omit ‘baz` #   {foo: foo, bar: baz} # @example EnforcedStyle: hash_rockets #   # bad #   {a: 1, b: 2} #   {c: 1, ’d’ =&gt; 5} # #   # good #   {:a =&gt; 1, :b =&gt; 2} # @example EnforcedStyle: no_mixed_keys #   # bad #   {:a =&gt; 1, b: 2} #   {c: 1, ‘d’ =&gt; 2} # #   # good #   {:a =&gt; 1, :b =&gt; 2} #   {c: 1, d: 2} # @example EnforcedStyle: ruby19_no_mixed_keys #   # bad #   {:a =&gt; 1, :b =&gt; 2} #   {c: 2, ‘d’ =&gt; 3} # should just use hash rockets # #   # good #   {a: 1, b: 2} #   {:c =&gt; 3, ‘d’ =&gt; 4} # @example EnforcedShorthandSyntax: always # #   # bad #   {foo: foo, bar: bar} # #   # good #   {foo:, bar:} # #   # good - allowed to mix syntaxes #   {foo:, bar: baz} # @example EnforcedShorthandSyntax: never # #   # bad #   {foo:, bar:} # #   # good #   {foo: foo, bar: bar} # @example EnforcedShorthandSyntax: either (default) # #   # good #   {foo: foo, bar: bar} # #   # good #   {foo: foo, bar:} # #   # good #   {foo:, bar:} # @example EnforcedShorthandSyntax: consistent # #   # bad - ‘foo` and `bar` values can be omitted #   {foo: foo, bar: bar} # #   # bad - `bar` value can be omitted #   {foo:, bar: bar} # #   # bad - mixed syntaxes #   {foo:, bar: baz} # #   # good #   {foo:, bar:} # #   # good - can’t omit ‘baz` #   {foo: foo, bar: baz} # @example EnforcedStyle: ruby19 (default) #   # bad #   {:a =&gt; 2} #   {b: 1, :c =&gt; 2} # #   # good #   {a: 2, b: 1} #   {:c =&gt; 2, ’d’ =&gt; 2} # acceptable since ‘d’ isn’t a symbol #   {d: 1, ‘e’ =&gt; 2} # technically not forbidden # # source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#134 class RuboCop::Cop::Style::HashSyntax &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashShorthandSyntax</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_rockets_check</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_mixed_keys_check</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby19_check</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby19_no_mixed_keys_check</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_19_syntax_symbol?</span>(<span class="ruby-identifier">sym_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_without_space?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_hash_rockets</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">pair_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_no_mixed_keys</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">pair_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_ruby19</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">pair_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">pairs</span>, <span class="ruby-identifier">delim</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_hash_rockets?</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_autocorrect_ruby19</span>(<span class="ruby-identifier">pair_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sym_indices?</span>(<span class="ruby-identifier">pairs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">word_symbol_pair?</span>(<span class="ruby-identifier">pair</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#140 RuboCop::Cop::Style::HashSyntax::MSG_19 = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#142 RuboCop::Cop::Style::HashSyntax::MSG_HASH_ROCKETS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#141 RuboCop::Cop::Style::HashSyntax::MSG_NO_MIXED_KEYS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/hash_syntax.rb#143 RuboCop::Cop::Style::HashSyntax::NO_MIXED_KEYS_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># Looks for uses of ‘+_.each_with_object({}) {…}+`, # `+_.map {…}.to_h+`, and `+Hash[_.map {…}]+` that are actually just # transforming the keys of a hash, and tries to use a simpler &amp; faster # call to `transform_keys` instead. # It should only be enabled on Ruby version 2.5 or newer. # (`transform_keys` was added in Ruby 2.5.) # # @example #   # bad #   {a: 1, b: 2}.each_with_object({}) { |(k, v), h| <a href="foo(k)">h</a> = v } #   Hash[{a: 1, b: 2}.collect { |k, v| [foo(k), v] }] #   {a: 1, b: 2}.map { |k, v| [k.to_s, v] }.to_h #   {a: 1, b: 2}.to_h { |k, v| [k.to_s, v] } # #   # good #   {a: 1, b: 2}.transform_keys { |k| foo(k) } #   {a: 1, b: 2}.transform_keys { |k| k.to_s } # # source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#28 class RuboCop::Cop::Style::HashTransformKeys &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashTransformMethod</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_each_with_object</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_hash_brackets_map</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_map_to_h</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_to_h</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_captures</span>(<span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_keys.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_method_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Looks for uses of ‘+_.each_with_object({}) {…}+`, # `+_.map {…}.to_h+`, and `+Hash[_.map {…}]+` that are actually just # transforming the values of a hash, and tries to use a simpler &amp; faster # call to `transform_values` instead. # # @example #   # bad #   {a: 1, b: 2}.each_with_object({}) { |(k, v), h| <a href="k">h</a> = foo(v) } #   Hash[{a: 1, b: 2}.collect { |k, v| [k, foo(v)] }] #   {a: 1, b: 2}.map { |k, v| [k, v * v] }.to_h #   {a: 1, b: 2}.to_h { |k, v| [k, v * v] } # #   # good #   {a: 1, b: 2}.transform_values { |v| foo(v) } #   {a: 1, b: 2}.transform_values { |v| v * v } # # source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#26 class RuboCop::Cop::Style::HashTransformValues &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">HashTransformMethod</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_each_with_object</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_hash_brackets_map</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_map_to_h</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_bad_to_h</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_captures</span>(<span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/hash_transform_values.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_method_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for identical expressions at the beginning or end of # each branch of a conditional expression. Such expressions should normally # be placed outside the conditional expression - before or after it. # # NOTE: The cop is poorly named and some people might think that it actually # checks for duplicated conditional branches. The name will probably be changed # in a future major RuboCop release. # # @example #   # bad #   if condition #   do_x #   do_z #   else #   do_y #   do_z #   end # #   # good #   if condition #   do_x #   else #   do_y #   end #   do_z # #   # bad #   if condition #   do_z #   do_x #   else #   do_z #   do_y #   end # #   # good #   do_z #   if condition #   do_x #   else #   do_y #   end # #   # bad #   case foo #   when 1 #   do_x #   when 2 #   do_x #   else #   do_x #   end # #   # good #   case foo #   when 1 #   do_x #   do_y #   when 2 #   # nothing #   else #   do_x #   do_z #   end # #   # bad #   case foo #   in 1 #   do_x #   in 2 #   do_x #   else #   do_x #   end # #   # good #   case foo #   in 1 #   do_x #   do_y #   in 2 #   # nothing #   else #   do_x #   do_z #   end # # source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#110 class RuboCop::Cop::Style::IdenticalConditionalBranches &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignable_condition_value</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_branches</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">branches</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_expressions</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">expressions</span>, <span class="ruby-identifier">insert_position</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_assignment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">expression</span>, <span class="ruby-identifier">insert_position</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_no_assignment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">expression</span>, <span class="ruby-identifier">insert_position</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">duplicated_expressions?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">expressions</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># `elsif` branches show up in the if node as nested `else` branches. We</span>
<span class="ruby-comment"># need to recursively iterate over all `else` branches.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expand_elses</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">head</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_child_of_parent?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_child_branch?</span>(<span class="ruby-identifier">branch_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#263</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tail</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/identical_conditional_branches.rb#114 RuboCop::Cop::Style::IdenticalConditionalBranches::MSG = T.let(T.unsafe(nil), String)</p>

<p># Corrector to correct conditional assignment in ‘if` statements. # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#571 class RuboCop::Cop::Style::IfCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalAssignmentHelper</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalCorrectorHelper</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#576</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">cop</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#580</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_assignment_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#594</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_tail_branches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#601</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_branch_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branch</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">assignment</span>, <span class="ruby-identifier">column</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># If the ‘else` branch of a conditional consists solely of an `if` node, # it can be combined with the `else` to become an `elsif`. # This helps to keep the nesting level from getting too deep. # # @example #   # bad #   if condition_a #   action_a #   else #   if condition_b #   action_b #   else #   action_c #   end #   end # #   # good #   if condition_a #   action_a #   elsif condition_b #   action_b #   else #   action_c #   end # @example AllowIfModifier: false (default) #   # bad #   if condition_a #   action_a #   else #   action_b if condition_b #   end # #   # good #   if condition_a #   action_a #   elsif condition_b #   action_b #   end # @example AllowIfModifier: true #   # good #   if condition_a #   action_a #   else #   action_b if condition_b #   end # #   # good #   if condition_a #   action_a #   elsif condition_b #   action_b #   end # # source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#61 class RuboCop::Cop::Style::IfInsideElse &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_if_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_if_modifier_in_else_branch?</span>(<span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_elsif_from_if_inside_else_form</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_elsif_from_modifier_form</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_end_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_condition_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/if_inside_else.rb#65 RuboCop::Cop::Style::IfInsideElse::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘if` and `unless` statements that would fit on one line if # written as modifier `if`/`unless`. The cop also checks for modifier # `if`/`unless` lines that exceed the maximum line length. # # The maximum line length is configured in the `Layout/LineLength` # cop. The tab size is configured in the `IndentationWidth` of the # `Layout/IndentationStyle` cop. # # One-line pattern matching is always allowed. To ensure that there are few cases # where the match variable is not used, and to prevent oversights. The variable `x` # becomes undefined and raises `NameError` when the following example is changed to # the modifier form: # # [source,ruby] # —- # if [42] in [x] #   x # `x` is undefined when using modifier form. # end # —- # # The code `def method_name = body if condition` is considered a bad case by # `Style/AmbiguousEndlessMethodDefinition` cop. So, to respect the user’s intention to use # an endless method definition in the ‘if` body, the following code is allowed: # # [source,ruby] # —- # if condition #   def method_name = body # end # —- # # NOTE: It is allowed when `defined?` argument has an undefined value, # because using the modifier form causes the following incompatibility: # # [source,ruby] # —- # unless defined?(undefined_foo) #   undefined_foo = ’default_value’ # end # undefined_foo # =&gt; ‘default_value’ # # undefined_bar = ‘default_value’ unless defined?(undefined_bar) # undefined_bar # =&gt; nil # —- # # @example #   # bad #   if condition #   do_stuff(bar) #   end # #   unless qux.empty? #   Foo.do_something #   end # #   do_something_with_a_long_name(arg) if long_condition_that_prevents_code_fit_on_single_line # #   # good #   do_stuff(bar) if condition #   Foo.do_something unless qux.empty? # #   if long_condition_that_prevents_code_fit_on_single_line #   do_something_with_a_long_name(arg) #   end # #   if short_condition # a long comment that makes it too long if it were just a single line #   do_something #   end # # source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#74 class RuboCop::Cop::Style::IfUnlessModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementModifier</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_patterns</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">another_statement_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_on_node_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_argument_is_undefined?</span>(<span class="ruby-identifier">if_node</span>, <span class="ruby-identifier">defined_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_nodes</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">endless_method?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_heredoc_from</span>(<span class="ruby-identifier">last_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_length_enabled_at_line?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_capture_in_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_eligible_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_simple_if_unless?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern_matching_nodes</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#316</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_comment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">_node</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_heredoc</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_for_modifier_form</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#292</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_modifier_form_with_move_comment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">indentation</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_normal_form</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">indentation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_normal_form_with_heredoc</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">indentation</span>, <span class="ruby-identifier">heredoc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_due_to_comment_after_modifier?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_due_to_modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_line_based_on_allow_qualified_name?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_line_based_on_allow_uri?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_line_based_on_config?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_line_based_on_ignore_cop_directives?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long_single_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#87</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#82 RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_MODIFIER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/if_unless_modifier.rb#85 RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_NORMAL = T.let(T.unsafe(nil), String)</p>

<p># Checks for if and unless statements used as modifiers of other if or # unless statements. # # @example # #   # bad #   tired? ? ‘stop’ : ‘go faster’ if running? # #   # bad #   if tired? #   “please stop” #   else #   “keep going” #   end if running? # #   # good #   if running? #   tired? ? ‘stop’ : ‘go faster’ #   end # # source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#25 class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementModifier</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/if_unless_modifier_of_if_unless.rb#29 RuboCop::Cop::Style::IfUnlessModifierOfIfUnless::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant ‘if` with boolean literal branches. # It checks only conditions to return boolean value (`true` or `false`) for safe detection. # The conditions to be checked are comparison methods, predicate methods, and # double negation (!!). # `nonzero?` method is allowed by default. # These are customizable with `AllowedMethods` option. # # This cop targets only “if“s with a single `elsif` or `else` branch. The following # code will be allowed, because it has two `elsif` branches: # # [source,ruby] # —- # if foo #   true # elsif bar &gt; baz #   true # elsif qux &gt; quux # Single `elsif` is warned, but two or more `elsif`s are not. #   true # else #   false # end # —- # # @example #   # bad #   if foo == bar #   true #   else #   false #   end # #   # bad #   foo == bar ? true : false # #   # good #   foo == bar # #   # bad #   if foo.do_something? #   true #   else #   false #   end # #   # good (but potentially an unsafe correction) #   foo.do_something? # @example AllowedMethods: [’nonzero?‘] (default) #   # good #   num.nonzero? ? true : false # # source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#61 class RuboCop::Cop::Style::IfWithBooleanLiteralBranches &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_negative?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_with_boolean_literal_branches?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assume_boolean_value?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_elsif?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range_with_keyword</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_condition</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_boolean_value?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#65 RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/if_with_boolean_literal_branches.rb#66 RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG_FOR_ELSIF = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of semicolon in if statements. # # @example # #   # bad #   result = if some_condition; something else another_thing end # #   # good #   result = some_condition ? something : another_thing # # source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#16 class RuboCop::Cop::Style::IfWithSemicolon &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OnNormalIfUnless</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_normal_if_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_else_branch</span>(<span class="ruby-identifier">second_condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_expression</span>(<span class="ruby-identifier">expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_elsif</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_argument_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_newline?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_masgn_or_block_in_branches?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_return_with_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#20 RuboCop::Cop::Style::IfWithSemicolon::MSG_IF_ELSE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#21 RuboCop::Cop::Style::IfWithSemicolon::MSG_NEWLINE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/if_with_semicolon.rb#22 RuboCop::Cop::Style::IfWithSemicolon::MSG_TERNARY = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘raise` or `fail` statements which do not specify an # explicit exception class. (This raises a `RuntimeError`. Some projects # might prefer to use exception classes which more precisely identify the # nature of the error.) # # @example #   # bad #   raise ’Error message here’ # #   # good #   raise ArgumentError, ‘Error message here’ # # source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#17 class RuboCop::Cop::Style::ImplicitRuntimeError &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_runtime_error_raise_or_fail</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#18 RuboCop::Cop::Style::ImplicitRuntimeError::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/implicit_runtime_error.rb#20 RuboCop::Cop::Style::ImplicitRuntimeError::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘in;` uses in `case` expressions. # # @example #   # bad #   case expression #   in pattern_a; foo #   in pattern_b; bar #   end # #   # good #   case expression #   in pattern_a then foo #   in pattern_b then bar #   end # # source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#21 class RuboCop::Cop::Style::InPatternThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative_pattern_source</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_alternative_patterns</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/in_pattern_then.rb#27 RuboCop::Cop::Style::InPatternThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># Use ‘Kernel#loop` for infinite loops. # # @example #   # bad #   while true #   work #   end # #   # good #   loop do #   work #   end # # source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#23 class RuboCop::Cop::Style::InfiniteLoop &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned_before_loop?</span>(<span class="ruby-identifier">var</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned_inside_loop?</span>(<span class="ruby-identifier">var</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_modifier_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced_after_loop?</span>(<span class="ruby-identifier">var</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_begin_end_with_modifier</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_source</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">while_or_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#27 RuboCop::Cop::Style::InfiniteLoop::LEADING_SPACE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/infinite_loop.rb#29 RuboCop::Cop::Style::InfiniteLoop::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing inline comments. # # @example # #   # good #   foo.each do |f| #   # Standalone comment #   f.bar #   end # #   # bad #   foo.each do |f| #   f.bar # Trailing inline comment #   end # # source://rubocop//lib/rubocop/cop/style/inline_comment.rb#20 class RuboCop::Cop::Style::InlineComment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inline_comment.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/inline_comment.rb#21 RuboCop::Cop::Style::InlineComment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Check for usages of not (‘not` or `!`) called on a method # when an inverse of that method can be used instead. # # Methods that can be inverted by a not (`not` or `!`) should be defined # in `InverseMethods`. # # Methods that are inverted by inverting the return # of the block that is passed to the method should be defined in # `InverseBlocks`. # # @example #   # bad #   !foo.none? #   !foo.any? { |f| f.even? } #   !foo.blank? #   !(foo == bar) #   foo.select { |f| !f.even? } #   foo.reject { |f| f != 7 } # #   # good #   foo.none? #   foo.blank? #   foo.any? { |f| f.even? } #   foo != bar #   foo == bar #   !!(’foo’ =~ /^w+$/) #   !(foo.class &lt; Numeric) # Checking class hierarchy is allowed #   # Blocks with guard clauses are ignored: #   foo.select do |f| #   next if f.zero? #   f != 1 #   end # # source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#43 class RuboCop::Cop::Style::InverseMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">camel_case_constant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_inverse_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_inverse_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_inverse_selector</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dot_range</span>(<span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_parentheses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_blocks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">inverse</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negated?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_to_receiver</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># When comparing classes, `!(Integer &lt; Numeric)` is not the same as</span>
<span class="ruby-comment"># `Integer &gt; Numeric`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">possible_class_hierarchy_check?</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_end_parenthesis</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_navigation_incompatible?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#56</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#52 RuboCop::Cop::Style::InverseMethods::CAMEL_CASE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#48 RuboCop::Cop::Style::InverseMethods::CLASS_COMPARISON_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#50 RuboCop::Cop::Style::InverseMethods::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#47 RuboCop::Cop::Style::InverseMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#51 RuboCop::Cop::Style::InverseMethods::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#54 RuboCop::Cop::Style::InverseMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/inverse_methods.rb#49 RuboCop::Cop::Style::InverseMethods::SAFE_NAVIGATION_INCOMPATIBLE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for usages of ‘unless` which can be replaced by `if` with inverted condition. # Code without `unless` is easier to read, but that is subjective, so this cop # is disabled by default. # # Methods that can be inverted should be defined in `InverseMethods`. Note that # the relationship of inverse methods needs to be defined in both directions. # For example, # # [source,yaml] # —- # InverseMethods: #   :!=: :== #   :even?: :odd? #   :odd?: :even? # —- # # will suggest both `even?` and `odd?` to be inverted, but only `!=` (and not `==`). # # @example #   # bad (simple condition) #   foo unless !bar #   foo unless x != y #   foo unless x &gt;= 10 #   foo unless x.even? #   foo unless odd? # #   # good #   foo if bar #   foo if x == y #   foo if x &lt; 10 #   foo if x.odd? #   foo if even? # #   # bad (complex condition) #   foo unless x != y || x.even? # #   # good #   foo if x == y &amp;&amp; x.odd? # #   # good (if) #   foo if !condition # # source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#53 class RuboCop::Cop::Style::InvertibleUnlessCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_send_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inheritance_check?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invertible?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_logical_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_send_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/invertible_unless_condition.rb#56 RuboCop::Cop::Style::InvertibleUnlessCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for hardcoded IP addresses, which can make code # brittle. IP addresses are likely to need to be changed when code # is deployed to a different server or environment, which may break # a deployment if forgotten. Prefer setting IP addresses in ENV or # other configuration. # # @example # #   # bad #   ip_address = ‘127.59.241.29’ # #   # good #   ip_address = <a href="&#39;DEPLOYMENT_IP_ADDRESS&#39;">ENV</a> # # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#21 class RuboCop::Cop::Style::IpAddresses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringHelp</span>

<span class="ruby-comment"># Dummy implementation of method in ConfigurableEnforcedStyle that is</span>
<span class="ruby-comment"># called from StringHelp.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Dummy implementation of method in ConfigurableEnforcedStyle that is</span>
<span class="ruby-comment"># called from StringHelp.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite_style_detected</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_addresses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">potential_ip?</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">starts_with_hex_or_colon?</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">too_long?</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># IPv4-mapped IPv6 is the longest # # source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#24 RuboCop::Cop::Style::IpAddresses::IPV6_MAX_SIZE = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/style/ip_addresses.rb#25 RuboCop::Cop::Style::IpAddresses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for assignments to a local ‘it` variable inside a block # where `it` can refer to the first anonymous parameter as of Ruby 3.4. # # Although Ruby allows reassigning `it` in these cases, it could # cause confusion if `it` is used as a block parameter elsewhere. # For consistency, this also applies to numblocks and blocks with # parameters, even though `it` cannot be used in those cases. # # @example #   # bad #   foo { it = 5 } #   foo { |bar| it = bar } #   foo { it = _2 } # #   # good - use a different variable name #   foo { var = 5 } #   foo { |bar| var = bar } #   foo { bar = _2 } # # source://rubocop//lib/rubocop/cop/style/it_assignment.rb#24 class RuboCop::Cop::Style::ItAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/it_assignment.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/it_assignment.rb#25 RuboCop::Cop::Style::ItAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for blocks with one argument where ‘it` block parameter can be used. # # It provides four `EnforcedStyle` options: # # 1. `allow_single_line` (default) … Always uses the `it` block parameter in a single line. # 2. `only_numbered_parameters` … Detects only numbered block parameters. # 3. `always` … Always uses the `it` block parameter. # 4. `disallow` … Disallows the `it` block parameter. # # A single numbered parameter is detected when `allow_single_line`, # `only_numbered_parameters`, or `always`. # # @example EnforcedStyle: allow_single_line (default) #   # bad #   block do #   do_something(it) #   end #   block { do_something(_1) } # #   # good #   block { do_something(it) } #   block { |named_param| do_something(named_param) } # @example EnforcedStyle: only_numbered_parameters #   # bad #   block { do_something(_1) } # #   # good #   block { do_something(it) } #   block { |named_param| do_something(named_param) } # @example EnforcedStyle: always #   # bad #   block { do_something(_1) } #   block { |named_param| do_something(named_param) } # #   # good #   block { do_something(it) } # @example EnforcedStyle: disallow #   # bad #   block { do_something(it) } # #   # good #   block { do_something(_1) } #   block { |named_param| do_something(named_param) } # # source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#53 class RuboCop::Cop::Style::ItBlockParameter &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_block_variables</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_argument_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#59 RuboCop::Cop::Style::ItBlockParameter::MSG_AVOID_IT_PARAMETER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#60 RuboCop::Cop::Style::ItBlockParameter::MSG_AVOID_IT_PARAMETER_MULTILINE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/it_block_parameter.rb#58 RuboCop::Cop::Style::ItBlockParameter::MSG_USE_IT_PARAMETER = T.let(T.unsafe(nil), String)</p>

<p># When passing an existing hash as keyword arguments, provide additional arguments # directly rather than using ‘merge`. # # Providing arguments directly is more performant than using `merge`, and # also leads to shorter and simpler code. # # @example #   # bad #   some_method(**opts.merge(foo: true)) #   some_method(**opts.merge(other_opts)) # #   # good #   some_method(**opts, foo: true) #   some_method(**opts, **other_opts) # # source://rubocop//lib/rubocop/cop/style/keyword_arguments_merging.rb#21 class RuboCop::Cop::Style::KeywordArgumentsMerging &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_arguments_merging.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_kwargs?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_arguments_merging.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwsplat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_arguments_merging.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">kwsplat_node</span>, <span class="ruby-identifier">hash_node</span>, <span class="ruby-identifier">other_hash_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/keyword_arguments_merging.rb#24 RuboCop::Cop::Style::KeywordArgumentsMerging::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces that optional keyword parameters are placed at the # end of the parameters list. # # This improves readability, because when looking through the source, # it is expected to find required parameters at the beginning of parameters list # and optional parameters at the end. # # @example #   # bad #   def some_method(first: false, second:, third: 10) #   # body omitted #   end # #   # good #   def some_method(second:, first: false, third: 10) #   # body omitted #   end # #   # bad #   do_something do |first: false, second:, third: 10| #   # body omitted #   end # #   # good #   do_something do |second:, first: false, third: 10| #   # body omitted #   end # # source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#34 class RuboCop::Cop::Style::KeywordParametersOrder &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">append_newline_to_last_kwoptarg</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">defining_node</span>, <span class="ruby-identifier">kwarg_nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_kwargs</span>(<span class="ruby-identifier">kwarg_nodes</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/keyword_parameters_order.rb#38 RuboCop::Cop::Style::KeywordParametersOrder::MSG = T.let(T.unsafe(nil), String)</p>

<p># (by default) checks for uses of the lambda literal syntax for # single line lambdas, and the method call syntax for multiline lambdas. # It is configurable to enforce one of the styles for both single line # and multiline lambdas as well. # # @example EnforcedStyle: line_count_dependent (default) #   # bad #   f = lambda { |x| x } #   f = -&gt;(x) do #   x #   end # #   # good #   f = -&gt;(x) { x } #   f = lambda do |x| #   x #   end # @example EnforcedStyle: lambda #   # bad #   f = -&gt;(x) { x } #   f = -&gt;(x) do #   x #   end # #   # good #   f = lambda { |x| x } #   f = lambda do |x| #   x #   end # @example EnforcedStyle: literal #   # bad #   f = lambda { |x| x } #   f = lambda do |x| #   x #   end # #   # good #   f = -&gt;(x) { x } #   f = -&gt;(x) do #   x #   end # # source://rubocop//lib/rubocop/cop/style/lambda.rb#49 class RuboCop::Cop::Style::Lambda &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_with_whitespace</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_method_to_literal</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_arg_string</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">selector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_line_modifier</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_selector?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">selector</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/lambda.rb#53 RuboCop::Cop::Style::Lambda::LITERAL_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/lambda.rb#54 RuboCop::Cop::Style::Lambda::METHOD_MESSAGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/lambda.rb#56 RuboCop::Cop::Style::Lambda::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)</p>

<p># Checks for use of the lambda.(args) syntax. # # @example EnforcedStyle: call (default) #   # bad #   lambda.(x, y) # #   # good #   lambda.call(x, y) # @example EnforcedStyle: braces #   # bad #   lambda.call(x, y) # #   # good #   lambda.(x, y) # # source://rubocop//lib/rubocop/cop/style/lambda_call.rb#21 class RuboCop::Cop::Style::LambdaCall &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prefer</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#25 RuboCop::Cop::Style::LambdaCall::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/lambda_call.rb#26 RuboCop::Cop::Style::LambdaCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for string literal concatenation at # the end of a line. # # @example # #   # bad #   some_str = ‘ala’ + #   ‘bala’ # #   some_str = ‘ala’ &lt;&lt; #   ‘bala’ # #   # good #   some_str = ‘ala’ \ #   ‘bala’ # # source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#35 class RuboCop::Cop::Style::LineEndConcatenation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">operator_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_token_set</span>(<span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_next_successor?</span>(<span class="ruby-identifier">next_successor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_operator?</span>(<span class="ruby-identifier">operator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_predecessor?</span>(<span class="ruby-identifier">predecessor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_successor?</span>(<span class="ruby-identifier">successor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_token_set?</span>(<span class="ruby-identifier">predecessor</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">successor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">operator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">standard_string_literal?</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">token_after_last_string</span>(<span class="ruby-identifier">successor</span>, <span class="ruby-identifier">base_index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#42 RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_BEGIN_TOKEN = T.let(T.unsafe(nil), Symbol)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#43 RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_END_TOKEN = T.let(T.unsafe(nil), Symbol)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#40 RuboCop::Cop::Style::LineEndConcatenation::CONCAT_TOKEN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#44 RuboCop::Cop::Style::LineEndConcatenation::HIGH_PRECEDENCE_OP_TOKEN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#39 RuboCop::Cop::Style::LineEndConcatenation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#45 RuboCop::Cop::Style::LineEndConcatenation::QUOTE_DELIMITERS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/line_end_concatenation.rb#41 RuboCop::Cop::Style::LineEndConcatenation::SIMPLE_STRING_TOKEN_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># Ensures magic comments are written consistently throughout your code base. # Looks for discrepancies in separators (‘-` vs `_`) and capitalization for # both magic comment directives and values. # # Required capitalization can be set with the `DirectiveCapitalization` and # `ValueCapitalization` configuration keys. # # NOTE: If one of these configuration is set to nil, any capitalization is allowed. # # @example ValueCapitalization: uppercase #   # bad #   # frozen-string-literal: true # #   # good #   # frozen-string-literal: TRUE # @example EnforcedStyle: kebab_case #   # The `kebab_case` style will enforce that the frozen string literal #   # comment is written in kebab case. (Words separated by hyphens) #   # bad #   # frozen_string_literal: true # #   module Baz #   # … #   end # #   # good #   # frozen-string-literal: true # #   module Baz #   # … #   end # @example DirectiveCapitalization: lowercase (default) #   # bad #   # FROZEN-STRING-LITERAL: true # #   # good #   # frozen-string-literal: true # @example DirectiveCapitalization: uppercase #   # bad #   # frozen-string-literal: true # #   # good #   # FROZEN-STRING-LITERAL: true # @example DirectiveCapitalization: nil #   # any capitalization is accepted # #   # good #   # frozen-string-literal: true # #   # good #   # FROZEN-STRING-LITERAL: true # @example ValueCapitalization: nil (default) #   # any capitalization is accepted # #   # good #   # frozen-string-literal: true # #   # good #   # frozen-string-literal: TRUE # @example ValueCapitalization: lowercase #   # when a value is not given, any capitalization is accepted # #   # bad #   # frozen-string-literal: TRUE # #   # good #   # frozen-string-literal: TRUE # @example EnforcedStyle: snake_case (default) #   # The `snake_case` style will enforce that the frozen string literal #   # comment is written in snake case. (Words separated by underscores) #   # bad #   # frozen-string-literal: true # #   module Bar #   # … #   end # #   # good #   # frozen_string_literal: false # #   module Bar #   # … #   end # # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#97 class RuboCop::Cop::Style::MagicCommentFormat &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_separator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_capitalization</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_offends?</span>(<span class="ruby-identifier">directive</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expected_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_issues</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_directives</span>(<span class="ruby-identifier">issues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_values</span>(<span class="ruby-identifier">issues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#245</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incorrect_separator?</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_comment_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_range</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magic_comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offenses</span>(<span class="ruby-identifier">issues</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_capitalization</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_separator</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_capitalizations</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_capitalization?</span>(<span class="ruby-identifier">style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_capitalization</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrong_capitalization?</span>(<span class="ruby-identifier">text</span>, <span class="ruby-identifier">expected_case</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrong_separator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Value object to extract source ranges for the different parts of a magic comment # # source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#107 class RuboCop::Cop::Style::MagicCommentFormat::CommentRange</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [CommentRange] a new instance of CommentRange</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A magic comment can contain one directive (normal style) or</span>
<span class="ruby-comment"># multiple directives (emacs style)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directives</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A magic comment can contain one value (normal style) or</span>
<span class="ruby-comment"># multiple directives (emacs style)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#110 RuboCop::Cop::Style::MagicCommentFormat::CommentRange::DIRECTIVE_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#114 RuboCop::Cop::Style::MagicCommentFormat::CommentRange::VALUE_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#102 RuboCop::Cop::Style::MagicCommentFormat::KEBAB_SEPARATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#103 RuboCop::Cop::Style::MagicCommentFormat::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#104 RuboCop::Cop::Style::MagicCommentFormat::MSG_VALUE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/magic_comment_format.rb#101 RuboCop::Cop::Style::MagicCommentFormat::SNAKE_SEPARATOR = T.let(T.unsafe(nil), String)</p>

<p># Prefer ‘select` or `reject` over `map { … }.compact`. # This cop also handles `filter_map { … }`, similar to `map { … }.compact`. # # @example # #   # bad #   array.map { |e| some_condition? ? e : next }.compact # #   # bad #   array.filter_map { |e| some_condition? ? e : next } # #   # bad #   array.map do |e| #   if some_condition? #   e #   else #   next #   end #   end.compact # #   # bad #   array.map do |e| #   next if some_condition? # #   e #   end.compact # #   # bad #   array.map do |e| #   e if some_condition? #   end.compact # #   # good #   array.select { |e| some_condition? } # #   # good #   array.reject { |e| some_condition? } # # source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#44 class RuboCop::Cop::Style::MapCompactWithConditionalBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter_map_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_argument_node</span>, <span class="ruby-identifier">condition_node</span>, <span class="ruby-identifier">return_value_node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map_with_compact_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">returns_block_argument?</span>(<span class="ruby-identifier">block_argument_node</span>, <span class="ruby-identifier">return_value_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_branch_for_guard?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_branch_for_if?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#47 RuboCop::Cop::Style::MapCompactWithConditionalBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/map_compact_with_conditional_block.rb#48 RuboCop::Cop::Style::MapCompactWithConditionalBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for usages of ‘each` with `&lt;&lt;`, `push`, or `append` which # can be replaced by `map`. # # If `PreferredMethods` is configured for `map` in `Style/CollectionMethods`, # this cop uses the specified method for replacement. # # NOTE: The return value of `Enumerable#each` is `self`, whereas the # return value of `Enumerable#map` is an `Array`. They are not autocorrected # when a return value could be used because these types differ. # # NOTE: It only detects when the mapping destination is either: # * a local variable initialized as an empty array and referred to only by the # pushing operation; # * or, if it is the single block argument to a `[].tap` block. # This is because, if not, it’s challenging to statically guarantee that the # mapping destination variable remains an empty array: # # [source,ruby] # —- # ret = [] # src.each { |e| ret &lt;&lt; e * 2 } # ‘&lt;&lt;` method may mutate `ret` # # dest = [] # src.each { |e| dest &lt;&lt; transform(e, dest) } # `transform` method may mutate `dest` # —- # # @example #   # bad #   dest = [] #   src.each { |e| dest &lt;&lt; e * 2 } #   dest # #   # good #   dest = src.map { |e| e * 2 } # #   # bad #   [].tap do |dest| #   src.each { |e| dest &lt;&lt; e * 2 } #   end # #   # good #   dest = src.map { |e| e * 2 } # #   # good - contains another operation #   dest = [] #   src.each { |e| dest &lt;&lt; e * 2; puts e } #   dest # # source://rubocop//lib/rubocop/cop/style/map_into_array.rb#60 class RuboCop::Cop::Style::MapIntoArray &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">scope</span>, <span class="ruby-identifier">_variable_table</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_block_with_push?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_array_asgn?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_array_tap</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lvar_ref?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suitable_argument_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_push_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">push_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_return_value_handling</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">dest_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dest_used_only_for_mapping?</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">dest_var</span>, <span class="ruby-identifier">asgn</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_closest_assignment</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">dest_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_dest_var</span>(<span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_empty_array_tap?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">dest_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">dest_var</span>, <span class="ruby-identifier">asgn</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_assignment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">asgn</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_tap</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_value_used?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#105</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">joining_forces</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/map_into_array.rb#64 RuboCop::Cop::Style::MapIntoArray::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for uses of ‘map.to_h` or `collect.to_h` that could be # written with just `to_h` in Ruby &gt;= 2.6. # # NOTE: `Style/HashTransformKeys` and `Style/HashTransformValues` will # also change this pattern if only hash keys or hash values are being # transformed. # # @example #   # bad #   something.map { |v| [v, v * 2] }.to_h # #   # good #   something.to_h { |v| [v, v * 2] } # #   # bad #   {foo: bar}.collect { |k, v| [k.to_s, v.do_something] }.to_h # #   # good #   {foo: bar}.to_h { |k, v| [k.to_s, v.do_something] } # # source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#30 class RuboCop::Cop::Style::MapToHash &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">destructuring_argument</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map_to_h</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">to_h</span>, <span class="ruby-identifier">map</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#53</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#37 RuboCop::Cop::Style::MapToHash::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/map_to_hash.rb#38 RuboCop::Cop::Style::MapToHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for uses of ‘map.to_set` or `collect.to_set` that could be # written with just `to_set`. # # @example #   # bad #   something.map { |i| i * 2 }.to_set # #   # good #   something.to_set { |i| i * 2 } # #   # bad #   [1, 2, 3].collect { |i| i.to_s }.to_set # #   # good #   [1, 2, 3].to_set { |i| i.to_s } # # source://rubocop//lib/rubocop/cop/style/map_to_set.rb#26 class RuboCop::Cop::Style::MapToSet &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map_to_set?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">to_set</span>, <span class="ruby-identifier">map</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#30 RuboCop::Cop::Style::MapToSet::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/map_to_set.rb#31 RuboCop::Cop::Style::MapToSet::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the presence (default) or absence of parentheses in # method calls containing arguments. # # In the default style (require_parentheses), macro methods are allowed. # Additional methods can be added to the ‘AllowedMethods` or # `AllowedPatterns` list. These options are valid only in the default # style. Macros can be included by either setting `IgnoreMacros` to false # or adding specific macros to the `IncludedMacros` list. # # Precedence of options is as follows: # # 1. `AllowedMethods` # 2. `AllowedPatterns` # 3. `IncludedMacros` # # If a method is listed in both `IncludedMacros` and `AllowedMethods`, # then the latter takes precedence (that is, the method is allowed). # # In the alternative style (omit_parentheses), there are three additional # options. # # 1. `AllowParenthesesInChaining` is `false` by default. Setting it to #    `true` allows the presence of parentheses in the last call during #    method chaining. # # 2. `AllowParenthesesInMultilineCall` is `false` by default. Setting it #     to `true` allows the presence of parentheses in multi-line method #     calls. # # 3. `AllowParenthesesInCamelCaseMethod` is `false` by default. This #     allows the presence of parentheses when calling a method whose name #     begins with a capital letter and which has no arguments. Setting it #     to `true` allows the presence of parentheses in such a method call #     even with arguments. # # NOTE: The style of `omit_parentheses` allows parentheses in cases where # omitting them results in ambiguous or syntactically incorrect code. # # Non-exhaustive list of examples: # # - Parentheses are required allowed in method calls with arguments inside #   literals, logical operators, setting default values in position and #   keyword arguments, chaining and more. # - Parentheses are allowed in method calls with arguments inside #   operators to avoid ambiguity. #   triple-dot syntax introduced in Ruby 2.7 as omitting them starts an #   endless range. # - Parentheses are allowed when forwarding arguments with the #   triple-dot syntax introduced in Ruby 2.7 as omitting them starts an #   endless range. # - Parentheses are required in calls with arguments when inside an #   endless method definition introduced in Ruby 3.0. # - Ruby 3.1’s hash omission syntax allows parentheses if the method call #   is in conditionals and requires parentheses if the call #   is not the value-returning expression. See #   <a href="https://bugs.ruby-lang.org/issues/18396">bugs.ruby-lang.org/issues/18396</a>. # - Parentheses are required in anonymous arguments, keyword arguments #   and block passing in Ruby 3.2. # - Parentheses are required when the first argument is a beginless range or #   the last argument is an endless range. # # @example AllowParenthesesInStringInterpolation: true # #   # good #   “#{t(‘this.is.good’)}” # #   # good #   “#{t ‘this.is.also.good’}” # @example EnforcedStyle: omit_parentheses # #   # bad #   array.delete(e) # #   # good #   array.delete e # #   # bad #   action.enforce(strict: true) # #   # good #   action.enforce strict: true # #   # good #   # Parentheses are allowed for code that can be ambiguous without #   # them. #   action.enforce(condition) || other_condition # #   # good #   # Parentheses are allowed for calls that won’t produce valid Ruby #   # without them. #   yield path, File.basename(path) # #   # good #   # Omitting the parentheses in Ruby 3.1 hash omission syntax can lead #   # to ambiguous code. We allow them in conditionals and non-last #   # expressions. See <a href="https://bugs.ruby-lang.org/issues/18396">bugs.ruby-lang.org/issues/18396</a> #   if meets(criteria:, action:) #   safe_action(action) || dangerous_action(action) #   end # @example IgnoreMacros: true (default) # #   # good #   class Foo #   bar :baz #   end # @example IgnoreMacros: false # #   # bad #   class Foo #   bar :baz #   end # @example AllowedMethods: [“puts”, “print”] # #   # good #   puts “Hello world” #   print “Hello world” #   # still enforces parentheses on other methods #   array.delete(e) # @example AllowedPatterns: [“^assert”] # #   # good #   assert_equal ‘test’, x #   assert_match(/foo/, bar) #   # still enforces parentheses on other methods #   array.delete(e) # @example AllowParenthesesInMultilineCall: false (default) # #   # bad #   foo.enforce( #   strict: true #   ) # #   # good #   foo.enforce \ #   strict: true # @example AllowParenthesesInMultilineCall: true # #   # good #   foo.enforce( #   strict: true #   ) # #   # good #   foo.enforce \ #   strict: true # @example AllowParenthesesInChaining: false (default) # #   # bad #   foo().bar(1) # #   # good #   foo().bar 1 # @example AllowParenthesesInChaining: true # #   # good #   foo().bar(1) # #   # good #   foo().bar 1 # @example AllowParenthesesInCamelCaseMethod: false (default) # #   # bad #   Array(1) # #   # good #   Array 1 # @example AllowParenthesesInCamelCaseMethod: true # #   # good #   Array(1) # #   # good #   Array 1 # @example AllowParenthesesInStringInterpolation: false (default) # #   # bad #   “#{t(‘this.is.bad’)}” # #   # good #   “#{t ‘this.is.better’}” # @example EnforcedStyle: require_parentheses (default) # #   # bad #   array.delete e # #   # good #   array.delete(e) # #   # good #   # Operators don’t need parens #   foo == bar # #   # good #   # Setter methods don’t need parens #   foo.bar = baz # #   # okay with ‘puts` listed in `AllowedMethods` #   puts ’test’ # #   # okay with ‘^assert` listed in `AllowedPatterns` #   assert_equal ’test’, x # # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#220 class RuboCop::Cop::Style::MethodCallWithArgsParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodCallWithArgsParentheses</span><span class="ruby-operator">::</span><span class="ruby-constant">RequireParentheses</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodCallWithArgsParentheses</span><span class="ruby-operator">::</span><span class="ruby-constant">OmitParentheses</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#235</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_parenthesized?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses.rb#231</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Style omit_parentheses # # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#9 module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_camel_case_method_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_chained_call_with_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_multiline_call_with_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_string_interpolation_method_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ambiguous_range_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned_before?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_in_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_as_argument_or_chain?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_argument_with_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_literals?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_logical_operators?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_match_pattern?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_optional_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_in_single_line_inheritance?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_with_ambiguous_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_with_braced_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwards_anonymous_rest_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_literal_in_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_endless_method_def?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_string_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Require hash value omission be enclosed in parentheses to prevent the following issue:</span>
<span class="ruby-comment"># https://bugs.ruby-lang.org/issues/18396.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">legitimate_call_with_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logical_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_before_constant_resolution?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">omit_parentheses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parentheses_at_the_end_of_multiline_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_slash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses_for_hash_value_omission?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">super_call_without_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">syntax_like_method_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_if?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unary_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#13 RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::OMIT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/omit_parentheses.rb#12 RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::TRAILING_WHITESPACE_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Style require_parentheses # # source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#8 module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_for_parentheses_omission?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignored_macro?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included_macros_list</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/method_call_with_args_parentheses/require_parentheses.rb#9 RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses::REQUIRE_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for unwanted parentheses in parameterless method calls. # # This cop’s allowed methods can be customized with ‘AllowedMethods`. # By default, there are no allowed methods. # # NOTE: This cop allows the use of `it()` without arguments in blocks, # as in `0.times { it() }`, following `Lint/ItWithoutArgumentsInBlock` cop. # # @example #   # bad #   object.some_method() # #   # good #   object.some_method # @example AllowedMethods: [] (default) #   # bad #   object.foo() # @example AllowedMethods: [foo] #   # good #   object.foo() # # source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#29 class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ineligible_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Respects `Lint/ItWithoutArgumentsInBlock` cop and the following Ruby 3.3&#39;s warning:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># $ ruby -e &#39;0.times { begin; it; end }&#39;</span>
<span class="ruby-comment"># -e:1: warning: `it` calls without arguments will refer to the first block param in</span>
<span class="ruby-comment"># Ruby 3.4; use it() or self.it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized_it_method_in_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_name_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_in_mass_assignment?</span>(<span class="ruby-identifier">variable_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/method_call_without_args_parentheses.rb#34 RuboCop::Cop::Style::MethodCallWithoutArgsParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for methods called on a do…end block. The point of # this check is that it’s easy to miss the call tacked on to the block # when reading code. # # @example #   # bad #   a do #   b #   end.c # #   # good #   a { b }.c # #   # good #   foo = a do #   b #   end #   foo.c # # source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#24 class RuboCop::Cop::Style::MethodCalledOnDoEndBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/method_called_on_do_end_block.rb#27 RuboCop::Cop::Style::MethodCalledOnDoEndBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for parentheses around the arguments in method # definitions. Both instance and class/singleton methods are checked. # # Regardless of style, parentheses are necessary for: # # 1. Endless methods # 2. Argument lists containing a ‘forward-arg` (`…`) # 3. Argument lists containing an anonymous rest arguments forwarding (`*`) # 4. Argument lists containing an anonymous keyword rest arguments forwarding (`**`) # 5. Argument lists containing an anonymous block forwarding (`&amp;`) # # Removing the parens would be a syntax error here. # # @example EnforcedStyle: require_parentheses (default) #   # The `require_parentheses` style requires method definitions #   # to always use parentheses # #   # bad #   def bar num1, num2 #   num1 + num2 #   end # #   def foo descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name #   do_something #   end # #   # good #   def bar(num1, num2) #   num1 + num2 #   end # #   def foo(descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name) #   do_something #   end # @example EnforcedStyle: require_no_parentheses #   # The `require_no_parentheses` style requires method definitions #   # to never use parentheses # #   # bad #   def bar(num1, num2) #   num1 + num2 #   end # #   def foo(descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name) #   do_something #   end # #   # good #   def bar num1, num2 #   num1 + num2 #   end # #   def foo descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name #   do_something #   end # @example EnforcedStyle: require_no_parentheses_except_multiline #   # The `require_no_parentheses_except_multiline` style prefers no #   # parentheses when method definition arguments fit on single line, #   # but prefers parentheses when arguments span multiple lines. # #   # bad #   def bar(num1, num2) #   num1 + num2 #   end # #   def foo descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name #   do_something #   end # #   # good #   def bar num1, num2 #   num1 + num2 #   end # #   def foo(descriptive_var_name, #   another_descriptive_var_name, #   last_descriptive_var_name) #   do_something #   end # # source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#97 class RuboCop::Cop::Style::MethodDefParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">anonymous_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_without_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_arguments</span>(<span class="ruby-identifier">arg_node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forced_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_parentheses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unwanted_parentheses</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#103 RuboCop::Cop::Style::MethodDefParentheses::MSG_MISSING = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/method_def_parentheses.rb#102 RuboCop::Cop::Style::MethodDefParentheses::MSG_PRESENT = T.let(T.unsafe(nil), String)</p>

<p># Checks for potential uses of ‘Enumerable#minmax`. # # @example # #   # bad #   bar = [foo.min, foo.max] #   return foo.min, foo.max # #   # good #   bar = foo.minmax #   return foo.minmax # # source://rubocop//lib/rubocop/cop/style/min_max.rb#17 class RuboCop::Cop::Style::MinMax &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_max_candidate</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">offender</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/min_max.rb#20 RuboCop::Cop::Style::MinMax::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of ‘max` or `min` instead of comparison for greater or less. # # NOTE: It can be used if you want to present limit or threshold in Ruby 2.7+. # That it is slow though. So autocorrection will apply generic `max` or `min`: # # [source,ruby] # —- # a.clamp(b..) # Same as `[a, b].max` # a.clamp(..b) # Same as `[a, b].min` # —- # # @example # #   # bad #   a &gt; b ? a : b #   a &gt;= b ? a : b # #   # good #   [a, b].max # #   # bad #   a &lt; b ? a : b #   a &lt;= b ? a : b # #   # good #   [a, b].min # # source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#37 class RuboCop::Cop::Style::MinMaxComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comparison_condition</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method</span>(<span class="ruby-identifier">operator</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">if_branch</span>, <span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#44 RuboCop::Cop::Style::MinMaxComparison::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#42 RuboCop::Cop::Style::MinMaxComparison::GREATER_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#43 RuboCop::Cop::Style::MinMaxComparison::LESS_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/min_max_comparison.rb#41 RuboCop::Cop::Style::MinMaxComparison::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘if` expressions that do not have an `else` branch. # # NOTE: Pattern matching is allowed to have no `else` branch because unlike `if` and `case`, # it raises `NoMatchingPatternError` if the pattern doesn’t match and without having ‘else`. # # Supported styles are: if, case, both. # # @example EnforcedStyle: both (default) #   # warn when an `if` or `case` expression is missing an `else` branch. # #   # bad #   if condition #   statement #   end # #   # bad #   case var #   when condition #   statement #   end # #   # good #   if condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # #   # good #   case var #   when condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # @example EnforcedStyle: if #   # warn when an `if` expression is missing an `else` branch. # #   # bad #   if condition #   statement #   end # #   # good #   if condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # #   # good #   case var #   when condition #   statement #   end # #   # good #   case var #   when condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # @example EnforcedStyle: case #   # warn when a `case` expression is missing an `else` branch. # #   # bad #   case var #   when condition #   statement #   end # #   # good #   case var #   when condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # #   # good #   if condition #   statement #   end # #   # good #   if condition #   statement #   else #   # the content of `else` branch will be determined by Style/EmptyElse #   end # # source://rubocop//lib/rubocop/cop/style/missing_else.rb#99 class RuboCop::Cop::Style::MissingElse &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OnNormalIfUnless</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_normal_if_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_else_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_else_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message_template</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_else_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_else.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_else_cop_enabled?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/missing_else.rb#104 RuboCop::Cop::Style::MissingElse::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/missing_else.rb#106 RuboCop::Cop::Style::MissingElse::MSG_EMPTY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/missing_else.rb#105 RuboCop::Cop::Style::MissingElse::MSG_NIL = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of ‘method_missing` without also # defining `respond_to_missing?`. # # Not defining `respond_to_missing?` will cause metaprogramming # methods like `respond_to?` to behave unexpectedly: # # [source,ruby] # —- # class StringDelegator #   def initialize(string) #     @string = string #   end # #   def method_missing(name, *args) #     @string.send(name, *args) #   end # end # # delegator = StringDelegator.new(“foo”) # # Claims to not respond to `upcase`. # delegator.respond_to?(:upcase) # =&gt; false # # But you can call it. # delegator.upcase # =&gt; FOO # —- # # @example #   # bad #   def method_missing(name, *args) #   if @delegate.respond_to?(name) #   @delegate.send(name, *args) #   else #   super #   end #   end # #   # good #   def respond_to_missing?(name, include_private) #   @delegate.respond_to?(name) || super #   end # #   def method_missing(name, *args) #   if @delegate.respond_to?(name) #   @delegate.send(name, *args) #   else #   super #   end #   end # # source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#54 class RuboCop::Cop::Style::MissingRespondToMissing &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implements_respond_to_missing?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/missing_respond_to_missing.rb#55 RuboCop::Cop::Style::MissingRespondToMissing::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for grouping of mixins in ‘class` and `module` bodies. # By default it enforces mixins to be placed in separate declarations, # but it can be configured to enforce grouping them in one declaration. # # @example EnforcedStyle: separated (default) #   # bad #   class Foo #   include Bar, Qox #   end # #   # good #   class Foo #   include Qox #   include Bar #   end # @example EnforcedStyle: grouped #   # bad #   class Foo #   extend Bar #   extend Qox #   end # #   # good #   class Foo #   extend Qox, Bar #   end # # source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#33 class RuboCop::Cop::Style::MixinGrouping &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_grouped_style</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_separated_style</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_mixins</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">mixins</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grouped_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_to_remove_for_subsequent_mixin</span>(<span class="ruby-identifier">mixins</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separate_mixins</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">separated_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sibling_mixins</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#37 RuboCop::Cop::Style::MixinGrouping::MIXIN_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/mixin_grouping.rb#38 RuboCop::Cop::Style::MixinGrouping::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks that ‘include`, `extend` and `prepend` statements appear # inside classes and modules, not at the top level, so as to not affect # the behavior of `Object`. # # @example #   # bad #   include M # #   class C #   end # #   # bad #   extend M # #   class C #   end # #   # bad #   prepend M # #   class C #   end # #   # good #   class C #   include M #   end # #   # good #   class C #   extend M #   end # #   # good #   class C #   prepend M #   end # # source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#43 class RuboCop::Cop::Style::MixinUsage &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_top_level_scope?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_statement</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#44 RuboCop::Cop::Style::MixinUsage::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/mixin_usage.rb#45 RuboCop::Cop::Style::MixinUsage::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for use of ‘extend self` or `module_function` in a module. # # Supported styles are: `module_function` (default), `extend_self` and `forbidden`. # # A couple of things to keep in mind: # # - `forbidden` style prohibits the usage of both styles # - in default mode (`module_function`), the cop won’t be activated when the module #   contains any private methods # # @example EnforcedStyle: module_function (default) #   # bad #   module Test #   extend self #   # … #   end # #   # good #   module Test #   module_function #   # … #   end # #   # good #   module Test #   extend self #   # … #   private #   # … #   end # #   # good #   module Test #   class &lt;&lt; self #   # … #   end #   end # @example EnforcedStyle: extend_self #   # bad #   module Test #   module_function #   # … #   end # #   # good #   module Test #   extend self #   # … #   end # #   # good #   module Test #   class &lt;&lt; self #   # … #   end #   end # @example EnforcedStyle: forbidden #   # bad #   module Test #   module_function #   # … #   end # #   # bad #   module Test #   extend self #   # … #   end # #   # bad #   module Test #   extend self #   # … #   private #   # … #   end # #   # good #   module Test #   class &lt;&lt; self #   # … #   end #   end # # source://rubocop//lib/rubocop/cop/style/module_function.rb#95 class RuboCop::Cop::Style::ModuleFunction &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extend_self_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_function_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">private_directive?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_extend_self</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_forbidden</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_module_function</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_wrong_style</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/module_function.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/module_function.rb#100 RuboCop::Cop::Style::ModuleFunction::EXTEND_SELF_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/module_function.rb#101 RuboCop::Cop::Style::ModuleFunction::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/module_function.rb#99 RuboCop::Cop::Style::ModuleFunction::MODULE_FUNCTION_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for chaining of a block after another block that spans # multiple lines. # # @example # #   # bad #   Thread.list.select do |t| #   t.alive? #   end.map do |t| #   t.object_id #   end # #   # good #   alive_threads = Thread.list.select do |t| #   t.alive? #   end #   alive_threads.map do |t| #   t.object_id #   end # # source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#25 class RuboCop::Cop::Style::MultilineBlockChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_block_chain.rb#28 RuboCop::Cop::Style::MultilineBlockChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of if/unless modifiers with multiple-lines bodies. # # @example # #   # bad #   { #   result: ‘this should not happen’ #   } unless cond # #   # good #   { result: ‘ok’ } if cond # # source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#17 class RuboCop::Cop::Style::MultilineIfModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementModifier</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_body</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_normal_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_if_modifier.rb#22 RuboCop::Cop::Style::MultilineIfModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of the ‘then` keyword in multi-line if statements. # # @example #   # bad #   # This is considered bad practice. #   if cond then #   end # #   # good #   # If statements can contain `then` on the same line. #   if cond then a #   elsif cond then b #   end # # source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#19 class RuboCop::Cop::Style::MultilineIfThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OnNormalIfUnless</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_normal_if_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_modifier_then?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#26 RuboCop::Cop::Style::MultilineIfThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_if_then.rb#24 RuboCop::Cop::Style::MultilineIfThen::NON_MODIFIER_THEN = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks uses of the ‘then` keyword in multi-line `in` statement. # # @example #   # bad #   case expression #   in pattern then #   end # #   # good #   case expression #   in pattern #   end # #   # good #   case expression #   in pattern then do_something #   end # #   # good #   case expression #   in pattern then do_something(arg1, #   arg2) #   end # # source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#30 class RuboCop::Cop::Style::MultilineInPatternThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Requires `then` for write `in` and its body on the same line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_then?</span>(<span class="ruby-identifier">in_pattern_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_in_pattern_then.rb#37 RuboCop::Cop::Style::MultilineInPatternThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks expressions wrapping styles for multiline memoization. # # @example EnforcedStyle: keyword (default) #   # bad #   foo ||= ( #   bar #   baz #   ) # #   # good #   foo ||= begin #   bar #   baz #   end # @example EnforcedStyle: braces #   # bad #   foo ||= begin #   bar #   baz #   end # #   # good #   foo ||= ( #   bar #   baz #   ) # # source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#33 class RuboCop::Cop::Style::MultilineMemoization &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_rhs?</span>(<span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_autocorrect</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_begin_str</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_buf</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_end_str</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_buf</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#39 RuboCop::Cop::Style::MultilineMemoization::BRACES_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_memoization.rb#38 RuboCop::Cop::Style::MultilineMemoization::KEYWORD_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for method signatures that span multiple lines. # # @example # #   # good # #   def foo(bar, baz) #   end # #   # bad # #   def foo(bar, #   baz) #   end # # source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#21 class RuboCop::Cop::Style::MultilineMethodSignature &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">begin_of_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_exceeds_max_line_length?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">definition_width</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_width</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line_source_of_arguments</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_line_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opening_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_method_signature.rb#25 RuboCop::Cop::Style::MultilineMethodSignature::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for multi-line ternary op expressions. # # NOTE: ‘return if … else … end` is syntax error. If `return` is used before # multiline ternary operator expression, it will be autocorrected to single-line # ternary operator. The same is true for `break`, `next`, and method call. # # @example #   # bad #   a = cond ? #   b : c #   a = cond ? b : #   c #   a = cond ? #   b : #   c # #   return cond ? #   b : #   c # #   # good #   a = cond ? b : c #   a = if cond #   b #   else #   c #   end # #   return cond ? b : c # # source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#36 class RuboCop::Cop::Style::MultilineTernaryOperator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_in_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_single_line_ternary_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_assignment_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#40 RuboCop::Cop::Style::MultilineTernaryOperator::MSG_IF = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#41 RuboCop::Cop::Style::MultilineTernaryOperator::MSG_SINGLE_LINE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_ternary_operator.rb#42 RuboCop::Cop::Style::MultilineTernaryOperator::SINGLE_LINE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks uses of the ‘then` keyword # in multi-line when statements. # # @example #   # bad #   case foo #   when bar then #   end # #   # good #   case foo #   when bar #   end # #   # good #   case foo #   when bar then do_something #   end # #   # good #   case foo #   when bar then do_something(arg1, #   arg2) #   end # # source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#31 class RuboCop::Cop::Style::MultilineWhenThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Requires `then` for write `when` and its body on the same line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_then?</span>(<span class="ruby-identifier">when_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiline_when_then.rb#35 RuboCop::Cop::Style::MultilineWhenThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks against comparing a variable with multiple items, where # ‘Array#include?`, `Set#include?` or a `case` could be used instead # to avoid code repetition. # It accepts comparisons of multiple method calls to avoid unnecessary method calls # by default. It can be configured by `AllowMethodComparison` option. # # @example #   # bad #   a = ’a’ #   foo if a == ‘a’ || a == ‘b’ || a == ‘c’ # #   # good #   a = ‘a’ #   foo if [‘a’, ‘b’, ‘c’].include?(a) # #   VALUES = Set[‘a’, ‘b’, ‘c’].freeze #   # elsewhere… #   foo if VALUES.include?(a) # #   case foo #   when ‘a’, ‘b’, ‘c’ then foo #   # … #   end # #   # accepted (but consider ‘case` as above) #   foo if a == b.lightweight || a == b.heavyweight # @example AllowMethodComparison: true (default) #   # good #   foo if a == b.lightweight || a == b.heavyweight # @example AllowMethodComparison: false #   # bad #   foo if a == b.lightweight || a == b.heavyweight # #   # good #   foo if [b.lightweight, b.heavyweight].include?(a) # @example ComparisonsThreshold: 2 (default) #   # bad #   foo if a == ’a’ || a == ‘b’ # @example ComparisonsThreshold: 3 #   # good #   foo if a == ‘a’ || a == ‘b’ # # source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#52 class RuboCop::Cop::Style::MultipleComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_comparison_lhs</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_comparison_rhs</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_double_comparison?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_method_comparison?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comparison?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comparisons_threshold</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offending_var</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">variables</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">values</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nested_comparison?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_of_or_node</span>(<span class="ruby-identifier">or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_comparison</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/multiple_comparison.rb#55 RuboCop::Cop::Style::MultipleComparison::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks whether some constant value isn’t a # mutable literal (e.g. array or hash). # # Strict mode can be used to freeze all constants, rather than # just literals. # Strict mode is considered an experimental feature. It has not been # updated with an exhaustive list of all methods that will produce # frozen objects so there is a decent chance of getting some false # positives. Luckily, there is no harm in freezing an already # frozen object. # # From Ruby 3.0, this cop honours the magic comment # ‘shareable_constant_value’. When this magic comment is set to any # acceptable value other than none, it will suppress the offenses # raised by this cop. It enforces frozen state. # # NOTE: ‘Regexp` and `Range` literals are frozen objects since Ruby 3.0. # # NOTE: From Ruby 3.0, interpolated strings are not frozen when # `# frozen-string-literal: true` is used, so this cop enforces explicit # freezing for such strings. # # NOTE: From Ruby 3.0, this cop allows explicit freezing of constants when # the `shareable_constant_value` directive is used. # # @example EnforcedStyle: literals (default) #   # bad #   CONST = [1, 2, 3] # #   # good #   CONST = [1, 2, 3].freeze # #   # good #   CONST = &lt;&lt;~TESTING.freeze #   This is a heredoc #   TESTING # #   # good #   CONST = Something.new # @example EnforcedStyle: strict #   # bad #   CONST = Something.new # #   # bad #   CONST = Struct.new do #   def foo #   puts 1 #   end #   end # #   # good #   CONST = Something.new.freeze # #   # good #   CONST = Struct.new do #   def foo #   puts 1 #   end #   end.freeze # @example #   # Magic comment - shareable_constant_value: literal # #   # bad #   CONST = [1, 2, 3] # #   # good #   # shareable_constant_value: literal #   CONST = [1, 2, 3] # # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#83 class RuboCop::Cop::Style::MutableConstant &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">MutableConstant</span><span class="ruby-operator">::</span><span class="ruby-constant">ShareableConstantValue</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Some of these patterns may not actually return an immutable object,</span>
<span class="ruby-comment"># but we want to consider them immutable for this cop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operation_produces_immutable_object?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_enclosed_in_parentheses?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat_value</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_splat_expansion</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">splat_value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_regexp_or_range_literals?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">immutable_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mutable_literal?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_assignment</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shareable_constant_value?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strict_check</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#125 RuboCop::Cop::Style::MutableConstant::MSG = T.let(T.unsafe(nil), String)</p>

<p># Handles magic comment shareable_constant_value with O(n ^ 2) complexity # n - number of lines in the source # Iterates over all lines before a CONSTANT # until it reaches shareable_constant_value # # source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#88 module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># Identifies the most recent magic comment with valid shareable constant values</span>
<span class="ruby-comment"># that&#39;s in scope for this node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magic_comment_in_scope</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source_till_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recent_shareable_value?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shareable_constant_value_enabled?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Identifies the most recent magic comment with valid shareable constant values</span>
  <span class="ruby-comment"># that&#39;s in scope for this node</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#102</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magic_comment_in_scope</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/mutable_constant.rb#91</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recent_shareable_value?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for uses of if with a negated condition. Only ifs # without else are considered. There are three different styles: # # * both # * prefix # * postfix # # @example EnforcedStyle: both (default) #   # enforces ‘unless` for `prefix` and `postfix` conditionals # #   # bad # #   if !foo #   bar #   end # #   # good # #   unless foo #   bar #   end # #   # bad # #   bar if !foo # #   # good # #   bar unless foo # @example EnforcedStyle: prefix #   # enforces `unless` for just `prefix` conditionals # #   # bad # #   if !foo #   bar #   end # #   # good # #   unless foo #   bar #   end # #   # good # #   bar if !foo # @example EnforcedStyle: postfix #   # enforces `unless` for just `postfix` conditionals # #   # bad # #   bar if !foo # #   # good # #   bar unless foo # #   # good # #   if !foo #   bar #   end # # source://rubocop//lib/rubocop/cop/style/negated_if.rb#71 class RuboCop::Cop::Style::NegatedIf &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NegativeConditional</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for uses of ‘if-else` and ternary operators with a negated condition # which can be simplified by inverting condition and swapping branches. # # @example #   # bad #   if !x #   do_something #   else #   do_something_else #   end # #   # good #   if x #   do_something_else #   else #   do_something #   end # #   # bad #   !x ? do_something : do_something_else # #   # good #   x ? do_something_else : do_something # # source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#30 class RuboCop::Cop::Style::NegatedIfElseCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_negation?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_negated_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_ancestor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Collect the entire else branch, including whitespace and comments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_else?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Collect the entire if branch, including whitespace and comments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negated_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap_branches</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unwrap_begin_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#41</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#34 RuboCop::Cop::Style::NegatedIfElseCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/negated_if_else_condition.rb#36 RuboCop::Cop::Style::NegatedIfElseCondition::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of unless with a negated condition. Only unless # without else are considered. There are three different styles: # # * both # * prefix # * postfix # # @example EnforcedStyle: both (default) #   # enforces ‘if` for `prefix` and `postfix` conditionals # #   # bad #   unless !foo #   bar #   end # #   # good #   if foo #   bar #   end # #   # bad #   bar unless !foo # #   # good #   bar if foo # @example EnforcedStyle: prefix #   # enforces `if` for just `prefix` conditionals # #   # bad #   unless !foo #   bar #   end # #   # good #   if foo #   bar #   end # #   # good #   bar unless !foo # @example EnforcedStyle: postfix #   # enforces `if` for just `postfix` conditionals # #   # bad #   bar unless !foo # #   # good #   bar if foo # #   # good #   unless !foo #   bar #   end # # source://rubocop//lib/rubocop/cop/style/negated_unless.rb#61 class RuboCop::Cop::Style::NegatedUnless &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NegativeConditional</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_unless.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_unless.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_unless.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for uses of while with a negated condition. # # @example #   # bad #   while !foo #   bar #   end # #   # good #   until foo #   bar #   end # #   # bad #   bar until !foo # #   # good #   bar while foo #   bar while !foo &amp;&amp; baz # # source://rubocop//lib/rubocop/cop/style/negated_while.rb#25 class RuboCop::Cop::Style::NegatedWhile &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NegativeConditional</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_while.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/negated_while.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for nested ‘File.dirname`. # It replaces nested `File.dirname` with the level argument introduced in Ruby 3.1. # # @example # #   # bad #   File.dirname(File.dirname(path)) # #   # good #   File.dirname(path, 2) # # source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#17 class RuboCop::Cop::Style::NestedFileDirname &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_dirname?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path_with_dir_level</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">level</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#22 RuboCop::Cop::Style::NestedFileDirname::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/nested_file_dirname.rb#23 RuboCop::Cop::Style::NestedFileDirname::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for nested use of if, unless, while and until in their # modifier form. # # @example # #   # bad #   something if a if b # #   # good #   something if b &amp;&amp; a # # source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#16 class RuboCop::Cop::Style::NestedModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parentheses_to_method_arguments</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_hand_operand</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">operator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_expression</span>(<span class="ruby-identifier">inner_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_operator</span>(<span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parens?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_hand_operand</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left_hand_keyword</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nested_modifier.rb#20 RuboCop::Cop::Style::NestedModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for unparenthesized method calls in the argument list # of a parenthesized method call. # ‘be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`, # `be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`, # `respond_to`, and `start_with` methods are allowed by default. # These are customizable with `AllowedMethods` option. # # @example #   # good #   method1(method2(arg)) # #   # bad #   method1(method2 arg) # @example AllowedMethods: [foo] #   # good #   method1(foo arg) # # source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#24 class RuboCop::Cop::Style::NestedParenthesizedCalls &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_omission?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">nested</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nested_parenthesized_calls.rb#29 RuboCop::Cop::Style::NestedParenthesizedCalls::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for nested ternary op expressions. # # @example #   # bad #   a ? (b ? b1 : b2) : a2 # #   # good #   if a #   b ? b1 : b2 #   else #   a2 #   end # # source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#18 class RuboCop::Cop::Style::NestedTernaryOperator &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">if_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_parentheses</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_loc_and_whitespace</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nested_ternary_operator.rb#22 RuboCop::Cop::Style::NestedTernaryOperator::MSG = T.let(T.unsafe(nil), String)</p>

<p># Use ‘next` to skip iteration instead of a condition at the end. # # @example EnforcedStyle: skip_modifier_ifs (default) #   # bad #   [1, 2].each do |a| #   if a == 1 #   puts a #   end #   end # #   # good #   [1, 2].each do |a| #   next unless a == 1 #   puts a #   end # #   # good #   [1, 2].each do |a| #   puts a if a == 1 #   end # @example EnforcedStyle: always #   # With `always` all conditions at the end of an iteration needs to be #   # replaced by next - with `skip_modifier_ifs` the modifier if like #   # this one are ignored: `[1, 2].each { |a| puts a if a == 1 }` # #   # bad #   [1, 2].each do |a| #   puts a if a == 1 #   end # #   # bad #   [1, 2].each do |a| #   if a == 1 #   puts a #   end #   end # #   # good #   [1, 2].each do |a| #   next unless a == 1 #   puts a #   end # @example AllowConsecutiveConditionals: false (default) #   # bad #   [1, 2].each do |a| #   if a == 1 #   puts a #   end #   if a == 2 #   puts a #   end #   end # #   # good #   [1, 2].each do |a| #   if a == 1 #   puts a #   end #   next unless a == 2 #   puts a #   end # @example AllowConsecutiveConditionals: true #   # good #   [1, 2].each do |a| #   if a == 1 #   puts a #   end #   if a == 2 #   puts a #   end #   end # # source://rubocop//lib/rubocop/cop/style/next.rb#81 class RuboCop::Cop::Style::Next &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MinBodyLength</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">actual_indent</span>(<span class="ruby-identifier">lines</span>, <span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#271</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_consecutive_conditionals?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_modifier_if?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_modifier</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cond_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">cond</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consecutive_conditionals?</span>(<span class="ruby-identifier">if_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_followed_by_whitespace_only?</span>(<span class="ruby-identifier">source_buffer</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_with_condition?</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exit_body_type?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_else_children?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_without_else?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_location</span>(<span class="ruby-identifier">offense_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_node</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adjust indentation of `lines` to match `node`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reindent</span>(<span class="ruby-identifier">lines</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reindent_line</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">delta</span>, <span class="ruby-identifier">buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reindentable_lines</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_if_without_break?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/next.rb#90</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/next.rb#88 RuboCop::Cop::Style::Next::EXIT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/next.rb#87 RuboCop::Cop::Style::Next::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for comparison of something with nil using ‘==` and # `nil?`. # # Supported styles are: predicate, comparison. # # @example EnforcedStyle: predicate (default) # #   # bad #   if x == nil #   end # #   # good #   if x.nil? #   end # @example EnforcedStyle: comparison # #   # bad #   if x.nil? #   end # #   # good #   if x == nil #   end # # source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#31 class RuboCop::Cop::Style::NilComparison &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_comparison?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prefer_comparison?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_check?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#36 RuboCop::Cop::Style::NilComparison::EXPLICIT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#35 RuboCop::Cop::Style::NilComparison::PREDICATE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/nil_comparison.rb#38 RuboCop::Cop::Style::NilComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for lambdas and procs that always return nil, # which can be replaced with an empty lambda or proc instead. # # @example #   # bad #   -&gt; { nil } # #   lambda do #   next nil #   end # #   proc { nil } # #   Proc.new do #   break nil #   end # #   # good #   -&gt; {} # #   lambda do #   end # #   -&gt; (x) { nil if x } # #   proc {} # #   Proc.new { nil if x } # # source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#35 class RuboCop::Cop::Style::NilLambda &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_return?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/nil_lambda.rb#39 RuboCop::Cop::Style::NilLambda::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for non-nil checks, which are usually redundant. # # With ‘IncludeSemanticChanges` set to `false` by default, this cop # does not report offenses for `!x.nil?` and does no changes that might # change behavior. # Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of # `Style/NilComparison` cop, this cop does not report offenses for `x != nil` and # does no changes to `!x.nil?` style. # # With `IncludeSemanticChanges` set to `true`, this cop reports offenses # for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which # is <strong>usually</strong> OK, but might change behavior. # # @example #   # bad #   if x != nil #   end # #   # good #   if x #   end # #   # Non-nil checks are allowed if they are the final nodes of predicate. #   # good #   def signed_in? #   !current_user.nil? #   end # @example IncludeSemanticChanges: false (default) #   # good #   if !x.nil? #   end # @example IncludeSemanticChanges: true #   # bad #   if !x.nil? #   end # # source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#44 class RuboCop::Cop::Style::NonNilCheck &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_and_nil_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_equal_to_nil?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_comparison</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_non_nil</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">inner_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_unless_nil</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_semantic_changes?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_comparison_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_and_nil_check?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#48 RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REDUNDANCY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#47 RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REPLACEMENT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/non_nil_check.rb#50 RuboCop::Cop::Style::NonNilCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of the keyword ‘not` instead of `!`. # # @example # #   # bad - parentheses are required because of op precedence #   x = (not something) # #   # good #   x = !something # # source://rubocop//lib/rubocop/cop/style/not.rb#16 class RuboCop::Cop::Style::Not &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_opposite_method</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_with_parens</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_without_parens</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite_method?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/not.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parens?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/not.rb#20 RuboCop::Cop::Style::Not::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/not.rb#23 RuboCop::Cop::Style::Not::OPPOSITE_METHODS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/not.rb#21 RuboCop::Cop::Style::Not::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for numbered parameters. # # It can either restrict the use of numbered parameters to # single-lined blocks, or disallow completely numbered parameters. # # @example EnforcedStyle: allow_single_line (default) #   # bad #   collection.each do #   puts _1 #   end # #   # good #   collection.each { puts _1 } # @example EnforcedStyle: disallow #   # bad #   collection.each { puts _1 } # #   # good #   collection.each { |item| puts item } # # source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#27 class RuboCop::Cop::Style::NumberedParameters &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#31 RuboCop::Cop::Style::NumberedParameters::MSG_DISALLOW = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numbered_parameters.rb#32 RuboCop::Cop::Style::NumberedParameters::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)</p>

<p># Detects use of an excessive amount of numbered parameters in a # single block. Having too many numbered parameters can make code too # cryptic and hard to read. # # The cop defaults to registering an offense if there is more than 1 numbered # parameter but this maximum can be configured by setting ‘Max`. # # @example Max: 1 (default) #   # bad #   use_multiple_numbered_parameters { _1.call(_2, _3, _4) } # #   # good #   array.each { use_array_element_as_numbered_parameter(_1) } #   hash.each { use_only_hash_value_as_numbered_parameter(_2) } # # source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#20 class RuboCop::Cop::Style::NumberedParametersLimit &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numbered_parameter_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#24 RuboCop::Cop::Style::NumberedParametersLimit::DEFAULT_MAX_VALUE = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#29 RuboCop::Cop::Style::NumberedParametersLimit::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numbered_parameters_limit.rb#30 RuboCop::Cop::Style::NumberedParametersLimit::NUMBERED_PARAMETER_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for octal, hex, binary, and decimal literals using # uppercase prefixes and corrects them to lowercase prefix # or no prefix (in case of decimals). # # @example EnforcedOctalStyle: zero_with_o (default) #   # bad - missing octal prefix #   num = 01234 # #   # bad - uppercase prefix #   num = 0O1234 #   num = 0X12AB #   num = 0B10101 # #   # bad - redundant decimal prefix #   num = 0D1234 #   num = 0d1234 # #   # good #   num = 0o1234 #   num = 0x12AB #   num = 0b10101 #   num = 1234 # @example EnforcedOctalStyle: zero_only #   # bad #   num = 0o1234 #   num = 0O1234 # #   # good #   num = 01234 # # source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#36 class RuboCop::Cop::Style::NumericLiteralPrefix &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">IntegerNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_int</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_binary</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_decimal</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_hex</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_octal</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_octal_zero_only</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hex_bin_dec_literal_type</span>(<span class="ruby-identifier">literal</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">octal_literal_type</span>(<span class="ruby-identifier">literal</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">octal_zero_only?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#49 RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#43 RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#50 RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#44 RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#48 RuboCop::Cop::Style::NumericLiteralPrefix::HEX_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#42 RuboCop::Cop::Style::NumericLiteralPrefix::HEX_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#47 RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#41 RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#46 RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literal_prefix.rb#40 RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for big numeric literals without ‘_` between groups # of digits in them. # # Additional allowed patterns can be added by adding regexps to # the `AllowedPatterns` configuration. All regexps are treated # as anchored even if the patterns do not contain anchors (so # `d{4}_d{4}` will allow `1234_5678` but not `1234_5678_9012`). # # NOTE: Even if `AllowedPatterns` are given, autocorrection will # only correct to the standard pattern of an `_` every 3 digits. # # @example # #   # bad #   1000000 #   1_00_000 #   1_0000 # #   # good #   1_000_000 #   1000 # @example Strict: false (default) # #   # good #   10_000_00 # typical representation of $10,000 in cents # @example Strict: true # #   # bad #   10_000_00 # typical representation of $10,000 in cents # @example AllowedNumbers: [3000] # #   # good #   3000 # You can specify allowed numbers. (e.g. port number) # # source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#43 class RuboCop::Cop::Style::NumericLiterals &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">IntegerNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_digits=</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_float</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_int</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_numbers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_patterns</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param int_part [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_int_part</span>(<span class="ruby-identifier">int_part</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_number</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_digits</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">short_group_regex</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#49 RuboCop::Cop::Style::NumericLiterals::DELIMITER_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_literals.rb#48 RuboCop::Cop::Style::NumericLiterals::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for usage of comparison operators (‘==`, # `&gt;`, `&lt;`) to test numbers as zero, positive, or negative. # These can be replaced by their respective predicate methods. # This cop can also be configured to do the reverse. # # This cop’s allowed methods can be customized with ‘AllowedMethods`. # By default, there are no allowed methods. # # This cop disregards `#nonzero?` as its value is truthy or falsey, # but not `true` and `false`, and thus not always interchangeable with # `!= 0`. # # This cop allows comparisons to global variables, since they are often # populated with objects which can be compared with integers, but are # not themselves `Integer` polymorphic. # # @example EnforcedStyle: predicate (default) #   # bad #   foo == 0 #   0 &gt; foo #   bar.baz &gt; 0 # #   # good #   foo.zero? #   foo.negative? #   bar.baz.positive? # @example EnforcedStyle: comparison #   # bad #   foo.zero? #   foo.negative? #   bar.baz.positive? # #   # good #   foo == 0 #   0 &gt; foo #   bar.baz &gt; 0 # @example AllowedMethods: [] (default) with EnforcedStyle: predicate #   # bad #   foo == 0 #   0 &gt; foo #   bar.baz &gt; 0 # @example AllowedMethods: [==] with EnforcedStyle: predicate #   # good #   foo == 0 # #   # bad #   0 &gt; foo #   bar.baz &gt; 0 # @example AllowedPatterns: [] (default) with EnforcedStyle: comparison #   # bad #   foo.zero? #   foo.negative? #   bar.baz.positive? # @example AllowedPatterns: [’zero’] with EnforcedStyle: predicate #   # good #   # bad #   foo.zero? # #   # bad #   foo.negative? #   bar.baz.positive? # # source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#78 class RuboCop::Cop::Style::NumericPredicate &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comparison</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverted_comparison</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">predicate</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invert</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negated?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized_source</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">numeric</span>, <span class="ruby-identifier">operation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_supported?</span>(<span class="ruby-identifier">operator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#84 RuboCop::Cop::Style::NumericPredicate::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#86 RuboCop::Cop::Style::NumericPredicate::REPLACEMENTS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/numeric_predicate.rb#88 RuboCop::Cop::Style::NumericPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use of consistent method names # ‘Object#yield_self` or `Object#then`. # # @example EnforcedStyle: then (default) # #   # bad #   obj.yield_self { |x| x.do_something } # #   # good #   obj.then { |x| x.do_something } # @example EnforcedStyle: yield_self # #   # bad #   obj.then { |x| x.do_something } # #   # good #   obj.yield_self { |x| x.do_something } # # source://rubocop//lib/rubocop/cop/style/object_then.rb#25 class RuboCop::Cop::Style::ObjectThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_method_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/object_then.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/object_then.rb#32 RuboCop::Cop::Style::ObjectThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/object_then.rb#33 RuboCop::Cop::Style::ObjectThen::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of if/then/else/end constructs on a single line. # ‘AlwaysCorrectToMultiline` config option can be set to true to autocorrect all offenses to # multi-line constructs. When `AlwaysCorrectToMultiline` is false (default case) the # autocorrect will first try converting them to ternary operators. # # @example #   # bad #   if foo then bar else baz end # #   # bad #   unless foo then baz else bar end # #   # good #   foo ? bar : baz # #   # good #   bar if foo # #   # good #   if foo then bar end # #   # good #   if foo #   bar #   else #   baz #   end # @example AlwaysCorrectToMultiline: false (default) #   # bad #   if cond then run else dont end # #   # good #   cond ? run : dont # @example AlwaysCorrectToMultiline: true #   # bad #   if cond then run else dont end # #   # good #   if cond #   run #   else #   dont #   end # # source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#52 class RuboCop::Cop::Style::OneLineConditional &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">OnNormalIfUnless</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_normal_if_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_multiline?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cannot_replace_to_ternary?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expr_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_with_changed_precedence?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_with_changed_precedence?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/one_line_conditional.rb#58 RuboCop::Cop::Style::OneLineConditional::MSG = T.let(T.unsafe(nil), String)</p>

<p># Flags uses of ‘OpenStruct`, as it is now officially discouraged # to be used for performance, version compatibility, and potential security issues. # # @example # #   # bad #   point = OpenStruct.new(x: 0, y: 1) # #   # good #   Point = Struct.new(:x, :y) #   point = Point.new(0, 1) # #   # also good #   point = { x: 0, y: 1 } # #   # bad #   test_double = OpenStruct.new(a: ’b’) # #   # good (assumes test using rspec-mocks) #   test_double = double #   allow(test_double).to receive(:a).and_return(‘b’) # # source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#44 class RuboCop::Cop::Style::OpenStructUse &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uses_open_struct?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">custom_class_or_module_definition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/open_struct_use.rb#45 RuboCop::Cop::Style::OpenStructUse::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant dot before operator method call. # The target operator methods are ‘|`, `^`, `&amp;`, “&lt;=&gt;“, `==`, `===`, `=~`, `&gt;`, `&gt;=`, `&lt;`, # “&lt;=“, `&lt;&lt;`, `&gt;&gt;`, `+`, `-`, `*`, `/`, `%`, `**`, `~`, `!`, `!=`, and `!~`. # # @example # #   # bad #   foo.+ bar #   foo.&amp; bar # #   # good #   foo + bar #   foo &amp; bar # # source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#20 class RuboCop::Cop::Style::OperatorMethodCall &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert_space_after?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_syntax_argument?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks for an acceptable case of `foo.+(bar).baz`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_with_parenthesized_arg?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap_in_parentheses_if_chained</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#25 RuboCop::Cop::Style::OperatorMethodCall::INVALID_SYNTAX_ARG_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#23 RuboCop::Cop::Style::OperatorMethodCall::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/operator_method_call.rb#24 RuboCop::Cop::Style::OperatorMethodCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for options hashes and discourages them if the # current Ruby version supports keyword arguments. # # @example # #   # bad #   def fry(options = {}) #   temperature = options.fetch(:temperature, 300) #   # … #   end # #   # good #   def fry(temperature: 300) #   # … #   end # # source://rubocop//lib/rubocop/cop/style/option_hash.rb#22 class RuboCop::Cop::Style::OptionHash &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/option_hash.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/option_hash.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">option_hash</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/option_hash.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowlist</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/option_hash.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">super_used?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/option_hash.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suspicious_name?</span>(<span class="ruby-identifier">arg_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/option_hash.rb#23 RuboCop::Cop::Style::OptionHash::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for optional arguments to methods # that do not come at the end of the argument list. # # @example #   # bad #   def foo(a = 1, b, c) #   end # #   # good #   def baz(a, b, c = 1) #   end # #   def foobar(a = 1, b = 2, c = 3) #   end # # source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#24 class RuboCop::Cop::Style::OptionalArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_positions</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_misplaced_optional_arg</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/optional_arguments.rb#25 RuboCop::Cop::Style::OptionalArguments::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for places where keyword arguments can be used instead of # boolean arguments when defining methods. ‘respond_to_missing?` method is allowed by default. # These are customizable with `AllowedMethods` option. # # @example #   # bad #   def some_method(bar = false) #   puts bar #   end # #   # bad - common hack before keyword args were introduced #   def some_method(options = {}) #   bar = options.fetch(:bar, false) #   puts bar #   end # #   # good #   def some_method(bar: false) #   puts bar #   end # @example AllowedMethods: [’some_method’] #   # good #   def some_method(bar = false) #   puts bar #   end # # source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#37 class RuboCop::Cop::Style::OptionalBooleanParameter &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/optional_boolean_parameter.rb#40 RuboCop::Cop::Style::OptionalBooleanParameter::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for potential usage of the ‘||=` operator. # # @example #   # bad #   name = name ? name : ’Bozhidar’ # #   # bad #   name = if name #   name #   else #   ‘Bozhidar’ #   end # #   # bad #   unless name #   name = ‘Bozhidar’ #   end # #   # bad #   name = ‘Bozhidar’ unless name # #   # good - set name to ‘Bozhidar’, only if it’s nil or false #   name ||= ‘Bozhidar’ # # source://rubocop//lib/rubocop/cop/style/or_assignment.rb#29 class RuboCop::Cop::Style::OrAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">take_variable_and_default_from_ternary</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">take_variable_and_default_from_unless</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/or_assignment.rb#32 RuboCop::Cop::Style::OrAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for simple usages of parallel assignment. # This will only complain when the number of variables # being assigned matched the number of assigning variables. # # @example #   # bad #   a, b, c = 1, 2, 3 #   a, b, c = [1, 2, 3] # #   # good #   one, two = *foo #   a, b = foo() #   a, b = b, a # #   a = 1 #   b = 2 #   c = 3 # # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#25 class RuboCop::Cop::Style::ParallelAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RescueNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_self_getter?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Converts (send nil :something) nodes to (send (:self) :something).</span>
<span class="ruby-comment"># This makes the sorting algorithm work for expressions such as</span>
<span class="ruby-comment"># `self.a, self.b = b, a`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_self_to_getters</span>(<span class="ruby-identifier">right_elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_lhs?</span>(<span class="ruby-identifier">elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_masign?</span>(<span class="ruby-identifier">lhs_elements</span>, <span class="ruby-identifier">rhs_elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_rhs?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_corrector</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">order</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_valid_order</span>(<span class="ruby-identifier">left_elements</span>, <span class="ruby-identifier">right_elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_statement?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Helper class necessitated by silly design of TSort prior to Ruby 2.1 # Newer versions have a better API, but that doesn’t help us # # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#119 class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">TSort</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [AssignmentSorter] a new instance of AssignmentSorter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">assignments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># `lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`.</span>
<span class="ruby-comment"># Does `rhs` access the same value which is assigned by `lhs`?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accesses?</span>(<span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">lhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependency?</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_calls</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>, <span class="ruby-identifier">param2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tsort_each_child</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tsort_each_node</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uses_var?</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">var_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An internal class for correcting parallel assignment # # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#181 class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>

<span class="ruby-comment"># @return [GenericCorrector] a new instance of GenericCorrector</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">modifier</span>, <span class="ruby-identifier">config</span>, <span class="ruby-identifier">new_elements</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute rescue_result.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_result</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute rhs.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_sources</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#29 RuboCop::Cop::Style::ParallelAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># An internal class for correcting parallel assignment # guarded by if, unless, while, or until # # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#267 class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector &lt; ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#268</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An internal class for correcting parallel assignment # protected by rescue # # source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#232 class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector &lt; ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_correction</span>(<span class="ruby-identifier">rescue_result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parallel_assignment.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_correction</span>(<span class="ruby-identifier">rescue_result</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for the presence of superfluous parentheses around the # condition of if/unless/while/until. # # ‘AllowSafeAssignment` option for safe assignment. # By safe assignment we mean putting parentheses around # an assignment to indicate “I know I’m using an assignment # as a condition. It’s not a mistake.” # # @example #   # bad #   x += 1 while (x &lt; 10) #   foo unless (bar || baz) # #   if (x &gt; 10) #   elsif (x &lt; 3) #   end # #   # good #   x += 1 while x &lt; 10 #   foo unless bar || baz # #   if x &gt; 10 #   elsif x &lt; 3 #   end # @example AllowSafeAssignment: true (default) #   # good #   foo unless (bar = baz) # @example AllowSafeAssignment: false #   # bad #   foo unless (bar = baz) # @example AllowInMultilineConditions: false (default) #   # bad #   if (x &gt; 10 &amp;&amp; #   y &gt; 10) #   end # #   # good #   if x &gt; 10 &amp;&amp; #   y &gt; 10 #   end # @example AllowInMultilineConditions: true #   # good #   if (x &gt; 10 &amp;&amp; #   y &gt; 10) #   end # # source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#56 class RuboCop::Cop::Style::ParenthesesAroundCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Parentheses</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">control_op_condition</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_multiline_conditions?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_op?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parens_allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_control_op</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/parentheses_around_condition.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semicolon_separated_expressions?</span>(<span class="ruby-identifier">first_exp</span>, <span class="ruby-identifier">rest_exps</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Enforces the consistent usage of ‘%`-literal delimiters. # # Specify the ’default’ key to set all preferred delimiters at once. You # can continue to specify individual preferred delimiters to override the # default. # # @example #   # Style/PercentLiteralDelimiters: #   #   PreferredDelimiters: #   #     default: ‘[]’ #   #     ‘%i’:    ‘()’ # #   # good #   %w[alpha beta] + %i(gamma delta) # #   # bad #   %W(alpha #{beta}) # #   # bad #   %I(alpha beta) # # source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#26 class RuboCop::Cop::Style::PercentLiteralDelimiters &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">delimiters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_preferred_delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_same_character_as_used_for_delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matchpairs</span>(<span class="ruby-identifier">begin_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters_for</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_source</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_literal_delimiters.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uses_preferred_delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for usage of the %Q() syntax when %q() would do. # # @example EnforcedStyle: lower_case_q (default) #   # The ‘lower_case_q` style prefers `%q` unless #   # interpolation is needed. #   # bad #   %Q[Mix the foo into the baz.] #   %Q(They all said: ’Hooray!‘) # #   # good #   %q[Mix the foo into the baz] #   %q(They all said: ’Hooray!‘) # @example EnforcedStyle: upper_case_q #   # The `upper_case_q` style requires the sole use of `%Q`. #   # bad #   %q/Mix the foo into the baz./ #   %q{They all said: ’Hooray!‘} # #   # good #   %Q/Mix the foo into the baz./ #   %Q{They all said: ’Hooray!‘} # # source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#28 class RuboCop::Cop::Style::PercentQLiterals &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_literal_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected</span>(<span class="ruby-identifier">src</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#33 RuboCop::Cop::Style::PercentQLiterals::LOWER_CASE_Q_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/percent_q_literals.rb#34 RuboCop::Cop::Style::PercentQLiterals::UPPER_CASE_Q_MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for uses of Perl-style regexp match # backreferences and their English versions like # $1, $2, $&amp;, &amp;+, $MATCH, $PREMATCH, etc. # # @example #   # bad #   puts $1 # #   # good #   puts Regexp.last_match(1) # # source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#16 class RuboCop::Cop::Style::PerlBackrefs &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_back_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nth_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_prefix</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">derived_from_braceless_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @param preferred_expression [String]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-value">node:</span>, <span class="ruby-value">preferred_expression:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_back_ref_or_gvar_or_nth_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">original_expression_of</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [String, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_expression_to</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param node [RuboCop::AST::Node]</span>
<span class="ruby-comment"># @private</span>
<span class="ruby-comment"># @return [String, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_expression_to_node_with_constant_prefix</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/perl_backrefs.rb#19 RuboCop::Cop::Style::PerlBackrefs::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of methods ‘Hash#has_key?` and # `Hash#has_value?`, and suggests using `Hash#key?` and `Hash#value?` instead. # # It is configurable to enforce the verbose method names, by using the # `EnforcedStyle: verbose` configuration. # # @example EnforcedStyle: short (default) #   # bad #   Hash#has_key? #   Hash#has_value? # #   # good #   Hash#key? #   Hash#value? # @example EnforcedStyle: verbose #   # bad #   Hash#key? #   Hash#value? # #   # good #   Hash#has_key? #   Hash#has_value? # # source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#33 class RuboCop::Cop::Style::PreferredHashMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_selector?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proper_method_name</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#37 RuboCop::Cop::Style::PreferredHashMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#39 RuboCop::Cop::Style::PreferredHashMethods::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/preferred_hash_methods.rb#41 RuboCop::Cop::Style::PreferredHashMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of Proc.new where Kernel#proc # would be more appropriate. # # @example #   # bad #   p = Proc.new { |n| puts n } # #   # good #   p = proc { |n| puts n } # # source://rubocop//lib/rubocop/cop/style/proc.rb#16 class RuboCop::Cop::Style::Proc &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/proc.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/proc.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/proc.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/proc.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proc_new?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/proc.rb#19 RuboCop::Cop::Style::Proc::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if the quotes used for quoted symbols match the configured defaults. # By default uses the same configuration as ‘Style/StringLiterals`; if that # cop is not enabled, the default `EnforcedStyle` is `single_quotes`. # # String interpolation is always kept in double quotes. # # NOTE: `Lint/SymbolConversion` can be used in parallel to ensure that symbols # are not quoted that don’t need to be. This cop is for configuring the quoting # style to use for symbols that require quotes. # # @example EnforcedStyle: same_as_string_literals (default) / single_quotes #   # bad #   :“abc-def” # #   # good #   :‘abc-def’ #   :“#{str}” #   :“a&#39;b” # @example EnforcedStyle: double_quotes #   # bad #   :‘abc-def’ # #   # good #   :“abc-def” #   :“#{str}” #   :“a&#39;b” # # source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#33 class RuboCop::Cop::Style::QuotedSymbols &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SymbolHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternative_style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_quotes</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_colon_key?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_double_quotes?</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quoted?</span>(<span class="ruby-identifier">sym_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrong_quotes?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#41 RuboCop::Cop::Style::QuotedSymbols::MSG_DOUBLE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/quoted_symbols.rb#39 RuboCop::Cop::Style::QuotedSymbols::MSG_SINGLE = T.let(T.unsafe(nil), String)</p>

<p># Checks the args passed to ‘fail` and `raise`. # # Exploded style (default) enforces passing the exception class and message # arguments separately, rather than constructing an instance of the error. # # Compact style enforces constructing an error instance. # # Both styles allow passing just a message, or an error instance when there is more # than one argument. # # The exploded style has an `AllowedCompactTypes` configuration # option that takes an `Array` of exception name Strings. # # @example EnforcedStyle: exploded (default) #   # bad #   raise StandardError.new(’message’) # #   # good #   raise StandardError, ‘message’ #   fail ‘message’ #   raise MyCustomError #   raise MyCustomError.new(arg1, arg2, arg3) #   raise MyKwArgError.new(key1: val1, key2: val2) # #   # With ‘AllowedCompactTypes` set to [’MyWrappedError’] #   raise MyWrappedError.new(obj) #   raise MyWrappedError.new(obj), ‘message’ # @example EnforcedStyle: compact #   # bad #   raise StandardError, ‘message’ #   raise RuntimeError, arg1, arg2, arg3 # #   # good #   raise StandardError.new(‘message’) #   raise MyCustomError #   raise MyCustomError.new(arg1, arg2, arg3) #   fail ‘message’ # # source://rubocop//lib/rubocop/cop/style/raise_args.rb#47 class RuboCop::Cop::Style::RaiseArgs &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_exploded_args?</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_non_exploded_type?</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_compact</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_exploded</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_compact_to_exploded</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_exploded_to_compact</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_parens?</span>(<span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/raise_args.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_new_method?</span>(<span class="ruby-identifier">first_arg</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/raise_args.rb#53 RuboCop::Cop::Style::RaiseArgs::ACCEPTABLE_ARG_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/raise_args.rb#52 RuboCop::Cop::Style::RaiseArgs::COMPACT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/raise_args.rb#51 RuboCop::Cop::Style::RaiseArgs::EXPLODED_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/raise_args.rb#57 RuboCop::Cop::Style::RaiseArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of randomly generated numbers, # added/subtracted with integer literals, as well as those with # Integer#succ and Integer#pred methods. Prefer using ranges instead, # as it clearly states the intentions. # # @example #   # bad #   rand(6) + 1 #   1 + rand(6) #   rand(6) - 1 #   1 - rand(6) #   rand(6).succ #   rand(6).pred #   Random.rand(6) + 1 #   Kernel.rand(6) + 1 #   rand(0..5) + 1 # #   # good #   rand(1..6) #   rand(1…7) # # source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#26 class RuboCop::Cop::Style::RandomWithOffset &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integer_op_rand?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rand_modified?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rand_op_integer?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">random_call</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_int</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">boundaries_from_random_node</span>(<span class="ruby-identifier">random_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_integer_op_rand</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_rand_modified</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_rand_op_integer</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prefix_from_prefix_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#29 RuboCop::Cop::Style::RandomWithOffset::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/random_with_offset.rb#30 RuboCop::Cop::Style::RandomWithOffset::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for a redundant argument passed to certain methods. # # NOTE: This cop is limited to methods with single parameter. # # Method names and their redundant arguments can be configured like this: # # [source,yaml] # —- # Methods: #   join: ” #   sum: 0 #   split: ‘ ’ #   chomp: “n” #   chomp!: “n” #   foo: 2 # —- # # @example #   # bad #   array.join(”) #   [1, 2, 3].join(“”) #   array.sum(0) #   exit(true) #   exit!(false) #   string.split(“ ”) #   “firstnsecond”.split(“ ”) #   string.chomp(“n”) #   string.chomp!(“n”) #   A.foo(2) # #   # good #   array.join #   [1, 2, 3].join #   array.sum #   exit #   exit! #   string.split #   “first second”.split #   string.chomp #   string.chomp! #   A.foo # # source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#57 class RuboCop::Cop::Style::RedundantArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_matched?</span>(<span class="ruby-identifier">target_argument</span>, <span class="ruby-identifier">redundant_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclude_cntrl_character?</span>(<span class="ruby-identifier">target_argument</span>, <span class="ruby-identifier">redundant_argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_arg_for_method</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#61 RuboCop::Cop::Style::RedundantArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_argument.rb#62 RuboCop::Cop::Style::RedundantArgument::NO_RECEIVER_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the instantiation of array using redundant ‘Array` constructor. # Autocorrect replaces to array literal which is the simplest and fastest. # # @example # #   # bad #   Array.new([]) #   Array[] #   Array([]) #   Array.new([’foo’, ‘foo’, ‘foo’]) #   Array[‘foo’, ‘foo’, ‘foo’] #   Array([‘foo’, ‘foo’, ‘foo’]) # #   # good #   [] #   [‘foo’, ‘foo’, ‘foo’] #   Array.new(3, ‘foo’) #   Array.new(3) { ‘foo’ } # # source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#25 class RuboCop::Cop::Style::RedundantArrayConstructor &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_array_constructor</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#28 RuboCop::Cop::Style::RedundantArrayConstructor::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_array_constructor.rb#30 RuboCop::Cop::Style::RedundantArrayConstructor::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant calls of ‘Array#flatten`. # # `Array#join` joins nested arrays recursively, so flattening an array # beforehand is redundant. # # @example #   # bad #   x.flatten.join #   x.flatten(1).join # #   # good #   x.join # # source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#26 class RuboCop::Cop::Style::RedundantArrayFlatten &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten_join?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#29 RuboCop::Cop::Style::RedundantArrayFlatten::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_array_flatten.rb#31 RuboCop::Cop::Style::RedundantArrayFlatten::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant assignment before returning. # # @example #   # bad #   def test #   x = foo #   x #   end # #   # bad #   def test #   if x #   z = foo #   z #   elsif y #   z = bar #   z #   end #   end # #   # good #   def test #   foo #   end # #   # good #   def test #   if x #   foo #   elsif y #   bar #   end #   end # # source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#40 class RuboCop::Cop::Style::RedundantAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_begin_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_branch</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case_match_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ensure_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_if_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_rescue_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_assignment.rb#43 RuboCop::Cop::Style::RedundantAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant ‘begin` blocks. # # Currently it checks for code like this: # # @example # #   # bad #   def redundant #   begin #   ala #   bala #   rescue StandardError =&gt; e #   something #   end #   end # #   # good #   def preferred #   ala #   bala #   rescue StandardError =&gt; e #   something #   end # #   # bad #   begin #   do_something #   end # #   # good #   do_something # #   # bad #   # When using Ruby 2.5 or later. #   do_something do #   begin #   something #   rescue =&gt; ex #   anything #   end #   end # #   # good #   # In Ruby 2.5 or later, you can omit `begin` in `do-end` block. #   do_something do #   something #   rescue =&gt; ex #   anything #   end # #   # good #   # Stabby lambdas don’t support implicit ‘begin` in `do-end` blocks. #   -&gt; do #   begin #   foo #   rescue Bar #   baz #   end #   end # # source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#65 class RuboCop::Cop::Style::RedundantBegin &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive_kwbegins</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowable_kwbegin?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_block_has_multiline_statements?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contain_rescue_or_ensure?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_modifier_form_after_multiline_begin_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_begin?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_begin</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">offense_range</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_begin_with_statement</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">offense_range</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Restore comments that occur between &quot;begin&quot; and &quot;first_child&quot;.</span>
<span class="ruby-comment"># These comments will be moved to above the assignment line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restore_removed_comments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">offense_range</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">first_child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_modifier_form_after_multiline_begin_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_begin_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_context_using_only_begin?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#71</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_begin.rb#69 RuboCop::Cop::Style::RedundantBegin::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for usage of the %W() syntax when %w() would do. # # @example #   # bad #   %W(cat dog pig) #   %W[door wall floor] # #   # good #   %w/swim run bike/ #   %w[shirt pants shoes] #   %W(apple #{fruit} grape) # # source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#17 class RuboCop::Cop::Style::RedundantCapitalW &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_percent_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_capital_w.rb#21 RuboCop::Cop::Style::RedundantCapitalW::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for unnecessary conditional expressions. # # NOTE: Since the intention of the comment cannot be automatically determined, # autocorrection is not applied when a comment is used, as shown below: # # [source,ruby] # —– # if b #   # Important note. #   b # else #   c # end # —– # # @example #   # bad #   a = b ? b : c # #   # good #   a = b || c # #   # bad #   if b #   b #   else #   c #   end # #   # good #   b || c # #   # good #   if b #   b #   elsif cond #   c #   end # #   # bad #   a.nil? ? true : a # #   # good #   a.nil? || a # #   # bad #   if a.nil? #   true #   else #   a #   end # #   # good #   a.nil? || a # @example AllowedMethods: [‘nonzero?’] (default) #   # good #   num.nonzero? ? true : false # # source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#65 class RuboCop::Cop::Style::RedundantCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># If the argument is using an operator, it is an invalid syntax.</span>
<span class="ruby-comment"># e.g. `foo || *bar`, `foo || **bar`, and `foo || &amp;bar`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_with_operator?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">asgn_type?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches_have_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches_have_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_ternary</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_source</span>(<span class="ruby-identifier">else_branch</span>, <span class="ruby-identifier">arithmetic_operation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_source_if_has_assignment</span>(<span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_source_if_has_method</span>(<span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_branch_is_true_type_and_else_is_not?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_source</span>(<span class="ruby-identifier">if_branch</span>, <span class="ruby-identifier">arithmetic_operation</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">make_ternary_form</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_braces?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_method?</span>(<span class="ruby-identifier">if_branch</span>, <span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_argument_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">synonymous_condition_and_branch?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_arithmetic_operation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_hash_key_access?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_hash_key_assignment?</span>(<span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_if_branch?</span>(<span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without_argument_parentheses_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap_arguments_with_parens</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#73 RuboCop::Cop::Style::RedundantCondition::ARGUMENT_WITH_OPERATOR_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#71 RuboCop::Cop::Style::RedundantCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_condition.rb#72 RuboCop::Cop::Style::RedundantCondition::REDUNDANT_CONDITION = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant returning of true/false in conditionals. # # @example #   # bad #   x == y ? true : false # #   # bad #   if x == y #   true #   else #   false #   end # #   # good #   x == y # #   # bad #   x == y ? false : true # #   # good #   x != y # # source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#27 class RuboCop::Cop::Style::RedundantConditional &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_condition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_condition_inverted?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indented_else_node</span>(<span class="ruby-identifier">expression</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#32 RuboCop::Cop::Style::RedundantConditional::COMPARISON_OPERATOR_MATCHER = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_conditional.rb#34 RuboCop::Cop::Style::RedundantConditional::MSG = T.let(T.unsafe(nil), String)</p>

<p># Avoid redundant ‘::` prefix on constant. # # How Ruby searches constant is a bit complicated, and it can often be difficult to # understand from the code whether the `::` is intended or not. Where `Module.nesting` # is empty, there is no need to prepend `::`, so it would be nice to consistently # avoid such meaningless `::` prefix to avoid confusion. # # NOTE: This cop is disabled if `Lint/ConstantResolution` cop is enabled to prevent # conflicting rules. Because it respects user configurations that want to enable # `Lint/ConstantResolution` cop which is disabled by default. # # @example #   # bad #   ::Const # #   # good #   Const # #   # bad #   class &lt;&lt; self #   ::Const #   end # #   # good #   class &lt;&lt; self #   Const #   end # #   # good #   class A #   ::Const #   end # #   # good #   module A #   ::Const #   end # # source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#43 class RuboCop::Cop::Style::RedundantConstantBase &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cbase</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lint_constant_resolution_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lint_constant_resolution_cop_enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_nesting_ancestors_of</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used_in_super_class_part?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">class_node:</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_constant_base.rb#46 RuboCop::Cop::Style::RedundantConstantBase::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for paths given to ‘require_relative` that start with # the current directory (`./`), which can be omitted. # # @example # #   # bad #   require_relative ’./path/to/feature’ # #   # good #   require_relative ‘path/to/feature’ # # source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#17 class RuboCop::Cop::Style::RedundantCurrentDirectoryInPath &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_path_length</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#23 RuboCop::Cop::Style::RedundantCurrentDirectoryInPath::CURRENT_DIRECTORY_PREFIX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#21 RuboCop::Cop::Style::RedundantCurrentDirectoryInPath::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#24 RuboCop::Cop::Style::RedundantCurrentDirectoryInPath::REDUNDANT_CURRENT_DIRECTORY_PREFIX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_current_directory_in_path.rb#22 RuboCop::Cop::Style::RedundantCurrentDirectoryInPath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant uses of double splat hash braces. # # @example # #   # bad #   do_something(**{foo: bar, baz: qux}) # #   # good #   do_something(foo: bar, baz: qux) # #   # bad #   do_something(**{foo: bar, baz: qux}.merge(options)) # #   # good #   do_something(foo: bar, baz: qux, **options) # # source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#22 class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_double_splat_receiver?</span>(<span class="ruby-identifier">kwsplat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">kwsplat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_merge_methods</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">merge_methods</span>, <span class="ruby-identifier">kwsplat</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_brace</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convert_to_new_arguments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mergeable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opening_brace</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_of_merge_methods</span>(<span class="ruby-identifier">merge_methods</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_receiver</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_merge_method_nodes</span>(<span class="ruby-identifier">kwsplat</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#26 RuboCop::Cop::Style::RedundantDoubleSplatHashBraces::MERGE_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_double_splat_hash_braces.rb#25 RuboCop::Cop::Style::RedundantDoubleSplatHashBraces::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant ‘each`. # # @example # #   # bad #   array.each.each { |v| do_something(v) } # #   # good #   array.each { |v| do_something(v) } # #   # bad #   array.each.each_with_index { |v, i| do_something(v, i) } # #   # good #   array.each.with_index { |v, i| do_something(v, i) } #   array.each_with_index { |v, i| do_something(v, i) } # #   # bad #   array.each.each_with_object { |v, o| do_something(v, o) } # #   # good #   array.each.with_object { |v, o| do_something(v, o) } #   array.each_with_object { |v, o| do_something(v, o) } # # source://rubocop//lib/rubocop/cop/style/redundant_each.rb#34 class RuboCop::Cop::Style::RedundantEach &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_each_method</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_redundant_each</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">redundant_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#37 RuboCop::Cop::Style::RedundantEach::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#38 RuboCop::Cop::Style::RedundantEach::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#39 RuboCop::Cop::Style::RedundantEach::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_each.rb#41 RuboCop::Cop::Style::RedundantEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for ‘RuntimeError` as the argument of `raise`/`fail`. # # @example #   # bad #   raise RuntimeError, ’message’ #   raise RuntimeError.new(‘message’) # #   # good #   raise ‘message’ # #   # bad - message is not a string #   raise RuntimeError, Object.new #   raise RuntimeError.new(Object.new) # #   # good #   raise Object.new.to_s # # source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#23 class RuboCop::Cop::Style::RedundantException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exploded?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Switch `raise RuntimeError, &#39;message&#39;` to `raise &#39;message&#39;`, and</span>
<span class="ruby-comment"># `raise RuntimeError.new(&#39;message&#39;)` to `raise &#39;message&#39;`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_compact</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fix_exploded</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replaced_compact</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replaced_exploded</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">command</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_message?</span>(<span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#26 RuboCop::Cop::Style::RedundantException::MSG_1 = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#27 RuboCop::Cop::Style::RedundantException::MSG_2 = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_exception.rb#29 RuboCop::Cop::Style::RedundantException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies places where ‘fetch(key) { value }` can be replaced by `fetch(key, value)`. # # In such cases `fetch(key, value)` method is faster than `fetch(key) { value }`. # # NOTE: The block string `’value’‘ in `hash.fetch(:key) { ’value’ }‘ is detected # but not when disabled. # # @example SafeForConstants: false (default) #   # bad #   hash.fetch(:key) { 5 } #   hash.fetch(:key) { true } #   hash.fetch(:key) { nil } #   array.fetch(5) { :value } #   ENV.fetch(:key) { ’value’ } # #   # good #   hash.fetch(:key, 5) #   hash.fetch(:key, true) #   hash.fetch(:key, nil) #   array.fetch(5, :value) #   ENV.fetch(:key, ‘value’) # @example SafeForConstants: true #   # bad #   ENV.fetch(:key) { VALUE } # #   # good #   ENV.fetch(:key, VALUE) # # source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#40 class RuboCop::Cop::Style::RedundantFetchBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rails_cache?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_fetch_block_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_bad_method</span>(<span class="ruby-identifier">send</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_good_method</span>(<span class="ruby-identifier">send</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_constant?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_string?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch_range</span>(<span class="ruby-identifier">send</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_not_check?</span>(<span class="ruby-identifier">send</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_fetch_block.rb#45 RuboCop::Cop::Style::RedundantFetchBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the presence of superfluous ‘.rb` extension in # the filename provided to `require` and `require_relative`. # # NOTE: If the extension is omitted, Ruby tries adding ’.rb’, ‘.so’, #       and so on to the name until found. If the file named cannot be found, #       a ‘LoadError` will be raised. #       There is an edge case where `foo.so` file is loaded instead of a `LoadError` #       if `foo.so` file exists when `require ’foo.rb’‘ will be changed to `require ’foo’‘, #       but that seems harmless. # # @example #   # bad #   require ’foo.rb’ #   require_relative ‘../foo.rb’ # #   # good #   require ‘foo’ #   require ‘foo.so’ #   require_relative ‘../foo’ #   require_relative ‘../foo.so’ # # source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#27 class RuboCop::Cop::Style::RedundantFileExtensionInRequire &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extension_range</span>(<span class="ruby-identifier">name_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#31 RuboCop::Cop::Style::RedundantFileExtensionInRequire::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_file_extension_in_require.rb#32 RuboCop::Cop::Style::RedundantFileExtensionInRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies usages of ‘any?`, `empty?` or `none?` predicate methods # chained to `select`/`filter`/`find_all` and change them to use predicate method instead. # # @example #   # bad #   arr.select { |x| x &gt; 1 }.any? # #   # good #   arr.any? { |x| x &gt; 1 } # #   # bad #   arr.select { |x| x &gt; 1 }.empty? #   arr.select { |x| x &gt; 1 }.none? # #   # good #   arr.none? { |x| x &gt; 1 } # #   # good #   relation.select(:name).any? #   arr.select { |x| x &gt; 1 }.any?(&amp;:odd?) # @example AllCops:ActiveSupportExtensionsEnabled: false (default) #   # good #   arr.select { |x| x &gt; 1 }.many? # #   # good #   arr.select { |x| x &gt; 1 }.present? # @example AllCops:ActiveSupportExtensionsEnabled: true #   # bad #   arr.select { |x| x &gt; 1 }.many? # #   # good #   arr.many? { |x| x &gt; 1 } # #   # bad #   arr.select { |x| x &gt; 1 }.present? # #   # good #   arr.any? { |x| x &gt; 1 } # # source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#53 class RuboCop::Cop::Style::RedundantFilterChain &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select_predicate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">select_node</span>, <span class="ruby-identifier">predicate_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">predicate_range</span>(<span class="ruby-identifier">predicate_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">select_node</span>, <span class="ruby-identifier">predicate_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#56 RuboCop::Cop::Style::RedundantFilterChain::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#58 RuboCop::Cop::Style::RedundantFilterChain::RAILS_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#71 RuboCop::Cop::Style::RedundantFilterChain::REPLACEMENT_METHODS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_filter_chain.rb#59 RuboCop::Cop::Style::RedundantFilterChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for calls to ‘Kernel#format` or `Kernel#sprintf` that are redundant. # # Calling `format` with only a single string or constant argument is redundant, # as it can be replaced by the string or constant itself. # # Also looks for `format` calls where the arguments are literals that can be # inlined into a string easily. This applies to the `%s`, `%d`, `%i`, `%u`, and # `%f` format specifiers. # # @example # #   # bad #   format(’the quick brown fox jumps over the lazy dog.‘) #   sprintf(’the quick brown fox jumps over the lazy dog.‘) # #   # good #   ’the quick brown fox jumps over the lazy dog.‘ # #   # bad #   format(MESSAGE) #   sprintf(MESSAGE) # #   # good #   MESSAGE # #   # bad #   format(’%s %s’, ‘foo’, ‘bar’) #   sprintf(‘%s %s’, ‘foo’, ‘bar’) # #   # good #   ‘foo bar’ # # source://rubocop//lib/rubocop/cop/style/redundant_format.rb#54 class RuboCop::Cop::Style::RedundantFormat &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_number?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_hash_value_node</span>(<span class="ruby-identifier">param0</span>, <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_without_additional_args?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rational_number?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splatted_arguments?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_fields_literal?</span>(<span class="ruby-identifier">string</span>, <span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_value</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_values</span>(<span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_value</span>(<span class="ruby-identifier">complex_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect_unnecessary_fields</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dsym_value</span>(<span class="ruby-identifier">dsym_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_argument</span>(<span class="ruby-identifier">sequence</span>, <span class="ruby-identifier">arguments</span>, <span class="ruby-identifier">hash</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">float?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_value</span>(<span class="ruby-identifier">hash_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integer?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_argument?</span>(<span class="ruby-identifier">sequence</span>, <span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">prefer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numeric?</span>(<span class="ruby-identifier">argument</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Add correct quotes to the formatted string, preferring retaining the existing</span>
<span class="ruby-comment"># quotes if possible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quote</span>(<span class="ruby-identifier">string</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rational_value</span>(<span class="ruby-identifier">rational_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_all_fields_literal</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">string</span>, <span class="ruby-identifier">arguments</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#60 RuboCop::Cop::Style::RedundantFormat::ACCEPTABLE_LITERAL_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#57 RuboCop::Cop::Style::RedundantFormat::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_format.rb#59 RuboCop::Cop::Style::RedundantFormat::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># Check for uses of ‘Object#freeze` on immutable objects. # # NOTE: `Regexp` and `Range` literals are frozen objects since Ruby 3.0. # # NOTE: From Ruby 3.0, this cop allows explicit freezing of interpolated # string literals when `# frozen-string-literal: true` is used. # # @example #   # bad #   CONST = 1.freeze # #   # good #   CONST = 1 # # source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#19 class RuboCop::Cop::Style::RedundantFreeze &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operation_produces_immutable_object?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">immutable_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strip_parenthesis</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#23 RuboCop::Cop::Style::RedundantFreeze::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_freeze.rb#24 RuboCop::Cop::Style::RedundantFreeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant heredoc delimiter quotes. # # @example # #   # bad #   do_something(&lt;&lt;~‘EOS’) #   no string interpolation style text #   EOS # #   # good #   do_something(&lt;&lt;~EOS) #   no string interpolation style text #   EOS # #   do_something(&lt;&lt;~‘EOS’) #   #{string_interpolation_style_text_not_evaluated} #   EOS # #   do_something(&lt;&lt;~‘EOS’) #   Preserve \ #   newlines #   EOS # # source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#29 class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Heredoc</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_heredoc</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">need_heredoc_delimiter_quotes?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#33 RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_heredoc_delimiter_quotes.rb#34 RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes::STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># Checks for ‘initialize` methods that are redundant. # # An initializer is redundant if it does not do anything, or if it only # calls `super` with the same arguments given to it. If the initializer takes # an argument that accepts multiple values (`restarg`, `kwrestarg`, etc.) it # will not register an offense, because it allows the initializer to take a different # number of arguments as its superclass potentially does. # # NOTE: If an initializer takes any arguments and has an empty body, RuboCop # assumes it to <strong>not</strong> be redundant. This is to prevent potential `ArgumentError`. # # NOTE: If an initializer argument has a default value, RuboCop assumes it # to <strong>not</strong> be redundant. # # NOTE: Empty initializers are registered as offenses, but it is possible # to purposely create an empty `initialize` method to override a superclass’s # initializer. # # @example #   # bad #   def initialize #   end # #   # bad #   def initialize #   super #   end # #   # bad #   def initialize(a, b) #   super #   end # #   # bad #   def initialize(a, b) #   super(a, b) #   end # #   # good #   def initialize #   do_something #   end # #   # good #   def initialize #   do_something #   super #   end # #   # good (different number of parameters) #   def initialize(a, b) #   super(a) #   end # #   # good (default value) #   def initialize(a, b = 5) #   super #   end # #   # good (default value) #   def initialize(a, b: 5) #   super #   end # #   # good (changes the parameter requirements) #   def initialize(_) #   end # #   # good (changes the parameter requirements) #   def initialize(*) #   end # #   # good (changes the parameter requirements) #   def initialize(**) #   end # #   # good (changes the parameter requirements) #   def initialize(…) #   end # @example AllowComments: true (default) # #   # good #   def initialize #   # Overriding to negate superclass ‘initialize` method. #   end # @example AllowComments: false # #   # bad #   def initialize #   # Overriding to negate superclass `initialize` method. #   end # # source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#106 class RuboCop::Cop::Style::RedundantInitialize &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_forwards?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_comments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwards?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_args?</span>(<span class="ruby-identifier">super_node</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#111 RuboCop::Cop::Style::RedundantInitialize::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_initialize.rb#112 RuboCop::Cop::Style::RedundantInitialize::MSG_EMPTY = T.let(T.unsafe(nil), String)</p>

<p># Checks for strings that are just an interpolated expression. # # @example # #   # bad #   “#{@var}” # #   # good #   @var.to_s # #   # good if @var is already a String #   @var # # source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#39 class RuboCop::Cop::Style::RedundantInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_other</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">embedded_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_single_variable_interpolation</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">embedded_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_variable_interpolation</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">embedded_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">embedded_in_percent_array?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_concatenation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_variable_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#45</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_interpolation.rb#43 RuboCop::Cop::Style::RedundantInterpolation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Before Ruby 3.0, interpolated strings followed the frozen string literal # magic comment which sometimes made it necessary to explicitly unfreeze them. # Ruby 3.0 changed interpolated strings to always be unfrozen which makes # unfreezing them redundant. # # @example #   # bad #   +“#{foo} bar” # #   # bad #   “#{foo} bar”.dup # #   # good #   “#{foo} bar” # # source://rubocop//lib/rubocop/cop/style/redundant_interpolation_unfreeze.rb#21 class RuboCop::Cop::Style::RedundantInterpolationUnfreeze &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">FrozenStringLiteral</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_interpolation_unfreeze.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_interpolation_unfreeze.rb#26 RuboCop::Cop::Style::RedundantInterpolationUnfreeze::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_interpolation_unfreeze.rb#28 RuboCop::Cop::Style::RedundantInterpolationUnfreeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Check for redundant line continuation. # # This cop marks a line continuation as redundant if removing the backslash # does not result in a syntax error. # However, a backslash at the end of a comment or # for string concatenation is not redundant and is not considered an offense. # # @example #   # bad #   foo. \ #   bar #   foo \ #   &amp;.bar \ #   .baz # #   # good #   foo. #   bar #   foo #   &amp;.bar #   .baz # #   # bad #   [foo, \ #   bar] #   {foo: \ #   bar} # #   # good #   [foo, #   bar] #   {foo: #   bar} # #   # bad #   foo(bar, \ #   baz) # #   # good #   foo(bar, #   baz) # #   # also good - backslash in string concatenation is not redundant #   foo(‘bar’ \ #   ‘baz’) # #   # also good - backslash at the end of a comment is not redundant #   foo(bar, # \ #   baz) # #   # also good - backslash at the line following the newline begins with a + or -, #   # it is not redundant #   1 \ #   + 2 \ #   - 3 # #   # also good - backslash with newline between the method name and its arguments, #   # it is not redundant. #   some_method \ #   (argument) # # source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#67 class RuboCop::Cop::Style::RedundantLineContinuation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MatchRange</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_is_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_newline?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">code_ends_with_continuation?</span>(<span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_with_uncommented_backslash?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_node_for_line</span>(<span class="ruby-identifier">last_line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_string_literal?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_string_literal_or_method_with_argument?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_end_of_ruby_code_line_continuation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">leading_dot_method_chain_with_blank_line?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_with_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A method call without parentheses such as the following cannot remove `\`:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   do_something \</span>
<span class="ruby-comment">#     argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_with_argument?</span>(<span class="ruby-identifier">line_range</span>, <span class="ruby-identifier">current_token</span>, <span class="ruby-identifier">next_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_line_continuation?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_line_continuation?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_with_arithmetic_operator?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_concatenation?</span>(<span class="ruby-identifier">source_line</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#74 RuboCop::Cop::Style::RedundantLineContinuation::ALLOWED_STRING_TOKENS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#81 RuboCop::Cop::Style::RedundantLineContinuation::ARGUMENT_TAKING_FLOW_TOKEN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#75 RuboCop::Cop::Style::RedundantLineContinuation::ARGUMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#84 RuboCop::Cop::Style::RedundantLineContinuation::ARITHMETIC_OPERATOR_TOKENS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#72 RuboCop::Cop::Style::RedundantLineContinuation::LINE_CONTINUATION = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#73 RuboCop::Cop::Style::RedundantLineContinuation::LINE_CONTINUATION_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_line_continuation.rb#71 RuboCop::Cop::Style::RedundantLineContinuation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant parentheses. # # @example # #   # bad #   (x) if ((y.z).nil?) # #   # good #   x if y.z.nil? # # source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#16 class RuboCop::Cop::Style::RedundantParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Parentheses</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_pin_operator?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#314</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_send_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_super_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#324</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_yield_argument?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_node_and_args</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">square_brackets?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_in_multiline_conditions?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_ancestor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_multiple_expression?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_ternary?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_of_parenthesized_method_call?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#328</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_chain_starts_with_int?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_send</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_unary</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disallowed_literal?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disallowed_one_line_pattern_matching?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#334</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_end_block_in_method_chain?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_message</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_arg_begins_with_hash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_syntax?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_pattern_matching_in_method_argument?</span>(<span class="ruby-identifier">begin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_ancestor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_with_redundant_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">like_method_argument_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_parentheses_required?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#290</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_call_with_redundant_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_chain_begins_with_hash_literal</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_control_flow_statements?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_begin_arg?</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parens_allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raised_to_power_negative_numeric?</span>(<span class="ruby-identifier">begin_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suspect_unary?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_parentheses_required?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_parentheses.rb#20 RuboCop::Cop::Style::RedundantParentheses::ALLOWED_NODE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for usage of the %q/%Q syntax when ” or “” would do. # # @example # #   # bad #   name = %q(Bruce Wayne) #   time = %q(8 o’clock) #   question = %q(“What did you say?”) # #   # good #   name = ‘Bruce Wayne’ #   time = “8 o’clock” #   question = ‘“What did you say?”’ # # source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#20 class RuboCop::Cop::Style::RedundantPercentQ &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_capital_q?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">acceptable_q?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_percent_q?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolated_quotes?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_with_percent_q_variant?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#25 RuboCop::Cop::Style::RedundantPercentQ::DYNAMIC_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#28 RuboCop::Cop::Style::RedundantPercentQ::EMPTY = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#32 RuboCop::Cop::Style::RedundantPercentQ::ESCAPED_NON_BACKSLASH = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#23 RuboCop::Cop::Style::RedundantPercentQ::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#30 RuboCop::Cop::Style::RedundantPercentQ::PERCENT_CAPITAL_Q = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#29 RuboCop::Cop::Style::RedundantPercentQ::PERCENT_Q = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#27 RuboCop::Cop::Style::RedundantPercentQ::QUOTE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#26 RuboCop::Cop::Style::RedundantPercentQ::SINGLE_QUOTE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_percent_q.rb#31 RuboCop::Cop::Style::RedundantPercentQ::STRING_INTERPOLATION_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># Identifies places where argument can be replaced from # a deterministic regexp to a string. # # @example #   # bad #   ‘foo’.byteindex(/f/) #   ‘foo’.byterindex(/f/) #   ‘foo’.gsub(/f/, ‘x’) #   ‘foo’.gsub!(/f/, ‘x’) #   ‘foo’.partition(/f/) #   ‘foo’.rpartition(/f/) #   ‘foo’.scan(/f/) #   ‘foo’.split(/f/) #   ‘foo’.start_with?(/f/) #   ‘foo’.sub(/f/, ‘x’) #   ‘foo’.sub!(/f/, ‘x’) # #   # good #   ‘foo’.byteindex(‘f’) #   ‘foo’.byterindex(‘f’) #   ‘foo’.gsub(‘f’, ‘x’) #   ‘foo’.gsub!(‘f’, ‘x’) #   ‘foo’.partition(‘f’) #   ‘foo’.rpartition(‘f’) #   ‘foo’.scan(‘f’) #   ‘foo’.split(‘f’) #   ‘foo’.start_with?(‘f’) #   ‘foo’.sub(‘f’, ‘x’) #   ‘foo’.sub!(‘f’, ‘x’) # # source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#35 class RuboCop::Cop::Style::RedundantRegexpArgument &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">determinist_regexp?</span>(<span class="ruby-identifier">regexp_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_argument</span>(<span class="ruby-identifier">regexp_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">regexp_node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#43 RuboCop::Cop::Style::RedundantRegexpArgument::DETERMINISTIC_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#39 RuboCop::Cop::Style::RedundantRegexpArgument::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#40 RuboCop::Cop::Style::RedundantRegexpArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_argument.rb#44 RuboCop::Cop::Style::RedundantRegexpArgument::STR_SPECIAL_CHARS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for unnecessary single-element ‘Regexp` character classes. # # @example # #   # bad #   r = /[x]/ # #   # good #   r = /x/ # #   # bad #   r = /[s]/ # #   # good #   r = /s/ # #   # bad #   r = %r{/[b]} # #   # good #   r = %r{/b} # #   # good #   r = /[ab]/ # # source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#30 class RuboCop::Cop::Style::RedundantRegexpCharacterClass &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">backslash_b?</span>(<span class="ruby-identifier">elem</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_redundant_character_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_single_element_character_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_codepoints?</span>(<span class="ruby-identifier">expression</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">octal_requiring_char_class?</span>(<span class="ruby-identifier">elem</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_single_element_character_class?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">char_class</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_escape_outside_char_class?</span>(<span class="ruby-identifier">elem</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_in_free_space_mode?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elem</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without_character_class</span>(<span class="ruby-identifier">loc</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#34 RuboCop::Cop::Style::RedundantRegexpCharacterClass::MSG_REDUNDANT_CHARACTER_CLASS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_character_class.rb#33 RuboCop::Cop::Style::RedundantRegexpCharacterClass::REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the instantiation of regexp using redundant ‘Regexp.new` or `Regexp.compile`. # Autocorrect replaces to regexp literal which is the simplest and fastest. # # @example # #   # bad #   Regexp.new(/regexp/) #   Regexp.compile(/regexp/) # #   # good #   /regexp/ #   Regexp.new(’regexp’) #   Regexp.compile(‘regexp’) # # source://rubocop//lib/rubocop/cop/style/redundant_regexp_constructor.rb#20 class RuboCop::Cop::Style::RedundantRegexpConstructor &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_constructor.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_constructor.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_regexp_constructor</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_constructor.rb#23 RuboCop::Cop::Style::RedundantRegexpConstructor::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_constructor.rb#24 RuboCop::Cop::Style::RedundantRegexpConstructor::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant escapes inside ‘Regexp` literals. # # @example #   # bad #   %r{foo/bar} # #   # good #   %r{foo/bar} # #   # good #   /foo/bar/ # #   # good #   %r/foo/bar/ # #   # good #   %r!foo!bar! # #   # bad #   /a-b/ # #   # good #   /a-b/ # #   # bad #   /[+-]d/ # #   # good #   /[+-]d/ # # source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#35 class RuboCop::Cop::Style::RedundantRegexpEscape &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_escape?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">char</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">within_character_class</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">char_class_begins_or_ends_with_escaped_hyphen?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_escape</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape_range_at_index</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">index</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#41 RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_ALWAYS_ESCAPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#43 RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#42 RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_regexp_escape.rb#39 RuboCop::Cop::Style::RedundantRegexpEscape::MSG_REDUNDANT_ESCAPE = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant ‘return` expressions. # # @example #   # These bad cases should be extended to handle methods whose body is #   # if/else or a case expression with a default branch. # #   # bad #   def test #   return something #   end # #   # bad #   def test #   one #   two #   three #   return something #   end # #   # bad #   def test #   return something if something_else #   end # #   # good #   def test #   something if something_else #   end # #   # good #   def test #   if x #   elsif y #   else #   end #   end # @example AllowMultipleReturnValues: false (default) #   # bad #   def test #   return x, y #   end # @example AllowMultipleReturnValues: true #   # good #   def test #   return x, y #   end # # source://rubocop//lib/rubocop/cop/style/redundant_return.rb#55 class RuboCop::Cop::Style::RedundantReturn &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_braces</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_brackets</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_multiple_return_values?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_begin_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_branch</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case_match_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_case_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_ensure_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_if_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_resbody_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_rescue_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_return_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_with_arguments</span>(<span class="ruby-identifier">return_node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_without_arguments</span>(<span class="ruby-identifier">return_node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_without_braces?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#59 RuboCop::Cop::Style::RedundantReturn::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#60 RuboCop::Cop::Style::RedundantReturn::MULTI_RETURN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_return.rb#61 RuboCop::Cop::Style::RedundantReturn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for redundant uses of ‘self`. # # The usage of `self` is only needed when: # # * Sending a message to same object with zero arguments in #   presence of a method name clash with an argument or a local #   variable. # # * Calling an attribute writer to prevent a local variable assignment. # # Note, with using explicit self you can only send messages with public or # protected scope, you cannot send private messages this way. # # Note we allow uses of `self` with operators because it would be awkward # otherwise. Also allows the use of `self.it` without arguments in blocks, # as in `0.times { self.it }`, following `Lint/ItWithoutArgumentsInBlock` cop. # # @example # #   # bad #   def foo(bar) #   self.baz #   end # #   # good #   def foo(bar) #   self.bar  # Resolves name clash with the argument. #   end # #   def foo #   bar = 1 #   self.bar  # Resolves name clash with the local variable. #   end # #   def foo #   %w[x y z].select do |bar| #   self.bar == bar  # Resolves name clash with argument of the block. #   end #   end # # source://rubocop//lib/rubocop/cop/style/redundant_self.rb#45 class RuboCop::Cop::Style::RedundantSelf &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [RedundantSelf] a new instance of RedundantSelf</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Assignment of self.x</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_blockarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Using self.x to distinguish from local variable x</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Using self.x to distinguish from local variable x</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Assignment of self.x</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_lhs_to_local_variables_scopes</span>(<span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">lhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_masgn_lhs_variables</span>(<span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">lhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_match_var_scopes</span>(<span class="ruby-identifier">in_pattern_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_scope</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">local_variables</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_self</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_send_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Respects `Lint/ItWithoutArgumentsInBlock` cop and the following Ruby 3.3&#39;s warning:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># $ ruby -e &#39;0.times { begin; it; end }&#39;</span>
<span class="ruby-comment"># -e:1: warning: `it` calls without arguments will refer to the first block param in</span>
<span class="ruby-comment"># Ruby 3.4; use it() or self.it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">it_method_in_block?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_argument</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regular_method_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#56</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#49 RuboCop::Cop::Style::RedundantSelf::KERNEL_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#50 RuboCop::Cop::Style::RedundantSelf::KEYWORDS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self.rb#48 RuboCop::Cop::Style::RedundantSelf::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for places where redundant assignments are made for in place # modification methods. # # @example #   # bad #   args = args.concat(ary) #   hash = hash.merge!(other) # #   # good #   args.concat(foo) #   args += foo #   hash.merge!(other) # #   # good #   foo.concat(ary) # # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#27 class RuboCop::Cop::Style::RedundantSelfAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_self_assignment?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>, <span class="ruby-identifier">param2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_returning_self?</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#41 RuboCop::Cop::Style::RedundantSelfAssignment::ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#34 RuboCop::Cop::Style::RedundantSelfAssignment::METHODS_RETURNING_SELF = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment.rb#31 RuboCop::Cop::Style::RedundantSelfAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for places where conditional branch makes redundant self-assignment. # # It only detects local variable because it may replace state of instance variable, # class variable, and global variable that have state across methods with ‘nil`. # # @example # #   # bad #   foo = condition ? bar : foo # #   # good #   foo = bar if condition # #   # bad #   foo = condition ? foo : bar # #   # good #   foo = bar unless condition # # source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#25 class RuboCop::Cop::Style::RedundantSelfAssignmentBranch &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bad_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inconvertible_to_modifier?</span>(<span class="ruby-identifier">if_branch</span>, <span class="ruby-identifier">else_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_statements?</span>(<span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">if_node</span>, <span class="ruby-identifier">offense_branch</span>, <span class="ruby-identifier">opposite_branch</span>, <span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">self_assign?</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_if_and_else_branch?</span>(<span class="ruby-identifier">expression</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_self_assignment_branch.rb#28 RuboCop::Cop::Style::RedundantSelfAssignmentBranch::MSG = T.let(T.unsafe(nil), String)</p>

<p># Identifies instances of sorting and then # taking only the first or last element. The same behavior can # be accomplished without a relatively expensive sort by using # ‘Enumerable#min` instead of sorting and taking the first # element and `Enumerable#max` instead of sorting and taking the # last element. Similarly, `Enumerable#min_by` and # `Enumerable#max_by` can replace `Enumerable#sort_by` calls # after which only the first or last element is used. # # @example #   # bad #   [2, 1, 3].sort.first #   [2, 1, <a href="0">3].sort</a> #   [2, 1, 3].sort.at(0) #   [2, 1, 3].sort.slice(0) # #   # good #   [2, 1, 3].min # #   # bad #   [2, 1, 3].sort.last #   [2, 1, <a href="-1">3].sort</a> #   [2, 1, 3].sort.at(-1) #   [2, 1, 3].sort.slice(-1) # #   # good #   [2, 1, 3].max # #   # bad #   arr.sort_by(&amp;:foo).first #   <a href="0">arr.sort_by(&amp;:foo)</a> #   arr.sort_by(&amp;:foo).at(0) #   arr.sort_by(&amp;:foo).slice(0) # #   # good #   arr.min_by(&amp;:foo) # #   # bad #   arr.sort_by(&amp;:foo).last #   <a href="-1">arr.sort_by(&amp;:foo)</a> #   arr.sort_by(&amp;:foo).at(-1) #   arr.sort_by(&amp;:foo).slice(-1) # #   # good #   arr.max_by(&amp;:foo) # # source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#79 class RuboCop::Cop::Style::RedundantSort &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_sort?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># This gets the start of the accessor whether it has a dot</span>
<span class="ruby-comment"># (e.g. `.first`) or doesn&#39;t (e.g. `[0]`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accessor_start</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_value</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">sort_node</span>, <span class="ruby-identifier">sorter</span>, <span class="ruby-identifier">accessor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base</span>(<span class="ruby-identifier">accessor</span>, <span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_redundant_sort</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sorter</span>, <span class="ruby-identifier">accessor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">sort_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">sort_node</span>, <span class="ruby-identifier">sorter</span>, <span class="ruby-identifier">accessor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace_with_logical_operator</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suffix</span>(<span class="ruby-identifier">sorter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suggestion</span>(<span class="ruby-identifier">sorter</span>, <span class="ruby-identifier">accessor</span>, <span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_logical_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#83 RuboCop::Cop::Style::RedundantSort::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_sort.rb#85 RuboCop::Cop::Style::RedundantSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Identifies places where ‘sort_by { … }` can be replaced by # `sort`. # # @example #   # bad #   array.sort_by { |x| x } #   array.sort_by do |var| #   var #   end # #   # good #   array.sort # # source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#18 class RuboCop::Cop::Style::RedundantSortBy &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_sort_by_block</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_sort_by_itblock</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_sort_by_numblock</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort_by_range</span>(<span class="ruby-identifier">send</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#22 RuboCop::Cop::Style::RedundantSortBy::MSG_BLOCK = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#24 RuboCop::Cop::Style::RedundantSortBy::MSG_ITBLOCK = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_sort_by.rb#23 RuboCop::Cop::Style::RedundantSortBy::MSG_NUMBLOCK = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant escapes in string literals. # # @example #   # bad - no need to escape # without following {/$/@ #   “#foo” # #   # bad - no need to escape single quotes inside double quoted string #   “&#39;foo&#39;” # #   # bad - heredocs are also checked for unnecessary escapes #   &lt;&lt;~STR #   #foo "foo&quot; #   STR # #   # good #   “#foo” # #   # good #   “#{no_interpolation}” # #   # good #   “‘foo’” # #   # good #   “foo\ #   bar” # #   # good #   &lt;&lt;~STR #   #foo “foo” #   STR # # source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#37 class RuboCop::Cop::Style::RedundantStringEscape &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MatchRange</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_escape?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_literal?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">prefix</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_loc_present?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabling_interpolation?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_with_disabled_interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation_not_enabled?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal_in_interpolated_or_multiline_string?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_array_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_q_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_w_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_w_upper_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_quoted?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_contents_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/redundant_string_escape.rb#41 RuboCop::Cop::Style::RedundantStringEscape::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces using ‘//` or `%r` around regular expressions. # # NOTE: The following `%r` cases using a regexp starts with a blank or `=` # as a method argument allowed to prevent syntax errors. # # [source,ruby] # —- # do_something %r{ regexp} # `do_something / regexp/` is an invalid syntax. # do_something %r{=regexp} # `do_something /=regexp/` is an invalid syntax. # —- # # @example EnforcedStyle: slashes (default) #   # bad #   snake_case = %r{^[dA-Z_]+$} # #   # bad #   regex = %r{ #   foo #   (bar) #   (baz) #   }x # #   # good #   snake_case = /^[dA-Z_]+$/ # #   # good #   regex = / #   foo #   (bar) #   (baz) #   /x # @example EnforcedStyle: percent_r #   # bad #   snake_case = /^[dA-Z_]+$/ # #   # bad #   regex = / #   foo #   (bar) #   (baz) #   /x # #   # good #   snake_case = %r{^[dA-Z_]+$} # #   # good #   regex = %r{ #   foo #   (bar) #   (baz) #   }x # @example EnforcedStyle: mixed #   # bad #   snake_case = %r{^[dA-Z_]+$} # #   # bad #   regex = / #   foo #   (bar) #   (baz) #   /x # #   # good #   snake_case = /^[dA-Z_]+$/ # #   # good #   regex = %r{ #   foo #   (bar) #   (baz) #   }x # @example AllowInnerSlashes: false (default) #   # If `false`, the cop will always recommend using `%r` if one or more #   # slashes are found in the regexp string. # #   # bad #   x =~ /home// # #   # good #   x =~ %r{home/} # @example AllowInnerSlashes: true #   # good #   x =~ /home// # # source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#93 class RuboCop::Cop::Style::RegexpLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_inner_slashes?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_mixed_percent_r?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_mixed_slash?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_omit_parentheses_with_percent_r_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_percent_r_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_slash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#221</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calculate_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_disallowed_slash?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_slash?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_delimiters</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_inner_slashes</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_slash_after_correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_slash_before_correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_slash_for</span>(<span class="ruby-identifier">opening_delimiter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_slash_indices</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_body</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">include_begin_nodes:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slash_literal?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#99 RuboCop::Cop::Style::RegexpLiteral::MSG_USE_PERCENT_R = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/regexp_literal.rb#98 RuboCop::Cop::Style::RegexpLiteral::MSG_USE_SLASHES = T.let(T.unsafe(nil), String)</p>

<p># Sort ‘require` and `require_relative` in alphabetical order. # # @example #   # bad #   require ’b’ #   require ‘a’ # #   # good #   require ‘a’ #   require ‘b’ # #   # bad #   require_relative ‘b’ #   require_relative ‘a’ # #   # good #   require_relative ‘a’ #   require_relative ‘b’ # #   # good (sorted within each section separated by a blank line) #   require ‘a’ #   require ‘d’ # #   require ‘b’ #   require ‘c’ # #   # good #   require ‘b’ #   require_relative ‘c’ #   require ‘a’ # #   # bad #   require ‘a’ #   require ‘c’ if foo #   require ‘b’ # #   # good #   require ‘a’ #   require ‘b’ #   require ‘c’ if foo # #   # bad #   require ‘c’ #   if foo #   require ‘d’ #   require ‘b’ #   end #   require ‘a’ # #   # good #   require ‘c’ #   if foo #   require ‘b’ #   require ‘d’ #   end #   require ‘a’ # # source://rubocop//lib/rubocop/cop/style/require_order.rb#66 class RuboCop::Cop::Style::RequireOrder &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_inside_only_require</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">previous_older_sibling</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_previous_older_sibling</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_same_section?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_modifier_form?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">search_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/require_order.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sibling_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/require_order.rb#73 RuboCop::Cop::Style::RequireOrder::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/require_order.rb#71 RuboCop::Cop::Style::RequireOrder::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of ‘rescue` in its modifier form is added for following # reasons: # # * The syntax of modifier form `rescue` can be misleading because it #   might lead us to believe that `rescue` handles the given exception #   but it actually rescue all exceptions to return the given rescue #   block. In this case, value returned by handle_error or #   SomeException. # # * Modifier form `rescue` would rescue all the exceptions. It would #   silently skip all exception or errors and handle the error. #   Example: If `NoMethodError` is raised, modifier form rescue would #   handle the exception. # # @example #   # bad #   some_method rescue handle_error # #   # bad #   some_method rescue SomeException # #   # good #   begin #   some_method #   rescue #   handle_error #   end # #   # good #   begin #   some_method #   rescue SomeException #   handle_error #   end # # source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#40 class RuboCop::Cop::Style::RescueModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RescueNode</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_rescue_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">parenthesized</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indentation_and_offset</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">parenthesized</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/rescue_modifier.rb#46 RuboCop::Cop::Style::RescueModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for rescuing ‘StandardError`. There are two supported # styles `implicit` and `explicit`. This cop will not register an offense # if any error other than `StandardError` is specified. # # @example EnforcedStyle: explicit (default) #   # `explicit` will enforce using `rescue StandardError` #   # instead of `rescue`. # #   # bad #   begin #   foo #   rescue #   bar #   end # #   # good #   begin #   foo #   rescue StandardError #   bar #   end # #   # good #   begin #   foo #   rescue OtherError #   bar #   end # #   # good #   begin #   foo #   rescue StandardError, SecurityError #   bar #   end # @example EnforcedStyle: implicit #   # `implicit` will enforce using `rescue` instead of #   # `rescue StandardError`. # #   # bad #   begin #   foo #   rescue StandardError #   bar #   end # #   # good #   begin #   foo #   rescue #   bar #   end # #   # good #   begin #   foo #   rescue OtherError #   bar #   end # #   # good #   begin #   foo #   rescue StandardError, SecurityError #   bar #   end # # source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#73 class RuboCop::Cop::Style::RescueStandardError &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RescueNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_standard_error?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_without_error_class?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_for_explicit_enforced_style</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_for_implicit_enforced_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#80 RuboCop::Cop::Style::RescueStandardError::MSG_EXPLICIT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/rescue_standard_error.rb#79 RuboCop::Cop::Style::RescueStandardError::MSG_IMPLICIT = T.let(T.unsafe(nil), String)</p>

<p># Enforces consistency between ‘return nil` and `return`. # # This cop is disabled by default. Because there seems to be a perceived semantic difference # between `return` and `return nil`. The former can be seen as just halting evaluation, # while the latter might be used when the return value is of specific concern. # # Supported styles are `return` and `return_nil`. # # @example EnforcedStyle: return (default) #   # bad #   def foo(arg) #   return nil if arg #   end # #   # good #   def foo(arg) #   return if arg #   end # @example EnforcedStyle: return_nil #   # bad #   def foo(arg) #   return if arg #   end # #   # good #   def foo(arg) #   return nil if arg #   end # # source://rubocop//lib/rubocop/cop/style/return_nil.rb#35 class RuboCop::Cop::Style::ReturnNil &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained_send?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_nil_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_style?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scoped_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/return_nil.rb#39 RuboCop::Cop::Style::ReturnNil::RETURN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/return_nil.rb#40 RuboCop::Cop::Style::ReturnNil::RETURN_NIL_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for predicate method definitions that return ‘nil`. # A predicate method should only return a boolean value. # # @example #   # bad #   def foo? #   return if condition # #   do_something? #   end # #   # bad #   def foo? #   return nil if condition # #   do_something? #   end # #   # good #   def foo? #   return false if condition # #   do_something? #   end # #   # bad #   def foo? #   if condition #   nil #   else #   true #   end #   end # #   # good #   def foo? #   if condition #   false #   else #   true #   end #   end # @example AllowedMethods: [’foo?‘] #   # good #   def foo? #   return if condition # #   do_something? #   end # @example AllowedPatterns: [/foo/] #   # good #   def foo? #   return if condition # #   do_something? #   end # # source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#69 class RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_nil?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_if</span>(<span class="ruby-identifier">if_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_implicit_return_values</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_nil</span>(<span class="ruby-identifier">nil_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_return</span>(<span class="ruby-identifier">return_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_node_of_type</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_type?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">offense_node</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/return_nil_in_predicate_method_definition.rb#74 RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Transforms usages of a method call safeguarded by a non ‘nil` # check for the variable whose method is being called to # safe navigation (`&amp;.`). If there is a method chain, all of the methods # in the chain need to be checked for safety, and all of the methods will # need to be changed to use safe navigation. # # The default for `ConvertCodeThatCanStartToReturnNil` is `false`. # When configured to `true`, this will # check for code in the format `!foo.nil? &amp;&amp; foo.bar`. As it is written, # the return of this code is limited to `false` and whatever the return # of the method is. If this is converted to safe navigation, # `foo&amp;.bar` can start returning `nil` as well as what the method # returns. # # The default for `MaxChainLength` is `2`. # We have limited the cop to not register an offense for method chains # that exceed this option’s value. # # NOTE: This cop will recognize offenses but not autocorrect code when the # right hand side (RHS) of the ‘&amp;&amp;` statement is an `||` statement # (eg. `foo &amp;&amp; (foo.bar? || foo.baz?)`). It can be corrected # manually by removing the `foo &amp;&amp;` and adding `&amp;.` to each `foo` on the RHS. # # @example #   # bad #   foo.bar if foo #   foo.bar.baz if foo #   foo.bar(param1, param2) if foo #   foo.bar { |e| e.something } if foo #   foo.bar(param) { |e| e.something } if foo # #   foo.bar if !foo.nil? #   foo.bar unless !foo #   foo.bar unless foo.nil? # #   foo &amp;&amp; foo.bar #   foo &amp;&amp; foo.bar.baz #   foo &amp;&amp; foo.bar(param1, param2) #   foo &amp;&amp; foo.bar { |e| e.something } #   foo &amp;&amp; foo.bar(param) { |e| e.something } # #   foo ? foo.bar : nil #   foo.nil? ? nil : foo.bar #   !foo.nil? ? foo.bar : nil #   !foo ? nil : foo.bar # #   # good #   foo&amp;.bar #   foo&amp;.bar&amp;.baz #   foo&amp;.bar(param1, param2) #   foo&amp;.bar { |e| e.something } #   foo&amp;.bar(param) { |e| e.something } #   foo &amp;&amp; foo.bar.baz.qux # method chain with more than 2 methods #   foo &amp;&amp; foo.nil? # method that `nil` responds to # #   # Method calls that do not use `.` #   foo &amp;&amp; foo &lt; bar #   foo &lt; bar if foo # #   # When checking `foo&amp;.empty?` in a conditional, `foo` being `nil` will actually #   # do the opposite of what the author intends. #   foo &amp;&amp; foo.empty? # #   # This could start returning `nil` as well as the return of the method #   foo.nil? || foo.bar #   !foo || foo.bar # #   # Methods that are used on assignment, arithmetic operation or #   # comparison should not be converted to use safe navigation #   foo.baz = bar if foo #   foo.baz + bar if foo #   foo.bar &gt; 2 if foo # #   foo ? <a href="index">foo</a> : nil    # Ignored `foo&amp;.[](index)` due to unclear readability benefit. #   foo ? <a href="idx">foo</a> = v : nil  # Ignored `foo&amp;.[]=(idx, v)` due to unclear readability benefit. #   foo ? foo * 42 : nil      # Ignored `foo&amp;.*(42)` due to unclear readability benefit. # # source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#93 class RuboCop::Cop::Style::SafeNavigation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">NilMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_inside_begin?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_with_rhs_or?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># if format: (if checked_variable body nil)</span>
<span class="ruby-comment"># unless format: (if checked_variable nil body)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_if_safe_navigation_candidate</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_nil_check?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strip_begin</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary_safe_navigation_candidate</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_safe_nav_to_all_methods_in_chain</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">start_method</span>, <span class="ruby-identifier">method_chain</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_if_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_parts</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#340</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chain_length</span>(<span class="ruby-identifier">method_chain</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_and_clauses</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">concat_nodes</span>(<span class="ruby-identifier">nodes</span>, <span class="ruby-identifier">and_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#261</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dotless_operator_call?</span>(<span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#312</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_common_parts</span>(<span class="ruby-identifier">method_chain</span>, <span class="ruby-identifier">checked_variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_if_body</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#297</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_parts_from_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_matching_receiver_invocation</span>(<span class="ruby-identifier">method_chain</span>, <span class="ruby-identifier">checked_variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_method_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_comments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_call</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#334</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_call_nodes?</span>(<span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#330</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_nodes?</span>(<span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#402</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_chain_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_called?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#369</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negated?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_node?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">lhs_receiver</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">rhs_receiver</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_comment_ranges</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">rhs_receiver</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">removal_ranges</span>, <span class="ruby-value">offense_range:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_method?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_method_used?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_chain</span>, <span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_var_only_in_unless_modifier?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#101 RuboCop::Cop::Style::SafeNavigation::LOGIC_JUMP_KEYWORDS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/safe_navigation.rb#99 RuboCop::Cop::Style::SafeNavigation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces safe navigation chains length to not exceed the configured maximum. # The longer the chain is, the harder it becomes to track what on it could be # returning ‘nil`. # # There is a potential interplay with `Style/SafeNavigation` - if both are enabled # and their settings are “incompatible”, one of the cops will complain about what # the other proposes. # # E.g. if `Style/SafeNavigation` is configured with `MaxChainLength: 2` (default) # and this cop is configured with `Max: 1`, then for `foo.bar.baz if foo` the former # will suggest `foo&amp;.bar&amp;.baz`, which is an offense for the latter. # # @example Max: 2 (default) #   # bad #   user&amp;.address&amp;.zip&amp;.upcase # #   # good #   user&amp;.address&amp;.zip #   user.address.zip if user # # source://rubocop//lib/rubocop/cop/style/safe_navigation_chain_length.rb#26 class RuboCop::Cop::Style::SafeNavigationChainLength &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation_chain_length.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation_chain_length.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/safe_navigation_chain_length.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_navigation_chains</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/safe_navigation_chain_length.rb#27 RuboCop::Cop::Style::SafeNavigationChainLength::MSG = T.let(T.unsafe(nil), String)</p>

<p># Identifies usages of ‘shuffle.first`, # `shuffle.last`, and `shuffle[]` and change them to use # `sample` instead. # # @example #   # bad #   [1, 2, 3].shuffle.first #   [1, 2, 3].shuffle.first(2) #   [1, 2, 3].shuffle.last #   [2, 1, 3].shuffle.at(0) #   [2, 1, 3].shuffle.slice(0) #   [1, 2, <a href="2">3].shuffle</a> #   [1, 2, 3].shuffle[0, 2]    # sample(2) will do the same #   [1, 2, <a href="0..2">3].shuffle</a>    # sample(3) will do the same #   [1, 2, 3].shuffle(random: Random.new).first # #   # good #   [1, 2, 3].shuffle #   [1, 2, 3].sample #   [1, 2, 3].sample(3) #   [1, 2, 3].shuffle[1, 3]    # sample(3) might return a longer Array #   [1, 2, <a href="1..3">3].shuffle</a>    # sample(3) might return a longer Array #   [1, 2, 3].shuffle[foo, bar] #   [1, 2, 3].shuffle(random: Random.new) # # source://rubocop//lib/rubocop/cop/style/sample.rb#30 class RuboCop::Cop::Style::Sample &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample_candidate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>(<span class="ruby-identifier">shuffle_arg</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">method_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_source</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">shuffle_arg</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">method_args</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offensive?</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">method_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_size</span>(<span class="ruby-identifier">range_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample_arg</span>(<span class="ruby-identifier">method</span>, <span class="ruby-identifier">method_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample_size</span>(<span class="ruby-identifier">method_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample_size_for_one_arg</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample_size_for_two_args</span>(<span class="ruby-identifier">first</span>, <span class="ruby-identifier">second</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sample.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>(<span class="ruby-identifier">shuffle_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/sample.rb#33 RuboCop::Cop::Style::Sample::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/sample.rb#34 RuboCop::Cop::Style::Sample::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Looks for places where a subset of an Enumerable (array, # range, set, etc.; see note below) is calculated based on a ‘Regexp` # match, and suggests `grep` or `grep_v` instead. # # NOTE: Hashes do not behave as you may expect with `grep`, which # means that `hash.grep` is not equivalent to `hash.select`. Although # RuboCop is limited by static analysis, this cop attempts to avoid # registering an offense when the receiver is a hash (hash literal, # `Hash.new`, `Hash#[]`, or `to_h`/`to_hash`). # # NOTE: `grep` and `grep_v` were optimized when used without a block # in Ruby 3.0, but may be slower in previous versions. # See <a href="https://bugs.ruby-lang.org/issues/17030">bugs.ruby-lang.org/issues/17030</a> # # @example #   # bad (select, filter, or find_all) #   array.select { |x| x.match? /regexp/ } #   array.select { |x| /regexp/.match?(x) } #   array.select { |x| x =~ /regexp/ } #   array.select { |x| /regexp/ =~ x } # #   # bad (reject) #   array.reject { |x| x.match? /regexp/ } #   array.reject { |x| /regexp/.match?(x) } #   array.reject { |x| x =~ /regexp/ } #   array.reject { |x| /regexp/ =~ x } # #   # good #   array.grep(regexp) #   array.grep_v(regexp) # # source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#45 class RuboCop::Cop::Style::SelectByRegexp &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">calls_lvar?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if a node appears to return a hash</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">creates_hash?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">env_const?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_match?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_send_node</span>(<span class="ruby-identifier">block_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_regexp</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_predicate_without_receiver?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opposite?</span>(<span class="ruby-identifier">regexp_method_send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver_allowed?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">block_node</span>, <span class="ruby-identifier">regexp</span>, <span class="ruby-identifier">replacement</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">regexp_method_send_node</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#49 RuboCop::Cop::Style::SelectByRegexp::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#52 RuboCop::Cop::Style::SelectByRegexp::OPPOSITE_REPLACEMENTS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#55 RuboCop::Cop::Style::SelectByRegexp::REGEXP_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#51 RuboCop::Cop::Style::SelectByRegexp::REPLACEMENTS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/select_by_regexp.rb#50 RuboCop::Cop::Style::SelectByRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces the use the shorthand for self-assignment. # # @example # #   # bad #   x = x + 1 # #   # good #   x += 1 # # source://rubocop//lib/rubocop/cop/style/self_assignment.rb#15 class RuboCop::Cop::Style::SelfAssignment &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">apply_autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">new_rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_boolean_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_send_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">var_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_boolean_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">var_name</span>, <span class="ruby-identifier">var_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_send_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">rhs</span>, <span class="ruby-identifier">var_name</span>, <span class="ruby-identifier">var_type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#21</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#18 RuboCop::Cop::Style::SelfAssignment::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/self_assignment.rb#19 RuboCop::Cop::Style::SelfAssignment::OPS = T.let(T.unsafe(nil), Array)</p>

<p># Checks for multiple expressions placed on the same line. # It also checks for lines terminated with a semicolon. # # This cop has ‘AllowAsExpressionSeparator` configuration option. # It allows `;` to separate several expressions on the same line. # # @example #   # bad #   foo = 1; bar = 2; #   baz = 3; # #   # good #   foo = 1 #   bar = 2 #   baz = 3 # @example AllowAsExpressionSeparator: false (default) #   # bad #   foo = 1; bar = 2 # @example AllowAsExpressionSeparator: true #   # good #   foo = 1; bar = 2 # # source://rubocop//lib/rubocop/cop/style/semicolon.rb#29 class RuboCop::Cop::Style::Semicolon &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_line_terminator_or_opener</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_semicolon</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_semicolon_after_left_curly_brace?</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_semicolon_after_left_lambda_curly_brace?</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_semicolon_after_left_string_interpolation_brace?</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_semicolon_before_right_curly_brace?</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exist_semicolon_before_right_string_interpolation_brace?</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expressions_per_line</span>(<span class="ruby-identifier">exprs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_range_node</span>(<span class="ruby-identifier">token_before_semicolon</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_semicolon_positions</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_semicolon</span>(<span class="ruby-identifier">line</span>, <span class="ruby-identifier">column</span>, <span class="ruby-identifier">after_expression</span>, <span class="ruby-identifier">token_before_semicolon</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semicolon_position</span>(<span class="ruby-identifier">tokens</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens_for_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/semicolon.rb#35</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/semicolon.rb#33 RuboCop::Cop::Style::Semicolon::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of the send method. # # @example #   # bad #   Foo.send(bar) #   quuz.send(fred) # #   # good #   Foo.__send__(bar) #   quuz.public_send(fred) # # source://rubocop//lib/rubocop/cop/style/send.rb#16 class RuboCop::Cop::Style::Send &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/send.rb#17 RuboCop::Cop::Style::Send::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/send.rb#18 RuboCop::Cop::Style::Send::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Detects the use of the ‘public_send` method with a literal method name argument. # Since the `send` method can be used to call private methods, by default, # only the `public_send` method is detected. # # NOTE: Writer methods with names ending in `=` are always permitted because their # behavior differs as follows: # # [source,ruby] # —- # def foo=(foo) #   @foo = foo #   42 # end # # self.foo = 1   # =&gt; 1 # send(:foo=, 1) # =&gt; 42 # —- # # @example #   # bad #   obj.public_send(:method_name) #   obj.public_send(’method_name’) # #   # good #   obj.method_name # @example AllowSend: true (default) #   # good #   obj.send(:method_name) #   obj.send(‘method_name’) #   obj.__send__(:method_name) #   obj.__send__(‘method_name’) # @example AllowSend: false #   # bad #   obj.send(:method_name) #   obj.send(‘method_name’) #   obj.__send__(:method_name) #   obj.__send__(‘method_name’) # #   # good #   obj.method_name # # source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#54 class RuboCop::Cop::Style::SendWithLiteralMethodName &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_send?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">removal_argument_range</span>(<span class="ruby-identifier">first_argument</span>, <span class="ruby-identifier">second_argument</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#60 RuboCop::Cop::Style::SendWithLiteralMethodName::METHOD_NAME_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#57 RuboCop::Cop::Style::SendWithLiteralMethodName::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#61 RuboCop::Cop::Style::SendWithLiteralMethodName::RESERVED_WORDS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#58 RuboCop::Cop::Style::SendWithLiteralMethodName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/send_with_literal_method_name.rb#59 RuboCop::Cop::Style::SendWithLiteralMethodName::STATIC_METHOD_NAME_NODE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of ‘fail` and `raise`. # # @example EnforcedStyle: only_raise (default) #   # The `only_raise` style enforces the sole use of `raise`. #   # bad #   begin #   fail #   rescue Exception #   # handle it #   end # #   def watch_out #   fail #   rescue Exception #   # handle it #   end # #   Kernel.fail # #   # good #   begin #   raise #   rescue Exception #   # handle it #   end # #   def watch_out #   raise #   rescue Exception #   # handle it #   end # #   Kernel.raise # @example EnforcedStyle: only_fail #   # The `only_fail` style enforces the sole use of `fail`. #   # bad #   begin #   raise #   rescue Exception #   # handle it #   end # #   def watch_out #   raise #   rescue Exception #   # handle it #   end # #   Kernel.raise # #   # good #   begin #   fail #   rescue Exception #   # handle it #   end # #   def watch_out #   fail #   rescue Exception #   # handle it #   end # #   Kernel.fail # @example EnforcedStyle: semantic #   # The `semantic` style enforces the use of `fail` to signal an #   # exception, then will use `raise` to trigger an offense after #   # it has been rescued. #   # bad #   begin #   raise #   rescue Exception #   # handle it #   end # #   def watch_out #   # Error thrown #   rescue Exception #   fail #   end # #   Kernel.fail #   Kernel.raise # #   # good #   begin #   fail #   rescue Exception #   # handle it #   end # #   def watch_out #   fail #   rescue Exception #   raise ’Preferably with descriptive message’ #   end # #   explicit_receiver.fail #   explicit_receiver.raise # # source://rubocop//lib/rubocop/cop/style/signal_exception.rb#107 class RuboCop::Cop::Style::SignalException &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">custom_fail_methods</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kernel_call?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_scope</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_send</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command_or_kernel_call?</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">custom_fail_defined?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_command_or_kernel_call</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#111 RuboCop::Cop::Style::SignalException::FAIL_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#112 RuboCop::Cop::Style::SignalException::RAISE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/signal_exception.rb#114 RuboCop::Cop::Style::SignalException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Sometimes using ‘dig` method ends up with just a single # argument. In such cases, dig should be replaced with `[]`. # # Since replacing `hash&amp;.dig(:key)` with `<a href=":key">hash</a>` could potentially lead to error, # calls to the `dig` method using safe navigation will be ignored. # # @example #   # bad #   { key: ’value’ }.dig(:key) #   [1, 2, 3].dig(0) # #   # good #   <a href=":key"> key: ‘value’ </a> #   [1, 2, <a href="0">3]</a> # #   # good #   { key1: { key2: ‘value’ } }.dig(:key1, :key2) #   [1, [2, [3]]].dig(1, 1) # #   # good #   keys = %i[key1 key2] #   { key1: { key2: ‘value’ } }.dig(*keys) # # source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#34 class RuboCop::Cop::Style::SingleArgumentDig &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">DigHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_dig_chain?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#40 RuboCop::Cop::Style::SingleArgumentDig::IGNORED_ARGUMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#38 RuboCop::Cop::Style::SingleArgumentDig::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/single_argument_dig.rb#39 RuboCop::Cop::Style::SingleArgumentDig::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks whether the block parameters of a single-line # method accepting a block match the names specified via configuration. # # For instance one can configure ‘reduce`(`inject`) to use |a, e| as # parameters. # # Configuration option: Methods # Should be set to use this cop. `Array` of hashes, where each key is the # method name and value - array of argument names. # # @example Methods: [{reduce: %w[a b]}] #   # bad #   foo.reduce { |c, d| c + d } #   foo.reduce { |_, _d| 1 } # #   # good #   foo.reduce { |a, b| a + b } #   foo.reduce { |a, _b| a } #   foo.reduce { |a, (id, _)| a + id } #   foo.reduce { true } # #   # good #   foo.reduce do |c, d| #   c + d #   end # # source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#31 class RuboCop::Cop::Style::SingleLineBlockParams &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_match?</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">preferred_block_arguments</span>, <span class="ruby-identifier">joined_block_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_preferred_arguments_map</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">preferred_arguments</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_arguments?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eligible_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">methods</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_args</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/single_line_block_params.rb#34 RuboCop::Cop::Style::SingleLineBlockParams::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for single-line ‘do`…`end` block. # # In practice a single line `do`…`end` is autocorrected when `EnforcedStyle: semantic` # is configured for `Style/BlockDelimiters`. The autocorrection maintains the # `do` … `end` syntax to preserve semantics and does not change it to `{`…`}` block. # # NOTE: If `InspectBlocks` is set to `true` for `Layout/RedundantLineBreak`, blocks will # be autocorrected to be on a single line if possible. This cop respects that configuration # by not registering an offense if it would subsequently cause a # `Layout/RedundantLineBreak` offense. # # @example # #   # bad #   foo do |arg| bar(arg) end # #   # good #   foo do |arg| #   bar(arg) #   end # #   # bad #   -&gt;(arg) do bar(arg) end # #   # good #   -&gt;(arg) { bar(arg) } # # source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#33 class RuboCop::Cop::Style::SingleLineDoEndBlock &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CheckSingleLineSuitability</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_blocks_preferred?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/single_line_do_end_block.rb#37 RuboCop::Cop::Style::SingleLineDoEndBlock::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for single-line method definitions that contain a body. # It will accept single-line methods with no body. # # Endless methods added in Ruby 3.0 are also accepted by this cop. # # If ‘Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line`, `allow_always`, # `require_single_line`, or `require_always`, single-line methods will be autocorrected # to endless methods if there is only one statement in the body. # # @example #   # bad #   def some_method; body end #   def link_to(url); {:name =&gt; url}; end #   def @table.columns; super; end # #   # good #   def self.resource_class=(klass); end #   def @table.columns; end #   def some_method() = body # @example AllowIfMethodIsEmpty: true (default) #   # good #   def no_op; end # @example AllowIfMethodIsEmpty: false #   # bad #   def no_op; end # # source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#34 class RuboCop::Cop::Style::SingleLineMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_line_before</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-value">indent_steps:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_endless</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_endless?</span>(<span class="ruby-identifier">body_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_to_multiline</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disallow_endless_method_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_part</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_body_source</span>(<span class="ruby-identifier">method_body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_comment</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>(<span class="ruby-identifier">method_body</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#38 RuboCop::Cop::Style::SingleLineMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/single_line_methods.rb#39 RuboCop::Cop::Style::SingleLineMethods::NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Checks that arrays are not sliced with the redundant ‘<a href="0..-1">ary</a>`, replacing it with `ary`, # and ensures arrays are sliced with endless ranges instead of `<a href="start..-1">ary</a>` on Ruby 2.6+, # and with beginless ranges instead of `<a href="nil..end">ary</a>` on Ruby 2.7+. # # @example #   # bad #   <a href="0..-1">items</a> #   <a href="0..nil">items</a> #   <a href="0...nil">items</a> # #   # good #   items # #   # bad #   <a href="1..-1">items</a>   # Ruby 2.6+ #   <a href="1..nil">items</a>  # Ruby 2.6+ # #   # good #   <a href="1..">items</a>     # Ruby 2.6+ # #   # bad #   <a href="nil..42">items</a> # Ruby 2.7+ # #   # good #   <a href="..42">items</a>    # Ruby 2.7+ #   <a href="0..42">items</a>   # Ruby 2.7+ # # source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#46 class RuboCop::Cop::Style::SlicingWithRange &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_from_zero?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_from_zero_till_minus_one?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_till_minus_one?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_source</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">beginless</span>(<span class="ruby-identifier">range_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">endless</span>(<span class="ruby-identifier">range_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message_for_partial_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">prefer</span>, <span class="ruby-identifier">offense_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_message_with_removal_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range_node</span>, <span class="ruby-identifier">offense_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unparenthesized_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#52 RuboCop::Cop::Style::SlicingWithRange::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#53 RuboCop::Cop::Style::SlicingWithRange::MSG_USELESS_RANGE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/slicing_with_range.rb#54 RuboCop::Cop::Style::SlicingWithRange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># If the branch of a conditional consists solely of a conditional node, # its conditions can be combined with the conditions of the outer branch. # This helps to keep the nesting level from getting too deep. # # @example #   # bad #   if condition_a #   if condition_b #   do_something #   end #   end # #   # bad #   if condition_b #   do_something #   end if condition_a # #   # good #   if condition_a &amp;&amp; condition_b #   do_something #   end # @example AllowModifier: false (default) #   # bad #   if condition_a #   do_something if condition_b #   end # #   # bad #   if condition_b #   do_something #   end if condition_a # @example AllowModifier: true #   # good #   if condition_a #   do_something if condition_b #   end # #   # good #   if condition_b #   do_something #   end if condition_a # # source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#49 class RuboCop::Cop::Style::SoleNestedConditional &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parentheses_if_needed</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assigned_variables</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_outer_condition_basic</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_outer_condition_modify_form</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chainable_condition</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_for_basic_condition_style</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_for_comment</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_for_guard_condition_style</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_node</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_branch?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesize_method?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized_method_arguments</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_variable_assignment_in_condition?</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">if_branch</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#55</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/sole_nested_conditional.rb#53 RuboCop::Cop::Style::SoleNestedConditional::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for uses of Perl-style global variables. # Correcting to global variables in the ‘English’ library # will add a require statement to the top of the file if # enabled by RequireEnglish config. # # @example EnforcedStyle: use_english_names (default) #   # good #   require ‘English’ # or this could be in another file. # #   puts $LOAD_PATH #   puts $LOADED_FEATURES #   puts $PROGRAM_NAME #   puts $ERROR_INFO #   puts $ERROR_POSITION #   puts $FIELD_SEPARATOR # or $FS #   puts $OUTPUT_FIELD_SEPARATOR # or $OFS #   puts $INPUT_RECORD_SEPARATOR # or $RS #   puts $OUTPUT_RECORD_SEPARATOR # or $ORS #   puts $INPUT_LINE_NUMBER # or $NR #   puts $LAST_READ_LINE #   puts $DEFAULT_OUTPUT #   puts $DEFAULT_INPUT #   puts $PROCESS_ID # or $PID #   puts $CHILD_STATUS #   puts $LAST_MATCH_INFO #   puts $IGNORECASE #   puts $ARGV # or ARGV # @example EnforcedStyle: use_perl_names #   # good #   puts $: #   puts $“ #   puts $0 #   puts $! #   puts $@ #   puts $; #   puts $, #   puts $/ #   puts $\ #   puts $. #   puts $_ #   puts $&gt; #   puts $&lt; #   puts $$ #   puts $? #   puts $~ #   puts $= #   puts $* # @example EnforcedStyle: use_builtin_english_names # #   # good #   # Like ‘use_perl_names` but allows builtin global vars. #   puts $LOAD_PATH #   puts $LOADED_FEATURES #   puts $PROGRAM_NAME #   puts ARGV #   puts $: #   puts $” #   puts $0 #   puts $! #   puts $@ #   puts $; #   puts $, #   puts $/ #   puts $\ #   puts $. #   puts $_ #   puts $&gt; #   puts $&lt; #   puts $$ #   puts $? #   puts $~ #   puts $= #   puts $* # # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#86 class RuboCop::Cop::Style::SpecialGlobalVars &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RequireLibrary</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_require_english?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">english_name_replacement</span>(<span class="ruby-identifier">preferred_name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_english_message</span>(<span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For now, we assume that lists are 2 items or less. Easy grammar!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_list</span>(<span class="ruby-identifier">items</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message</span>(<span class="ruby-identifier">english</span>, <span class="ruby-identifier">regular</span>, <span class="ruby-identifier">global</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matching_styles</span>(<span class="ruby-identifier">global</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preferred_names</span>(<span class="ruby-identifier">global</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_require_english?</span>(<span class="ruby-identifier">global_var</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#127 RuboCop::Cop::Style::SpecialGlobalVars::BUILTIN_VARS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#99 RuboCop::Cop::Style::SpecialGlobalVars::ENGLISH_VARS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#144 RuboCop::Cop::Style::SpecialGlobalVars::LIBRARY_NAME = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#92 RuboCop::Cop::Style::SpecialGlobalVars::MSG_BOTH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#95 RuboCop::Cop::Style::SpecialGlobalVars::MSG_ENGLISH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#97 RuboCop::Cop::Style::SpecialGlobalVars::MSG_REGULAR = T.let(T.unsafe(nil), String)</p>

<p># Anything <strong>not</strong> in this set is provided by the English library. # # source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#121 RuboCop::Cop::Style::SpecialGlobalVars::NON_ENGLISH_VARS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#123 RuboCop::Cop::Style::SpecialGlobalVars::PERL_VARS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/cop/style/special_global_vars.rb#138 RuboCop::Cop::Style::SpecialGlobalVars::STYLE_VARS_MAP = T.let(T.unsafe(nil), Hash)</p>

<p># Check for parentheses around stabby lambda arguments. # There are two different styles. Defaults to ‘require_parentheses`. # # @example EnforcedStyle: require_parentheses (default) #   # bad #   -&gt;a,b,c { a + b + c } # #   # good #   -&gt;(a,b,c) { a + b + c} # @example EnforcedStyle: require_no_parentheses #   # bad #   -&gt;(a,b,c) { a + b + c } # #   # good #   -&gt;a,b,c { a + b + c} # # source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#22 class RuboCop::Cop::Style::StabbyLambdaParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_parentheses_corrector</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stabby_lambda_with_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unwanted_parentheses_corrector</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#27 RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_NO_REQUIRE = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/stabby_lambda_parentheses.rb#26 RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_REQUIRE = T.let(T.unsafe(nil), String)</p>

<p># Checks for places where classes with only class methods can be # replaced with a module. Classes should be used only when it makes sense to create # instances out of them. # # @example #   # bad #   class SomeClass #   def self.some_method #   # body omitted #   end # #   def self.some_other_method #   # body omitted #   end #   end # #   # good #   module SomeModule #   module_function # #   def some_method #   # body omitted #   end # #   def some_other_method #   # body omitted #   end #   end # #   # good - has instance method #   class SomeClass #   def instance_method; end #   def self.class_method; end #   end # # source://rubocop//lib/rubocop/cop/style/static_class.rb#46 class RuboCop::Cop::Style::StaticClass &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VisibilityHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_def</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_sclass</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_convertible_to_module?</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_elements</span>(<span class="ruby-identifier">class_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extend_call?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/static_class.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sclass_convertible_to_module?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/static_class.rb#51 RuboCop::Cop::Style::StaticClass::MSG = T.let(T.unsafe(nil), String)</p>

<p># Identifies places where ‘$stderr.puts` can be replaced by # `warn`. The latter has the advantage of easily being disabled by, # the `-W0` interpreter flag or setting `$VERBOSE` to `nil`. # # @example #   # bad #   $stderr.puts(’hello’) # #   # good #   warn(‘hello’) # # source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#17 class RuboCop::Cop::Style::StderrPuts &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stderr_puts?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stderr_gvar?</span>(<span class="ruby-identifier">sym</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stderr_puts_range</span>(<span class="ruby-identifier">send</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#21 RuboCop::Cop::Style::StderrPuts::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/stderr_puts.rb#22 RuboCop::Cop::Style::StderrPuts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for uses of ‘String#split` with empty string or regexp literal argument. # # @example #   # bad #   string.split(//) #   string.split(”) # #   # good #   string.chars # # source://rubocop//lib/rubocop/cop/style/string_chars.rb#21 class RuboCop::Cop::Style::StringChars &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_chars.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_chars.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/string_chars.rb#27 RuboCop::Cop::Style::StringChars::BAD_ARGUMENTS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/string_chars.rb#25 RuboCop::Cop::Style::StringChars::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/string_chars.rb#26 RuboCop::Cop::Style::StringChars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for places where string concatenation # can be replaced with string interpolation. # # The cop can autocorrect simple cases but will skip autocorrecting # more complex cases where the resulting code would be harder to read. # In those cases, it might be useful to extract statements to local # variables or methods which you can then interpolate in a string. # # NOTE: When concatenation between two strings is broken over multiple # lines, this cop does not register an offense; instead, # ‘Style/LineEndConcatenation` will pick up the offense if enabled. # # Two modes are supported: # 1. `aggressive` style checks and corrects all occurrences of `+` where # either the left or right side of `+` is a string literal. # 2. `conservative` style on the other hand, checks and corrects only if # left side (receiver of `+` method call) is a string literal. # This is useful when the receiver is some expression that returns string like `Pathname` # instead of a string literal. # # @example Mode: aggressive (default) #   # bad #   email_with_name = user.name + ’ &lt;‘ + user.email + ’&gt;‘ #   Pathname.new(’/‘) + ’test’ # #   # good #   email_with_name = “#{user.name} &lt;#{user.email}&gt;” #   email_with_name = format(‘%s &lt;%s&gt;’, user.name, user.email) #   “#{Pathname.new(‘/’)}test” # #   # accepted, line-end concatenation #   name = ‘First’ + #   ‘Last’ # @example Mode: conservative #   # bad #   ‘Hello’ + user.name # #   # good #   “Hello #{user.name}” #   user.name + ‘!!’ #   Pathname.new(‘/’) + ‘test’ # # source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#53 class RuboCop::Cop::Style::StringConcatenation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_concatenation?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_parts</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">parts</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_ancestor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_topmost_plus_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_quotes</span>(<span class="ruby-identifier">parts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_end_concatenation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">plus_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">topmost_plus_node</span>, <span class="ruby-identifier">parts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">parts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#168</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_quoted?</span>(<span class="ruby-identifier">str_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uncorrectable?</span>(<span class="ruby-identifier">part</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#56 RuboCop::Cop::Style::StringConcatenation::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/string_concatenation.rb#57 RuboCop::Cop::Style::StringConcatenation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for the use of strings as keys in hashes. The use of # symbols is preferred instead. # # @example #   # bad #   { ‘one’ =&gt; 1, ‘two’ =&gt; 2, ‘three’ =&gt; 3 } # #   # good #   { one: 1, two: 2, three: 3 } # # source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#19 class RuboCop::Cop::Style::StringHashKeys &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receive_environments_method?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_hash_key?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/string_hash_keys.rb#22 RuboCop::Cop::Style::StringHashKeys::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks if uses of quotes match the configured preference. # # @example EnforcedStyle: single_quotes (default) #   # bad #   “No special symbols” #   “No string interpolation” #   “Just text” # #   # good #   ‘No special symbols’ #   ‘No string interpolation’ #   ‘Just text’ #   “Wait! What’s #{this}!” # @example EnforcedStyle: double_quotes #   # bad #   ‘Just some text’ #   ‘No special chars or interpolation’ # #   # good #   “Just some text” #   “No special chars or interpolation” #   “Every string in #{project} uses double_quotes” # # source://rubocop//lib/rubocop/cop/style/string_literals.rb#29 class RuboCop::Cop::Style::StringLiterals &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept_child_double_quotes?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_string_literals?</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_multiline_quote_style</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">quote</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">consistent_multiline?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect_quote_styles</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">message:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unexpected_double_quotes?</span>(<span class="ruby-identifier">quote</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unexpected_single_quotes?</span>(<span class="ruby-identifier">quote</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/string_literals.rb#35 RuboCop::Cop::Style::StringLiterals::MSG_INCONSISTENT = T.let(T.unsafe(nil), String)</p>

<p># Checks that quotes inside string, symbol, and regexp interpolations # match the configured preference. # # @example EnforcedStyle: single_quotes (default) #   # bad #   string = “Tests #{success ? ”PASS“ : ”FAIL“}” #   symbol = :“Tests #{success ? ”PASS“ : ”FAIL“}” #   heredoc = &lt;&lt;~TEXT #   Tests #{success ? “PASS” : “FAIL”} #   TEXT #   regexp = /Tests #{success ? “PASS” : “FAIL”}/ # #   # good #   string = “Tests #{success ? ‘PASS’ : ‘FAIL’}” #   symbol = :“Tests #{success ? ‘PASS’ : ‘FAIL’}” #   heredoc = &lt;&lt;~TEXT #   Tests #{success ? ‘PASS’ : ‘FAIL’} #   TEXT #   regexp = /Tests #{success ? ‘PASS’ : ‘FAIL’}/ # @example EnforcedStyle: double_quotes #   # bad #   string = “Tests #{success ? ‘PASS’ : ‘FAIL’}” #   symbol = :“Tests #{success ? ‘PASS’ : ‘FAIL’}” #   heredoc = &lt;&lt;~TEXT #   Tests #{success ? ‘PASS’ : ‘FAIL’} #   TEXT #   regexp = /Tests #{success ? ‘PASS’ : ‘FAIL’}/ # #   # good #   string = “Tests #{success ? ”PASS“ : ”FAIL“}” #   symbol = :“Tests #{success ? ”PASS“ : ”FAIL“}” #   heredoc = &lt;&lt;~TEXT #   Tests #{success ? “PASS” : “FAIL”} #   TEXT #   regexp = /Tests #{success ? “PASS” : “FAIL”}/ # # source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#42 class RuboCop::Cop::Style::StringLiteralsInInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringLiteralsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StringHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Cop classes that include the StringHelp module usually ignore regexp</span>
<span class="ruby-comment"># nodes. Not so for this cop, which is why we override the on_regexp</span>
<span class="ruby-comment"># definition with an empty one.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_literals_in_interpolation.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Enforces the use of consistent method names # from the ‘String` class. # # @example #   # bad #   ’name’.intern #   ‘var’.unfavored_method # #   # good #   ‘name’.to_sym #   ‘var’.preferred_method # # source://rubocop//lib/rubocop/cop/style/string_methods.rb#17 class RuboCop::Cop::Style::StringMethods &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodPreference</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_methods.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/string_methods.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/string_methods.rb#21 RuboCop::Cop::Style::StringMethods::MSG = T.let(T.unsafe(nil), String)</p>

<p># Identifies places where ‘lstrip.rstrip` can be replaced by # `strip`. # # @example #   # bad #   ’abc’.lstrip.rstrip #   ‘abc’.rstrip.lstrip # #   # good #   ‘abc’.strip # # source://rubocop//lib/rubocop/cop/style/strip.rb#16 class RuboCop::Cop::Style::Strip &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/strip.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lstrip_rstrip</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/strip.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/strip.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/strip.rb#20 RuboCop::Cop::Style::Strip::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/strip.rb#21 RuboCop::Cop::Style::Strip::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for inheritance from ‘Struct.new`. Inheriting from `Struct.new` # adds a superfluous level in inheritance tree. # # @example #   # bad #   class Person &lt; Struct.new(:first_name, :last_name) #   def age #   42 #   end #   end # #   Person.ancestors #   # =&gt; [Person, #<Class:0x000000010b4e14a0&gt;, Struct, (…)] # #   # good #   Person = Struct.new(:first_name, :last_name) do #   def age #   42 #   end #   end # #   Person.ancestors #   # =&gt; [Person, Struct, (…)] # # source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#33 class RuboCop::Cop::Style::StructInheritance &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">struct_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_parent</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_empty_class_body</span>(<span class="ruby-identifier">class_node</span>, <span class="ruby-identifier">struct_new</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/struct_inheritance.rb#37 RuboCop::Cop::Style::StructInheritance::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for redundant argument forwarding when calling super with arguments identical to # the method definition. # # Using zero arity ‘super` within a `define_method` block results in `RuntimeError`: # # [source,ruby] # —- # def m #   define_method(:foo) { super() } # =&gt; OK # end # # def m #   define_method(:foo) { super }   # =&gt; RuntimeError # end # —- # # Furthermore, any arguments accompanied by a block may potentially be delegating to # `define_method`, therefore, `super` used within these blocks will be allowed. # This approach might result in false negatives, yet ensuring safe detection takes precedence. # # NOTE: When forwarding the same arguments but replacing the block argument with a new inline # block, it is not necessary to explicitly list the non-block arguments. As such, an offense # will be registered in this case. # # @example #   # bad #   def method(*args, **kwargs) #   super(*args, **kwargs) #   end # #   # good - implicitly passing all arguments #   def method(*args, **kwargs) #   super #   end # #   # good - forwarding a subset of the arguments #   def method(*args, **kwargs) #   super(*args) #   end # #   # good - forwarding no arguments #   def method(*args, **kwargs) #   super() #   end # #   # bad - forwarding with overridden block #   def method(*args, **kwargs, &amp;block) #   super(*args, **kwargs) { do_something } #   end # #   # good - implicitly passing all non-block arguments #   def method(*args, **kwargs, &amp;block) #   super { do_something } #   end # #   # good - assigning to the block variable before calling super #   def method(&amp;block) #   # Assigning to the block variable would pass the old value to super, #   # under this circumstance the block must be referenced explicitly. #   block ||= proc { ’fallback behavior’ } #   super(&amp;block) #   end # # source://rubocop//lib/rubocop/cop/style/super_arguments.rb#68 class RuboCop::Cop::Style::SuperArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">super_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_list_size_differs?</span>(<span class="ruby-identifier">def_args</span>, <span class="ruby-identifier">super_args</span>, <span class="ruby-identifier">super_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments_identical?</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">super_node</span>, <span class="ruby-identifier">def_args</span>, <span class="ruby-identifier">super_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_arg_same?</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">super_node</span>, <span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Reassigning the block argument will still pass along the original block to super</span>
<span class="ruby-comment"># https://bugs.ruby-lang.org/issues/20505</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_reassigned?</span>(<span class="ruby-identifier">def_node</span>, <span class="ruby-identifier">block_arg_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_sends_to_super?</span>(<span class="ruby-identifier">super_node</span>, <span class="ruby-identifier">parent_node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_def_node</span>(<span class="ruby-identifier">super_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward_arg_same?</span>(<span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_arg_same?</span>(<span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#170</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_rest_arg_same?</span>(<span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">positional_arg_same?</span>(<span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">positional_rest_arg_same</span>(<span class="ruby-identifier">def_arg</span>, <span class="ruby-identifier">super_arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preprocess_super_args</span>(<span class="ruby-identifier">super_args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#71 RuboCop::Cop::Style::SuperArguments::ASSIGN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#73 RuboCop::Cop::Style::SuperArguments::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/super_arguments.rb#74 RuboCop::Cop::Style::SuperArguments::MSG_INLINE_BLOCK = T.let(T.unsafe(nil), String)</p>

<p># Enforces the presence of parentheses in ‘super` containing arguments. # # `super` is a keyword and is provided as a distinct cop from those designed for method call. # # @example # #   # bad #   super name, age # #   # good #   super(name, age) # # source://rubocop//lib/rubocop/cop/style/super_with_args_parentheses.rb#18 class RuboCop::Cop::Style::SuperWithArgsParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/super_with_args_parentheses.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/super_with_args_parentheses.rb#21 RuboCop::Cop::Style::SuperWithArgsParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># Enforces the use of shorthand-style swapping of 2 variables. # # @example #   # bad #   tmp = x #   x = y #   y = tmp # #   # good #   x, y = y, x # # source://rubocop//lib/rubocop/cop/style/swap_values.rb#21 class RuboCop::Cop::Style::SwapValues &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction_range</span>(<span class="ruby-identifier">tmp_assign</span>, <span class="ruby-identifier">y_assign</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">x_assign</span>, <span class="ruby-identifier">y_assign</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">x_assign</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">simple_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/swap_values.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swapping_values?</span>(<span class="ruby-identifier">tmp_assign</span>, <span class="ruby-identifier">x_assign</span>, <span class="ruby-identifier">y_assign</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/swap_values.rb#25 RuboCop::Cop::Style::SwapValues::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/swap_values.rb#28 RuboCop::Cop::Style::SwapValues::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Set)</p>

<p># Checks for array literals made up of symbols that are not # using the %i() syntax. # # Alternatively, it checks for symbol arrays using the %i() syntax on # projects which do not want to use that syntax, perhaps because they # support a version of Ruby lower than 2.0. # # Configuration option: MinSize # If set, arrays with fewer elements than this value will not trigger the # cop. For example, a ‘MinSize` of `3` will not enforce a style on an # array of 2 or fewer elements. # # @example EnforcedStyle: percent (default) #   # good #   %i[foo bar baz] # #   # bad #   [:foo, :bar, :baz] # #   # bad (contains spaces) #   %i[foo\ bar baz\ quux] # #   # bad (contains [] with spaces) #   %i[foo [ ]] # #   # bad (contains () with spaces) #   %i(foo ( )) # @example EnforcedStyle: brackets #   # good #   [:foo, :bar, :baz] # #   # bad #   %i[foo bar baz] # # source://rubocop//lib/rubocop/cop/style/symbol_array.rb#40 class RuboCop::Cop::Style::SymbolArray &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ArrayMinSize</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ArraySyntax</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentArray</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_bracketed_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_content?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_percent_array_contents?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">symbol_without_quote?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_symbol_literal</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute largest_brackets.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_brackets</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute largest_brackets</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute largest_brackets to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#63</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_brackets=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#51 RuboCop::Cop::Style::SymbolArray::ARRAY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#52 RuboCop::Cop::Style::SymbolArray::DELIMITERS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#50 RuboCop::Cop::Style::SymbolArray::PERCENT_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#57 RuboCop::Cop::Style::SymbolArray::REDEFINABLE_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_array.rb#53 RuboCop::Cop::Style::SymbolArray::SPECIAL_GVARS = T.let(T.unsafe(nil), Array)</p>

<p># Checks symbol literal syntax. # # @example # #   # bad #   :“symbol” # #   # good #   :symbol # # source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#15 class RuboCop::Cop::Style::SymbolLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_literal.rb#18 RuboCop::Cop::Style::SymbolLiteral::MSG = T.let(T.unsafe(nil), String)</p>

<p># Use symbols as procs when possible. # # If you prefer a style that allows block for method with arguments, # please set ‘true` to `AllowMethodsWithArguments`. # `define_method?` methods are allowed by default. # These are customizable with `AllowedMethods` option. # # @example AllCops:ActiveSupportExtensionsEnabled: true #   # good #   -&gt;(x) { x.foo } #   proc { |x| x.foo } #   Proc.new { |x| x.foo } # @example AllowMethodsWithArguments: false (default) #   # bad #   something.do_something(foo) { |o| o.bar } # #   # good #   something.do_something(foo, &amp;:bar) # @example AllowMethodsWithArguments: true #   # good #   something.do_something(foo) { |o| o.bar } # @example AllowComments: false (default) #   # bad #   something.do_something do |s| # some comment #   # some comment #   s.upcase # some comment #   # some comment #   end # @example AllowComments: true #   # good  - if there are comment in either position #   something.do_something do |s| # some comment #   # some comment #   s.upcase # some comment #   # some comment #   end # @example AllowedMethods: [define_method] (default) #   # good #   define_method(:foo) { |foo| foo.bar } # @example AllowedPatterns: [] (default) #   # bad #   something.map { |s| s.upcase } # @example AllowedPatterns: [’map’] (default) #   # good #   something.map { |s| s.upcase } # @example AllCops:ActiveSupportExtensionsEnabled: false (default) #   # bad #   -&gt;(x) { x.foo } #   proc { |x| x.foo } #   Proc.new { |x| x.foo } # #   # good #   lambda(&amp;:foo) #   proc(&amp;:foo) #   Proc.new(&amp;:foo) # @example #   # bad #   something.map { |s| s.upcase } #   something.map { _1.upcase } # #   # good #   something.map(&amp;:upcase) # # source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#140 class RuboCop::Cop::Style::SymbolProc &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">CommentsHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedPattern</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">destructuring_block_argument?</span>(<span class="ruby-identifier">argument_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proc_node?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">symbol_proc?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">symbol_proc_receiver?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_comments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_if_method_has_argument?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_lambda_block</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_with_args</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_without_args</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos_for_replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_range_with_space</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">register_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">block_method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_array_usage?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># See: https://github.com/rubocop/rubocop/issues/10864</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_hash_usage?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#166</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#149 RuboCop::Cop::Style::SymbolProc::LAMBDA_OR_PROC = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#147 RuboCop::Cop::Style::SymbolProc::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/symbol_proc.rb#148 RuboCop::Cop::Style::SymbolProc::SUPER_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Corrector to correct conditional assignment in ternary conditions. # # source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#511 class RuboCop::Cop::Style::TernaryCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalAssignmentHelper</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Style</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalCorrectorHelper</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#516</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#520</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_assignment_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#534</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correction</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#547</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">element_assignment?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#551</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_branches</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#564</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move_branch_inside_condition</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">branch</span>, <span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#559</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_parentheses</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/conditional_assignment.rb#538</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for the presence of parentheses around ternary # conditions. It is configurable to enforce inclusion or omission of # parentheses using ‘EnforcedStyle`. Omission is only enforced when # removing the parentheses won’t cause a different behavior. # # ‘AllowSafeAssignment` option for safe assignment. # By safe assignment we mean putting parentheses around # an assignment to indicate “I know I’m using an assignment # as a condition. It’s not a mistake.” # # @example EnforcedStyle: require_no_parentheses (default) #   # bad #   foo = (bar?) ? a : b #   foo = (bar.baz?) ? a : b #   foo = (bar &amp;&amp; baz) ? a : b # #   # good #   foo = bar? ? a : b #   foo = bar.baz? ? a : b #   foo = bar &amp;&amp; baz ? a : b # @example EnforcedStyle: require_parentheses #   # bad #   foo = bar? ? a : b #   foo = bar.baz? ? a : b #   foo = bar &amp;&amp; baz ? a : b # #   # good #   foo = (bar?) ? a : b #   foo = (bar.baz?) ? a : b #   foo = (bar &amp;&amp; baz) ? a : b # @example EnforcedStyle: require_parentheses_when_complex #   # bad #   foo = (bar?) ? a : b #   foo = (bar.baz?) ? a : b #   foo = bar &amp;&amp; baz ? a : b # #   # good #   foo = bar? ? a : b #   foo = bar.baz? ? a : b #   foo = (bar &amp;&amp; baz) ? a : b # @example AllowSafeAssignment: true (default) #   # good #   foo = (bar = baz) ? a : b # @example AllowSafeAssignment: false #   # bad #   foo = (bar = baz) ? a : b # # source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#57 class RuboCop::Cop::Style::TernaryParentheses &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SafeAssignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">below_ternary_precedence?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If the condition is parenthesized we recurse and check for any</span>
<span class="ruby-comment"># complex expressions within it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_condition?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition_as_parenthesized_one_line_pattern_matching?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_parenthesized</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_unparenthesized</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#227</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_args_need_parens?</span>(<span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_with_args?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Anything that is not a variable, constant, or method/.method call</span>
<span class="ruby-comment"># will be counted as a complex expression.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_complex_expression?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_complex_send?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_closing_parenthesis_is_last_line?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesize_condition_arguments</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">send_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_parentheses_when_complex?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unparenthesized_method_call?</span>(<span class="ruby-identifier">child</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unsafe_autocorrect?</span>(<span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">whitespace_after?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#66 RuboCop::Cop::Style::TernaryParentheses::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#67 RuboCop::Cop::Style::TernaryParentheses::MSG_COMPLEX = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#64 RuboCop::Cop::Style::TernaryParentheses::NON_COMPLEX_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/ternary_parentheses.rb#63 RuboCop::Cop::Style::TernaryParentheses::VARIABLE_TYPES = T.let(T.unsafe(nil), Set)</p>

<p># Newcomers to ruby applications may write top-level methods, # when ideally they should be organized in appropriate classes or modules. # This cop looks for definitions of top-level methods and warns about them. # # However for ruby scripts it is perfectly fine to use top-level methods. # Hence this cop is disabled by default. # # @example #   # bad #   def some_method #   end # #   # bad #   def self.some_method #   end # #   # bad #   define_method(:foo) { puts 1 } # #   # good #   module Foo #   def some_method #   end #   end # #   # good #   class Foo #   def self.some_method #   end #   end # #   # good #   Struct.new do #   def some_method #   end #   end # #   # good #   class Foo #   define_method(:foo) { puts 1 } #   end # # source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#47 class RuboCop::Cop::Style::TopLevelMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_method_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">top_level_method_definition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#48 RuboCop::Cop::Style::TopLevelMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/top_level_method_definition.rb#50 RuboCop::Cop::Style::TopLevelMethodDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for trailing code after the class definition. # # @example #   # bad #   class Foo; def foo; end #   end # #   # good #   class Foo #   def foo; end #   end # # source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#18 class RuboCop::Cop::Style::TrailingBodyOnClass &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_body_on_class.rb#23 RuboCop::Cop::Style::TrailingBodyOnClass::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing code after the method definition. # # NOTE: It always accepts endless method definitions that are basically on the same line. # # @example #   # bad #   def some_method; do_stuff #   end # #   def f(x); b = foo #   b[c: x] #   end # #   # good #   def some_method #   do_stuff #   end # #   def f(x) #   b = foo #   b[c: x] #   end # #   def endless_method = do_stuff # # source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#31 class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_body_on_method_definition.rb#36 RuboCop::Cop::Style::TrailingBodyOnMethodDefinition::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing code after the module definition. # # @example #   # bad #   module Foo extend self #   end # #   # good #   module Foo #   extend self #   end # # source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#18 class RuboCop::Cop::Style::TrailingBodyOnModule &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingBody</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_body_on_module.rb#23 RuboCop::Cop::Style::TrailingBodyOnModule::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing comma in argument lists. # The supported styles are: # # * ‘consistent_comma`: Requires a comma after the last argument, # for all parenthesized multi-line method calls with arguments. # * `comma`: Requires a comma after the last argument, but only for # parenthesized method calls where each argument is on its own line. # * `no_comma`: Requires that there is no comma after the last # argument. # # Regardless of style, trailing commas are not allowed in # single-line method calls. # # @example EnforcedStyleForMultiline: consistent_comma #   # bad #   method(1, 2,) # #   # good #   method(1, 2) # #   # good #   method( #   1, 2, #   3, #   ) # #   # good #   method( #   1, 2, 3, #   ) # #   # good #   method( #   1, #   2, #   ) # @example EnforcedStyleForMultiline: comma #   # bad #   method(1, 2,) # #   # good #   method(1, 2) # #   # bad #   method( #   1, 2, #   3, #   ) # #   # good #   method( #   1, 2, #   3 #   ) # #   # bad #   method( #   1, 2, 3, #   ) # #   # good #   method( #   1, 2, 3 #   ) # #   # good #   method( #   1, #   2, #   ) # @example EnforcedStyleForMultiline: no_comma (default) #   # bad #   method(1, 2,) # #   # bad #   object[1, 2,] # #   # good #   method(1, 2) # #   # good #   object[1, 2] # #   # good #   method( #   1, #   2 #   ) # # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#96 class RuboCop::Cop::Style::TrailingCommaInArguments &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingComma</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_arguments.rb#100</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_incompatible_with</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for trailing comma in array literals. # The configuration options are: # # * ‘consistent_comma`: Requires a comma after the last item of all non-empty, multiline array # literals. # * `comma`: Requires a comma after the last item in an array, but only when each item is on # its own line. # * `diff_comma`: Requires a comma after the last item in an array, but only when that item is # followed by an immediate newline, even if there is an inline comment on the same line. # * `no_comma`: Does not require a comma after the last item in an array # # @example EnforcedStyleForMultiline: consistent_comma #   # bad #   a = [1, 2,] # #   # good #   a = [1, 2] # #   # good #   a = [ #   1, 2, #   3, #   ] # #   # good #   a = [ #   1, 2, 3, #   ] # #   # good #   a = [ #   1, #   2, #   ] # #   # bad #   a = [1, 2, #   3, 4] # #   # good #   a = [1, 2, #   3, 4,] # @example EnforcedStyleForMultiline: comma #   # bad #   a = [1, 2,] # #   # good #   a = [1, 2] # #   # bad #   a = [ #   1, 2, #   3, #   ] # #   # good #   a = [ #   1, 2, #   3 #   ] # #   # bad #   a = [ #   1, 2, 3, #   ] # #   # good #   a = [ #   1, 2, 3 #   ] # #   # good #   a = [ #   1, #   2, #   ] # @example EnforcedStyleForMultiline: diff_comma #   # bad #   a = [1, 2,] # #   # good #   a = [1, 2] # #   # good #   a = [ #   1, 2, #   3, #   ] # #   # good #   a = [ #   1, 2, 3, #   ] # #   # good #   a = [ #   1, #   2, #   ] # #   # bad #   a = [1, 2, #   3, 4,] # #   # good #   a = [1, 2, #   3, 4] # @example EnforcedStyleForMultiline: no_comma (default) #   # bad #   a = [1, 2,] # #   # good #   a = [ #   1, #   2 #   ] # # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#125 class RuboCop::Cop::Style::TrailingCommaInArrayLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingComma</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_array_literal.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks whether trailing commas in block arguments are # required. Blocks with only one argument and a trailing comma require # that comma to be present. Blocks with more than one argument never # require a trailing comma. # # @example #   # bad #   add { |foo, bar,| foo + bar } # #   # good #   add { |foo, bar| foo + bar } # #   # good #   add { |foo,| foo } # #   # good #   add { foo } # #   # bad #   add do |foo, bar,| #   foo + bar #   end # #   # good #   add do |foo, bar| #   foo + bar #   end # #   # good #   add do |foo,| #   foo #   end # #   # good #   add do #   foo + bar #   end # # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#62 class RuboCop::Cop::Style::TrailingCommaInBlockArgs &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_count</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_tokens</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_comma</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_comma?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">useless_trailing_comma?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_block_args.rb#65 RuboCop::Cop::Style::TrailingCommaInBlockArgs::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for trailing comma in hash literals. # The configuration options are: # # * ‘consistent_comma`: Requires a comma after the last item of all non-empty, multiline hash # literals. # * `comma`: Requires a comma after the last item in a hash, but only when each item is on its # own line. # * `diff_comma`: Requires a comma after the last item in a hash, but only when that item is # followed by an immediate newline, even if there is an inline comment on the same line. # * `no_comma`: Does not require a comma after the last item in a hash # # @example EnforcedStyleForMultiline: consistent_comma # #   # bad #   a = { foo: 1, bar: 2, } # #   # good #   a = { foo: 1, bar: 2 } # #   # good #   a = { #   foo: 1, bar: 2, #   qux: 3, #   } # #   # good #   a = { #   foo: 1, bar: 2, qux: 3, #   } # #   # good #   a = { #   foo: 1, #   bar: 2, #   } # #   # bad #   a = { foo: 1, bar: 2, #   baz: 3, qux: 4 } # #   # good #   a = { foo: 1, bar: 2, #   baz: 3, qux: 4, } # @example EnforcedStyleForMultiline: comma # #   # bad #   a = { foo: 1, bar: 2, } # #   # good #   a = { foo: 1, bar: 2 } # #   # bad #   a = { #   foo: 1, bar: 2, #   qux: 3, #   } # #   # good #   a = { #   foo: 1, bar: 2, #   qux: 3 #   } # #   # bad #   a = { #   foo: 1, bar: 2, qux: 3, #   } # #   # good #   a = { #   foo: 1, bar: 2, qux: 3 #   } # #   # good #   a = { #   foo: 1, #   bar: 2, #   } # @example EnforcedStyleForMultiline: diff_comma # #   # bad #   a = { foo: 1, bar: 2, } # #   # good #   a = { foo: 1, bar: 2 } # #   # good #   a = { #   foo: 1, bar: 2, #   qux: 3, #   } # #   # good #   a = { #   foo: 1, bar: 2, qux: 3, #   } # #   # good #   a = { #   foo: 1, #   bar: 2, #   } # #   # bad #   a = { foo: 1, bar: 2, #   baz: 3, qux: 4, } # #   # good #   a = { foo: 1, bar: 2, #   baz: 3, qux: 4 } # @example EnforcedStyleForMultiline: no_comma (default) # #   # bad #   a = { foo: 1, bar: 2, } # #   # good #   a = { #   foo: 1, #   bar: 2 #   } # # source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#129 class RuboCop::Cop::Style::TrailingCommaInHashLiteral &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TrailingComma</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_comma_in_hash_literal.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Checks for trailing code after the method definition. # # @example #   # bad #   def some_method #   do_stuff; end # #   def do_this(x) #   baz.map { |b| b.this(x) } end # #   def foo #   block do #   bar #   end end # #   # good #   def some_method #   do_stuff #   end # #   def do_this(x) #   baz.map { |b| b.this(x) } #   end # #   def foo #   block do #   bar #   end #   end # # source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#36 class RuboCop::Cop::Style::TrailingMethodEndStatement &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_and_end_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_end?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_method_end_statement.rb#39 RuboCop::Cop::Style::TrailingMethodEndStatement::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for extra underscores in variable assignment. # # @example #   # bad #   a, b, _ = foo() #   a, b, _, = foo() #   a, _, _ = foo() #   a, _, _, = foo() # #   # good #   a, b, = foo() #   a, = foo() #   *a, b, _ = foo() #   # =&gt; We need to know to not include 2 variables in a #   a, *b, _ = foo() #   # =&gt; The correction ‘a, *b, = foo()` is a syntax error # @example AllowNamedUnderscoreVariables: true (default) #   # good #   a, b, _something = foo() # @example AllowNamedUnderscoreVariables: false #   # bad #   a, b, _something = foo() # # source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#31 class RuboCop::Cop::Style::TrailingUnderscoreVariable &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">SurroundingSpace</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_named_underscore_variables</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children_offenses</span>(<span class="ruby-identifier">variables</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_first_offense</span>(<span class="ruby-identifier">variables</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_first_possible_offense</span>(<span class="ruby-identifier">variables</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">main_node_offense</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_for_parentheses</span>(<span class="ruby-identifier">offense</span>, <span class="ruby-identifier">left</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reverse_index</span>(<span class="ruby-identifier">collection</span>, <span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat_variable_before?</span>(<span class="ruby-identifier">first_offense</span>, <span class="ruby-identifier">variables</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unneeded_ranges</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unused_range</span>(<span class="ruby-identifier">node_type</span>, <span class="ruby-identifier">mlhs_node</span>, <span class="ruby-identifier">right</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unused_variables_only?</span>(<span class="ruby-identifier">offense</span>, <span class="ruby-identifier">variables</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#38 RuboCop::Cop::Style::TrailingUnderscoreVariable::DISALLOW = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#36 RuboCop::Cop::Style::TrailingUnderscoreVariable::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/trailing_underscore_variable.rb#37 RuboCop::Cop::Style::TrailingUnderscoreVariable::UNDERSCORE = T.let(T.unsafe(nil), String)</p>

<p># Looks for trivial reader/writer methods, that could # have been created with the attr_* family of functions automatically. # ‘to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`, # `to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, and `to_sym` methods # are allowed by default. These are customizable with `AllowedMethods` option. # # @example AllowedMethods: [’allowed_method’] #   # good #   def allowed_method #   @foo #   end # @example ExactNameMatch: true (default) #   # good #   def name #   @other_name #   end # @example ExactNameMatch: false #   # bad #   def name #   @other_name #   end # @example AllowPredicates: true (default) #   # good #   def foo? #   @foo #   end # @example AllowPredicates: false #   # bad #   def foo? #   @foo #   end # #   # good #   attr_reader :foo # @example AllowDSLWriters: true (default) #   # good #   def on_exception(action) #   @on_exception=action #   end # @example AllowDSLWriters: false #   # bad #   def on_exception(action) #   @on_exception=action #   end # #   # good #   attr_writer :on_exception # @example IgnoreClassMethods: false (default) #   # bad #   def self.foo #   @foo #   end # #   # good #   class &lt;&lt; self #   attr_reader :foo #   end # @example IgnoreClassMethods: true #   # good #   def self.foo #   @foo #   end # @example #   # bad #   def foo #   @foo #   end # #   def bar=(val) #   @bar = val #   end # #   def self.baz #   @baz #   end # #   # good #   attr_reader :foo #   attr_writer :bar # #   class &lt;&lt; self #   attr_reader :baz #   end # # source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#98 class RuboCop::Cop::Style::TrivialAccessors &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AllowedMethods</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">looks_like_trivial_writer?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accessor</span>(<span class="ruby-identifier">kind</span>, <span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_dsl_writers?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_predicates?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#195</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_name?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_method_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_reader?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_writer?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_class</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_instance</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dsl_writer?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exact_name_match?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_class_methods?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_module_or_instance_eval?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">looks_like_trivial_reader?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">names_match?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_method_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">top_level_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trivial_accessor_kind</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trivial_reader?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trivial_writer?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/trivial_accessors.rb#102 RuboCop::Cop::Style::TrivialAccessors::MSG = T.let(T.unsafe(nil), String)</p>

<p># Looks for ‘unless` expressions with `else` clauses. # # @example #   # bad #   unless foo_bar.nil? #   # do something… #   else #   # do a different thing… #   end # #   # good #   if foo_bar.present? #   # do something… #   else #   # do a different thing… #   end # # source://rubocop//lib/rubocop/cop/style/unless_else.rb#22 class RuboCop::Cop::Style::UnlessElse &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_else.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_else.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_between_condition_and_else</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">condition</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_else.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_between_else_and_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/unless_else.rb#26 RuboCop::Cop::Style::UnlessElse::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of logical operators in an ‘unless` condition. # It discourages such code, as the condition becomes more difficult # to read and understand. # # This cop supports two styles: # # - `forbid_mixed_logical_operators` (default) # - `forbid_logical_operators` # # `forbid_mixed_logical_operators` style forbids the use of more than one type # of logical operators. This makes the `unless` condition easier to read # because either all conditions need to be met or any condition need to be met # in order for the expression to be truthy or falsey. # # `forbid_logical_operators` style forbids any use of logical operator. # This makes it even more easy to read the `unless` condition as # there is only one condition in the expression. # # @example EnforcedStyle: forbid_mixed_logical_operators (default) #   # bad #   return unless a || b &amp;&amp; c #   return unless a &amp;&amp; b || c #   return unless a &amp;&amp; b and c #   return unless a || b or c #   return unless a &amp;&amp; b or c #   return unless a || b and c # #   # good #   return unless a &amp;&amp; b &amp;&amp; c #   return unless a || b || c #   return unless a and b and c #   return unless a or b or c #   return unless a? # @example EnforcedStyle: forbid_logical_operators #   # bad #   return unless a || b #   return unless a &amp;&amp; b #   return unless a or b #   return unless a and b # #   # good #   return unless a #   return unless a? # # source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#50 class RuboCop::Cop::Style::UnlessLogicalOperators &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_with_or?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logical_operator?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">or_with_and?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_logical_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_precedence_and?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_precedence_or?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#54 RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/unless_logical_operators.rb#53 RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_MIXED_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)</p>

<p># Checks for accessing the first element of ‘String#unpack` # which can be replaced with the shorter method `unpack1`. # # @example # #   # bad #   ’foo’.unpack(‘h*’).first #   ‘<a href="0">foo’.unpack(‘h*’)</a> #   ‘foo’.unpack(‘h*’).slice(0) #   ‘foo’.unpack(‘h*’).at(0) # #   # good #   ‘foo’.unpack1(‘h*’) # # source://rubocop//lib/rubocop/cop/style/unpack_first.rb#20 class RuboCop::Cop::Style::UnpackFirst &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">TargetRubyVersion</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unpack_and_first_element?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_element_range</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">unpack_call</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#26 RuboCop::Cop::Style::UnpackFirst::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/unpack_first.rb#27 RuboCop::Cop::Style::UnpackFirst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for variable interpolation (like “#@ivar”). # # @example #   # bad #   “His name is #$name” #   /check #$pattern/ #   “Let’s go to the #@store” # #   # good #   “His name is #{$name}” #   /check #{$pattern}/ #   “Let’s go to the #{@store}” # # source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#18 class RuboCop::Cop::Style::VariableInterpolation &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Interpolation</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_node_with_interpolations</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">var_nodes</span>(<span class="ruby-identifier">nodes</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/variable_interpolation.rb#22 RuboCop::Cop::Style::VariableInterpolation::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for ‘when;` uses in `case` expressions. # # @example #   # bad #   case foo #   when 1; ’baz’ #   when 2; ‘bar’ #   end # #   # good #   case foo #   when 1 then ‘baz’ #   when 2 then ‘bar’ #   end # # source://rubocop//lib/rubocop/cop/style/when_then.rb#20 class RuboCop::Cop::Style::WhenThen &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/when_then.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/when_then.rb#23 RuboCop::Cop::Style::WhenThen::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for uses of ‘do` in multi-line `while/until` statements. # # @example # #   # bad #   while x.any? do #   do_something(x.pop) #   end # #   # good #   while x.any? #   do_something(x.pop) #   end # #   # bad #   until x.empty? do #   do_something(x.pop) #   end # #   # good #   until x.empty? #   do_something(x.pop) #   end # # source://rubocop//lib/rubocop/cop/style/while_until_do.rb#29 class RuboCop::Cop::Style::WhileUntilDo &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/while_until_do.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/while_until_do.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/while_until_do.rb#32 RuboCop::Cop::Style::WhileUntilDo::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for while and until statements that would fit on one line # if written as a modifier while/until. The maximum line length is # configured in the ‘Layout/LineLength` cop. # # @example #   # bad #   while x &lt; 10 #   x += 1 #   end # #   # good #   x += 1 while x &lt; 10 # #   # bad #   until x &gt; 10 #   x += 1 #   end # #   # good #   x += 1 until x &gt; 10 # #   # bad #   x += 100 while x &lt; 500 # a long comment that makes code too long if it were a single line # #   # good #   while x &lt; 500 # a long comment that makes code too long if it were a single line #   x += 100 #   end # # source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#34 class RuboCop::Cop::Style::WhileUntilModifier &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">Alignment</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">LineLengthHelp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">StatementModifier</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/while_until_modifier.rb#38 RuboCop::Cop::Style::WhileUntilModifier::MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for array literals made up of word-like # strings, that are not using the %w() syntax. # # Alternatively, it can check for uses of the %w() syntax, in projects # which do not want to include that syntax. # # NOTE: When using the ‘percent` style, %w() arrays containing a space # will be registered as offenses. # # Configuration option: MinSize # If set, arrays with fewer elements than this value will not trigger the # cop. For example, a `MinSize` of `3` will not enforce a style on an # array of 2 or fewer elements. # # @example EnforcedStyle: percent (default) #   # good #   %w[foo bar baz] # #   # bad #   [’foo’, ‘bar’, ‘baz’] # #   # bad (contains spaces) #   %w[foo\ bar baz\ quux] # #   # bad #   [ #   [‘one’, ‘One’], #   [‘two’, ‘Two’] #   ] # #   # good #   [ #   %w[one One], #   %w[two Two] #   ] # #   # good (2d array containing spaces) #   [ #   [‘one’, ‘One’], #   [‘two’, ‘Two’], #   [‘forty two’, ‘Forty Two’] #   ] # @example EnforcedStyle: brackets #   # good #   [‘foo’, ‘bar’, ‘baz’] # #   # bad #   %w[foo bar baz] # #   # good (contains spaces) #   [‘foo bar’, ‘baz quux’] # #   # good #   [ #   [‘one’, ‘One’], #   [‘two’, ‘Two’] #   ] # #   # bad #   [ #   %w[one One], #   %w[two Two] #   ] # # source://rubocop//lib/rubocop/cop/style/word_array.rb#71 class RuboCop::Cop::Style::WordArray &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ArrayMinSize</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ArraySyntax</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">PercentArray</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_bracketed_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_content?</span>(<span class="ruby-identifier">strings</span>, <span class="ruby-value">complex_regex:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_percent_array_contents?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matrix_of_complex_content?</span>(<span class="ruby-identifier">array</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_matrix_of_complex_content?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">word_regex</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute largest_brackets.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_brackets</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute largest_brackets</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute largest_brackets to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/word_array.rb#82</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">largest_brackets=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/word_array.rb#79 RuboCop::Cop::Style::WordArray::ARRAY_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/word_array.rb#78 RuboCop::Cop::Style::WordArray::PERCENT_MSG = T.let(T.unsafe(nil), String)</p>

<p># Checks for the use of ‘YAML.load`, `YAML.safe_load`, and `YAML.parse` with # `File.read` argument. # # NOTE: `YAML.safe_load_file` was introduced in Ruby 3.0. # # @example # #   # bad #   YAML.load(File.read(path)) #   YAML.parse(File.read(path)) # #   # good #   YAML.load_file(path) #   YAML.parse_file(path) # #   # bad #   YAML.safe_load(File.read(path)) # Ruby 3.0 and newer # #   # good #   YAML.safe_load_file(path)       # Ruby 3.0 and newer # # source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#27 class RuboCop::Cop::Style::YAMLFileRead &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yaml_file_read?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#30 RuboCop::Cop::Style::YAMLFileRead::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/yaml_file_read.rb#31 RuboCop::Cop::Style::YAMLFileRead::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Enforces or forbids Yoda conditions, # i.e. comparison operations where the order of expression is reversed. # eg. ‘5 == x` # # @example EnforcedStyle: forbid_for_all_comparison_operators (default) #   # bad #   99 == foo #   “bar” != foo #   42 &gt;= foo #   10 &lt; bar #   99 == CONST # #   # good #   foo == 99 #   foo == “bar” #   foo &lt;= 42 #   bar &gt; 10 #   CONST == 99 #   “#{interpolation}” == foo #   /#{interpolation}/ == foo # @example EnforcedStyle: forbid_for_equality_operators_only #   # bad #   99 == foo #   “bar” != foo # #   # good #   99 &gt;= foo #   3 &lt; a &amp;&amp; a &lt; 5 # @example EnforcedStyle: require_for_all_comparison_operators #   # bad #   foo == 99 #   foo == “bar” #   foo &lt;= 42 #   bar &gt; 10 # #   # good #   99 == foo #   “bar” != foo #   42 &gt;= foo #   10 &lt; bar # @example EnforcedStyle: require_for_equality_operators_only #   # bad #   99 &gt;= foo #   3 &lt; a &amp;&amp; a &lt; 5 # #   # good #   99 == foo #   “bar” != foo # # source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#77 class RuboCop::Cop::Style::YodaCondition &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_constant_equal_program_name?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">actual_code_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_portion?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrected_code</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_yoda?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">equality_only?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_equality_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">noncommutative_operator?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">program_name?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reverse_comparison</span>(<span class="ruby-identifier">operator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_file_path_constant?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_yoda?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yoda_compatible_condition?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#88 RuboCop::Cop::Style::YodaCondition::ENFORCE_YODA_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#91 RuboCop::Cop::Style::YodaCondition::EQUALITY_ONLY_STYLES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#84 RuboCop::Cop::Style::YodaCondition::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#82 RuboCop::Cop::Style::YodaCondition::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#85 RuboCop::Cop::Style::YodaCondition::NONCOMMUTATIVE_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#86 RuboCop::Cop::Style::YodaCondition::PROGRAM_NAMES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#87 RuboCop::Cop::Style::YodaCondition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_condition.rb#83 RuboCop::Cop::Style::YodaCondition::REVERSE_COMPARISON = T.let(T.unsafe(nil), Hash)</p>

<p># Forbids Yoda expressions, i.e. binary operations (using ‘*`, `+`, `&amp;`, `|`, # and `^` operators) where the order of expression is reversed, eg. `1 + x`. # This cop complements `Style/YodaCondition` cop, which has a similar purpose. # # This cop is disabled by default to respect user intentions such as: # # [source,ruby] # —- # config.server_port = 9000 + <a href="&quot;TEST_ENV_NUMBER&quot;">ENV</a>.to_i # —- # # @example SupportedOperators: [’*‘, ’+‘, ’&amp;‘, ’|‘, ’^‘] (default) #   # bad #   10 * y #   1 + x #   1 &amp; z #   1 | x #   1 ^ x #   1 + CONST # #   # good #   y * 10 #   x + 1 #   z &amp; 1 #   x | 1 #   x ^ 1 #   CONST + 1 #   60 * 24 # # source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#40 class RuboCop::Cop::Style::YodaExpression &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constant_portion?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offended_ancestor?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offended_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_operators</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yoda_expression_constant?</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">rhs</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#43 RuboCop::Cop::Style::YodaExpression::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/yoda_expression.rb#45 RuboCop::Cop::Style::YodaExpression::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># Checks for numeric comparisons that can be replaced # by a predicate method, such as ‘receiver.length == 0`, # `receiver.length &gt; 0`, and `receiver.length != 0`, # `receiver.length &lt; 1` and `receiver.size == 0` that can be # replaced by `receiver.empty?` and `!receiver.empty?`. # # NOTE: `File`, `Tempfile`, and `StringIO` do not have `empty?` # so allow `size == 0` and `size.zero?`. # # @example #   # bad #   [1, 2, 3].length == 0 #   0 == “foobar”.length #   array.length &lt; 1 #   {a: 1, b: 2}.length != 0 #   string.length &gt; 0 #   hash.size &gt; 0 # #   # good #   [1, 2, 3].empty? #   “foobar”.empty? #   array.empty? #   !{a: 1, b: 2}.empty? #   !string.empty? #   !hash.empty? # # source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#37 class RuboCop::Cop::Style::ZeroLengthPredicate &lt; ::RuboCop::Cop::Base</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">AutoCorrector</span>

<span class="ruby-comment"># Some collection like objects in the Ruby standard library</span>
<span class="ruby-comment"># implement `#size`, but not `#empty`. We ignore those to</span>
<span class="ruby-comment"># reduce false positives.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_polymorphic_collection?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonzero_length_comparison</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">other_length_node</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zero_length_comparison</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zero_length_node</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zero_length_predicate?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_nonzero_length_comparison</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_zero_length_comparison</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_zero_length_predicate</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replacement</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#41 RuboCop::Cop::Style::ZeroLengthPredicate::NONZERO_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#43 RuboCop::Cop::Style::ZeroLengthPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/cop/style/zero_length_predicate.rb#40 RuboCop::Cop::Style::ZeroLengthPredicate::ZERO_MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for checking and correcting surrounding whitespace. # # source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#6 module RuboCop::Cop::SurroundingSpace</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_brackets?</span>(<span class="ruby-identifier">left_bracket_token</span>, <span class="ruby-identifier">right_bracket_token</span>, <span class="ruby-value">tokens:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">message</span>, <span class="ruby-identifier">command</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">right</span>, <span class="ruby-identifier">message</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_space?</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">side</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_character_between?</span>(<span class="ruby-identifier">left_bracket_token</span>, <span class="ruby-identifier">right_bracket_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_space_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>, <span class="ruby-identifier">message</span>, <span class="ruby-value">start_ok:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">end_ok:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_empty_no_space?</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offending_empty_space?</span>(<span class="ruby-identifier">config</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_new_investigation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reposition</span>(<span class="ruby-identifier">src</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">step</span>, <span class="ruby-value">include_newlines:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">side_space_range</span>(<span class="ruby-value">range:</span>, <span class="ruby-value">side:</span>, <span class="ruby-value">include_newlines:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_between?</span>(<span class="ruby-identifier">left_bracket_token</span>, <span class="ruby-identifier">right_bracket_token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">side</span>, <span class="ruby-identifier">message</span>, <span class="ruby-identifier">command</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">left_token</span>, <span class="ruby-identifier">right_token</span>, <span class="ruby-identifier">message</span>, <span class="ruby-value">start_ok:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">end_ok:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#9 RuboCop::Cop::SurroundingSpace::NO_SPACE_COMMAND = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#12 RuboCop::Cop::SurroundingSpace::SINGLE_SPACE_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/surrounding_space.rb#10 RuboCop::Cop::SurroundingSpace::SPACE_COMMAND = T.let(T.unsafe(nil), String)</p>

<p># Classes that include this module just implement functions for working # with symbol nodes. # # source://rubocop//lib/rubocop/cop/mixin/symbol_help.rb#7 module RuboCop::Cop::SymbolHelp</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/symbol_help.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_key?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for checking target ruby version. # # source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#6 module RuboCop::Cop::TargetRubyVersion</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maximum_target_ruby_version</span>(<span class="ruby-identifier">version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minimum_target_ruby_version</span>(<span class="ruby-identifier">version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_maximum_ruby_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_minimum_ruby_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/target_ruby_version.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_target_ruby_version?</span>(<span class="ruby-identifier">version</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A group of cops, ready to be called on duty to inspect files. # Team is responsible for selecting only relevant cops to be sent on duty, # as well as insuring that the needed forces are sent along with them. # # For performance reasons, Team will first dispatch cops &amp; forces in two groups, # first the ones needed for autocorrection (if any), then the rest # (unless autocorrections happened). # # source://rubocop//lib/rubocop/cop/team.rb#13 class RuboCop::Cop::Team</p>

<pre class="ruby"><span class="ruby-comment"># @return [Team] a new instance of Team</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">cops</span>, <span class="ruby-identifier">config</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cops.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute errors.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">external_dependency_checksum</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forces</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_file</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Commissioner::InvestigationReport]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">original:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute updated_source_file.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">updated_source_file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute updated_source_file.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">updated_source_file?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute warnings.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warnings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">report</span>, <span class="ruby-value">original:</span>, <span class="ruby-value">offset:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_report</span>(<span class="ruby-identifier">report</span>, <span class="ruby-value">offset:</span>, <span class="ruby-value">original:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">be_ready</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collate_corrections</span>(<span class="ruby-identifier">report</span>, <span class="ruby-value">offset:</span>, <span class="ruby-value">original:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_corrector</span>(<span class="ruby-identifier">report</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_error</span>(<span class="ruby-identifier">error</span>, <span class="ruby-identifier">location</span>, <span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_warning</span>(<span class="ruby-identifier">error</span>, <span class="ruby-identifier">location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Commissioner::InvestigationReport]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate_partial</span>(<span class="ruby-identifier">cops</span>, <span class="ruby-identifier">processed_source</span>, <span class="ruby-value">offset:</span>, <span class="ruby-value">original:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_errors</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">errors</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;cop&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">roundup_relevant_cops</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_target_rails_version?</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">support_target_ruby_version?</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">suppress_clobbering</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @return [Array&lt;Force&gt;] needed for the given cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#43</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forces_for</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Team] with cops assembled from the given `cop_classes`</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mobilize</span>(<span class="ruby-identifier">cop_classes</span>, <span class="ruby-identifier">config</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Array&lt;Cop::Base&gt;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mobilize_cops</span>(<span class="ruby-identifier">cop_classes</span>, <span class="ruby-identifier">config</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Team]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/team.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-identifier">cop_or_classes</span>, <span class="ruby-identifier">config</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common methods shared by TrailingBody cops # # source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#6 module RuboCop::Cop::TrailingBody</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_on_first_line?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_part_of</span>(<span class="ruby-identifier">body</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_body.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trailing_body?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common methods shared by Style/TrailingCommaInArguments, # Style/TrailingCommaInArrayLiteral and Style/TrailingCommaInHashLiteral # # source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#8 module RuboCop::Cop::TrailingComma</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">ConfigurableEnforcedStyle</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># A single argument with the closing bracket on the same line as the end</span>
<span class="ruby-comment"># of the argument is not considered multiline, even if the argument</span>
<span class="ruby-comment"># itself might span multiple lines.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_multiline_argument?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_heredoc?</span>(<span class="ruby-identifier">items</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">autocorrect_range</span>(<span class="ruby-identifier">item</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">avoid_comma</span>(<span class="ruby-identifier">kind</span>, <span class="ruby-identifier">comma_begin_pos</span>, <span class="ruby-identifier">extra_info</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the node has round/square/curly brackets.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">brackets?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">items</span>, <span class="ruby-identifier">kind</span>, <span class="ruby-identifier">begin_pos</span>, <span class="ruby-identifier">end_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_comma</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">kind</span>, <span class="ruby-identifier">comma_pos</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_literal</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comma_offset</span>(<span class="ruby-identifier">items</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">elements</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extra_avoid_comma_info</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc_send?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inside_comment?</span>(<span class="ruby-identifier">range</span>, <span class="ruby-identifier">comma_offset</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_item_precedes_newline?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name_and_arguments_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the round/square/curly brackets of the given node are</span>
<span class="ruby-comment"># on different lines, each item within is on its own line, and the</span>
<span class="ruby-comment"># closing bracket is on its own line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_elements_on_same_line?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_end_location</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_same_line?</span>(<span class="ruby-identifier">range1</span>, <span class="ruby-identifier">range2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">put_comma</span>(<span class="ruby-identifier">items</span>, <span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_have_comma?</span>(<span class="ruby-identifier">style</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_parameter_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/trailing_comma.rb#12 RuboCop::Cop::TrailingComma::MSG = T.let(T.unsafe(nil), String)</p>

<p># Common functionality shared by Uncommunicative cops # # source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#6 module RuboCop::Cop::UncommunicativeName</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_nums</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allowed_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_range</span>(<span class="ruby-identifier">arg</span>, <span class="ruby-identifier">length</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_with_num?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbidden_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">issue_offenses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">long_enough?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name_type</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">num_offense</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uppercase?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#7 RuboCop::Cop::UncommunicativeName::CASE_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#10 RuboCop::Cop::UncommunicativeName::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#9 RuboCop::Cop::UncommunicativeName::LENGTH_MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/cop/mixin/uncommunicative_name.rb#8 RuboCop::Cop::UncommunicativeName::NUM_MSG = T.let(T.unsafe(nil), String)</p>

<p># This autocorrects unused arguments. # # source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#6 class RuboCop::Cop::UnusedArgCorrector</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">RangeHelp</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correct_for_blockarg_type</span>(<span class="ruby-identifier">corrector</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute processed_source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/correctors/unused_arg_corrector.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processed_source</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module contains a collection of useful utility methods. # # source://rubocop//lib/rubocop/cop/util.rb#7 module RuboCop::Cop::Util</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parentheses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_descendant?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begins_its_line?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is a bad API</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_line?</span>(<span class="ruby-identifier">line_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compatible_external_encoding_for?</span>(<span class="ruby-identifier">src</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># If converting a string to Ruby string literal source code, must</span>
<span class="ruby-comment"># double quotes be used?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_quotes_required?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape_string</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns, for example, a bare `if` node if the given node is an `if`</span>
<span class="ruby-comment"># with calls chained to the end of it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_part_of_call_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_or_equal?</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">target</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_string_escapes</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>(<span class="ruby-identifier">node_or_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needs_escaping?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_node</span>(<span class="ruby-identifier">syms</span>, <span class="ruby-identifier">sexp</span>, <span class="ruby-identifier">excludes</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_regexp</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_string_literal</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_supported_styles</span>(<span class="ruby-identifier">enforced_style</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trim_string_interpolation_escape_character</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#39</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_parentheses</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">corrector</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#60</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_descendant?</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#75</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#87</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#108</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begins_its_line?</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># This is a bad API</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_line?</span>(<span class="ruby-identifier">line_source</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @deprecated Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_lines?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># If converting a string to Ruby string literal source code, must</span>
  <span class="ruby-comment"># double quotes be used?</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#134</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_quotes_required?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#148</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape_string</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns, for example, a bare `if` node if the given node is an `if`</span>
  <span class="ruby-comment"># with calls chained to the end of it.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#118</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_part_of_call_chain</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#185</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indent</span>(<span class="ruby-identifier">node</span>, <span class="ruby-value">offset:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#165</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_string_escapes</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#169</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>(<span class="ruby-identifier">node_or_range</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#30</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_range</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#144</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">needs_escaping?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @yield [sexp]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#91</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_node</span>(<span class="ruby-identifier">syms</span>, <span class="ruby-identifier">sexp</span>, <span class="ruby-identifier">excludes</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parentheses?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#196</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_regexp</span>(<span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#177</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">node1</span>, <span class="ruby-identifier">node2</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#152</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_string_literal</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#191</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_supported_styles</span>(<span class="ruby-identifier">enforced_style</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/util.rb#161</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trim_string_interpolation_escape_character</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/util.rb#103 RuboCop::Cop::Util::LINE_BEGINS_REGEX_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># Match literal regex characters, not including anchors, character # classes, alternatives, groups, repetitions, references, etc # # source://rubocop//lib/rubocop/cop/util.rb#12 RuboCop::Cop::Util::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># Arbitrarily chosen value, should be enough to cover # the most nested source code in real world projects. # # source://rubocop//lib/rubocop/cop/util.rb#102 RuboCop::Cop::Util::MAX_LINE_BEGINS_REGEX_INDEX = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#5 module RuboCop::Cop::Utils; end</p>

<p># Parses {Kernel#sprintf} format strings. # # source://rubocop//lib/rubocop/cop/utils/format_string.rb#7 class RuboCop::Cop::Utils::FormatString</p>

<pre class="ruby"><span class="ruby-comment"># @return [FormatString] a new instance of FormatString</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_sequences</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_digit_dollar_num</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_interpolation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_formats?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Escaping the ‘#` in `INTERPOLATION` and `TEMPLATE_NAME` is necessary to # avoid a bug in Ruby 3.2.0 # See: <a href="https://bugs.ruby-lang.org/issues/19379">bugs.ruby-lang.org/issues/19379</a> # # source://rubocop//lib/rubocop/cop/utils/format_string.rb#11 RuboCop::Cop::Utils::FormatString::DIGIT_DOLLAR = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#13 RuboCop::Cop::Utils::FormatString::FLAG = T.let(T.unsafe(nil), Regexp)</p>

<p># The syntax of a format sequence is as follows. # # “‘ # %[<a href="width">flags]</a>[.precision]type # “` # # A format sequence consists of a percent sign, followed by optional # flags, width, and precision indicators, then terminated with a field # type character. # # For more complex formatting, Ruby supports a reference by name. # # @see <a href="https://ruby-doc.org/core-2.6.3/Kernel.html#method-i-format">ruby-doc.org/core-2.6.3/Kernel.html#method-i-format</a> # # source://rubocop//lib/rubocop/cop/utils/format_string.rb#47 class RuboCop::Cop::Utils::FormatString::FormatSequence</p>

<pre class="ruby"><span class="ruby-comment"># @return [FormatSequence] a new instance of FormatSequence</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">match</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotated?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute arg_number.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Number of arguments required for the format sequence</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute begin_pos.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute end_pos.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute flags.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flags</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_digit_dollar_num</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute precision.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">precision</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">template?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute width.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/utils/format_string.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">width</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#12 RuboCop::Cop::Utils::FormatString::INTERPOLATION = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#19 RuboCop::Cop::Utils::FormatString::NAME = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#15 RuboCop::Cop::Utils::FormatString::NUMBER = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#14 RuboCop::Cop::Utils::FormatString::NUMBER_ARG = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#17 RuboCop::Cop::Utils::FormatString::PRECISION = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#22 RuboCop::Cop::Utils::FormatString::SEQUENCE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#20 RuboCop::Cop::Utils::FormatString::TEMPLATE_NAME = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#18 RuboCop::Cop::Utils::FormatString::TYPE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/cop/utils/format_string.rb#16 RuboCop::Cop::Utils::FormatString::WIDTH = T.let(T.unsafe(nil), Regexp)</p>

<p># This force provides a way to track local variables and scopes of Ruby. # Cops interact with this force need to override some of the hook methods. # #     def before_entering_scope(scope, variable_table) #     end # #     def after_entering_scope(scope, variable_table) #     end # #     def before_leaving_scope(scope, variable_table) #     end # #     def after_leaving_scope(scope, variable_table) #     end # #     def before_declaring_variable(variable, variable_table) #     end # #     def after_declaring_variable(variable, variable_table) #     end # # @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#27 class RuboCop::Cop::VariableForce &lt; ::RuboCop::Cop::Force</p>

<pre class="ruby"><span class="ruby-comment"># Starting point.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">investigate</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_node</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_table</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_declaring_variable</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_entering_scope</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after_leaving_scope</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_declaring_variable</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_entering_scope</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_leaving_scope</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#346</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">descendant_reference</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_descendant_reference</span>(<span class="ruby-identifier">loop_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#321</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_variables_in_loop</span>(<span class="ruby-identifier">loop_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is called for each scope recursively.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_variables_in_scope</span>(<span class="ruby-identifier">scope_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Mark all assignments which are referenced in the same loop</span>
<span class="ruby-comment"># as referenced by ignoring AST order since they would be referenced</span>
<span class="ruby-comment"># in next iteration.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mark_assignments_as_referenced_in_loop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_handler_method_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_children</span>(<span class="ruby-identifier">origin_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_loop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#182</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_pattern_match_variable</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_regexp_named_captures</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_scope</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#291</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_variable_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_variable_declaration</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_variable_multiple_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_variable_operator_assignment</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#233</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_variable_referencing</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_zero_arity_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_captured_names</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#357</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scanned_node?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#361</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scanned_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_children!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">twisted_nodes</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#35 RuboCop::Cop::VariableForce::ARGUMENT_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># This class represents each assignment of a variable. # # source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#7 class RuboCop::Cop::VariableForce::Assignment</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branchable</span>

<span class="ruby-comment"># @return [Assignment] a new instance of Assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">meta_assignment_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute reassigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reassigned</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reassigned!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute reassigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reassigned?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference!</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute referenced.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute referenced.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute references.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">references</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_named_capture?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest_assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_multiple_assignment_node</span>(<span class="ruby-identifier">grandparent_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_assignment_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_assignment_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_assignment_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest_assignment_node</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/variable_force/assignment.rb#10 RuboCop::Cop::VariableForce::Assignment::MULTIPLE_LEFT_HAND_SIDE_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#68 class RuboCop::Cop::VariableForce::AssignmentReference &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute node to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#68</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Namespace for branch classes for each control structure. # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#7 module RuboCop::Cop::VariableForce::Branch</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">of</span>(<span class="ruby-identifier">target_node</span>, <span class="ruby-value">scope:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># left_body &amp;&amp; right_body # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#265 class RuboCop::Cop::VariableForce::Branch::And &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">LogicalOperator</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Abstract base class for branch classes. # A branch represents a conditional branch in a scope. # # @example #   def some_scope #   do_something     # no branch # #   if foo #   do_something   # branch A #   do_something   # branch A #   else #   do_something   # branch B #   if bar #   do_something # branch C (whose parent is branch B) #   end #   end # #   do_something     # no branch #   end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42 class RuboCop::Cop::VariableForce::Branch::Base &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branched?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute child_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of child_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">child_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute child_node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute child_node to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">child_node=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">control_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [_self]</span>
<span class="ruby-comment"># @yieldparam _self [RuboCop::Cop::VariableForce::Branch::Base] the object that the method was called on</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_ancestor</span>(<span class="ruby-value">include_self:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eql?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclusive_with?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_jump_to_other_branch?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_run_incompletely?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute scope</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of scope</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute scope</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute scope to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan_ancestors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#43</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classes</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#56</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_predicate</span>(<span class="ruby-identifier">name</span>, <span class="ruby-value">child_index:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">subclass</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#325 RuboCop::Cop::VariableForce::Branch::CLASSES_BY_TYPE = T.let(T.unsafe(nil), Hash)</p>

<p># case target # when /pattern/ # when_clause # else #   else_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#219 class RuboCop::Cop::VariableForce::Branch::Case &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">when_clause?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># case target # in pattern # in_pattern # else #   else_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#234 class RuboCop::Cop::VariableForce::Branch::CaseMatch &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_pattern?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># begin #     main_body #   ensure #     ensure_body #   end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#314 class RuboCop::Cop::VariableForce::Branch::Ensure &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">ExceptionHandler</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">main_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Mix-in module for exception handling control structures. # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#281 module RuboCop::Cop::VariableForce::Branch::ExceptionHandler</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_jump_to_other_branch?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#286</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_run_incompletely?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># for element in collection #   loop_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#247 class RuboCop::Cop::VariableForce::Branch::For &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">element?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># if conditional_clause #   truthy_body # else #   falsey_body # end # # unless conditional_clause #   falsey_body # else #   truthy_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#166 class RuboCop::Cop::VariableForce::Branch::If &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleConditional</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">falsey_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Mix-in module for logical operator control structures. # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#258 module RuboCop::Cop::VariableForce::Branch::LogicalOperator</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># left_body || right_body # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#273 class RuboCop::Cop::VariableForce::Branch::Or &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">LogicalOperator</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># begin #     main_body #   rescue StandardError =&gt; error # rescue_clause #   else #     else_body #   end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#297 class RuboCop::Cop::VariableForce::Branch::Rescue &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">ExceptionHandler</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#304</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">main_body?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_clause?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Mix-in module for simple conditional control structures. # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#145 module RuboCop::Cop::VariableForce::Branch::SimpleConditional</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">always_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># until conditional_clause #   loop_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#187 class RuboCop::Cop::VariableForce::Branch::Until &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleConditional</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># begin #   loop_body # end until conditional_clause # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#207 class RuboCop::Cop::VariableForce::Branch::UntilPost &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleConditional</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># while conditional_clause #   loop_body # end # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#177 class RuboCop::Cop::VariableForce::Branch::While &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleConditional</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># begin #   loop_body # end while conditional_clause # # source://rubocop//lib/rubocop/cop/variable_force/branch.rb#197 class RuboCop::Cop::VariableForce::Branch::WhilePost &lt; ::RuboCop::Cop::VariableForce::Branch::Base</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branch</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleConditional</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branch.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_body?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Mix-in module for classes which own a node and need branch information # of the node. The user classes must implement #node and #scope. # # source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#8 module RuboCop::Cop::VariableForce::Branchable</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/branchable.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run_exclusively_with?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#42 RuboCop::Cop::VariableForce::LOGICAL_OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#51 RuboCop::Cop::VariableForce::LOOP_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#45 RuboCop::Cop::VariableForce::MULTIPLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#115 RuboCop::Cop::VariableForce::NODE_HANDLER_METHOD_NAMES = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#43 RuboCop::Cop::VariableForce::OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#30 RuboCop::Cop::VariableForce::PATTERN_MATCH_VARIABLE_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#50 RuboCop::Cop::VariableForce::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#29 RuboCop::Cop::VariableForce::REGEXP_NAMED_CAPTURE_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#53 RuboCop::Cop::VariableForce::RESCUE_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#46 RuboCop::Cop::VariableForce::REST_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># This class represents each reference of a variable. # # source://rubocop//lib/rubocop/cop/variable_force/reference.rb#7 class RuboCop::Cop::VariableForce::Reference</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Cop</span><span class="ruby-operator">::</span><span class="ruby-constant">VariableForce</span><span class="ruby-operator">::</span><span class="ruby-constant">Branchable</span>

<span class="ruby-comment"># @return [Reference] a new instance of Reference</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/reference.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">scope</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># There&#39;s an implicit variable reference by the zero-arity `super`:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#     def some_method(foo)</span>
<span class="ruby-comment">#       super</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Another case is `binding`:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#     def some_method(foo)</span>
<span class="ruby-comment">#       do_something(binding)</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In these cases, the variable `foo` is not explicitly referenced,</span>
<span class="ruby-comment"># but it can be considered used implicitly by the `super` or `binding`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/reference.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/reference.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute scope.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/reference.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/variable_force/reference.rb#10 RuboCop::Cop::VariableForce::Reference::VARIABLE_REFERENCE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#58 RuboCop::Cop::VariableForce::SCOPE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#60 RuboCop::Cop::VariableForce::SEND_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># A Scope represents a context of local variable visibility. # This is a place where local variables belong to. # A scope instance holds a scope node and variable entries. # # source://rubocop//lib/rubocop/cop/variable_force/scope.rb#9 class RuboCop::Cop::VariableForce::Scope</p>

<pre class="ruby"><span class="ruby-comment"># @return [Scope] a new instance of Scope</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_node</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include?</span>(<span class="ruby-identifier">target_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute naked_top_level.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">naked_top_level</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute naked_top_level.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">naked_top_level?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute variables.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variables</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ancestor_node?</span>(<span class="ruby-identifier">target_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">belong_to_inner_scope?</span>(<span class="ruby-identifier">target_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">belong_to_outer_scope?</span>(<span class="ruby-identifier">target_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan_node</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/variable_force/scope.rb#10 RuboCop::Cop::VariableForce::Scope::OUTER_SCOPE_CHILD_INDICES = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#57 RuboCop::Cop::VariableForce::TWISTED_SCOPE_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#28 RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#31 RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#48 RuboCop::Cop::VariableForce::VARIABLE_REFERENCE_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># A Variable represents existence of a local variable. # This holds a variable declaration node and some states of the variable. # # source://rubocop//lib/rubocop/cop/variable_force/variable.rb#8 class RuboCop::Cop::VariableForce::Variable</p>

<pre class="ruby"><span class="ruby-comment"># @return [Variable] a new instance of Variable</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">declaration_node</span>, <span class="ruby-identifier">scope</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assign</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute assignments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">capture_with_block!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute captured_by_block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">captured_by_block</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute captured_by_block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">captured_by_block?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute declaration_node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">declaration_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">explicit_block_local_variable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_modifier_conditional?</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mark_last_as_reassigned!</span>(<span class="ruby-identifier">assignment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference!</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">referenced?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute references.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">references</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute scope.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_be_unused?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is a convenient way to check whether the variable is used</span>
<span class="ruby-comment"># in its entire variable lifetime.</span>
<span class="ruby-comment"># For more precise usage check, refer Assignment#used?.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Once the variable is captured by a block, we have no idea</span>
<span class="ruby-comment"># when, where, and how many times the block would be invoked.</span>
<span class="ruby-comment"># This means we cannot track the usage of the variable.</span>
<span class="ruby-comment"># So we consider it&#39;s used to suppress false positive offenses.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">used?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/variable_force/variable.rb#9 RuboCop::Cop::VariableForce::Variable::VARIABLE_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#62 class RuboCop::Cop::VariableForce::VariableReference &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute name to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force.rb#62</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A VariableTable manages the lifetime of all scopes and local variables # in a program. # This holds scopes as stack structure, provides a way to add local # variables to current scope, and find local variables by considering # variable visibility of the current scope. # # source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#11 class RuboCop::Cop::VariableForce::VariableTable</p>

<pre class="ruby"><span class="ruby-comment"># @return [VariableTable] a new instance of VariableTable</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">hook_receiver</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accessible_variables</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assign_to_variable</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_scope</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_scope_level</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">declare_variable</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_variable</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invoke_hook</span>(<span class="ruby-identifier">hook_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pop_scope</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push_scope</span>(<span class="ruby-identifier">scope_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference_variable</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scope_stack</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#109</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable_exist?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/variable_force/variable_table.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mark_variable_as_captured_by_block_if_so</span>(<span class="ruby-identifier">variable</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/cop/variable_force.rb#55 RuboCop::Cop::VariableForce::ZERO_ARITY_SUPER_TYPE = T.let(T.unsafe(nil), Symbol)</p>

<p># Help methods for determining node visibility. # # source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#8 module RuboCop::Cop::VisibilityHelp</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility_inline_on_def?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visibility_inline_on_method_name?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">method_name:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Navigate to find the last protected method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_visibility_end</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_visibility_start</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_visibility</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_visibility_from_visibility_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_visibility_from_visibility_inline</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_visibility_from_visibility_inline_on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_visibility_from_visibility_inline_on_method_name</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/cop/mixin/visibility_help.rb#11 RuboCop::Cop::VisibilityHelp::VISIBILITY_SCOPES = T.let(T.unsafe(nil), Set)</p>

<p># This class wraps the ‘Parser::Source::Comment` object that represents a # cops it contains. # # source://rubocop//lib/rubocop/directive_comment.rb#7 class RuboCop::DirectiveComment</p>

<pre class="ruby"><span class="ruby-comment"># @return [DirectiveComment] a new instance of DirectiveComment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">cop_registry</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if all cops specified in this directive</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_cops?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns array of specified in this directive cop names</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop_registry.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_registry</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cops.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cops</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns array of specified in this directive department names</span>
<span class="ruby-comment"># when all department disabled</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">directive_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive disables cops</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive disables all cops</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled_all?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive enables cops</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive enables all cops</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled_all?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if directive departments include cop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_directive_department?</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns line number for directive</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">malformed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive contains all the given cop names</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">cop_names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns match captures to directive comment pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_captures</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if the directive comment is missing a cop name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">missing_cop_name?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute mode.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if cop department has already used in directive comment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">overridden_by_department?</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of cops for this directive comment, without resolving departments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raw_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this directive relates to single line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_with_marker?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_names_for_department</span>(<span class="ruby-identifier">department</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">department?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclude_lint_department_cops</span>(<span class="ruby-identifier">cops</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parsed_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/directive_comment.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before_comment</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#21 RuboCop::DirectiveComment::AVAILABLE_MODES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#19 RuboCop::DirectiveComment::COPS_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#17 RuboCop::DirectiveComment::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#15 RuboCop::DirectiveComment::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#29 RuboCop::DirectiveComment::DIRECTIVE_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#27 RuboCop::DirectiveComment::DIRECTIVE_HEADER_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#23 RuboCop::DirectiveComment::DIRECTIVE_MARKER_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#25 RuboCop::DirectiveComment::DIRECTIVE_MARKER_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#9 RuboCop::DirectiveComment::LINT_DEPARTMENT = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#11 RuboCop::DirectiveComment::LINT_REDUNDANT_DIRECTIVE_COP = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#13 RuboCop::DirectiveComment::LINT_SYNTAX_COP = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#36 RuboCop::DirectiveComment::MALFORMED_DIRECTIVE_WITHOUT_COP_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/directive_comment.rb#34 RuboCop::DirectiveComment::TRAILING_COMMENT_MARKER = T.let(T.unsafe(nil), String)</p>

<p># An Error exception is different from an Offense with severity ‘error’ # When this exception is raised, it means that RuboCop is unable to perform # a requested action (probably due to misconfiguration) and must stop # immediately, rather than carrying on # # source://rubocop//lib/rubocop/error.rb#8 class RuboCop::Error &lt; ::StandardError; end</p>

<p># A wrapper to display errored location of analyzed file. # # source://rubocop//lib/rubocop/error.rb#13 class RuboCop::ErrorWithAnalyzedFileLocation &lt; ::RuboCop::Error</p>

<pre class="ruby"><span class="ruby-comment"># @return [ErrorWithAnalyzedFileLocation] a new instance of ErrorWithAnalyzedFileLocation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">cause:</span>, <span class="ruby-value">node:</span>, <span class="ruby-value">cop:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cause</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute cop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/error.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Allows specified configuration options to have an exclude limit # ie. a maximum value tracked that it can be used by ‘–auto-gen-config`. # # source://rubocop//lib/rubocop/cop/exclude_limit.rb#6 module RuboCop::ExcludeLimit</p>

<pre class="ruby"><span class="ruby-comment"># Sets up a configuration option to have an exclude limit tracked.</span>
<span class="ruby-comment"># The parameter name given is transformed into a method name (eg. `Max`</span>
<span class="ruby-comment"># becomes `self.max=` and `MinDigits` becomes `self.min_digits=`).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/exclude_limit.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclude_limit</span>(<span class="ruby-identifier">parameter_name</span>, <span class="ruby-value">method_name:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/cop/exclude_limit.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transform</span>(<span class="ruby-identifier">parameter_name</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/ext/comment.rb#4 module RuboCop::Ext; end</p>

<p># Extensions to ‘Parser::Source::Comment`. # # source://rubocop//lib/rubocop/ext/comment.rb#6 module RuboCop::Ext::Comment</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/ext/comment.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/comment.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Extensions to AST::ProcessedSource for our cached comment_config # # source://rubocop//lib/rubocop/ext/processed_source.rb#6 module RuboCop::Ext::ProcessedSource</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute config.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute config</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute config to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disabled_line_ranges</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute registry.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute registry</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute registry to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/processed_source.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Extensions to Parser::Source::Range # # source://rubocop//lib/rubocop/ext/range.rb#6 module RuboCop::Ext::Range</p>

<pre class="ruby"><span class="ruby-comment"># Adds `Range#single_line?` to parallel `Node#single_line?`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/range.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Extensions to AST::RegexpNode for our cached parsed regexp info # # source://rubocop//lib/rubocop/ext/regexp_node.rb#6 module RuboCop::Ext::RegexpNode</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assign_properties</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_node.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_capture</span>(<span class="ruby-value">named:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Note: we extend Regexp nodes to provide `loc` and `expression`</span>
<span class="ruby-comment"># see `ext/regexp_parser`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Regexp::Expression::Root, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parsed_tree</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_node.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_capturing?</span>(<span class="ruby-identifier">exp</span>, <span class="ruby-identifier">event</span>, <span class="ruby-identifier">named</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_node.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_interpolations_blanked</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/ext/regexp_node.rb#7 RuboCop::Ext::RegexpNode::ANY = T.let(T.unsafe(nil), <a href="../../../Object.html"><code>Object</code></a>)</p>

<p># Extensions for ‘regexp_parser` gem # # source://rubocop//lib/rubocop/ext/regexp_parser.rb#6 module RuboCop::Ext::RegexpParser; end</p>

<p># source://rubocop//lib/rubocop/ext/regexp_parser.rb#20 module RuboCop::Ext::RegexpParser::Expression; end</p>

<p># Add ‘expression` and `loc` to all `regexp_parser` nodes # # source://rubocop//lib/rubocop/ext/regexp_parser.rb#22 module RuboCop::Ext::RegexpParser::Expression::Base</p>

<pre class="ruby"><span class="ruby-comment"># Shortcut to `loc.expression`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># E.g.</span>
<span class="ruby-comment">#     [a-z]{2,}</span>
<span class="ruby-comment">#     ^^^^^^^^^ expression</span>
<span class="ruby-comment">#          ^^^^ quantifier</span>
<span class="ruby-comment">#     ^^^^^     body</span>
<span class="ruby-comment">#     ^         begin</span>
<span class="ruby-comment">#         ^     end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Please open issue if you need other locations</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute origin.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">origin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute origin</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute origin to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">origin=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_location</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Provide ‘CharacterSet` with `begin` and `end` locations. # # source://rubocop//lib/rubocop/ext/regexp_parser.rb#62 module RuboCop::Ext::RegexpParser::Expression::CharacterSet</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_location</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Source map for RegexpParser nodes # # source://rubocop//lib/rubocop/ext/regexp_parser.rb#8 class RuboCop::Ext::RegexpParser::Map &lt; ::Parser::Source::Map</p>

<pre class="ruby"><span class="ruby-comment"># @return [Map] a new instance of Map</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">expression</span>, <span class="ruby-value">body:</span>, <span class="ruby-value">quantifier:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">begin_l:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">end_l:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute begin.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">begin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute body.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute end.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute quantifier.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/ext/regexp_parser.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quantifier</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class handles loading files (a.k.a. features in Ruby) specified # by ‘–require` command line option and `require` directive in the config. # # Normally, the given string is directly passed to `require`. If a string # beginning with `.` is given, it is assumed to be relative to the given # directory. # # If a string containing `-` is given, it will be used as is, but if we # cannot find the file to load, we will replace `-` with `/` and try it # again as when Bundler loads gems. # # @api private # # source://rubocop//lib/rubocop/feature_loader.rb#16 class RuboCop::FeatureLoader</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param config_directory_path [String]</span>
<span class="ruby-comment"># @param feature [String]</span>
<span class="ruby-comment"># @return [FeatureLoader] a new instance of FeatureLoader</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">config_directory_path:</span>, <span class="ruby-value">feature:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespaced_feature</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespaced_target</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param [String]</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative</span>(<span class="ruby-identifier">feature</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param error [LoadError]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">seems_cannot_load_such_file_error?</span>(<span class="ruby-identifier">error</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @param config_directory_path [String]</span>
  <span class="ruby-comment"># @param feature [String]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/feature_loader.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load</span>(<span class="ruby-value">config_directory_path:</span>, <span class="ruby-value">feature:</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common methods for finding files. # # @api private # # source://rubocop//lib/rubocop/file_finder.rb#8 module RuboCop::FileFinder</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_file_upwards</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">start_dir</span>, <span class="ruby-identifier">stop_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_last_file_upwards</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">start_dir</span>, <span class="ruby-identifier">stop_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">traverse_directories_upwards</span>(<span class="ruby-identifier">start_dir</span>, <span class="ruby-identifier">stop_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">traverse_files_upwards</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">start_dir</span>, <span class="ruby-identifier">stop_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_level</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/file_finder.rb#10</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root_level=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A wrapper around patterns array to perform optimized search. # # For projects with a large set of rubocop todo files, most items in ‘Exclude`/`Include` # are exact file names. It is wasteful to linearly check the list of patterns over and over # to check if the file is relevant to the cop. # # This class partitions an array of patterns into a set of exact match strings and the rest # of the patterns. This way we can firstly do a cheap check in the set and then proceed via # the costly patterns check, if needed. # # @api private # # source://rubocop//lib/rubocop/file_patterns.rb#14 class RuboCop::FilePatterns</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [FilePatterns] a new instance of FilePatterns</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_patterns.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">patterns</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_patterns.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/file_patterns.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">partition_patterns</span>(<span class="ruby-identifier">patterns</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/file_patterns.rb#17</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from</span>(<span class="ruby-identifier">patterns</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The bootstrap module for formatter. # # source://rubocop//lib/rubocop/formatter.rb#5 module RuboCop::Formatter; end</p>

<p># Does not show individual offenses in the console. # # source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#6 class RuboCop::Formatter::AutoGenConfigFormatter &lt; ::RuboCop::Formatter::ProgressFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/auto_gen_config_formatter.rb#7</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Abstract base class for formatter, implements all public API methods. # # ## Creating Custom Formatter # # You can create a custom formatter by subclassing # ‘RuboCop::Formatter::BaseFormatter` and overriding some methods # or by implementing all the methods by duck typing. # # ## Using Custom Formatter in Command Line # # You can tell RuboCop to use your custom formatter with a combination of # `–format` and `–require` option. # For example, when you have defined `MyCustomFormatter` in # `./path/to/my_custom_formatter.rb`, you would type this command: # #     rubocop –require ./path/to/my_custom_formatter –format MyCustomFormatter # # Note: The path passed to `–require` is directly passed to # `Kernel.require`. # If your custom formatter file is not in `$LOAD_PATH`, # you need to specify the path as relative path prefixed with `./` # explicitly or absolute path. # # ## Method Invocation Order # # For example, when RuboCop inspects 2 files, # the invocation order should be like this: # # * `#initialize` # * `#started` # * `#file_started` # * `#file_finished` # * `#file_started` # * `#file_finished` # * `#finished` # # source://rubocop//lib/rubocop/formatter/base_formatter.rb#41 class RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param output [IO] `$stdout` or opened file</span>
<span class="ruby-comment"># @return [BaseFormatter] a new instance of BaseFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked at the end of inspecting each files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param file [String] the file path</span>
<span class="ruby-comment"># @param offenses [Array(RuboCop::Cop::Offense)] all detected offenses for the file</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment"># @see RuboCop::Cop::Offense</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked at the beginning of inspecting each files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param file [String] the file path</span>
<span class="ruby-comment"># @param options [Hash] file specific information, currently this is always empty.</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_started</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked after all files are inspected or interrupted by user.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param inspected_files [Array(String)] the inspected file paths.</span>
<span class="ruby-comment">#   This would be same as `target_files` passed to `#started`</span>
<span class="ruby-comment">#   unless RuboCop is interrupted by user.</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [Hash]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @return [IO] the IO object passed to `#initialize`</span>
<span class="ruby-comment"># @see #initialize</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Invoked once before any files are inspected.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api public</span>
<span class="ruby-comment"># @param target_files [Array(String)] all target file paths to be inspected</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/base_formatter.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter formats report data in clang style. # The precise location of the problem is shown together with the # relevant source code. # # source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#8 class RuboCop::Formatter::ClangStyleFormatter &lt; ::RuboCop::Formatter::SimpleTextFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_file</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_highlighted_area</span>(<span class="ruby-identifier">highlighted_area</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_line</span>(<span class="ruby-identifier">location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_offense</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_line?</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/clang_style_formatter.rb#9 RuboCop::Formatter::ClangStyleFormatter::ELLIPSES = T.let(T.unsafe(nil), String)</p>

<p># This mix-in module provides string coloring methods for terminals. # It automatically disables coloring if coloring is disabled in the process # globally or the formatter’s output is not a terminal. # # source://rubocop//lib/rubocop/formatter/colorizable.rb#8 module RuboCop::Formatter::Colorizable</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">black</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blue</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colorize</span>(<span class="ruby-identifier">string</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cyan</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">green</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">magenta</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rainbow</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">red</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">white</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/colorizable.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yellow</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter displays a YAML configuration file where all cops that # detected any offenses are configured to not detect the offense. # # source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#7 class RuboCop::Formatter::DisabledConfigFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>

<span class="ruby-comment"># @return [DisabledConfigFormatter] a new instance of DisabledConfigFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_started</span>(<span class="ruby-identifier">_file</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">_inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">auto_gen_enforced_style?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_config_params</span>(<span class="ruby-identifier">default_cfg</span>, <span class="ruby-identifier">cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_config</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excludes</span>(<span class="ruby-identifier">offending_files</span>, <span class="ruby-identifier">cop_name</span>, <span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filtered_config</span>(<span class="ruby-identifier">cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true if the given arr include the given elm or if any of the</span>
<span class="ruby-comment"># given arr is a regexp that matches the given elm.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include_or_match?</span>(<span class="ruby-identifier">arr</span>, <span class="ruby-identifier">elm</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_mode_for_exclude?</span>(<span class="ruby-identifier">cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_exclude_limit?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_cop</span>(<span class="ruby-identifier">cop_name</span>, <span class="ruby-identifier">offense_count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_cop_comments</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">cfg</span>, <span class="ruby-identifier">cop_name</span>, <span class="ruby-identifier">offense_count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_cop_config</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">cfg</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_cop_param_comments</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">default_cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_exclude_list</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">offending_files</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_exclude_path</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">exclude_path</span>, <span class="ruby-identifier">parent</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_offending_files</span>(<span class="ruby-identifier">output_buffer</span>, <span class="ruby-identifier">cfg</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#268</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_autocorrect?</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">set_max</span>(<span class="ruby-identifier">cfg</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">should_set_max?</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">show_offense_counts?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">show_timestamp?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supports_safe_autocorrect?</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">default_cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supports_unsafe_autocorrect?</span>(<span class="ruby-identifier">cop_class</span>, <span class="ruby-identifier">default_cfg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">timestamp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute config_to_allow_offenses.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_to_allow_offenses</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute config_to_allow_offenses</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute config_to_allow_offenses to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_to_allow_offenses=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute detected_styles.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_styles</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute detected_styles</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute detected_styles to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detected_styles=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/disabled_config_formatter.rb#10 RuboCop::Formatter::DisabledConfigFormatter::HEADING = T.let(T.unsafe(nil), String)</p>

<p># This formatter displays the report data in format that’s # easy to process in the Emacs text editor. # The output is machine-parsable. # # source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#8 class RuboCop::Formatter::EmacsStyleFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/emacs_style_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter displays just a list of the files with offenses in them, # separated by newlines. The output is machine-parsable. # # Here’s the format: # # /some/file # /some/other/file # # source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#12 class RuboCop::Formatter::FileListFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/file_list_formatter.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This is a collection of formatters. A FormatterSet can hold multiple # formatter instances and provides transparent formatter API methods # which invoke same method of each formatters. # # source://rubocop//lib/rubocop/formatter/formatter_set.rb#10 class RuboCop::Formatter::FormatterSet &lt; ::Array</p>

<pre class="ruby"><span class="ruby-comment"># @return [FormatterSet] a new instance of FormatterSet</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_formatter</span>(<span class="ruby-identifier">formatter_type</span>, <span class="ruby-identifier">output_path</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close_output_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_started</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">builtin_formatter_class</span>(<span class="ruby-identifier">specified_key</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">custom_formatter_class</span>(<span class="ruby-identifier">specified_class_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/formatter_set.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">formatter_class</span>(<span class="ruby-identifier">formatter_type</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/formatter_set.rb#11 RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTERS_FOR_KEYS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/formatter/formatter_set.rb#30 RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTER_NAMES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop//lib/rubocop/formatter/formatter_set.rb#32 RuboCop::Formatter::FormatterSet::FORMATTER_APIS = T.let(T.unsafe(nil), Array)</p>

<p># This formatter displays a progress bar and shows details of offenses as # soon as they are detected. # This is inspired by the Fuubar formatter for RSpec by Jeff Kreeftmeijer. # <a href="https://github.com/jeffkreeftmeijer/fuubar">github.com/jeffkreeftmeijer/fuubar</a> # # source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#11 class RuboCop::Formatter::FuubarStyleFormatter &lt; ::RuboCop::Formatter::ClangStyleFormatter</p>

<pre class="ruby"><span class="ruby-comment"># @return [FuubarStyleFormatter] a new instance of FuubarStyleFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">output</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_stats</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">progressbar_color</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_color</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/fuubar_style_formatter.rb#12 RuboCop::Formatter::FuubarStyleFormatter::RESET_SEQUENCE = T.let(T.unsafe(nil), String)</p>

<p># This formatter formats report data as GitHub Workflow commands resulting # in GitHub check annotations when run within GitHub Actions. # # source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#7 class RuboCop::Formatter::GitHubActionsFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">_inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">_target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">github_escape</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">github_severity</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minimum_severity_to_fail</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_offense</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/github_actions_formatter.rb#8 RuboCop::Formatter::GitHubActionsFormatter::ESCAPE_MAP = T.let(T.unsafe(nil), Hash)</p>

<p># This formatter saves the output as an html file. # # source://rubocop//lib/rubocop/formatter/html_formatter.rb#9 class RuboCop::Formatter::HTMLFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># @return [HTMLFormatter] a new instance of HTMLFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">render_html</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute summary.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">summary</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This class provides helper methods used in the ERB CSS template. # # source://rubocop//lib/rubocop/formatter/html_formatter.rb#137 class RuboCop::Formatter::HTMLFormatter::CSSContext</p>

<pre class="ruby"><span class="ruby-comment"># Make Kernel#binding public.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binding</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#138 RuboCop::Formatter::HTMLFormatter::CSSContext::SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#12 RuboCop::Formatter::HTMLFormatter::CSS_PATH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14 class RuboCop::Formatter::HTMLFormatter::Color &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute alpha</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of alpha</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alpha</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute alpha</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute alpha to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alpha=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute blue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of blue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blue</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute blue</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute blue to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blue=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fade_out</span>(<span class="ruby-identifier">amount</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute green</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of green</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">green</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute green</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute green to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">green=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute red</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of red</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">red</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute red</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute red to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">red=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#14</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#10 RuboCop::Formatter::HTMLFormatter::ELLIPSES = T.let(T.unsafe(nil), String)</p>

<p># This class provides helper methods used in the ERB template. # # source://rubocop//lib/rubocop/formatter/html_formatter.rb#63 class RuboCop::Formatter::HTMLFormatter::ERBContext</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>

<span class="ruby-comment"># @return [ERBContext] a new instance of ERBContext</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">files</span>, <span class="ruby-identifier">summary</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">base64_encoded_logo_image</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Make Kernel#binding public.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decorated_message</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">escape</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">highlight_source_tag</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">highlighted_source_line</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">possible_ellipses</span>(<span class="ruby-identifier">location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">render_css</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_after_highlight</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_before_highlight</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute summary.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">summary</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#67 RuboCop::Formatter::HTMLFormatter::ERBContext::LOGO_IMAGE_PATH = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25 class RuboCop::Formatter::HTMLFormatter::FileOffenses &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute offenses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute offenses to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute path</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of path</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute path</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute path to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24 class RuboCop::Formatter::HTMLFormatter::Summary &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute inspected_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of inspected_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspected_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute inspected_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute inspected_files to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspected_files=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offense_count</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of offense_count</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute offense_count</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute offense_count to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_count=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute target_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of target_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute target_files</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute target_files to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_files=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/html_formatter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/html_formatter.rb#11 RuboCop::Formatter::HTMLFormatter::TEMPLATE_PATH = T.let(T.unsafe(nil), String)</p>

<p># This formatter formats the report data in JSON format. # # source://rubocop//lib/rubocop/formatter/json_formatter.rb#8 class RuboCop::Formatter::JSONFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>

<span class="ruby-comment"># @return [JSONFormatter] a new instance of JSONFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_for_file</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># TODO: Consider better solution for Offense#real_column.</span>
<span class="ruby-comment">#       The minimum value of `start_column: real_column` is 1.</span>
<span class="ruby-comment">#       So, the minimum value of `last_column` should be 1.</span>
<span class="ruby-comment">#       And non-zero value of `last_column` should be used as is.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_for_location</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_for_offense</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">metadata_hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute output_hash.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">output_hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/json_formatter.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter formats the report data in JUnit format. # # source://rubocop//lib/rubocop/formatter/junit_formatter.rb#15 class RuboCop::Formatter::JUnitFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># @return [JUnitFormatter] a new instance of JUnitFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">_inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_failure_to</span>(<span class="ruby-identifier">testcase</span>, <span class="ruby-identifier">offenses</span>, <span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_testcase_element_to_testsuite_element</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">target_offenses</span>, <span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classname_attribute_value</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_for_cop</span>(<span class="ruby-identifier">all_offenses</span>, <span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_for_output?</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">target_offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reset_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">xml_escape</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#16 RuboCop::Formatter::JUnitFormatter::ESCAPE_MAP = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#132 class RuboCop::Formatter::JUnitFormatter::FailureElement</p>

<pre class="ruby"><span class="ruby-comment"># @return [FailureElement] a new instance of FailureElement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">type:</span>, <span class="ruby-value">message:</span>, <span class="ruby-value">text:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute message.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute text.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#122 class RuboCop::Formatter::JUnitFormatter::TestCaseElement</p>

<pre class="ruby"><span class="ruby-comment"># @return [TestCaseElement] a new instance of TestCaseElement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-value">classname:</span>, <span class="ruby-value">name:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute classname.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classname</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute failures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">failures</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/junit_formatter.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter displays the report data in markdown # # source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#6 class RuboCop::Formatter::MarkdownFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>

<span class="ruby-comment"># @return [MarkdownFormatter] a new instance of MarkdownFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute summary.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">summary</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">possible_ellipses</span>(<span class="ruby-identifier">location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">render_markdown</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_code</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_context</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_file_messages</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/markdown_formatter.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_heading</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter displays the list of offended cops with a count of how # many offenses of their kind were found. Ordered by desc offense count # # Here’s the format: # # 26  LineLength # 3   OneLineConditional # – # 29  Total in 5 files # # source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#16 class RuboCop::Formatter::OffenseCountFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cop_information</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">_file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">_inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offense_counts.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_counts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ordered_offense_counts</span>(<span class="ruby-identifier">offense_counts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_summary</span>(<span class="ruby-identifier">offense_counts</span>, <span class="ruby-identifier">offending_files_count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/offense_count_formatter.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">total_offense_count</span>(<span class="ruby-identifier">offense_counts</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter prints a PACDOT per every file to be analyzed. # Pacman will “eat” one PACDOT per file when no offense is detected. # Otherwise it will print a Ghost. # This is inspired by the Pacman formatter for RSpec by Carlos Rojas. # <a href="https://github.com/go-labs/rspec_pacman_formatter">github.com/go-labs/rspec_pacman_formatter</a> # # source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#10 class RuboCop::Formatter::PacmanFormatter &lt; ::RuboCop::Formatter::ClangStyleFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>

<span class="ruby-comment"># @return [PacmanFormatter] a new instance of PacmanFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cols</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_started</span>(<span class="ruby-identifier">_file</span>, <span class="ruby-identifier">_options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_step</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pacdots</span>(<span class="ruby-identifier">number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute progress_line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">progress_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute progress_line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute progress_line to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">progress_line=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">step</span>(<span class="ruby-identifier">character</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update_progress_line</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#14 RuboCop::Formatter::PacmanFormatter::FALLBACK_TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#15 RuboCop::Formatter::PacmanFormatter::GHOST = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#17 RuboCop::Formatter::PacmanFormatter::PACDOT = T.let(T.unsafe(nil), Rainbow::Presenter)</p>

<p># source://rubocop//lib/rubocop/formatter/pacman_formatter.rb#16 RuboCop::Formatter::PacmanFormatter::PACMAN = T.let(T.unsafe(nil), Rainbow::Presenter)</p>

<p># This formatter display dots for files with no offenses and # letters for files with problems in the them. In the end it # appends the regular report data in the clang style format. # # source://rubocop//lib/rubocop/formatter/progress_formatter.rb#8 class RuboCop::Formatter::ProgressFormatter &lt; ::RuboCop::Formatter::ClangStyleFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>

<span class="ruby-comment"># @return [ProgressFormatter] a new instance of ProgressFormatter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_file_as_mark</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/progress_formatter.rb#11 RuboCop::Formatter::ProgressFormatter::DOT = T.let(T.unsafe(nil), String)</p>

<p># If no offenses are found, no output is displayed. # Otherwise, SimpleTextFormatter’s output is displayed. # # source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#7 class RuboCop::Formatter::QuietFormatter &lt; ::RuboCop::Formatter::SimpleTextFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/quiet_formatter.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_summary</span>(<span class="ruby-identifier">file_count</span>, <span class="ruby-identifier">offense_count</span>, <span class="ruby-identifier">correction_count</span>, <span class="ruby-identifier">correctable_count</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A basic formatter that displays only files with offenses. # Offenses are displayed at compact form - just the # location of the problem and the associated message. # # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#10 class RuboCop::Formatter::SimpleTextFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">Colorizable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">PathUtil</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_file</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_summary</span>(<span class="ruby-identifier">file_count</span>, <span class="ruby-identifier">offense_count</span>, <span class="ruby-identifier">correction_count</span>, <span class="ruby-identifier">correctable_count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">_target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotate_message</span>(<span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colored_severity_code</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count_stats</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#14 RuboCop::Formatter::SimpleTextFormatter::COLOR_FOR_SEVERITY = T.let(T.unsafe(nil), Hash)</p>

<p># A helper class for building the report summary text. # # source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#105 class RuboCop::Formatter::SimpleTextFormatter::Report</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">Colorizable</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span><span class="ruby-operator">::</span><span class="ruby-constant">TextUtil</span>

<span class="ruby-comment"># @return [Report] a new instance of Report</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">file_count</span>, <span class="ruby-identifier">offense_count</span>, <span class="ruby-identifier">correction_count</span>, <span class="ruby-identifier">correctable_count</span>, <span class="ruby-identifier">rainbow</span>, <span class="ruby-value">safe_autocorrect:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">summary</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">correctable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">corrections</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">files</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute rainbow.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/simple_text_formatter.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rainbow</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter formats report data using the Test Anything Protocol. # TAP allows for to communicate tests results in a language agnostics way. # # source://rubocop//lib/rubocop/formatter/tap_formatter.rb#7 class RuboCop::Formatter::TapFormatter &lt; ::RuboCop::Formatter::ClangStyleFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">annotate_message</span>(<span class="ruby-identifier">msg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_highlighted_area</span>(<span class="ruby-identifier">highlighted_area</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_line</span>(<span class="ruby-identifier">location</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/tap_formatter.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_offense</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common logic for UI texts. # # source://rubocop//lib/rubocop/formatter/text_util.rb#6 module RuboCop::Formatter::TextUtil</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/text_util.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pluralize</span>(<span class="ruby-identifier">number</span>, <span class="ruby-identifier">thing</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/text_util.rb#9</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pluralize</span>(<span class="ruby-identifier">number</span>, <span class="ruby-identifier">thing</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This formatter displays the list of offensive files, sorted by number of # offenses with the worst offenders first. # # Here’s the format: # # 26  this/file/is/really/bad.rb # 3   just/ok.rb # – # 29  Total in 2 files # # source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#16 class RuboCop::Formatter::WorstOffendersFormatter &lt; ::RuboCop::Formatter::BaseFormatter</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">finished</span>(<span class="ruby-identifier">_inspected_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offense_counts.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_counts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ordered_offense_counts</span>(<span class="ruby-identifier">offense_counts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">report_summary</span>(<span class="ruby-identifier">offense_counts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">started</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/formatter/worst_offenders_formatter.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">total_offense_count</span>(<span class="ruby-identifier">offense_counts</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/options.rb#8 class RuboCop::IncorrectCopNameError &lt; ::StandardError; end</p>

<p># The RuboCop’s built-in LSP module. # # source://rubocop//lib/rubocop/lsp.rb#5 module RuboCop::LSP</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># Disable LSP.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enable LSP.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [void]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true when LSP is enabled, false when disabled.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Disable LSP.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [void]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Enable LSP.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [void]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#18</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns true when LSP is enabled, false when disabled.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/lsp.rb#11</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enabled?</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Encapsulation of a lockfile for use when checking for gems. # Does not actually resolve gems, just parses the lockfile. # # @api private # # source://rubocop//lib/rubocop/lockfile.rb#15 class RuboCop::Lockfile</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param lockfile_path [String, Pathname, nil]</span>
<span class="ruby-comment"># @return [Lockfile] a new instance of Lockfile</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">lockfile_path</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Gems that the bundle directly depends on.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Array&lt;Bundler::Dependency&gt;, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dependencies</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the locked versions of gems from this lockfile.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param include_transitive_dependencies: [Boolean] When false, only direct dependencies</span>
<span class="ruby-comment">#   are returned, i.e. those listed explicitly in the `Gemfile`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_versions</span>(<span class="ruby-value">include_transitive_dependencies:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># All activated gems, including transitive dependencies.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Array&lt;Bundler::Dependency&gt;, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gems</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Whether this lockfile includes the named gem, directly or indirectly.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param name [String]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">includes_gem?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Bundler::LockfileParser, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/lockfile.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_bundler_lock_parser?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Parse different formats of magic comments. # # @abstract parent of three different magic comment handlers # # source://rubocop//lib/rubocop/magic_comment.rb#7 class RuboCop::MagicComment</p>

<pre class="ruby"><span class="ruby-comment"># @return [MagicComment] a new instance of MagicComment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding_specified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Expose the `frozen_string_literal` value coerced to a boolean if possible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] if value is `true` or `false` in any case</span>
<span class="ruby-comment"># @return [nil] if frozen_string_literal comment isn&#39;t found</span>
<span class="ruby-comment"># @return [String] if comment is found but isn&#39;t true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Does the magic comment enable the frozen string literal feature.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Test whether the frozen string literal value is `true`. Cannot</span>
<span class="ruby-comment"># just return `frozen_string_literal` since an invalid magic comment</span>
<span class="ruby-comment"># `&#39;yes&#39;` does not actually enable the feature</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Was a magic comment for the frozen string literal found?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal_specified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Expose the `shareable_constant_value` value coerced to a boolean if possible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] for shareable_constant_value config</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shareable_constant_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Was a shareable_constant_value specified?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shareable_constant_value_specified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">typed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Was the Sorbet `typed` sigil specified?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">typed_specified?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_literal_value?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_shareable_constant_value?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Match the entire comment string with a pattern and take the first capture.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param pattern [Regexp]</span>
<span class="ruby-comment"># @return [String] if pattern matched</span>
<span class="ruby-comment"># @return [nil] otherwise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">specified?</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Detect magic comment format and pass it to the appropriate wrapper.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param comment [String]</span>
  <span class="ruby-comment"># @return [RuboCop::MagicComment]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#23</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">comment</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Parent to Vim and Emacs magic comment handling. # # @abstract # # source://rubocop//lib/rubocop/magic_comment.rb#138 class RuboCop::MagicComment::EditorComment &lt; ::RuboCop::MagicComment</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Rewrite the comment without a given token type</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Find a token starting with the provided keyword and extract its value.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param keyword [String]</span>
<span class="ruby-comment"># @return [String] extracted value if it is found</span>
<span class="ruby-comment"># @return [nil] otherwise</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match</span>(<span class="ruby-identifier">keyword</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Individual tokens composing an editor specific comment string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;String&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Wrapper for Emacs style magic comments. # # @example Emacs style comment #   comment = RuboCop::MagicComment.parse( #   ‘# -*- encoding: ASCII-8BIT -*-’ #   ) # #   comment.encoding # =&gt; ‘ascii-8bit’ # @see <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Specify-Coding.html">www.gnu.org/software/emacs/manual/html_node/emacs/Specify-Coding.html</a> # @see <a href="https://github.com/ruby/ruby/blob/3f306dc/parse.y#L6873-L6892">github.com/ruby/ruby/blob/3f306dc/parse.y#L6873-L6892</a> Emacs handling in parse.y # # source://rubocop//lib/rubocop/magic_comment.rb#190 class RuboCop::MagicComment::EmacsComment &lt; ::RuboCop::MagicComment::EditorComment</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_frozen_string_literal</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_frozen_string_literal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_shareable_constant_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Emacs comments cannot specify Sorbet typechecking behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_typed</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#192 RuboCop::MagicComment::EmacsComment::FORMAT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#194 RuboCop::MagicComment::EmacsComment::OPERATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#191 RuboCop::MagicComment::EmacsComment::REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#193 RuboCop::MagicComment::EmacsComment::SEPARATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#11 RuboCop::MagicComment::KEYWORDS = T.let(T.unsafe(nil), Hash)</p>

<p># Wrapper for regular magic comments not bound to an editor. # # Simple comments can only specify one setting per comment. # # @example frozen string literal comments #   comment1 = RuboCop::MagicComment.parse(‘# frozen_string_literal: true’) #   comment1.frozen_string_literal # =&gt; true #   comment1.encoding              # =&gt; nil # @example encoding comments #   comment2 = RuboCop::MagicComment.parse(‘# encoding: utf-8’) #   comment2.frozen_string_literal # =&gt; nil #   comment2.encoding              # =&gt; ‘utf-8’ # # source://rubocop//lib/rubocop/magic_comment.rb#265 class RuboCop::MagicComment::SimpleComment &lt; ::RuboCop::MagicComment</p>

<pre class="ruby"><span class="ruby-comment"># Match `encoding` or `coding`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_frozen_string_literal</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Rewrite the comment without a given token type</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#274</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># Extract `frozen_string_literal`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The `frozen_string_literal` magic comment only works if it</span>
<span class="ruby-comment"># is the only text in the comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Case-insensitive and dashes/underscores are acceptable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @see https://github.com/ruby/ruby/blob/78b95b49f8/parse.y#L7134-L7138</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_frozen_string_literal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#299</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_shareable_constant_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_typed</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#266 RuboCop::MagicComment::SimpleComment::FSTRING_LITERAL_COMMENT = T.let(T.unsafe(nil), String)</p>

<p># IRB’s pattern for matching magic comment tokens. # # @see <a href="https://github.com/ruby/ruby/blob/b4a55c1/lib/irb/magic-file.rb#L5">github.com/ruby/ruby/blob/b4a55c1/lib/irb/magic-file.rb#L5</a> # # source://rubocop//lib/rubocop/magic_comment.rb#10 RuboCop::MagicComment::TOKEN = T.let(T.unsafe(nil), String)</p>

<p># Wrapper for Vim style magic comments. # # @example Vim style comment #   comment = RuboCop::MagicComment.parse( #   ‘# vim: filetype=ruby, fileencoding=ascii-8bit’ #   ) # #   comment.encoding # =&gt; ‘ascii-8bit’ # # source://rubocop//lib/rubocop/magic_comment.rb#222 class RuboCop::MagicComment::VimComment &lt; ::RuboCop::MagicComment::EditorComment</p>

<pre class="ruby"><span class="ruby-comment"># For some reason the fileencoding keyword only works if there</span>
<span class="ruby-comment"># is at least one other token included in the string. For example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#    # works</span>
<span class="ruby-comment">#      # vim: foo=bar, fileencoding=ascii-8bit</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#    # does nothing</span>
<span class="ruby-comment">#      # vim: foo=bar, fileencoding=ascii-8bit</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Vim comments cannot specify Sorbet typechecking behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_typed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Vim comments cannot specify frozen string literal behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">frozen_string_literal</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Vim comments cannot specify shareable constant values behavior.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/magic_comment.rb#246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shareable_constant_value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#224 RuboCop::MagicComment::VimComment::FORMAT = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#227 RuboCop::MagicComment::VimComment::KEYWORDS = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#226 RuboCop::MagicComment::VimComment::OPERATOR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#223 RuboCop::MagicComment::VimComment::REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/magic_comment.rb#225 RuboCop::MagicComment::VimComment::SEPARATOR = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for finding names that are similar to a given name. # # @api private # # source://rubocop//lib/rubocop/name_similarity.rb#6 module RuboCop::NameSimilarity</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/name_similarity.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_similar_name</span>(<span class="ruby-identifier">target_name</span>, <span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/name_similarity.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_similar_names</span>(<span class="ruby-identifier">target_name</span>, <span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/name_similarity.rb#9</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_similar_name</span>(<span class="ruby-identifier">target_name</span>, <span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/name_similarity.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_similar_names</span>(<span class="ruby-identifier">target_name</span>, <span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/ast_aliases.rb#5 RuboCop::NodePattern = RuboCop::AST::NodePattern</p>

<p># source://rubocop//lib/rubocop/options.rb#10 class RuboCop::OptionArgumentError &lt; ::StandardError; end</p>

<p># This class handles command line options. # # @api private # # source://rubocop//lib/rubocop/options.rb#14 class RuboCop::Options</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Options] a new instance of Options</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">command_line_args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_additional_modes</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># the autocorrect command-line arguments map to the autocorrect @options values like so:</span>
<span class="ruby-comment">#                            :fix_layout  :autocorrect  :safe_autocorrect  :autocorrect_all</span>
<span class="ruby-comment"># -x, --fix-layout           true         true          -                  -</span>
<span class="ruby-comment"># -a, --auto-correct         -            true          true               -</span>
<span class="ruby-comment">#     --safe-auto-correct    -            true          true               -</span>
<span class="ruby-comment"># -A, --auto-correct-all     -            true          -                  true</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_autocorrection_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_cache_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_check_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_config_generation_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_cop_selection_csv_option</span>(<span class="ruby-identifier">option</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_general_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_lsp_option</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_output_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_profile_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_server_options</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_severity_option</span>(<span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">define_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_deprecated_option</span>(<span class="ruby-identifier">old_option</span>, <span class="ruby-identifier">new_option</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Finds the option in `args` starting with -- and converts it to a symbol,</span>
<span class="ruby-comment"># e.g. [..., &#39;--autocorrect&#39;, ...] to :autocorrect.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#298</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">long_opt_symbol</span>(<span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets a value in the @options hash, based on the given long option and its</span>
<span class="ruby-comment"># value, in addition to calling the block if a block is given.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">option</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">plugin_feature</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rainbow</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#309</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_feature</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Creates a section of options in order to separate them visually when</span>
<span class="ruby-comment"># using `--help`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">section</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-identifier">heading</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#20 RuboCop::Options::DEFAULT_MAXIMUM_EXCLUSION_ITEMS = T.let(T.unsafe(nil), Integer)</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#19 RuboCop::Options::EXITING_OPTIONS = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#15 RuboCop::Options::E_STDIN_NO_PATH = T.let(T.unsafe(nil), String)</p>

<p># This module contains help texts for command line options. # # @api private # # source://rubocop//lib/rubocop/options.rb#512 module RuboCop::OptionsHelp; end</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#514 RuboCop::OptionsHelp::FORMATTER_OPTION_LIST = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#513 RuboCop::OptionsHelp::MAX_EXCL = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/options.rb#516 RuboCop::OptionsHelp::TEXT = T.let(T.unsafe(nil), Hash)</p>

<p># Validates option arguments and the options’ compatibility with each other. # # @api private # # source://rubocop//lib/rubocop/options.rb#327 class RuboCop::OptionsValidator</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [OptionsValidator] a new instance of OptionsValidator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#486</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">boolean_or_empty_cache?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#456</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_parallel_when_invalid_option_combo</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#482</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">except_syntax?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#490</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">incompatible_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#469</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalid_arguments_for_parallel</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#477</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">only_includes_redundant_disable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#397</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_auto_gen_config</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#442</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_autocorrect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#502</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_cache_enabled_for_cache_root</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_compatibility</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#369</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_cop_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_display_only_correctable_and_autocorrect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#410</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_display_only_failed</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#427</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_display_only_failed_and_display_only_correctable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionParser::MissingArgument]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#494</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_exclude_limit_option</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [OptionArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#436</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_lsp_and_editor_mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Cop name validation must be done later than option parsing, so it&#39;s not</span>
  <span class="ruby-comment"># called from within Options.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#334</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_cop_list</span>(<span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/options.rb#351</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">format_message_from</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">cop_names</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common methods and behaviors for dealing with paths. # # source://rubocop//lib/rubocop/path_util.rb#5 module RuboCop::PathUtil</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># Returns true for an absolute Unix or Windows path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">absolute?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns true for a glob</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">glob?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_dir?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_file?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_file_in_not_hidden_dir?</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_path?</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Loose check to reduce memory allocations</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maybe_hidden_file?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_path</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">base_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_file?</span>(<span class="ruby-identifier">uri</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smart_path</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns true for an absolute Unix or Windows path.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#83</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">absolute?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns true for a glob</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#88</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">glob?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#118</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_dir?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#101</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_file?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#92</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hidden_file_in_not_hidden_dir?</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#55</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_path?</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Loose check to reduce memory allocations</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#108</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maybe_hidden_file?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_path</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">base_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute relative_paths_cache.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_paths_cache</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute relative_paths_cache</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute relative_paths_cache to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative_paths_cache=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remote_file?</span>(<span class="ruby-identifier">uri</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/path_util.rb#38</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">smart_path</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/path_util.rb#105 RuboCop::PathUtil::HIDDEN_FILE_PATTERN = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/path_util.rb#35 RuboCop::PathUtil::SMART_PATH_CACHE = T.let(T.unsafe(nil), Hash)</p>

<p># Reports information about pending cops that are not explicitly configured. # # This class is responsible for displaying warnings when new cops have been added to RuboCop # but have not yet been enabled or disabled in the user’s configuration. # It provides a centralized way to determine whether such warnings should be shown, # based on global flags or configuration settings. # # source://rubocop//lib/rubocop/pending_cops_reporter.rb#10 class RuboCop::PendingCopsReporter</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Returns the value of attribute disable_pending_cops.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_pending_cops</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute disable_pending_cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute disable_pending_cops to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">disable_pending_cops=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute enable_pending_cops.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_pending_cops</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Sets the attribute enable_pending_cops</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @param value the value to set the attribute enable_pending_cops to.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enable_pending_cops=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warn_if_needed</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pending_cops_only_qualified</span>(<span class="ruby-identifier">pending_cops</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#35</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">possible_new_cops?</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warn_on_pending_cops</span>(<span class="ruby-identifier">pending_cops</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/pending_cops_reporter.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warn_pending_cop</span>(<span class="ruby-identifier">cop</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module provides information on the platform that RuboCop is being run # on. # # source://rubocop//lib/rubocop/platform.rb#6 module RuboCop::Platform</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/platform.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">windows?</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Provides a plugin for RuboCop extensions that conform to lint_roller. # <a href="https://github.com/standardrb/lint_roller">github.com/standardrb/lint_roller</a> # # @api private # # source://rubocop//lib/rubocop/plugin/not_supported_error.rb#4 module RuboCop::Plugin</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integrate_plugins</span>(<span class="ruby-identifier">rubocop_config</span>, <span class="ruby-identifier">plugins</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">plugin_capable?</span>(<span class="ruby-identifier">feature_name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/plugin.rb#11 RuboCop::Plugin::BUILTIN_INTERNAL_PLUGINS = T.let(T.unsafe(nil), Hash)</p>

<p># A class for integrating plugin configurations into RuboCop. # Handles configuration merging, validation, and compatibility for plugins. # # @api private # # source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#11 class RuboCop::Plugin::ConfigurationIntegrator</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#13</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">integrate_plugins_into_rubocop_config</span>(<span class="ruby-identifier">rubocop_config</span>, <span class="ruby-identifier">plugins</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">combine_rubocop_configs</span>(<span class="ruby-identifier">default_config</span>, <span class="ruby-identifier">runner_context</span>, <span class="ruby-identifier">plugins</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#27</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_context</span>(<span class="ruby-identifier">rubocop_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#81</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fake_out_rubocop_default_configuration</span>(<span class="ruby-identifier">default_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#92</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load_plugin_rubocop_config</span>(<span class="ruby-identifier">plugin</span>, <span class="ruby-identifier">runner_context</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># This is how we ensure &quot;first-in wins&quot;: plugins can override AllCops settings that are</span>
  <span class="ruby-comment"># set by RuboCop&#39;s default configuration, but once a plugin sets an AllCop setting, they</span>
  <span class="ruby-comment"># have exclusive first-in-wins rights to that setting.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The one exception to this are array fields, because we don&#39;t want to</span>
  <span class="ruby-comment"># overwrite the AllCops defaults but rather munge the arrays (`existing |</span>
  <span class="ruby-comment"># new`) to allow plugins to add to the array, for example Include and</span>
  <span class="ruby-comment"># Exclude paths and patterns.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#118</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_all_cop_settings</span>(<span class="ruby-identifier">existing_all_cops</span>, <span class="ruby-identifier">new_all_cops</span>, <span class="ruby-identifier">already_configured_keys</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#67</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_plugin_config_into_all_cops!</span>(<span class="ruby-identifier">rubocop_config</span>, <span class="ruby-identifier">plugin_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#71</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_plugin_config_into_default_config!</span>(<span class="ruby-identifier">default_config</span>, <span class="ruby-identifier">plugin_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#137</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolver</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @raise [Plugin::NotSupportedError]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/configuration_integrator.rb#37</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_plugins!</span>(<span class="ruby-identifier">plugins</span>, <span class="ruby-identifier">runner_context</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/plugin.rb#18 RuboCop::Plugin::INTERNAL_AFFAIRS_PLUGIN_NAME = T.let(T.unsafe(nil), String)</p>

<p># An exception raised when a plugin fails to load. # # @api private # # source://rubocop//lib/rubocop/plugin/load_error.rb#7 class RuboCop::Plugin::LoadError &lt; ::RuboCop::Error</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [LoadError] a new instance of LoadError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/load_error.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">plugin_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/load_error.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A class for loading and resolving plugins. # # @api private # # source://rubocop//lib/rubocop/plugin/loader.rb#10 class RuboCop::Plugin::Loader</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#20</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load</span>(<span class="ruby-identifier">plugins</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#70</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constantize</span>(<span class="ruby-identifier">plugin_name</span>, <span class="ruby-identifier">plugin_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#61</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constantize_plugin_from</span>(<span class="ruby-identifier">plugin_name</span>, <span class="ruby-identifier">plugin_config</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#90</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">constantize_plugin_from_gemspec_metadata</span>(<span class="ruby-identifier">plugin_name</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#34</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">normalize</span>(<span class="ruby-identifier">plugin_configs</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/loader.rb#86</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">require_plugin</span>(<span class="ruby-identifier">require_path</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/plugin/loader.rb#12 RuboCop::Plugin::Loader::DEFAULT_PLUGIN_CONFIG = T.let(T.unsafe(nil), Hash)</p>

<p># An exception raised when a plugin is not supported by the RuboCop engine. # # @api private # # source://rubocop//lib/rubocop/plugin/not_supported_error.rb#7 class RuboCop::Plugin::NotSupportedError &lt; ::RuboCop::Error</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [NotSupportedError] a new instance of NotSupportedError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/not_supported_error.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">unsupported_plugins</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/plugin/not_supported_error.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">message</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/plugin.rb#19 RuboCop::Plugin::OBSOLETE_INTERNAL_AFFAIRS_PLUGIN_NAME = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/ast_aliases.rb#6 RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource</p>

<p># Common methods and behaviors for dealing with remote config files. # # @api private # # source://rubocop//lib/rubocop/remote_config.rb#9 class RuboCop::RemoteConfig</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [RemoteConfig] a new instance of RemoteConfig</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">base_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherit_from_remote</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uri</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_name_from_uri</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_path_exists?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_path_expired?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cloned_url</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @yield [request]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_request</span>(<span class="ruby-identifier">uri</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_response</span>(<span class="ruby-identifier">response</span>, <span class="ruby-identifier">limit</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/remote_config.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">request</span>(<span class="ruby-identifier">uri</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">limit</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/remote_config.rb#12 RuboCop::RemoteConfig::CACHE_LIFETIME = T.let(T.unsafe(nil), Integer)</p>

<p># Provides functionality for caching RuboCop runs. # # @api private # # source://rubocop//lib/rubocop/result_cache.rb#11 class RuboCop::ResultCache</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [ResultCache] a new instance of ResultCache</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">team</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">config_store</span>, <span class="ruby-identifier">cache_root_override</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">load</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">save</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_symlink?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># We combine team and options into a single &quot;context&quot; checksum to avoid</span>
<span class="ruby-comment"># making file names that are too long for some filesystems to handle.</span>
<span class="ruby-comment"># This context is for anything that&#39;s not (1) the RuboCop executable</span>
<span class="ruby-comment"># checksum or (2) the inspected file checksum.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">context_checksum</span>(<span class="ruby-identifier">team</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">digest</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_checksum</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">config_store</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Return a hash of the options given at invocation, minus the ones that have</span>
<span class="ruby-comment"># no effect on which offenses and disabled line ranges are found, and thus</span>
<span class="ruby-comment"># don&#39;t affect caching.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relevant_options_digest</span>(<span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The checksum of the RuboCop program running the inspection.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#174</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_checksum</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_extra_features</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">symlink_protection_triggered?</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#81</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">allow_symlinks_in_cache_location?</span>(<span class="ruby-identifier">config_store</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#75</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_root</span>(<span class="ruby-identifier">config_store</span>, <span class="ruby-identifier">cache_root_override</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Remove old files so that the cache doesn&#39;t grow too big. When the</span>
  <span class="ruby-comment"># threshold MaxFilesInCache has been exceeded, the oldest 50% of all the</span>
  <span class="ruby-comment"># files in the cache are removed. The reason for removing so much is that</span>
  <span class="ruby-comment"># cleaning should be done relatively seldom, since there is a slight risk</span>
  <span class="ruby-comment"># that some other RuboCop process was just about to read the file, when</span>
  <span class="ruby-comment"># there&#39;s parallel execution and the cache is shared.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#28</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cleanup</span>(<span class="ruby-identifier">config_store</span>, <span class="ruby-identifier">verbose</span>, <span class="ruby-identifier">cache_root_override</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#170</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inhibit_cleanup</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#170</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inhibit_cleanup=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_required_features</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_required_features=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#170</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_checksum</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#170</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_checksum=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#65</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_files</span>(<span class="ruby-identifier">files</span>, <span class="ruby-identifier">dirs</span>, <span class="ruby-identifier">remove_count</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_oldest_files</span>(<span class="ruby-identifier">files</span>, <span class="ruby-identifier">dirs</span>, <span class="ruby-identifier">rubocop_cache_dir</span>, <span class="ruby-identifier">verbose</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/result_cache.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">requires_file_removal?</span>(<span class="ruby-identifier">file_count</span>, <span class="ruby-identifier">config_store</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/result_cache.rb#16 RuboCop::ResultCache::DL_EXTENSIONS = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/result_cache.rb#12 RuboCop::ResultCache::NON_CHANGING = T.let(T.unsafe(nil), Array)</p>

<p># This class handles the processing of files, which includes dealing with # formatters and letting cops inspect the files. # # source://rubocop//lib/rubocop/runner.rb#8 class RuboCop::Runner</p>

<pre class="ruby"><span class="ruby-comment"># @return [Runner] a new instance of Runner</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">config_store</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute aborting</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value the value to set the attribute aborting to.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aborting=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">aborting?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute errors.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">errors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">run</span>(<span class="ruby-identifier">paths</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute warnings.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warnings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_redundant_disables</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>, <span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cached_result</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">team</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cached_run?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Check whether a run created source identical to a previous run, which</span>
<span class="ruby-comment"># means that we definitely have an infinite loop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_infinite_loop</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">offenses_by_iteration</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#225</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check_for_redundant_disables?</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#433</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">considered_failure?</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#470</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_config</span>(<span class="ruby-identifier">cop_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_inspection_loop</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_inspected_file</span>(<span class="ruby-identifier">files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">except_redundant_cop_disable_directive?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_ruby_sources</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_finished</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_offense_cache</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_offenses</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_started</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter_cop_classes</span>(<span class="ruby-identifier">cop_classes</span>, <span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_target_files</span>(<span class="ruby-identifier">paths</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">formatter_set</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#485</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">get_processed_source</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_file</span>(<span class="ruby-identifier">processed_source</span>, <span class="ruby-identifier">team</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect_files</span>(<span class="ruby-identifier">files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iterate_until_no_changes</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">offenses_by_iteration</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">list_files</span>(<span class="ruby-identifier">paths</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#466</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mark_as_safe_by_config?</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#474</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minimum_severity_to_fail</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mobilize_team</span>(<span class="ruby-identifier">processed_source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#379</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mobilized_cop_classes</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#442</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offense_displayed?</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#454</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses_to_report</span>(<span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_file</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">qualify_option_cop_names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [cop]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redundant_cop_disable_directive</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">save_in_cache</span>(<span class="ruby-identifier">cache</span>, <span class="ruby-identifier">offenses</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A Cop::Team instance is stateful and may change when inspecting.</span>
<span class="ruby-comment"># The &quot;standby&quot; team for a given config is an initialized but</span>
<span class="ruby-comment"># otherwise dormant team that can be used for config- and option-</span>
<span class="ruby-comment"># level caching in ResultCache.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#517</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">standby_team</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">style_guide_cops_only?</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#458</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supports_safe_autocorrect?</span>(<span class="ruby-identifier">offense</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [team]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">team_for_redundant_disables</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">offenses</span>, <span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Warms up the RuboCop cache by forking a suitable number of RuboCop</span>
<span class="ruby-comment"># instances that each inspects its allotted group of files.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">warm_cache</span>(<span class="ruby-identifier">target_files</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @return [Array&lt;#call&gt;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#29</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_extractors</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># @return [#call]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#36</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_ruby_extractor</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># An exception indicating that the inspection loop got stuck correcting # offenses back and forth. # # source://rubocop//lib/rubocop/runner.rb#11 class RuboCop::Runner::InfiniteCorrectionLoop &lt; ::StandardError</p>

<pre class="ruby"><span class="ruby-comment"># @return [InfiniteCorrectionLoop] a new instance of InfiniteCorrectionLoop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">offenses_by_iteration</span>, <span class="ruby-value">loop_start:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute offenses.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/runner.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">offenses</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/runner.rb#49 RuboCop::Runner::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)</p>

<p># @api private # # source://rubocop//lib/rubocop/runner.rb#52 RuboCop::Runner::REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = T.let(T.unsafe(nil), Array)</p>

<p># Take a string with embedded escapes, and convert the escapes as the Ruby # interpreter would when reading a double-quoted string literal. # For example, “\n” will be converted to “n”. # # source://rubocop//lib/rubocop/string_interpreter.rb#7 class RuboCop::StringInterpreter</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/string_interpreter.rb#24</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/string_interpreter.rb#51</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_hex</span>(<span class="ruby-identifier">escape</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/string_interpreter.rb#55</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_octal</span>(<span class="ruby-identifier">escape</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/string_interpreter.rb#33</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_string_escape</span>(<span class="ruby-identifier">escape</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop//lib/rubocop/string_interpreter.rb#43</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpret_unicode</span>(<span class="ruby-identifier">escape</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/string_interpreter.rb#8 RuboCop::StringInterpreter::STRING_ESCAPES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/string_interpreter.rb#12 RuboCop::StringInterpreter::STRING_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># This class finds target files to inspect by scanning the directory tree and picking ruby files. # # @api private # # source://rubocop//lib/rubocop/target_finder.rb#6 class RuboCop::TargetFinder</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [TargetFinder] a new instance of TargetFinder</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config_store</span>, <span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Generate a list of target files by expanding globbing patterns (if any). If args is empty,</span>
<span class="ruby-comment"># recursively find all Ruby source files under the current directory</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Array] array of file paths</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find</span>(<span class="ruby-identifier">args</span>, <span class="ruby-identifier">mode</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Search for files recursively starting at the given base directory using the given flags that</span>
<span class="ruby-comment"># determine how the match is made. Excluded files will be removed later by the caller, but as an</span>
<span class="ruby-comment"># optimization find_files removes the top level directories that are excluded in configuration</span>
<span class="ruby-comment"># in the normal way (dir/**/*).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_files</span>(<span class="ruby-identifier">base_dir</span>, <span class="ruby-identifier">flags</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Finds all Ruby source files under the current or other supplied directory. A Ruby source file</span>
<span class="ruby-comment"># is defined as a file with the `.rb` extension or a file with no extension that has a ruby</span>
<span class="ruby-comment"># shebang line as its first line.</span>
<span class="ruby-comment"># It is possible to specify includes and excludes using the config file, so you can include</span>
<span class="ruby-comment"># other Ruby files like Rakefiles and gemspecs.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @param base_dir Root directory under which to search for</span>
<span class="ruby-comment">#   ruby source files</span>
<span class="ruby-comment"># @return [Array] Array of filenames</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_files_in_dir</span>(<span class="ruby-identifier">base_dir</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all_cops_include</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">combined_exclude_glob_patterns</span>(<span class="ruby-identifier">base_dir</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#177</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">configured_include?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">debug?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fail_fast?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_exclusion?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_parent_exclusion?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included_file?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">order</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">process_explicit_path</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">mode</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_executable?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_extension?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_extensions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_file?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_filename?</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_filenames</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_interpreters</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stdin?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">symlink_excluded_or_infinite_loop?</span>(<span class="ruby-identifier">base_dir</span>, <span class="ruby-identifier">current_dir</span>, <span class="ruby-identifier">exclude_pattern</span>, <span class="ruby-identifier">flags</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_inspect?</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">hidden_files</span>, <span class="ruby-identifier">base_dir_config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wanted_dir_patterns</span>(<span class="ruby-identifier">base_dir</span>, <span class="ruby-identifier">exclude_pattern</span>, <span class="ruby-identifier">flags</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_finder.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without_excluded</span>(<span class="ruby-identifier">files</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/target_finder.rb#7 RuboCop::TargetFinder::HIDDEN_PATH_SUBSTRING = T.let(T.unsafe(nil), String)</p>

<p># The kind of Ruby that code inspected by RuboCop is written in. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#6 class RuboCop::TargetRuby</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [TargetRuby] a new instance of TargetRuby</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#273</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#289</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_version_with_support</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#258</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">supported_versions</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The lock file of Bundler may identify the target ruby version. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#205 class RuboCop::TargetRuby::BundlerLockFile &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#239</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bundler_lock_file_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#8 RuboCop::TargetRuby::DEFAULT_VERSION = T.let(T.unsafe(nil), Float)</p>

<p># If all else fails, a default version will be picked. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#246 class RuboCop::TargetRuby::Default &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The target ruby version may be found in a .gemspec file. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#67 class RuboCop::TargetRuby::GemspecFile &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gem_requirement_versions</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">required_ruby_version</span>(<span class="ruby-identifier">param0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_minimal_known_ruby</span>(<span class="ruby-identifier">right_hand_side</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gemspec_filepath</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_from_array</span>(<span class="ruby-identifier">array</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_from_gemspec_file</span>(<span class="ruby-identifier">file</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_from_right_hand_side</span>(<span class="ruby-identifier">right_hand_side</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#7 RuboCop::TargetRuby::KNOWN_RUBIES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#10 RuboCop::TargetRuby::OBSOLETE_RUBIES = T.let(T.unsafe(nil), Hash)</p>

<p># The target ruby version may be configured in RuboCop’s config. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#53 class RuboCop::TargetRuby::RuboCopConfig &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The target ruby version may be configured by setting the # ‘RUBOCOP_TARGET_RUBY_VERSION` environment variable. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#39 class RuboCop::TargetRuby::RuboCopEnvVar &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The target ruby version may be found in a .ruby-version file. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#151 class RuboCop::TargetRuby::RubyVersionFile &lt; ::RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filename</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version_file</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#152 RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_FILENAME = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#153 RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#262 RuboCop::TargetRuby::SOURCES = T.let(T.unsafe(nil), Array)</p>

<p># A place where information about a target ruby version is found. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#24 class RuboCop::TargetRuby::Source</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Source] a new instance of Source</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">config</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The target ruby version may be found in a .tool-versions file, in a line # starting with ‘ruby`. # # @api private # # source://rubocop//lib/rubocop/target_ruby.rb#184 class RuboCop::TargetRuby::ToolVersionsFile &lt; ::RuboCop::TargetRuby::RubyVersionFile</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filename</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/target_ruby.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#185 RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_FILENAME = T.let(T.unsafe(nil), String)</p>

<p># @api private # # source://rubocop//lib/rubocop/target_ruby.rb#186 RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_PATTERN = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop//lib/rubocop/ast_aliases.rb#7 RuboCop::Token = RuboCop::AST::Token</p>

<p># This module contains a collection of useful utility methods. # # source://rubocop//lib/rubocop/util.rb#5 module RuboCop::Util</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/util.rb#6</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">silence_warnings</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/error.rb#10 class RuboCop::ValidationError &lt; ::RuboCop::Error; end</p>

<p># This module holds the RuboCop version information. # # source://rubocop//lib/rubocop/version.rb#5 module RuboCop::Version</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#121</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">config_for_pwd</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#151</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">document_version</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#74</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extension_versions</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns feature version in one of two ways:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Find by RuboCop core version style (e.g. rubocop-performance, rubocop-rspec)</span>
  <span class="ruby-comment"># * Find by `bundle gem` version style (e.g. rubocop-rake)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#135</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">feature_version</span>(<span class="ruby-identifier">feature</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#57</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_version</span>(<span class="ruby-identifier">target_ruby_version</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#156</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">server_mode</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#112</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">target_ruby_version</span>(<span class="ruby-identifier">env</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#52</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">verbose</span>(<span class="ruby-value">env:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># NOTE: Marked as private but used by gems like standard.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/version.rb#26</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">version</span>(<span class="ruby-value">debug:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">env:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop//lib/rubocop/version.rb#15 RuboCop::Version::CANONICAL_FEATURE_NAMES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/version.rb#19 RuboCop::Version::EXTENSION_PATH_NAMES = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop//lib/rubocop/version.rb#13 RuboCop::Version::MINIMUM_PARSABLE_PRISM_VERSION = T.let(T.unsafe(nil), Float)</p>

<p># source://rubocop//lib/rubocop/version.rb#8 RuboCop::Version::MSG = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop//lib/rubocop/version.rb#6 RuboCop::Version::STRING = T.let(T.unsafe(nil), String)</p>

<p># A Warning exception is different from an Offense with severity ‘warning’ # When a Warning is raised, this means that RuboCop was unable to perform a # requested operation (such as inspecting or correcting a source file) due to # user error # For example, a configuration value in .rubocop.yml might be malformed # # source://rubocop//lib/rubocop/warning.rb#9 class RuboCop::Warning &lt; ::StandardError; end</p>

<p># Find duplicated keys from YAML. # # @api private # # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#6 module RuboCop::YAMLDuplicationChecker</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop//lib/rubocop/yaml_duplication_checker.rb#7</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">yaml_string</span>, <span class="ruby-identifier">filename</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">on_duplicated</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop//lib/rubocop/yaml_duplication_checker.rb#14 class RuboCop::YAMLDuplicationChecker::DuplicationCheckHandler &lt; ::Psych::TreeBuilder</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [DuplicationCheckHandler] a new instance of DuplicationCheckHandler</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/yaml_duplication_checker.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop//lib/rubocop/yaml_duplication_checker.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_mapping</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Extensions to the core String class # # source://rubocop//lib/rubocop/core_ext/string.rb#4 class String</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>
</pre>

<p>end</p>

</main>

