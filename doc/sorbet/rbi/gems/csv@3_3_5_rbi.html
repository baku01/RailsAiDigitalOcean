<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>csv@3.3.5.rbi - RDoc Documentation</title>

  <meta name="keywords" content="ruby,documentation,csv@3.3.5.rbi">
  <meta name="description" content="csv@3.3.5.rbi: false # DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the `csv` gem. tapioca gem csv`.">


<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../Dockerfile.html">Dockerfile</a>
    <li><a href="../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../README_md.html">README</a>
    <li><a href="../../../Rakefile.html">Rakefile</a>
    <li><details><summary>app</summary>
    <ul class="link-list">
      <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
      <li><a href="../../../app/views/pwa/service-worker_js.html">service-worker.js</a>
    </ul></details>
    <li><a href="../../../bin/docker-entrypoint.html">docker-entrypoint</a>
    <li><a href="../../../config_ru.html">config.ru</a>
    <li><details><summary>config</summary>
    <ul class="link-list">
      <li><a href="../../../config/credentials_yml_enc.html">credentials.yml.enc</a>
      <li><a href="../../../config/master_key.html">master.key</a>
    </ul></details>
    <li><details><summary>log</summary>
    <ul class="link-list">
      <li><a href="../../../log/development_log.html">development.log</a>
      <li><a href="../../../log/test_log.html">test.log</a>
    </ul></details>
    <li><details><summary>public</summary>
    <ul class="link-list">
      <li><a href="../../../public/400_html.html">400.html</a>
      <li><a href="../../../public/404_html.html">404.html</a>
      <li><a href="../../../public/406-unsupported-browser_html.html">406-unsupported-browser.html</a>
      <li><a href="../../../public/422_html.html">422.html</a>
      <li><a href="../../../public/500_html.html">500.html</a>
      <li><a href="../../../public/robots_txt.html">robots</a>
    </ul></details>
    <li><details open><summary>sorbet</summary>
    <ul class="link-list">
      <li><a href="../../../sorbet/config.html">config</a>
      <li><a href="../../../sorbet/rbi/annotations/actionmailer_rbi.html">actionmailer.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionpack_rbi.html">actionpack.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionview_rbi.html">actionview.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activejob_rbi.html">activejob.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activemodel_rbi.html">activemodel.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activerecord_rbi.html">activerecord.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activesupport_rbi.html">activesupport.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/globalid_rbi.html">globalid.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/minitest_rbi.html">minitest.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/railties_rbi.html">railties.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/rainbow_rbi.html">rainbow.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching/fragments_rbi.html">fragments.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/conditional_get_rbi.html">conditional_get.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/content_security_policy_rbi.html">content_security_policy.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/data_streaming_rbi.html">data_streaming.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_flash_rbi.html">etag_with_flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_template_digest_rbi.html">etag_with_template_digest.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/flash_rbi.html">flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/form_builder_rbi.html">form_builder.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/params_wrapper_rbi.html">params_wrapper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/redirecting_rbi.html">redirecting.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers_rbi.html">renderers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers/all_rbi.html">all.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/request_forgery_protection_rbi.html">request_forgery_protection.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/rescue_rbi.html">rescue.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/test_case/behavior_rbi.html">behavior.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/assertions_rbi.html">assertions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/integration_test_rbi.html">integration_test.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/route_set/mounted_helpers_rbi.html">mounted_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_helper_rbi.html">form_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_tag_helper_rbi.html">form_tag_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/text_helper_rbi.html">text_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/layouts_rbi.html">layouts.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/enqueuing_rbi.html">enqueuing.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/exceptions_rbi.html">exceptions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/execution_rbi.html">execution.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/logging_rbi.html">logging.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_adapter_rbi.html">queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_name_rbi.html">queue_name.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_priority_rbi.html">queue_priority.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/test_helper/test_queue_adapter_rbi.html">test_queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attribute_methods_rbi.html">attribute_methods.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attributes_rbi.html">attributes.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/serializers/json_rbi.html">json.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations_rbi.html">validations.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/actionable_error_rbi.html">actionable_error.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/rescuable_rbi.html">rescuable.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/testing/file_fixtures_rbi.html">file_fixtures.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/application_controller_rbi.html">application_controller.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/base_generator_rbi.html">base_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/form_generator_rbi.html">form_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_path_helpers_module_rbi.html">generated_path_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_rbi.html">generated_url_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_module_rbi.html">generated_url_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/policy_generator_rbi.html">policy_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/poro_generator_rbi.html">poro_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/service_generator_rbi.html">service_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/time_rbi.html">time.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/action_broadcast_job_rbi.html">action_broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_job_rbi.html">broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_stream_job_rbi.html">broadcast_stream_job.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actioncable@8_0_2_rbi.html">actioncable@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailbox@8_0_2_rbi.html">actionmailbox@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailer@8_0_2_rbi.html">actionmailer@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionpack@8_0_2_rbi.html">actionpack@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actiontext@8_0_2_rbi.html">actiontext@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionview@8_0_2_rbi.html">actionview@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activejob@8_0_2_rbi.html">activejob@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activemodel@8_0_2_rbi.html">activemodel@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activerecord@8_0_2_rbi.html">activerecord@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activestorage@8_0_2_rbi.html">activestorage@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activesupport@8_0_2_rbi.html">activesupport@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ast@2_4_3_rbi.html">ast@2.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/backport@1_2_0_rbi.html">backport@1.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/base64@0_3_0_rbi.html">base64@0.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bcrypt_pbkdf@1_1_1_rbi.html">bcrypt_pbkdf@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/benchmark@0_4_1_rbi.html">benchmark@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bigdecimal@3_2_2_rbi.html">bigdecimal@3.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bindex@0_8_1_rbi.html">bindex@0.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/brakeman@7_0_2_rbi.html">brakeman@7.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/commander@5_0_0_rbi.html">commander@5.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/concurrent-ruby@1_3_5_rbi.html">concurrent-ruby@1.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/connection_pool@2_5_3_rbi.html">connection_pool@2.5.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/crass@1_0_6_rbi.html">crass@1.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/csv@3_3_5_rbi.html">csv@3.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/date@3_4_1_rbi.html">date@3.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/diff-lcs@1_6_2_rbi.html">diff-lcs@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/dotenv@3_1_8_rbi.html">dotenv@3.1.8.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/drb@2_2_3_rbi.html">drb@2.2.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/e2mmap@0_1_0_rbi.html">e2mmap@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ed25519@1_4_0_rbi.html">ed25519@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erb@5_0_1_rbi.html">erb@5.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erubi@1_13_1_rbi.html">erubi@1.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/globalid@1_2_1_rbi.html">globalid@1.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/highline@3_0_1_rbi.html">highline@3.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/httparty@0_23_1_rbi.html">httparty@0.23.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/i18n@1_14_7_rbi.html">i18n@1.14.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/importmap-rails@2_1_0_rbi.html">importmap-rails@2.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/io-console@0_8_0_rbi.html">io-console@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/jaro_winkler@1_6_1_rbi.html">jaro_winkler@1.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/json@2_12_2_rbi.html">json@2.12.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kamal@2_7_0_rbi.html">kamal@2.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown-parser-gfm@1_1_0_rbi.html">kramdown-parser-gfm@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown@2_5_1_rbi.html">kramdown@2.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/language_server-protocol@3_17_0_5_rbi.html">language_server-protocol@3.17.0.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/lint_roller@1_1_0_rbi.html">lint_roller@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/logger@1_7_0_rbi.html">logger@1.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/loofah@2_24_1_rbi.html">loofah@2.24.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mail@2_8_1_rbi.html">mail@2.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/marcel@1_0_4_rbi.html">marcel@1.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/method_source@1_1_0_rbi.html">method_source@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mini_mime@1_1_5_rbi.html">mini_mime@1.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/minitest@5_25_5_rbi.html">minitest@5.25.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/multi_xml@0_7_2_rbi.html">multi_xml@0.7.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-imap@0_5_9_rbi.html">net-imap@0.5.9.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-pop@0_1_2_rbi.html">net-pop@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-protocol@0_2_2_rbi.html">net-protocol@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-scp@4_1_0_rbi.html">net-scp@4.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-sftp@4_0_0_rbi.html">net-sftp@4.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-smtp@0_5_1_rbi.html">net-smtp@0.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-ssh@7_3_0_rbi.html">net-ssh@7.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/netrc@0_11_0_rbi.html">netrc@0.11.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/nio4r@2_7_4_rbi.html">nio4r@2.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/observer@0_1_2_rbi.html">observer@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ostruct@0_6_2_rbi.html">ostruct@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parallel@1_27_0_rbi.html">parallel@1.27.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parlour@9_1_2_rbi.html">parlour@9.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parser@3_3_8_0_rbi.html">parser@3.3.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pattern_generator@0_1_0_rbi.html">pattern_generator@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/polyfill@1_9_0_rbi.html">polyfill@1.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pp@0_6_2_rbi.html">pp@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prettyprint@0_2_0_rbi.html">prettyprint@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prism@1_4_0_rbi.html">prism@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/propshaft@1_1_0_rbi.html">propshaft@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/psych@5_2_6_rbi.html">psych@5.2.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/puma@6_6_0_rbi.html">puma@6.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/racc@1_8_1_rbi.html">racc@1.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-session@2_1_1_rbi.html">rack-session@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-test@2_2_0_rbi.html">rack-test@2.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack@3_1_16_rbi.html">rack@3.1.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rackup@2_2_1_rbi.html">rackup@2.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-dom-testing@2_3_0_rbi.html">rails-dom-testing@2.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-html-sanitizer@1_6_2_rbi.html">rails-html-sanitizer@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails@8_0_2_rbi.html">rails@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/railties@8_0_2_rbi.html">railties@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rainbow@3_1_1_rbi.html">rainbow@3.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rake@13_3_0_rbi.html">rake@13.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbi@0_3_6_rbi.html">rbi@0.3.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbs@4_0_0_dev_4_rbi.html">rbs@4.0.0.dev.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rdoc@6_14_2_rbi.html">rdoc@6.14.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/redcarpet@3_6_1_rbi.html">redcarpet@3.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/regexp_parser@2_10_0_rbi.html">regexp_parser@2.10.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reline@0_6_1_rbi.html">reline@0.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/require-hooks@0_2_2_rbi.html">require-hooks@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reverse_markdown@2_1_1_rbi.html">reverse_markdown@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-core@3_13_5_rbi.html">rspec-core@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-expectations@3_13_5_rbi.html">rspec-expectations@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-mocks@3_13_5_rbi.html">rspec-mocks@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-rails@8_0_1_rbi.html">rspec-rails@8.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-support@3_13_4_rbi.html">rspec-support@3.13.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec@3_13_1_rbi.html">rspec@3.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-ast@1_45_1_rbi.html">rubocop-ast@1.45.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-performance@1_25_0_rbi.html">rubocop-performance@1.25.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails-omakase@1_1_0_rbi.html">rubocop-rails-omakase@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails@2_32_0_rbi.html">rubocop-rails@2.32.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop@1_78_0_rbi.html">rubocop@1.78.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp-rails@0_4_6_rbi.html">ruby-lsp-rails@0.4.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp@0_24_2_rbi.html">ruby-lsp@0.24.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-progressbar@1_13_0_rbi.html">ruby-progressbar@1.13.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/safe_type@1_1_1_rbi.html">safe_type@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/securerandom@0_4_1_rbi.html">securerandom@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph-rails@1_1_2_rbi.html">solargraph-rails@1.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph@0_48_0_rbi.html">solargraph@0.48.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-coerce@0_7_0_rbi.html">sorbet-coerce@0.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-rails@0_7_34_rbi.html">sorbet-rails@0.7.34.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-runtime-stub@0_2_0_rbi.html">sorbet-runtime-stub@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/spoom@1_7_4_rbi.html">spoom@1.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sshkit@1_24_0_rbi.html">sshkit@1.24.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stimulus-rails@1_3_4_rbi.html">stimulus-rails@1.3.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stringio@3_1_7_rbi.html">stringio@3.1.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tapioca@0_17_6_rbi.html">tapioca@0.17.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thor@1_3_2_rbi.html">thor@1.3.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thruster@0_1_14_rbi.html">thruster@0.1.14.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tilt@2_6_1_rbi.html">tilt@2.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/timeout@0_4_3_rbi.html">timeout@0.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/turbo-rails@2_0_16_rbi.html">turbo-rails@2.0.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tzinfo@2_0_6_rbi.html">tzinfo@2.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-display_width@3_1_4_rbi.html">unicode-display_width@3.1.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-emoji@4_0_4_rbi.html">unicode-emoji@4.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/uri@1_0_3_rbi.html">uri@1.0.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/useragent@0_16_11_rbi.html">useragent@0.16.11.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/web-console@4_2_1_rbi.html">web-console@4.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-driver@0_8_0_rbi.html">websocket-driver@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-extensions@0_1_5_rbi.html">websocket-extensions@0.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-kramdown@0_0_1_rbi.html">yard-kramdown@0.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-solargraph@0_1_0_rbi.html">yard-solargraph@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-sorbet@0_9_0_rbi.html">yard-sorbet@0.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard@0_9_37_rbi.html">yard@0.9.37.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/zeitwerk@2_7_3_rbi.html">zeitwerk@2.7.3.rbi</a>
      <li><a href="../../../sorbet/rbi/todo_rbi.html">todo.rbi</a>
    </ul></details>
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  </ul>
</div>


  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-label="Page sorbet/rbi/gems/csv@3.3.5.rbi">

<p># typed: false</p>

<p># DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the ‘csv` gem. # Please instead update this file by running `bin/tapioca gem csv`.</p>

<p># source://csv//lib/csv/core_ext/array.rb#1 class Array</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>

<span class="ruby-comment"># Equivalent to CSV::generate_line(self, options)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   [&quot;CSV&quot;, &quot;data&quot;].to_csv</span>
<span class="ruby-comment">#     #=&gt; &quot;CSV,data\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/core_ext/array.rb#6</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_csv</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># == CSV # # === CSV Data # # CSV (comma-separated values) data is a text representation of a table: # - A <em>row</em> <em>separator</em> delimits table rows. #   A common row separator is the newline character <code>&quot;\n&quot;</code>. # - A <em>column</em> <em>separator</em> delimits fields in a row. #   A common column separator is the comma character <code>&quot;,&quot;</code>. # # This CSV String, with row separator <code>&quot;\n&quot;</code> # and column separator <code>&quot;,&quot;</code>, # has three rows and two columns: #   “foo,0nbar,1nbaz,2n” # # Despite the name CSV, a CSV representation can use different separators. # # For more about tables, see the Wikipedia article # “<a href="https://en.wikipedia.org/wiki/Table_(information)">Table (information)</a>”, # especially its section # “<a href="https://en.wikipedia.org/wiki/Table_(information)#Simple_table">Simple table</a>” # # == Class CSV # # Class CSV provides methods for: # - Parsing CSV data from a String object, a File (via its file path), or an IO object. # - Generating CSV data to a String object. # # To make CSV available: #   require ‘csv’ # # All examples here assume that this has been done. # # == Keeping It Simple # # A CSV object has dozens of instance methods that offer fine-grained control # of parsing and generating CSV data. # For many needs, though, simpler approaches will do. # # This section summarizes the singleton methods in CSV # that allow you to parse and generate without explicitly # creating CSV objects. # For details, follow the links. # # === Simple Parsing # # Parsing methods commonly return either of: # - An Array of Arrays of Strings: #   - The outer Array is the entire “table”. #   - Each inner Array is a row. #   - Each String is a field. # - A CSV::Table object.  For details, see #   <a href="#class-CSV-label-CSV+with+Headers">CSV with Headers</a>. # # ==== Parsing a String # # The input to be parsed can be a string: #   string = “foo,0nbar,1nbaz,2n” # # Method CSV.parse returns the entire CSV data: #   CSV.parse(string) # =&gt; [[“foo”, “0”], [“bar”, “1”], [“baz”, “2”]] # # Method CSV.parse_line returns only the first row: #   CSV.parse_line(string) # =&gt; [“foo”, “0”] # # CSV extends class String with instance method String#parse_csv, # which also returns only the first row: #   string.parse_csv # =&gt; [“foo”, “0”] # # ==== Parsing Via a File Path # # The input to be parsed can be in a file: #   string = “foo,0nbar,1nbaz,2n” #   path = ‘t.csv’ #   File.write(path, string) # # Method CSV.read returns the entire CSV data: #  CSV.read(path) # =&gt; [[“foo”, “0”], [“bar”, “1”], [“baz”, “2”]] # # Method CSV.foreach iterates, passing each row to the given block: #  CSV.foreach(path) do |row| #    p row #  end # Output: #   [“foo”, “0”] #   [“bar”, “1”] #   [“baz”, “2”] # # Method CSV.table returns the entire CSV data as a CSV::Table object: #   CSV.table(path) # =&gt; #<CSV::Table mode:col_or_row row_count:3&gt; # # ==== Parsing from an Open \IO Stream # # The input to be parsed can be in an open \IO stream: # # \Method CSV.read returns the entire \CSV data: #   File.open(path) do |file| #     CSV.read(file) #   end # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]] # # As does method CSV.parse: #   File.open(path) do |file| #     CSV.parse(file) #   end # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]] # # \Method CSV.parse_line returns only the first row: #   File.open(path) do |file| #    CSV.parse_line(file) #   end # =&gt; [&quot;foo&quot;, &quot;0&quot;] # # \Method CSV.foreach iterates, passing each row to the given block: #   File.open(path) do |file| #     CSV.foreach(file) do |row| #       p row #     end #   end # Output: #   [&quot;foo&quot;, &quot;0&quot;] #   [&quot;bar&quot;, &quot;1&quot;] #   [&quot;baz&quot;, &quot;2&quot;] # # \Method CSV.table returns the entire \CSV data as a CSV::Table object: #   File.open(path) do |file| #     CSV.table(file) #   end # =&gt; #<CSV::Table mode:col_or_row row_count:3&gt; # # === Simple Generating # # \Method CSV.generate returns a \String; # this example uses method CSV#<< to append the rows # that are to be generated: #   output_string = CSV.generate do |csv| #     csv &lt;&lt; [&#39;foo&#39;, 0] #     csv &lt;&lt; [&#39;bar&#39;, 1] #     csv &lt;&lt; [&#39;baz&#39;, 2] #   end #   output_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot; # # \Method CSV.generate_line returns a \String containing the single row # constructed from an \Array: #   CSV.generate_line([&#39;foo&#39;, &#39;0&#39;]) # =&gt; &quot;foo,0\n&quot; # # \CSV extends class \Array with instance method <code>Array#to_csv</code>, # which forms an Array into a String: #   [‘foo’, ‘0’].to_csv # =&gt; “foo,0n” # # === “Filtering” CSV # # Method CSV.filter provides a Unix-style filter for CSV data. # The input data is processed to form the output data: #   in_string = “foo,0nbar,1nbaz,2n” #   out_string = ” #   CSV.filter(in_string, out_string) do |row| #     <a href="0">row</a> = <a href="0">row</a>.upcase #     <a href="1">row</a> *= 4 #   end #   out_string # =&gt; “FOO,0000nBAR,1111nBAZ,2222n” # # == CSV Objects # # There are three ways to create a CSV object: # - Method CSV.new returns a new CSV object. # - Method CSV.instance returns a new or cached CSV object. # - Method CSV() also returns a new or cached CSV object. # # === Instance Methods # # CSV has three groups of instance methods: # - Its own internally defined instance methods. # - Methods included by module Enumerable. # - Methods delegated to class IO. See below. # # ==== Delegated Methods # # For convenience, a CSV object will delegate to many methods in class IO. # (A few have wrapper “guard code” in CSV.) You may call: # * IO#binmode # * #binmode? # * IO#close # * IO#close_read # * IO#close_write # * IO#closed? # * #eof # * #eof? # * IO#external_encoding # * IO#fcntl # * IO#fileno # * #flock # * IO#flush # * IO#fsync # * IO#internal_encoding # * #ioctl # * IO#isatty # * #path # * IO#pid # * IO#pos # * IO#pos= # * IO#reopen # * #rewind # * IO#seek # * #stat # * IO#string # * IO#sync # * IO#sync= # * IO#tell # * #to_i # * #to_io # * IO#truncate # * IO#tty? # # === Options # # The default values for options are: #   DEFAULT_OPTIONS = { #     # For both parsing and generating. #     col_sep:            “,”, #     row_sep:            :auto, #     quote_char:         ‘“’, #     # For parsing. #     field_size_limit:   nil, #     converters:         nil, #     unconverted_fields: nil, #     headers:            false, #     return_headers:     false, #     header_converters:  nil, #     skip_blanks:        false, #     skip_lines:         nil, #     liberal_parsing:    false, #     nil_value:          nil, #     empty_value:        ”“, #     strip:              false, #     # For generating. #     write_headers:      nil, #     quote_empty:        true, #     force_quotes:       false, #     write_converters:   nil, #     write_nil_value:    nil, #     write_empty_value:  ”“, #   } # # ==== Options for Parsing # # Options for parsing, described in detail below, include: # - <code>row_sep</code>: Specifies the row separator; used to delimit rows. # - <code>col_sep</code>: Specifies the column separator; used to delimit fields. # - <code>quote_char</code>: Specifies the quote character; used to quote fields. # - <code>field_size_limit</code>: Specifies the maximum field size + 1 allowed. #   Deprecated since 3.2.3. Use <code>max_field_size</code> instead. # - <code>max_field_size</code>: Specifies the maximum field size allowed. # - <code>converters</code>: Specifies the field converters to be used. # - <code>unconverted_fields</code>: Specifies whether unconverted fields are to be available. # - <code>headers</code>: Specifies whether data contains headers, #   or specifies the headers themselves. # - <code>return_headers</code>: Specifies whether headers are to be returned. # - <code>header_converters</code>: Specifies the header converters to be used. # - <code>skip_blanks</code>: Specifies whether blanks lines are to be ignored. # - <code>skip_lines</code>: Specifies how comments lines are to be recognized. # - <code>strip</code>: Specifies whether leading and trailing whitespace are to be #   stripped from fields. This must be compatible with <code>col_sep</code>; if it is not, #   then an <code>ArgumentError</code> exception will be raised. # - <code>liberal_parsing</code>: Specifies whether CSV should attempt to parse #   non-compliant data. # - <code>nil_value</code>: Specifies the object that is to be substituted for each null (no-text) field. # - <code>empty_value</code>: Specifies the object that is to be substituted for each empty field. # # # # # # # # # # # # # # # # # ==== Options for Generating # # Options for generating, described in detail below, include: # - <code>row_sep</code>: Specifies the row separator; used to delimit rows. # - <code>col_sep</code>: Specifies the column separator; used to delimit fields. # - <code>quote_char</code>: Specifies the quote character; used to quote fields. # - <code>write_headers</code>: Specifies whether headers are to be written. # - <code>force_quotes</code>: Specifies whether each output field is to be quoted. # - <code>quote_empty</code>: Specifies whether each empty output field is to be quoted. # - <code>write_converters</code>: Specifies the field converters to be used in writing. # - <code>write_nil_value</code>: Specifies the object that is to be substituted for each <code>nil</code>-valued field. # - <code>write_empty_value</code>: Specifies the object that is to be substituted for each empty field. # # # # # # # # # # # === CSV with Headers # # CSV allows to specify column names of CSV file, whether they are in data, or # provided separately. If headers are specified, reading methods return an instance # of CSV::Table, consisting of CSV::Row. # #   # Headers are part of data #   data = CSV.parse(&lt;&lt;~ROWS, headers: true) #     Name,Department,Salary #     Bob,Engineering,1000 #     Jane,Sales,2000 #     John,Management,5000 #   ROWS # #   data.class      #=&gt; CSV::Table #   data.first      #=&gt; #<CSV::Row &quot;Name&quot;:&quot;Bob&quot; &quot;Department&quot;:&quot;Engineering&quot; &quot;Salary&quot;:&quot;1000&quot;&gt; #   data.first.to_h #=&gt; {&quot;Name&quot;=&gt;&quot;Bob&quot;, &quot;Department&quot;=&gt;&quot;Engineering&quot;, &quot;Salary&quot;=&gt;&quot;1000&quot;} # #   # Headers provided by developer #   data = CSV.parse(&#39;Bob,Engineering,1000&#39;, headers: %i[name department salary]) #   data.first      #=&gt; #<CSV::Row name:&quot;Bob&quot; department:&quot;Engineering&quot; salary:&quot;1000&quot;&gt; # # === \Converters # # By default, each value (field or header) parsed by \CSV is formed into a \String. # You can use a <em>field</em> <em>converter</em> or  <em>header</em> <em>converter</em> # to intercept and modify the parsed values: # - See <a href="#class-CSV-label-Field+Converters">Field Converters</a>. # - See <a href="#class-CSV-label-Header+Converters">Header Converters</a>. # # Also by default, each value to be written during generation is written ‘as-is’. # You can use a <em>write</em> <em>converter</em> to modify values before writing. # - See <a href="#class-CSV-label-Write+Converters">Write Converters</a>. # # ==== Specifying Converters # # You can specify converters for parsing or generating in the <code>options</code> # argument to various CSV methods: # - Option <code>converters</code> for converting parsed field values. # - Option <code>header_converters</code> for converting parsed header values. # - Option <code>write_converters</code> for converting values to be written (generated). # # There are three forms for specifying converters: # - A converter proc: executable code to be used for conversion. # - A converter name: the name of a stored converter. # - A converter list: an array of converter procs, converter names, and converter lists. # # ===== Converter Procs # # This converter proc, <code>strip_converter</code>, accepts a value <code>field</code> # and returns <code>field.strip</code>: #   strip_converter = proc {|field| field.strip } # In this call to <code>CSV.parse</code>, # the keyword argument <code>converters: string_converter</code> # specifies that: # - Proc <code>string_converter</code> is to be called for each parsed field. # - The converter’s return value is to replace the <code>field</code> value. # Example: #   string = ” foo , 0 n bar , 1 n baz , 2 n“ #   array = CSV.parse(string, converters: strip_converter) #   array # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # # A converter proc can receive a second argument, <code>field_info</code>, # that contains details about the field. # This modified <code>strip_converter</code> displays its arguments: #   strip_converter = proc do |field, field_info| #     p [field, field_info] #     field.strip #   end #   string = ” foo , 0 n bar , 1 n baz , 2 n“ #   array = CSV.parse(string, converters: strip_converter) #   array # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # Output: #  [” foo “, #<struct CSV::FieldInfo index=0, line=1, header=nil&gt;] #  [&quot; 0 &quot;, #<struct CSV::FieldInfo index=1, line=1, header=nil&gt;] #  [&quot; bar &quot;, #<struct CSV::FieldInfo index=0, line=2, header=nil&gt;] #  [&quot; 1 &quot;, #<struct CSV::FieldInfo index=1, line=2, header=nil&gt;] #  [&quot; baz &quot;, #<struct CSV::FieldInfo index=0, line=3, header=nil&gt;] #  [&quot; 2 &quot;, #<struct CSV::FieldInfo index=1, line=3, header=nil&gt;] # Each CSV::FieldInfo object shows: # - The 0-based field index. # - The 1-based line index. # - The field header, if any. # # ===== Stored \Converters # # A converter may be given a name and stored in a structure where # the parsing methods can find it by name. # # The storage structure for field converters is the \Hash CSV::Converters. # It has several built-in converter procs: # - <code>:integer</code>: converts each String-embedded integer into a true Integer. # - <code>:float</code>: converts each String-embedded float into a true Float. # - <code>:date</code>: converts each String-embedded date into a true Date. # - <code>:date_time</code>: converts each String-embedded date-time into a true DateTime # - <code>:time</code>: converts each String-embedded time into a true Time # . # This example creates a converter proc, then stores it: #   strip_converter = proc {|field| field.strip } #   <a href=":strip">CSV::Converters</a> = strip_converter # Then the parsing method call can refer to the converter # by its name, <code>:strip</code>: #   string = ” foo , 0 n bar , 1 n baz , 2 n“ #   array = CSV.parse(string, converters: :strip) #   array # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # # The storage structure for header converters is the Hash CSV::HeaderConverters, # which works in the same way. # It also has built-in converter procs: # - <code>:downcase</code>: Downcases each header. # - <code>:symbol</code>: Converts each header to a Symbol. # # There is no such storage structure for write headers. # # In order for the parsing methods to access stored converters in non-main-Ractors, the # storage structure must be made shareable first. # Therefore, <code>Ractor.make_shareable(CSV::Converters)</code> and # <code>Ractor.make_shareable(CSV::HeaderConverters)</code> must be called before the creation # of Ractors that use the converters stored in these structures. (Since making the storage # structures shareable involves freezing them, any custom converters that are to be used # must be added first.) # # ===== Converter Lists # # A <em>converter</em> <em>list</em> is an Array that may include any assortment of: # - Converter procs. # - Names of stored converters. # - Nested converter lists. # # Examples: #   numeric_converters = [:integer, :float] #   date_converters = [:date, :date_time] #   [numeric_converters, strip_converter] #   [strip_converter, date_converters, :float] # # Like a converter proc, a converter list may be named and stored in either # CSV::Converters or CSV::HeaderConverters: #   <a href=":custom">CSV::Converters</a> = [strip_converter, date_converters, :float] #   <a href=":custom">CSV::HeaderConverters</a> = [:downcase, :symbol] # # There are two built-in converter lists: #   <a href=":numeric">CSV::Converters</a> # =&gt; [:integer, :float] #   <a href=":all">CSV::Converters</a> # =&gt; [:date_time, :numeric] # # ==== Field Converters # # With no conversion, all parsed fields in all rows become Strings: #   string = ”foo,0nbar,1nbaz,2n“ #   ary = CSV.parse(string) #   ary # =&gt; # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # # When you specify a field converter, each parsed field is passed to the converter; # its return value becomes the stored value for the field. # A converter might, for example, convert an integer embedded in a String # into a true Integer. # (In fact, that’s what built-in field converter <code>:integer</code> does.) # # There are three ways to use field converters. # # - Using option <a href="#class-CSV-label-Option+converters">converters</a> with a parsing method: #     ary = CSV.parse(string, converters: :integer) #     ary # =&gt; [0, 1, 2] # =&gt; [[”foo“, 0], [”bar“, 1], [”baz“, 2]] # - Using option <a href="#class-CSV-label-Option+converters">converters</a> with a new CSV instance: #     csv = CSV.new(string, converters: :integer) #     # Field converters in effect: #     csv.converters # =&gt; [:integer] #     csv.read # =&gt; [[”foo“, 0], [”bar“, 1], [”baz“, 2]] # - Using method #convert to add a field converter to a CSV instance: #     csv = CSV.new(string) #     # Add a converter. #     csv.convert(:integer) #     csv.converters # =&gt; [:integer] #     csv.read # =&gt; [[”foo“, 0], [”bar“, 1], [”baz“, 2]] # # Installing a field converter does not affect already-read rows: #   csv = CSV.new(string) #   csv.shift # =&gt; [”foo“, ”0“] #   # Add a converter. #   csv.convert(:integer) #   csv.converters # =&gt; [:integer] #   csv.read # =&gt; [[”bar“, 1], [”baz“, 2]] # # There are additional built-in converters, and custom converters are also supported. # # ===== Built-In Field Converters # # The built-in field converters are in Hash CSV::Converters: # - Each key is a field converter name. # - Each value is one of: #   - A Proc field converter. #   - An Array of field converter names. # # Display: #   CSV::Converters.each_pair do |name, value| #     if value.kind_of?(Proc) #       p [name, value.class] #     else #       p [name, value] #     end #   end # Output: #   [:integer, Proc] #   [:float, Proc] #   [:numeric, [:integer, :float]] #   [:date, Proc] #   [:date_time, Proc] #   [:time, Proc] #   [:all, [:date_time, :numeric]] # # Each of these converters transcodes values to UTF-8 before attempting conversion. # If a value cannot be transcoded to UTF-8 the conversion will # fail and the value will remain unconverted. # # Converter <code>:integer</code> converts each field that Integer() accepts: #   data = ‘0,1,2,x’ #   # Without the converter #   csv = CSV.parse_line(data) #   csv # =&gt; [”0“, ”1“, ”2“, ”x“] #   # With the converter #   csv = CSV.parse_line(data, converters: :integer) #   csv # =&gt; [0, 1, 2, ”x“] # # Converter <code>:float</code> converts each field that Float() accepts: #   data = ‘1.0,3.14159,x’ #   # Without the converter #   csv = CSV.parse_line(data) #   csv # =&gt; [”1.0“, ”3.14159“, ”x“] #   # With the converter #   csv = CSV.parse_line(data, converters: :float) #   csv # =&gt; [1.0, 3.14159, ”x“] # # Converter <code>:numeric</code> converts with both <code>:integer</code> and <code>:float</code>.. # # Converter <code>:date</code> converts each field that Date::parse accepts: #   data = ‘2001-02-03,x’ #   # Without the converter #   csv = CSV.parse_line(data) #   csv # =&gt; [”2001-02-03“, ”x“] #   # With the converter #   csv = CSV.parse_line(data, converters: :date) #   csv # =&gt; [#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;, ”x“] # # Converter <code>:date_time</code> converts each field that DateTime::parse accepts: #   data = ‘2020-05-07T14:59:00-05:00,x’ #   # Without the converter #   csv = CSV.parse_line(data) #   csv # =&gt; [”2020-05-07T14:59:00-05:00“, ”x“] #   # With the converter #   csv = CSV.parse_line(data, converters: :date_time) #   csv # =&gt; [#&lt;DateTime: 2020-05-07T14:59:00-05:00 ((2458977j,71940s,0n),-18000s,2299161j)&gt;, ”x“] # # Converter <code>time</code> converts each field that Time::parse accepts: #   data = ‘2020-05-07T14:59:00-05:00,x’ #   # Without the converter #   csv = CSV.parse_line(data) #   csv # =&gt; [”2020-05-07T14:59:00-05:00“, ”x“] #   # With the converter #   csv = CSV.parse_line(data, converters: :time) #   csv # =&gt; [2020-05-07 14:59:00 -0500, ”x“] # # Converter <code>:numeric</code> converts with both <code>:date_time</code> and <code>:numeric</code>.. # # As seen above, method #convert adds converters to a CSV instance, # and method #converters returns an Array of the converters in effect: #   csv = CSV.new(‘0,1,2’) #   csv.converters # =&gt; [] #   csv.convert(:integer) #   csv.converters # =&gt; [:integer] #   csv.convert(:date) #   csv.converters # =&gt; [:integer, :date] # # ===== Custom Field Converters # # You can define a custom field converter: #   strip_converter = proc {|field| field.strip } #   string = ” foo , 0 n bar , 1 n baz , 2 n“ #   array = CSV.parse(string, converters: strip_converter) #   array # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # You can register the converter in Converters Hash, # which allows you to refer to it by name: #   <a href=":strip">CSV::Converters</a> = strip_converter #   string = ” foo , 0 n bar , 1 n baz , 2 n“ #   array = CSV.parse(string, converters: :strip) #   array # =&gt; [[”foo“, ”0“], [”bar“, ”1“], [”baz“, ”2“]] # # ==== Header Converters # # Header converters operate only on headers (and not on other rows). # # There are three ways to use header converters; # these examples use built-in header converter <code>:downcase</code>, # which downcases each parsed header. # # - Option <code>header_converters</code> with a singleton parsing method: #     string = ”Name,CountnFoo,0n,Bar,1nBaz,2“ #     tbl = CSV.parse(string, headers: true, header_converters: :downcase) #     tbl.class # =&gt; CSV::Table #     tbl.headers # =&gt; [”name“, ”count“] # # - Option <code>header_converters</code> with a new CSV instance: #     csv = CSV.new(string, header_converters: :downcase) #     # Header converters in effect: #     csv.header_converters # =&gt; [:downcase] #     tbl = CSV.parse(string, headers: true) #     tbl.headers # =&gt; [”Name“, ”Count“] # # - Method #header_convert adds a header converter to a CSV instance: #     csv = CSV.new(string) #     # Add a header converter. #     csv.header_convert(:downcase) #     csv.header_converters # =&gt; [:downcase] #     tbl = CSV.parse(string, headers: true) #     tbl.headers # =&gt; [”Name“, ”Count“] # # ===== Built-In Header Converters # # The built-in header converters are in Hash CSV::HeaderConverters. # The keys there are the names of the converters: #   CSV::HeaderConverters.keys # =&gt; [:downcase, :symbol] # # Converter <code>:downcase</code> converts each header by downcasing it: #   string = ”Name,CountnFoo,0n,Bar,1nBaz,2“ #   tbl = CSV.parse(string, headers: true, header_converters: :downcase) #   tbl.class # =&gt; CSV::Table #   tbl.headers # =&gt; [”name“, ”count“] # # Converter <code>:symbol</code> converts each header by making it into a Symbol: #   string = ”Name,CountnFoo,0n,Bar,1nBaz,2“ #   tbl = CSV.parse(string, headers: true, header_converters: :symbol) #   tbl.headers # =&gt; [:name, :count] # Details: # - Strips leading and trailing whitespace. # - Downcases the header. # - Replaces embedded spaces with underscores. # - Removes non-word characters. # - Makes the string into a Symbol. # # ===== Custom Header Converters # # You can define a custom header converter: #   upcase_converter = proc {|header| header.upcase } #   string = ”Name,Valuenfoo,0nbar,1nbaz,2n“ #   table = CSV.parse(string, headers: true, header_converters: upcase_converter) #   table # =&gt; #<CSV::Table mode:col_or_row row_count:4&gt; #   table.headers # =&gt; [&quot;NAME&quot;, &quot;VALUE&quot;] # You can register the converter in \HeaderConverters \Hash, # which allows you to refer to it by name: #   <a href=":upcase">CSV::HeaderConverters</a> = upcase_converter #   table = CSV.parse(string, headers: true, header_converters: :upcase) #   table # =&gt; #<CSV::Table mode:col_or_row row_count:4&gt; #   table.headers # =&gt; [&quot;NAME&quot;, &quot;VALUE&quot;] # # ===== Write \Converters # # When you specify a write converter for generating \CSV, # each field to be written is passed to the converter; # its return value becomes the new value for the field. # A converter might, for example, strip whitespace from a field. # # Using no write converter (all fields unmodified): #   output_string = CSV.generate do |csv| #     csv &lt;&lt; [&#39; foo &#39;, 0] #     csv &lt;&lt; [&#39; bar &#39;, 1] #     csv &lt;&lt; [&#39; baz &#39;, 2] #   end #   output_string # =&gt; &quot; foo ,0\n bar ,1\n baz ,2\n&quot; # Using option <code>write_converters</code> with two custom write converters: #   strip_converter = proc {|field| field.respond_to?(:strip) ? field.strip : field } #   upcase_converter = proc {|field| field.respond_to?(:upcase) ? field.upcase : field } #   write_converters = [strip_converter, upcase_converter] #   output_string = CSV.generate(write_converters: write_converters) do |csv| #     csv &lt;&lt; [‘ foo ’, 0] #     csv &lt;&lt; [‘ bar ’, 1] #     csv &lt;&lt; [‘ baz ’, 2] #   end #   output_string # =&gt; ”FOO,0nBAR,1nBAZ,2n“ # # === Character Encodings (M17n or Multilingualization) # # This new CSV parser is m17n savvy.  The parser works in the Encoding of the IO # or String object being read from or written to. Your data is never transcoded # (unless you ask Ruby to transcode it for you) and will literally be parsed in # the Encoding it is in. Thus CSV will return Arrays or Rows of Strings in the # Encoding of your data. This is accomplished by transcoding the parser itself # into your Encoding. # # Some transcoding must take place, of course, to accomplish this multiencoding # support. For example, <code>:col_sep</code>, <code>:row_sep</code>, and # <code>:quote_char</code> must be transcoded to match your data.  Hopefully this # makes the entire process feel transparent, since CSV’s defaults should just # magically work for your data. However, you can set these values manually in # the target Encoding to avoid the translation. # # It’s also important to note that while all of CSV’s core parser is now # Encoding agnostic, some features are not. For example, the built-in # converters will try to transcode data to UTF-8 before making conversions. # Again, you can provide custom converters that are aware of your Encodings to # avoid this translation. It’s just too hard for me to support native # conversions in all of Ruby’s Encodings. # # Anyway, the practical side of this is simple: make sure IO and String objects # passed into CSV have the proper Encoding set and everything should just work. # CSV methods that allow you to open IO objects (CSV::foreach(), CSV::open(), # CSV::read(), and CSV::readlines()) do allow you to specify the Encoding. # # One minor exception comes when generating CSV into a String with an Encoding # that is not ASCII compatible. There’s no existing data for CSV to use to # prepare itself and thus you will probably need to manually specify the desired # Encoding for most of those cases. It will try to guess using the fields in a # row of output though, when using CSV::generate_line() or Array#to_csv(). # # I try to point out any other Encoding issues in the documentation of methods # as they come up. # # This has been tested to the best of my ability with all non-”dummy“ Encodings # Ruby ships with. However, it is brave new code and may have some bugs. # Please feel free to <a href="mailto:james@grayproductions.net">report</a> any issues you # find with it. # # source://csv//lib/csv/fields_converter.rb#3 class CSV</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Forwardable</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   CSV.new(string)</span>
<span class="ruby-comment">#   CSV.new(io)</span>
<span class="ruby-comment">#   CSV.new(string, **options)</span>
<span class="ruby-comment">#   CSV.new(io, **options)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \CSV object created using +string+ or +io+</span>
<span class="ruby-comment"># and the specified +options+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +string+ should be a \String object;</span>
<span class="ruby-comment">#   it will be put into a new StringIO object positioned at the beginning.</span>
<span class="ruby-comment"># - Argument +options+: See:</span>
<span class="ruby-comment">#   * {Options for Parsing}[#class-CSV-label-Options+for+Parsing]</span>
<span class="ruby-comment">#   * {Options for Generating}[#class-CSV-label-Options+for+Generating]</span>
<span class="ruby-comment">#   For performance reasons, the options cannot be overridden</span>
<span class="ruby-comment">#   in a \CSV object, so those specified here will endure.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In addition to the \CSV instance methods, several \IO methods are delegated.</span>
<span class="ruby-comment"># See {Delegated Methods}[#class-CSV-label-Delegated+Methods].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Create a \CSV object from a \String object:</span>
<span class="ruby-comment">#   csv = CSV.new(&#39;foo,0&#39;)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Create a \CSV object from a \File object:</span>
<span class="ruby-comment">#   File.write(&#39;t.csv&#39;, &#39;foo,0&#39;)</span>
<span class="ruby-comment">#   csv = CSV.new(File.open(&#39;t.csv&#39;))</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the argument is +nil+:</span>
<span class="ruby-comment">#   # Raises ArgumentError (Cannot parse nil as CSV):</span>
<span class="ruby-comment">#   CSV.new(nil)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [CSV] a new instance of CSV</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2034</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">data</span>, <span class="ruby-value">col_sep:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">row_sep:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">quote_char:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">field_size_limit:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">max_field_size:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">converters:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">unconverted_fields:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">return_headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">write_headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">header_converters:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">skip_blanks:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">force_quotes:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">skip_lines:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">liberal_parsing:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">internal_encoding:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">external_encoding:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">encoding:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">nil_value:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">empty_value:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">strip:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">quote_empty:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">write_converters:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">write_nil_value:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">write_empty_value:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv &lt;&lt; row -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Appends a row to +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +row+ must be an \Array object or a CSV::Row object.</span>
<span class="ruby-comment"># - The output stream must be open for writing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append Arrays:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;bar&#39;, 1]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;baz&#39;, 2]</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append CSV::Rows:</span>
<span class="ruby-comment">#   headers = []</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Headers in CSV::Row objects are not appended:</span>
<span class="ruby-comment">#   headers = [&#39;Name&#39;, &#39;Count&#39;]</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if +row+ is not an \Array or \CSV::Row:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     # Raises NoMethodError (undefined method `collect&#39; for :foo:Symbol)</span>
<span class="ruby-comment">#     csv &lt;&lt; :foo</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the output stream is not opened for writing:</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, &#39;&#39;)</span>
<span class="ruby-comment">#   File.open(path) do |file|</span>
<span class="ruby-comment">#     CSV.open(file) do |csv|</span>
<span class="ruby-comment">#       # Raises IOError (not opened for writing)</span>
<span class="ruby-comment">#       csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2507</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">row</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv &lt;&lt; row -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Appends a row to +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +row+ must be an \Array object or a CSV::Row object.</span>
<span class="ruby-comment"># - The output stream must be open for writing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append Arrays:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;bar&#39;, 1]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;baz&#39;, 2]</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append CSV::Rows:</span>
<span class="ruby-comment">#   headers = []</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Headers in CSV::Row objects are not appended:</span>
<span class="ruby-comment">#   headers = [&#39;Name&#39;, &#39;Count&#39;]</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if +row+ is not an \Array or \CSV::Row:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     # Raises NoMethodError (undefined method `collect&#39; for :foo:Symbol)</span>
<span class="ruby-comment">#     csv &lt;&lt; :foo</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the output stream is not opened for writing:</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, &#39;&#39;)</span>
<span class="ruby-comment">#   File.open(path) do |file|</span>
<span class="ruby-comment">#     CSV.open(file) do |csv|</span>
<span class="ruby-comment">#       # Raises IOError (not opened for writing)</span>
<span class="ruby-comment">#       csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2511</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_row</span>(<span class="ruby-identifier">row</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binmode</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2396</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binmode?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close_read</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">close_write</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closed?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.col_sep -&gt; string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the encoded column separator; used for parsing and writing;</span>
<span class="ruby-comment"># see {Option +col_sep+}[#class-CSV-label-Option+col_sep]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).col_sep # =&gt; &quot;,&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">col_sep</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   convert(converter_name) -&gt; array_of_procs</span>
<span class="ruby-comment">#   convert {|field, field_info| ... } -&gt; array_of_procs</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - With no block, installs a field converter (a \Proc).</span>
<span class="ruby-comment"># - With a block, defines and installs a custom field converter.</span>
<span class="ruby-comment"># - Returns the \Array of installed field converters.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +converter_name+, if given, should be the name</span>
<span class="ruby-comment">#   of an existing field converter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># See {Field Converters}[#class-CSV-label-Field+Converters].</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With no block, installs a field converter:</span>
<span class="ruby-comment">#   csv = CSV.new(&#39;&#39;)</span>
<span class="ruby-comment">#   csv.convert(:integer)</span>
<span class="ruby-comment">#   csv.convert(:float)</span>
<span class="ruby-comment">#   csv.convert(:date)</span>
<span class="ruby-comment">#   csv.converters # =&gt; [:integer, :float, :date]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The block, if given, is called for each field:</span>
<span class="ruby-comment"># - Argument +field+ is the field value.</span>
<span class="ruby-comment"># - Argument +field_info+ is a CSV::FieldInfo object</span>
<span class="ruby-comment">#   containing details about the field.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The examples here assume the prior execution of:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Example giving a block:</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.convert {|field, field_info| p [field, field_info]; field.upcase }</span>
<span class="ruby-comment">#   csv.read # =&gt; [[&quot;FOO&quot;, &quot;0&quot;], [&quot;BAR&quot;, &quot;1&quot;], [&quot;BAZ&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [&quot;foo&quot;, #&lt;struct CSV::FieldInfo index=0, line=1, header=nil&gt;]</span>
<span class="ruby-comment">#   [&quot;0&quot;, #&lt;struct CSV::FieldInfo index=1, line=1, header=nil&gt;]</span>
<span class="ruby-comment">#   [&quot;bar&quot;, #&lt;struct CSV::FieldInfo index=0, line=2, header=nil&gt;]</span>
<span class="ruby-comment">#   [&quot;1&quot;, #&lt;struct CSV::FieldInfo index=1, line=2, header=nil&gt;]</span>
<span class="ruby-comment">#   [&quot;baz&quot;, #&lt;struct CSV::FieldInfo index=0, line=3, header=nil&gt;]</span>
<span class="ruby-comment">#   [&quot;2&quot;, #&lt;struct CSV::FieldInfo index=1, line=3, header=nil&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The block need not return a \String object:</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.convert {|field, field_info| field.to_sym }</span>
<span class="ruby-comment">#   csv.read # =&gt; [[:foo, :&quot;0&quot;], [:bar, :&quot;1&quot;], [:baz, :&quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If +converter_name+ is given, the block is not called:</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.convert(:integer) {|field, field_info| fail &#39;Cannot happen&#39; }</span>
<span class="ruby-comment">#   csv.read # =&gt; [[&quot;foo&quot;, 0], [&quot;bar&quot;, 1], [&quot;baz&quot;, 2]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises a parse-time exception if +converter_name+ is not the name of a built-in</span>
<span class="ruby-comment"># field converter:</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.convert(:nosuch) =&gt; [nil]</span>
<span class="ruby-comment">#   # Raises NoMethodError (undefined method `arity&#39; for nil:NilClass)</span>
<span class="ruby-comment">#   csv.read</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2578</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convert</span>(<span class="ruby-identifier">name</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.converters -&gt; array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns an \Array containing field converters;</span>
<span class="ruby-comment"># see {Field Converters}[#class-CSV-label-Field+Converters]:</span>
<span class="ruby-comment">#   csv = CSV.new(&#39;&#39;)</span>
<span class="ruby-comment">#   csv.converters # =&gt; []</span>
<span class="ruby-comment">#   csv.convert(:integer)</span>
<span class="ruby-comment">#   csv.converters # =&gt; [:integer]</span>
<span class="ruby-comment">#   csv.convert(proc {|x| x.to_s })</span>
<span class="ruby-comment">#   csv.converters</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Notes that you need to call</span>
<span class="ruby-comment"># +Ractor.make_shareable(CSV::Converters)+ on the main Ractor to use</span>
<span class="ruby-comment"># this method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">converters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.each -&gt; enumerator</span>
<span class="ruby-comment">#   csv.each {|row| ...}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calls the block with each successive row.</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.each do |row|</span>
<span class="ruby-comment">#     p row</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [&quot;foo&quot;, &quot;0&quot;]</span>
<span class="ruby-comment">#   [&quot;bar&quot;, &quot;1&quot;]</span>
<span class="ruby-comment">#   [&quot;baz&quot;, &quot;2&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   csv.each do |row|</span>
<span class="ruby-comment">#     p row</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.each do |row|</span>
<span class="ruby-comment">#     p row</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2689</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.encoding -&gt; encoding</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the encoding used for parsing and generating;</span>
<span class="ruby-comment"># see {Character Encodings (M17n or Multilingualization)}[#class-CSV-label-Character+Encodings+-28M17n+or+Multilingualization-29]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).encoding # =&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2432</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">external_encoding</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fcntl</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.field_size_limit -&gt; integer or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the limit for field size; used for parsing;</span>
<span class="ruby-comment"># see {Option +field_size_limit+}[#class-CSV-label-Option+field_size_limit]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).field_size_limit # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Deprecated since 3.2.3. Use +max_field_size+ instead.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">field_size_limit</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fileno</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2404</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flock</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flush</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.force_quotes? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether all output fields are to be quoted;</span>
<span class="ruby-comment"># used for generating;</span>
<span class="ruby-comment"># see {Option +force_quotes+}[#class-CSV-label-Option+force_quotes]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).force_quotes? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">force_quotes?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fsync</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.shift -&gt; array, csv_row, or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the next row of data as:</span>
<span class="ruby-comment"># - An \Array if no headers are used.</span>
<span class="ruby-comment"># - A CSV::Row object if headers are used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;bar&quot;, &quot;1&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;baz&quot;, &quot;2&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.shift</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2814</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gets</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The block need not return a \String object:</span>
<span class="ruby-comment">#   csv = CSV.open(path, headers: true)</span>
<span class="ruby-comment">#   csv.header_convert {|header, field_info| header.to_sym }</span>
<span class="ruby-comment">#   table = csv.read</span>
<span class="ruby-comment">#   table.headers # =&gt; [:Name, :Value]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If +converter_name+ is given, the block is not called:</span>
<span class="ruby-comment">#   csv = CSV.open(path, headers: true)</span>
<span class="ruby-comment">#   csv.header_convert(:downcase) {|header, field_info| fail &#39;Cannot happen&#39; }</span>
<span class="ruby-comment">#   table = csv.read</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;name&quot;, &quot;value&quot;]</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises a parse-time exception if +converter_name+ is not the name of a built-in</span>
<span class="ruby-comment"># field converter:</span>
<span class="ruby-comment">#   csv = CSV.open(path, headers: true)</span>
<span class="ruby-comment">#   csv.header_convert(:nosuch)</span>
<span class="ruby-comment">#   # Raises NoMethodError (undefined method `arity&#39; for nil:NilClass)</span>
<span class="ruby-comment">#   csv.read</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2644</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_convert</span>(<span class="ruby-identifier">name</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.header_converters -&gt; array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns an \Array containing header converters; used for parsing;</span>
<span class="ruby-comment"># see {Header Converters}[#class-CSV-label-Header+Converters]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).header_converters # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Notes that you need to call</span>
<span class="ruby-comment"># +Ractor.make_shareable(CSV::HeaderConverters)+ on the main Ractor</span>
<span class="ruby-comment"># to use this method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_converters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.header_row? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if the next row to be read is a header row\;</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.header_row? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   csv.header_row? # =&gt; true</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   csv.header_row? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.header_row?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2766</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_row?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.headers -&gt; object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether headers are used; used for parsing;</span>
<span class="ruby-comment"># see {Option +headers+}[#class-CSV-label-Option+headers]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).headers # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.inspect -&gt; string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a \String showing certain properties of +self+:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   s = csv.inspect</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2825</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">internal_encoding</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2409</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ioctl</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">isatty</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.liberal_parsing? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether illegal input is to be handled; used for parsing;</span>
<span class="ruby-comment"># see {Option +liberal_parsing+}[#class-CSV-label-Option+liberal_parsing]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).liberal_parsing? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2317</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">liberal_parsing?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.line -&gt; array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the line most recently read:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   CSV.open(path) do |csv|</span>
<span class="ruby-comment">#     csv.each do |row|</span>
<span class="ruby-comment">#       p [csv.lineno, csv.line]</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [1, &quot;foo,0\n&quot;]</span>
<span class="ruby-comment">#   [2, &quot;bar,1\n&quot;]</span>
<span class="ruby-comment">#   [3, &quot;baz,2\n&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2382</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.line_no -&gt; integer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the count of the rows parsed or generated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Parsing:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   CSV.open(path) do |csv|</span>
<span class="ruby-comment">#     csv.each do |row|</span>
<span class="ruby-comment">#       p [csv.lineno, row]</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [1, [&quot;foo&quot;, &quot;0&quot;]]</span>
<span class="ruby-comment">#   [2, [&quot;bar&quot;, &quot;1&quot;]]</span>
<span class="ruby-comment">#   [3, [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Generating:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     p csv.lineno; csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     p csv.lineno; csv &lt;&lt; [&#39;bar&#39;, 1]</span>
<span class="ruby-comment">#     p csv.lineno; csv &lt;&lt; [&#39;baz&#39;, 2]</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   0</span>
<span class="ruby-comment">#   1</span>
<span class="ruby-comment">#   2</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2358</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lineno</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.max_field_size -&gt; integer or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the limit for field size; used for parsing;</span>
<span class="ruby-comment"># see {Option +max_field_size+}[#class-CSV-label-Option+max_field_size]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).max_field_size # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Since 3.2.3.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_field_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2414</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pid</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pos</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pos=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv &lt;&lt; row -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Appends a row to +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +row+ must be an \Array object or a CSV::Row object.</span>
<span class="ruby-comment"># - The output stream must be open for writing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append Arrays:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;bar&#39;, 1]</span>
<span class="ruby-comment">#     csv &lt;&lt; [&#39;baz&#39;, 2]</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append CSV::Rows:</span>
<span class="ruby-comment">#   headers = []</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Headers in CSV::Row objects are not appended:</span>
<span class="ruby-comment">#   headers = [&#39;Name&#39;, &#39;Count&#39;]</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;bar&#39;, 1])</span>
<span class="ruby-comment">#     csv &lt;&lt; CSV::Row.new(headers, [&#39;baz&#39;, 2])</span>
<span class="ruby-comment">#   end # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if +row+ is not an \Array or \CSV::Row:</span>
<span class="ruby-comment">#   CSV.generate do |csv|</span>
<span class="ruby-comment">#     # Raises NoMethodError (undefined method `collect&#39; for :foo:Symbol)</span>
<span class="ruby-comment">#     csv &lt;&lt; :foo</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the output stream is not opened for writing:</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, &#39;&#39;)</span>
<span class="ruby-comment">#   File.open(path) do |file|</span>
<span class="ruby-comment">#     CSV.open(file) do |csv|</span>
<span class="ruby-comment">#       # Raises IOError (not opened for writing)</span>
<span class="ruby-comment">#       csv &lt;&lt; [&#39;foo&#39;, 0]</span>
<span class="ruby-comment">#     end</span>
<span class="ruby-comment">#   end</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2512</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">puts</span>(<span class="ruby-identifier">row</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.quote_char -&gt; character</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the encoded quote character; used for parsing and writing;</span>
<span class="ruby-comment"># see {Option +quote_char+}[#class-CSV-label-Option+quote_char]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).quote_char # =&gt; &quot;\&quot;&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quote_char</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.read -&gt; array or csv_table</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Forms the remaining rows from +self+ into:</span>
<span class="ruby-comment"># - A CSV::Table object, if headers are in use.</span>
<span class="ruby-comment"># - An \Array of Arrays, otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.read # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   csv = CSV.open(path, headers: true)</span>
<span class="ruby-comment">#   csv.read # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.read</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2730</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.shift -&gt; array, csv_row, or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the next row of data as:</span>
<span class="ruby-comment"># - An \Array if no headers are used.</span>
<span class="ruby-comment"># - A CSV::Row object if headers are used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;bar&quot;, &quot;1&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;baz&quot;, &quot;2&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.shift</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2815</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">readline</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.read -&gt; array or csv_table</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Forms the remaining rows from +self+ into:</span>
<span class="ruby-comment"># - A CSV::Table object, if headers are in use.</span>
<span class="ruby-comment"># - An \Array of Arrays, otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   csv = CSV.open(path)</span>
<span class="ruby-comment">#   csv.read # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
<span class="ruby-comment">#   File.write(path, string)</span>
<span class="ruby-comment">#   csv = CSV.open(path, headers: true)</span>
<span class="ruby-comment">#   csv.read # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.read</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2738</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">readlines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reopen</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.return_headers? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether headers are to be returned; used for parsing;</span>
<span class="ruby-comment"># see {Option +return_headers+}[#class-CSV-label-Option+return_headers]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).return_headers? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_headers?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Rewinds the underlying IO object and resets CSV&#39;s lineno() counter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2447</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rewind</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.row_sep -&gt; string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the encoded row separator; used for parsing and writing;</span>
<span class="ruby-comment"># see {Option +row_sep+}[#class-CSV-label-Option+row_sep]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).row_sep # =&gt; &quot;\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">row_sep</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">seek</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.shift -&gt; array, csv_row, or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the next row of data as:</span>
<span class="ruby-comment"># - An \Array if no headers are used.</span>
<span class="ruby-comment"># - A CSV::Row object if headers are used.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The data source must be opened for reading.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Without headers:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;bar&quot;, &quot;1&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; [&quot;baz&quot;, &quot;2&quot;]</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With headers:</span>
<span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string, headers: true)</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#   csv.shift # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the source is not opened for reading:</span>
<span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   csv = CSV.new(string)</span>
<span class="ruby-comment">#   csv.close</span>
<span class="ruby-comment">#   # Raises IOError (not opened for reading)</span>
<span class="ruby-comment">#   csv.shift</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2803</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shift</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.skip_blanks? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether blank lines are to be ignored; used for parsing;</span>
<span class="ruby-comment"># see {Option +skip_blanks+}[#class-CSV-label-Option+skip_blanks]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).skip_blanks? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2296</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_blanks?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.skip_lines -&gt; regexp or nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the \Regexp used to identify comment lines; used for parsing;</span>
<span class="ruby-comment"># see {Option +skip_lines+}[#class-CSV-label-Option+skip_lines]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).skip_lines # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">stat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sync</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sync=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tell</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [NotImplementedError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2423</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_i</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2428</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_io</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truncate</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tty?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.unconverted_fields? -&gt; object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether unconverted fields are to be</span>
<span class="ruby-comment"># available; used for parsing;</span>
<span class="ruby-comment"># see {Option +unconverted_fields+}[#class-CSV-label-Option+unconverted_fields]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).unconverted_fields? # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unconverted_fields?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   csv.write_headers? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the value that determines whether headers are to be written; used for generating;</span>
<span class="ruby-comment"># see {Option +write_headers+}[#class-CSV-label-Option+write_headers]:</span>
<span class="ruby-comment">#   CSV.new(&#39;&#39;).write_headers? # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_headers?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2957</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_fields_converter</span>(<span class="ruby-identifier">initial_converters</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2939</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_header_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2927</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_parser_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2952</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_writer_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Processes +fields+ with &lt;tt&gt;@converters&lt;/tt&gt;, or &lt;tt&gt;@header_converters&lt;/tt&gt;</span>
<span class="ruby-comment"># if +headers+ is passed as +true+, returning the converted field set. Any</span>
<span class="ruby-comment"># converter that changes the field into something other than a String halts</span>
<span class="ruby-comment"># the pipeline of conversion for that field. This is primarily an efficiency</span>
<span class="ruby-comment"># shortcut.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2902</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convert_fields</span>(<span class="ruby-identifier">fields</span>, <span class="ruby-identifier">headers</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2865</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">determine_encoding</span>(<span class="ruby-identifier">encoding</span>, <span class="ruby-identifier">internal_encoding</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2935</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2880</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">normalize_converters</span>(<span class="ruby-identifier">converters</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2965</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2974</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_enumerator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2923</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2969</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the encoding of the internal IO object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2913</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raw_encoding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2978</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">writer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2948</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">writer_fields_converter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#2982</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">writer_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   filter(in_string_or_io, **options) {|row| ... } -&gt; array_of_arrays or csv_table</span>
  <span class="ruby-comment">#   filter(in_string_or_io, out_string_or_io, **options) {|row| ... } -&gt; array_of_arrays or csv_table</span>
  <span class="ruby-comment">#   filter(**options) {|row| ... } -&gt; array_of_arrays or csv_table</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># - Parses \CSV from a source (\String, \IO stream, or ARGF).</span>
  <span class="ruby-comment"># - Calls the given block with each parsed row:</span>
  <span class="ruby-comment">#   - Without headers, each row is an \Array.</span>
  <span class="ruby-comment">#   - With headers, each row is a CSV::Row.</span>
  <span class="ruby-comment"># - Generates \CSV to an output (\String, \IO stream, or STDOUT).</span>
  <span class="ruby-comment"># - Returns the parsed source:</span>
  <span class="ruby-comment">#   - Without headers, an \Array of \Arrays.</span>
  <span class="ruby-comment">#   - With headers, a CSV::Table.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># When +in_string_or_io+ is given, but not +out_string_or_io+,</span>
  <span class="ruby-comment"># parses from the given +in_string_or_io+</span>
  <span class="ruby-comment"># and generates to STDOUT.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \String input without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;foo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   CSV.filter(in_string) do |row|</span>
  <span class="ruby-comment">#     row[0].upcase!</span>
  <span class="ruby-comment">#     row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#   end # =&gt; [[&quot;FOO&quot;, 0], [&quot;BAR&quot;, -1], [&quot;BAZ&quot;, -2]]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \String input with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   CSV.filter(in_string, headers: true) do |row|</span>
  <span class="ruby-comment">#     row[0].upcase!</span>
  <span class="ruby-comment">#     row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#   end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   Name,Value</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream input without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   File.write(&#39;t.csv&#39;, &quot;foo,0\nbar,1\nbaz,2&quot;)</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;) do |in_io|</span>
  <span class="ruby-comment">#     CSV.filter(in_io) do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end # =&gt; [[&quot;FOO&quot;, 0], [&quot;BAR&quot;, -1], [&quot;BAZ&quot;, -2]]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream input with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   File.write(&#39;t.csv&#39;, &quot;Name,Value\nfoo,0\nbar,1\nbaz,2&quot;)</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;) do |in_io|</span>
  <span class="ruby-comment">#     CSV.filter(in_io, headers: true) do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   Name,Value</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># When both +in_string_or_io+ and +out_string_or_io+ are given,</span>
  <span class="ruby-comment"># parses from +in_string_or_io+ and generates to +out_string_or_io+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \String output without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;foo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   out_string = &#39;&#39;</span>
  <span class="ruby-comment">#   CSV.filter(in_string, out_string) do |row|</span>
  <span class="ruby-comment">#     row[0].upcase!</span>
  <span class="ruby-comment">#     row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#   end # =&gt; [[&quot;FOO&quot;, 0], [&quot;BAR&quot;, -1], [&quot;BAZ&quot;, -2]]</span>
  <span class="ruby-comment">#   out_string # =&gt; &quot;FOO,0\nBAR,-1\nBAZ,-2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \String output with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   out_string = &#39;&#39;</span>
  <span class="ruby-comment">#   CSV.filter(in_string, out_string, headers: true) do |row|</span>
  <span class="ruby-comment">#     row[0].upcase!</span>
  <span class="ruby-comment">#     row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#   end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#   out_string # =&gt; &quot;Name,Value\nFOO,0\nBAR,-1\nBAZ,-2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream output without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;foo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;, &#39;w&#39;) do |out_io|</span>
  <span class="ruby-comment">#     CSV.filter(in_string, out_io) do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end # =&gt; [[&quot;FOO&quot;, 0], [&quot;BAR&quot;, -1], [&quot;BAZ&quot;, -2]]</span>
  <span class="ruby-comment">#   File.read(&#39;t.csv&#39;) # =&gt; &quot;FOO,0\nBAR,-1\nBAZ,-2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream output with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   in_string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2&quot;</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;, &#39;w&#39;) do |out_io|</span>
  <span class="ruby-comment">#     CSV.filter(in_string, out_io, headers: true) do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#   File.read(&#39;t.csv&#39;) # =&gt; &quot;Name,Value\nFOO,0\nBAR,-1\nBAZ,-2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># When neither +in_string_or_io+ nor +out_string_or_io+ given,</span>
  <span class="ruby-comment"># parses from {ARGF}[rdoc-ref:ARGF]</span>
  <span class="ruby-comment"># and generates to STDOUT.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   # Put Ruby code into a file.</span>
  <span class="ruby-comment">#   ruby = &lt;&lt;-EOT</span>
  <span class="ruby-comment">#     require &#39;csv&#39;</span>
  <span class="ruby-comment">#     CSV.filter do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   EOT</span>
  <span class="ruby-comment">#   File.write(&#39;t.rb&#39;, ruby)</span>
  <span class="ruby-comment">#   # Put some CSV into a file.</span>
  <span class="ruby-comment">#   File.write(&#39;t.csv&#39;, &quot;foo,0\nbar,1\nbaz,2&quot;)</span>
  <span class="ruby-comment">#   # Run the Ruby code with CSV filename as argument.</span>
  <span class="ruby-comment">#   system(Gem.ruby, &quot;t.rb&quot;, &quot;t.csv&quot;)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   # Put Ruby code into a file.</span>
  <span class="ruby-comment">#   ruby = &lt;&lt;-EOT</span>
  <span class="ruby-comment">#     require &#39;csv&#39;</span>
  <span class="ruby-comment">#     CSV.filter(headers: true) do |row|</span>
  <span class="ruby-comment">#       row[0].upcase!</span>
  <span class="ruby-comment">#       row[1] = - row[1].to_i</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   EOT</span>
  <span class="ruby-comment">#   File.write(&#39;t.rb&#39;, ruby)</span>
  <span class="ruby-comment">#   # Put some CSV into a file.</span>
  <span class="ruby-comment">#   File.write(&#39;t.csv&#39;, &quot;Name,Value\nfoo,0\nbar,1\nbaz,2&quot;)</span>
  <span class="ruby-comment">#   # Run the Ruby code with CSV filename as argument.</span>
  <span class="ruby-comment">#   system(Gem.ruby, &quot;t.rb&quot;, &quot;t.csv&quot;)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output (to STDOUT):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   Name,Value</span>
  <span class="ruby-comment">#   FOO,0</span>
  <span class="ruby-comment">#   BAR,-1</span>
  <span class="ruby-comment">#   BAZ,-2</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Arguments:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Argument +in_string_or_io+ must be a \String or an \IO stream.</span>
  <span class="ruby-comment"># * Argument +out_string_or_io+ must be a \String or an \IO stream.</span>
  <span class="ruby-comment"># * Arguments &lt;tt&gt;**options&lt;/tt&gt; must be keyword options.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   - Each option defined as an {option for parsing}[#class-CSV-label-Options+for+Parsing]</span>
  <span class="ruby-comment">#     is used for parsing the filter input.</span>
  <span class="ruby-comment">#   - Each option defined as an {option for generating}[#class-CSV-label-Options+for+Generating]</span>
  <span class="ruby-comment">#     is used for generator the filter input.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># However, there are three options that may be used for both parsing and generating:</span>
  <span class="ruby-comment"># +col_sep+, +quote_char+, and +row_sep+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Therefore for method +filter+ (and method +filter+ only),</span>
  <span class="ruby-comment"># there are special options that allow these parsing and generating options</span>
  <span class="ruby-comment"># to be specified separately:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># - Options +input_col_sep+ and +output_col_sep+</span>
  <span class="ruby-comment">#   (and their aliases +in_col_sep+ and +out_col_sep+)</span>
  <span class="ruby-comment">#   specify the column separators for parsing and generating.</span>
  <span class="ruby-comment"># - Options +input_quote_char+ and +output_quote_char+</span>
  <span class="ruby-comment">#   (and their aliases +in_quote_char+ and +out_quote_char+)</span>
  <span class="ruby-comment">#   specify the quote characters for parsing and generting.</span>
  <span class="ruby-comment"># - Options +input_row_sep+ and +output_row_sep+</span>
  <span class="ruby-comment">#   (and their aliases +in_row_sep+ and +out_row_sep+)</span>
  <span class="ruby-comment">#   specify the row separators for parsing and generating.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Example options (for column separators):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   CSV.filter                                    # Default for both parsing and generating.</span>
  <span class="ruby-comment">#   CSV.filter(in_col_sep: &#39;;&#39;)                   # &#39;;&#39; for parsing, default for generating.</span>
  <span class="ruby-comment">#   CSV.filter(out_col_sep: &#39;|&#39;)                  # Default for parsing, &#39;|&#39; for generating.</span>
  <span class="ruby-comment">#   CSV.filter(in_col_sep: &#39;;&#39;, out_col_sep: &#39;|&#39;) # &#39;;&#39; for parsing, &#39;|&#39; for generating.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Note that for a special option (e.g., +input_col_sep+)</span>
  <span class="ruby-comment"># and its corresponding &quot;regular&quot; option (e.g., +col_sep+),</span>
  <span class="ruby-comment"># the two are mutually overriding.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Another example (possibly surprising):</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   CSV.filter(in_col_sep: &#39;;&#39;, col_sep: &#39;|&#39;) # &#39;|&#39; for both parsing(!) and generating.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1259</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter</span>(<span class="ruby-identifier">input</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">output</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   foreach(path_or_io, mode=&#39;r&#39;, **options) {|row| ... )</span>
  <span class="ruby-comment">#   foreach(path_or_io, mode=&#39;r&#39;, **options) -&gt; new_enumerator</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Calls the block with each row read from source +path_or_io+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \Path input without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   in_path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(in_path, string)</span>
  <span class="ruby-comment">#   CSV.foreach(in_path) {|row| p row }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#   [&quot;bar&quot;, &quot;1&quot;]</span>
  <span class="ruby-comment">#   [&quot;baz&quot;, &quot;2&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \Path input with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   in_path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(in_path, string)</span>
  <span class="ruby-comment">#   CSV.foreach(in_path, headers: true) {|row| p row }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream input without headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;) do |in_io|</span>
  <span class="ruby-comment">#     CSV.foreach(in_io) {|row| p row }</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#   [&quot;bar&quot;, &quot;1&quot;]</span>
  <span class="ruby-comment">#   [&quot;baz&quot;, &quot;2&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># \IO stream input with headers:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   File.open(&#39;t.csv&#39;) do |in_io|</span>
  <span class="ruby-comment">#     CSV.foreach(in_io, headers: true) {|row| p row }</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
  <span class="ruby-comment">#   &lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With no block given, returns an \Enumerator:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   CSV.foreach(path) # =&gt; #&lt;Enumerator: CSV:foreach(&quot;t.csv&quot;, &quot;r&quot;)&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Arguments:</span>
  <span class="ruby-comment"># * Argument +path_or_io+ must be a file path or an \IO stream.</span>
  <span class="ruby-comment"># * Argument +mode+, if given, must be a \File mode.</span>
  <span class="ruby-comment">#   See {Access Modes}[https://docs.ruby-lang.org/en/master/File.html#class-File-label-Access+Modes].</span>
  <span class="ruby-comment"># * Arguments &lt;tt&gt;**options&lt;/tt&gt; must be keyword options.</span>
  <span class="ruby-comment">#   See {Options for Parsing}[#class-CSV-label-Options+for+Parsing].</span>
  <span class="ruby-comment"># * This method optionally accepts an additional &lt;tt&gt;:encoding&lt;/tt&gt; option</span>
  <span class="ruby-comment">#   that you can use to specify the Encoding of the data read from +path+ or +io+.</span>
  <span class="ruby-comment">#   You must provide this unless your data is in the encoding</span>
  <span class="ruby-comment">#   given by &lt;tt&gt;Encoding::default_external&lt;/tt&gt;.</span>
  <span class="ruby-comment">#   Parsing will use this to determine how to parse the data.</span>
  <span class="ruby-comment">#   You may provide a second Encoding to</span>
  <span class="ruby-comment">#   have the data transcoded as it is read. For example,</span>
  <span class="ruby-comment">#   would read +UTF-32BE+ data from the file</span>
  <span class="ruby-comment">#   but transcode it to +UTF-8+ before parsing.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1389</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foreach</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">mode</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   generate(csv_string, **options) {|csv| ... }</span>
  <span class="ruby-comment">#   generate(**options) {|csv| ... }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Argument +csv_string+, if given, must be a \String object;</span>
  <span class="ruby-comment">#   defaults to a new empty \String.</span>
  <span class="ruby-comment"># * Arguments +options+, if given, should be generating options.</span>
  <span class="ruby-comment">#   See {Options for Generating}[#class-CSV-label-Options+for+Generating].</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Creates a new \CSV object via &lt;tt&gt;CSV.new(csv_string, **options)&lt;/tt&gt;;</span>
  <span class="ruby-comment"># calls the block with the \CSV object, which the block may modify;</span>
  <span class="ruby-comment"># returns the \String generated from the \CSV object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Note that a passed \String *is* modified by this method.</span>
  <span class="ruby-comment"># Pass &lt;tt&gt;csv_string&lt;/tt&gt;.dup if the \String must be preserved.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># This method has one additional option: &lt;tt&gt;:encoding&lt;/tt&gt;,</span>
  <span class="ruby-comment"># which sets the base Encoding for the output if no no +str+ is specified.</span>
  <span class="ruby-comment"># CSV needs this hint if you plan to output non-ASCII compatible data.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Add lines:</span>
  <span class="ruby-comment">#   input_string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   output_string = CSV.generate(input_string) do |csv|</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;bat&#39;, 3]</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;bam&#39;, 4]</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#   output_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n&quot;</span>
  <span class="ruby-comment">#   input_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n&quot;</span>
  <span class="ruby-comment">#   output_string.equal?(input_string) # =&gt; true # Same string, modified</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Add lines into new string, preserving old string:</span>
  <span class="ruby-comment">#   input_string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   output_string = CSV.generate(input_string.dup) do |csv|</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;bat&#39;, 3]</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;bam&#39;, 4]</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#   output_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n&quot;</span>
  <span class="ruby-comment">#   input_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   output_string.equal?(input_string) # =&gt; false # Different strings</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Create lines from nothing:</span>
  <span class="ruby-comment">#   output_string = CSV.generate do |csv|</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;foo&#39;, 0]</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;bar&#39;, 1]</span>
  <span class="ruby-comment">#     csv &lt;&lt; [&#39;baz&#39;, 2]</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#   output_string # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception if +csv_string+ is not a \String object:</span>
  <span class="ruby-comment">#   # Raises TypeError (no implicit conversion of Integer into String)</span>
  <span class="ruby-comment">#   CSV.generate(0)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @yield [csv]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1455</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate</span>(<span class="ruby-identifier">str</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   CSV.generate_line(ary)</span>
  <span class="ruby-comment">#   CSV.generate_line(ary, **options)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns the \String created by generating \CSV from +ary+</span>
  <span class="ruby-comment"># using the specified +options+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Argument +ary+ must be an \Array.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Special options:</span>
  <span class="ruby-comment"># * Option &lt;tt&gt;:row_sep&lt;/tt&gt; defaults to &lt;tt&gt;&quot;\n&quot;&gt; on Ruby 3.0 or later</span>
  <span class="ruby-comment">#   and &lt;tt&gt;$INPUT_RECORD_SEPARATOR&lt;/tt&gt; (&lt;tt&gt;$/&lt;/tt&gt;) otherwise.:</span>
  <span class="ruby-comment">#     $INPUT_RECORD_SEPARATOR # =&gt; &quot;\n&quot;</span>
  <span class="ruby-comment"># * This method accepts an additional option, &lt;tt&gt;:encoding&lt;/tt&gt;, which sets the base</span>
  <span class="ruby-comment">#   Encoding for the output. This method will try to guess your Encoding from</span>
  <span class="ruby-comment">#   the first non-+nil+ field in +row+, if possible, but you may need to use</span>
  <span class="ruby-comment">#   this parameter as a backup plan.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># For other +options+,</span>
  <span class="ruby-comment"># see {Options for Generating}[#class-CSV-label-Options+for+Generating].</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns the \String generated from an \Array:</span>
  <span class="ruby-comment">#   CSV.generate_line([&#39;foo&#39;, &#39;0&#39;]) # =&gt; &quot;foo,0\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception if +ary+ is not an \Array:</span>
  <span class="ruby-comment">#   # Raises NoMethodError (undefined method `find&#39; for :foo:Symbol)</span>
  <span class="ruby-comment">#   CSV.generate_line(:foo)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1503</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_line</span>(<span class="ruby-identifier">row</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   CSV.generate_lines(rows)</span>
  <span class="ruby-comment">#   CSV.generate_lines(rows, **options)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns the \String created by generating \CSV from</span>
  <span class="ruby-comment"># using the specified +options+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Argument +rows+ must be an \Array of row. Row is \Array of \String or \CSV::Row.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Special options:</span>
  <span class="ruby-comment"># * Option &lt;tt&gt;:row_sep&lt;/tt&gt; defaults to &lt;tt&gt;&quot;\n&quot;&lt;/tt&gt; on Ruby 3.0 or later</span>
  <span class="ruby-comment">#   and &lt;tt&gt;$INPUT_RECORD_SEPARATOR&lt;/tt&gt; (&lt;tt&gt;$/&lt;/tt&gt;) otherwise.:</span>
  <span class="ruby-comment">#     $INPUT_RECORD_SEPARATOR # =&gt; &quot;\n&quot;</span>
  <span class="ruby-comment"># * This method accepts an additional option, &lt;tt&gt;:encoding&lt;/tt&gt;, which sets the base</span>
  <span class="ruby-comment">#   Encoding for the output. This method will try to guess your Encoding from</span>
  <span class="ruby-comment">#   the first non-+nil+ field in +row+, if possible, but you may need to use</span>
  <span class="ruby-comment">#   this parameter as a backup plan.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># For other +options+,</span>
  <span class="ruby-comment"># see {Options for Generating}[#class-CSV-label-Options+for+Generating].</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns the \String generated from an</span>
  <span class="ruby-comment">#   CSV.generate_lines([[&#39;foo&#39;, &#39;0&#39;], [&#39;bar&#39;, &#39;1&#39;], [&#39;baz&#39;, &#39;2&#39;]]) # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception</span>
  <span class="ruby-comment">#   # Raises NoMethodError (undefined method `each&#39; for :foo:Symbol)</span>
  <span class="ruby-comment">#   CSV.generate_lines(:foo)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1558</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_lines</span>(<span class="ruby-identifier">rows</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   instance(string, **options)</span>
  <span class="ruby-comment">#   instance(io = $stdout, **options)</span>
  <span class="ruby-comment">#   instance(string, **options) {|csv| ... }</span>
  <span class="ruby-comment">#   instance(io = $stdout, **options) {|csv| ... }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Creates or retrieves cached \CSV objects.</span>
  <span class="ruby-comment"># For arguments and options, see CSV.new.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># This API is not Ractor-safe.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With no block given, returns a \CSV object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># The first call to +instance+ creates and caches a \CSV object:</span>
  <span class="ruby-comment">#   s0 = &#39;s0&#39;</span>
  <span class="ruby-comment">#   csv0 = CSV.instance(s0)</span>
  <span class="ruby-comment">#   csv0.class # =&gt; CSV</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Subsequent calls to +instance+ with that _same_ +string+ or +io+</span>
  <span class="ruby-comment"># retrieve that same cached object:</span>
  <span class="ruby-comment">#   csv1 = CSV.instance(s0)</span>
  <span class="ruby-comment">#   csv1.class # =&gt; CSV</span>
  <span class="ruby-comment">#   csv1.equal?(csv0) # =&gt; true # Same CSV object</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># A subsequent call to +instance+ with a _different_ +string+ or +io+</span>
  <span class="ruby-comment"># creates and caches a _different_ \CSV object.</span>
  <span class="ruby-comment">#   s1 = &#39;s1&#39;</span>
  <span class="ruby-comment">#   csv2 = CSV.instance(s1)</span>
  <span class="ruby-comment">#   csv2.equal?(csv0) # =&gt; false # Different CSV object</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># All the cached objects remains available:</span>
  <span class="ruby-comment">#   csv3 = CSV.instance(s0)</span>
  <span class="ruby-comment">#   csv3.equal?(csv0) # true # Same CSV object</span>
  <span class="ruby-comment">#   csv4 = CSV.instance(s1)</span>
  <span class="ruby-comment">#   csv4.equal?(csv2) # true # Same CSV object</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># When a block is given, calls the block with the created or retrieved</span>
  <span class="ruby-comment"># \CSV object; returns the block&#39;s return value:</span>
  <span class="ruby-comment">#   CSV.instance(s0) {|csv| :foo } # =&gt; :foo</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1026</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">instance</span>(<span class="ruby-identifier">data</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   open(path_or_io, mode = &quot;rb&quot;, **options ) -&gt; new_csv</span>
  <span class="ruby-comment">#   open(path_or_io, mode = &quot;rb&quot;, **options ) { |csv| ... } -&gt; object</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># possible options elements:</span>
  <span class="ruby-comment">#   keyword form:</span>
  <span class="ruby-comment">#     :invalid =&gt; nil      # raise error on invalid byte sequence (default)</span>
  <span class="ruby-comment">#     :invalid =&gt; :replace # replace invalid byte sequence</span>
  <span class="ruby-comment">#     :undef =&gt; :replace   # replace undefined conversion</span>
  <span class="ruby-comment">#     :replace =&gt; string   # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># * Argument +path_or_io+, must be a file path or an \IO stream.</span>
  <span class="ruby-comment"># * Argument +mode+, if given, must be a \File mode.</span>
  <span class="ruby-comment">#   See {Access Modes}[https://docs.ruby-lang.org/en/master/File.html#class-File-label-Access+Modes].</span>
  <span class="ruby-comment"># * Arguments &lt;tt&gt;**options&lt;/tt&gt; must be keyword options.</span>
  <span class="ruby-comment">#   See {Options for Generating}[#class-CSV-label-Options+for+Generating].</span>
  <span class="ruby-comment"># * This method optionally accepts an additional &lt;tt&gt;:encoding&lt;/tt&gt; option</span>
  <span class="ruby-comment">#   that you can use to specify the Encoding of the data read from +path+ or +io+.</span>
  <span class="ruby-comment">#   You must provide this unless your data is in the encoding</span>
  <span class="ruby-comment">#   given by &lt;tt&gt;Encoding::default_external&lt;/tt&gt;.</span>
  <span class="ruby-comment">#   Parsing will use this to determine how to parse the data.</span>
  <span class="ruby-comment">#   You may provide a second Encoding to</span>
  <span class="ruby-comment">#   have the data transcoded as it is read. For example,</span>
  <span class="ruby-comment">#   would read +UTF-32BE+ data from the file</span>
  <span class="ruby-comment">#   but transcode it to +UTF-8+ before parsing.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># These examples assume prior execution of:</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment">#   string_io = StringIO.new</span>
  <span class="ruby-comment">#   string_io &lt;&lt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With no block given, returns a new \CSV object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Create a \CSV object using a file path:</span>
  <span class="ruby-comment">#   csv = CSV.open(path)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Create a \CSV object using an open \File:</span>
  <span class="ruby-comment">#   csv = CSV.open(File.open(path))</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Create a \CSV object using a \StringIO:</span>
  <span class="ruby-comment">#   csv = CSV.open(string_io)</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With a block given, calls the block with the created \CSV object;</span>
  <span class="ruby-comment"># returns the block&#39;s return value:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Using a file path:</span>
  <span class="ruby-comment">#   csv = CSV.open(path) {|csv| p csv}</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Using an open \File:</span>
  <span class="ruby-comment">#   csv = CSV.open(File.open(path)) {|csv| p csv}</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Using a \StringIO:</span>
  <span class="ruby-comment">#   csv = CSV.open(string_io) {|csv| p csv}</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception if the argument is not a \String object or \IO object:</span>
  <span class="ruby-comment">#   # Raises TypeError (no implicit conversion of Symbol into String)</span>
  <span class="ruby-comment">#   CSV.open(:foo)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1647</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">filename_or_io</span>, <span class="ruby-identifier">mode</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   parse(string) -&gt; array_of_arrays</span>
  <span class="ruby-comment">#   parse(io) -&gt; array_of_arrays</span>
  <span class="ruby-comment">#   parse(string, headers: ..., **options) -&gt; csv_table</span>
  <span class="ruby-comment">#   parse(io, headers: ..., **options) -&gt; csv_table</span>
  <span class="ruby-comment">#   parse(string, **options) {|row| ... }</span>
  <span class="ruby-comment">#   parse(io, **options) {|row| ... }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parses +string+ or +io+ using the specified +options+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># - Argument +string+ should be a \String object;</span>
  <span class="ruby-comment">#   it will be put into a new StringIO object positioned at the beginning.</span>
  <span class="ruby-comment"># - Argument +options+: see {Options for Parsing}[#class-CSV-label-Options+for+Parsing]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ====== Without Option +headers+</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Without {option +headers+}[#class-CSV-label-Option+headers] case.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># These examples assume prior execution of:</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With no block given, returns an \Array of Arrays formed from the source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse a \String:</span>
  <span class="ruby-comment">#   a_of_a = CSV.parse(string)</span>
  <span class="ruby-comment">#   a_of_a # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse an open \File:</span>
  <span class="ruby-comment">#   a_of_a = File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse(file)</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#   a_of_a # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With a block given, calls the block with each parsed row:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse a \String:</span>
  <span class="ruby-comment">#   CSV.parse(string) {|row| p row }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#   [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#   [&quot;bar&quot;, &quot;1&quot;]</span>
  <span class="ruby-comment">#   [&quot;baz&quot;, &quot;2&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse an open \File:</span>
  <span class="ruby-comment">#   File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse(file) {|row| p row }</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#   [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#   [&quot;bar&quot;, &quot;1&quot;]</span>
  <span class="ruby-comment">#   [&quot;baz&quot;, &quot;2&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ====== With Option +headers+</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With {option +headers+}[#class-CSV-label-Option+headers] case.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># These examples assume prior execution of:</span>
  <span class="ruby-comment">#   string = &quot;Name,Count\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With no block given, returns a CSV::Table object formed from the source.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse a \String:</span>
  <span class="ruby-comment">#   csv_table = CSV.parse(string, headers: [&#39;Name&#39;, &#39;Count&#39;])</span>
  <span class="ruby-comment">#   csv_table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:5&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse an open \File:</span>
  <span class="ruby-comment">#   csv_table = File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse(file, headers: [&#39;Name&#39;, &#39;Count&#39;])</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#   csv_table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With a block given, calls the block with each parsed row,</span>
  <span class="ruby-comment"># which has been formed into a CSV::Row object:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse a \String:</span>
  <span class="ruby-comment">#   CSV.parse(string, headers: [&#39;Name&#39;, &#39;Count&#39;]) {|row| p row }</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Count&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Count&quot;:&quot;1&quot;&gt;</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Count&quot;:&quot;2&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse an open \File:</span>
  <span class="ruby-comment">#   File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse(file, headers: [&#39;Name&#39;, &#39;Count&#39;]) {|row| p row }</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Count&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Count&quot;:&quot;1&quot;&gt;</span>
  <span class="ruby-comment">#   # &lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Count&quot;:&quot;2&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception if the argument is not a \String object or \IO object:</span>
  <span class="ruby-comment">#   # Raises NoMethodError (undefined method `close&#39; for :foo:Symbol)</span>
  <span class="ruby-comment">#   CSV.parse(:foo)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Please make sure if your text contains \BOM or not. CSV.parse will not remove</span>
  <span class="ruby-comment"># \BOM automatically. You might want to remove \BOM before calling CSV.parse :</span>
  <span class="ruby-comment">#   # remove BOM on calling File.open</span>
  <span class="ruby-comment">#     CSV.parse(file, headers: true) do |row|</span>
  <span class="ruby-comment">#       # you can get value by column name because BOM is removed</span>
  <span class="ruby-comment">#       p row[&#39;Name&#39;]</span>
  <span class="ruby-comment">#     end</span>
  <span class="ruby-comment">#   end</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Output:</span>
  <span class="ruby-comment">#   # &quot;foo&quot;</span>
  <span class="ruby-comment">#   # &quot;bar&quot;</span>
  <span class="ruby-comment">#   # &quot;baz&quot;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1825</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">str</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   CSV.parse_line(string) -&gt; new_array or nil</span>
  <span class="ruby-comment">#   CSV.parse_line(io) -&gt; new_array or nil</span>
  <span class="ruby-comment">#   CSV.parse_line(string, **options) -&gt; new_array or nil</span>
  <span class="ruby-comment">#   CSV.parse_line(io, **options) -&gt; new_array or nil</span>
  <span class="ruby-comment">#   CSV.parse_line(string, headers: true, **options) -&gt; csv_row or nil</span>
  <span class="ruby-comment">#   CSV.parse_line(io, headers: true, **options) -&gt; csv_row or nil</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns the data created by parsing the first line of +string+ or +io+</span>
  <span class="ruby-comment"># using the specified +options+.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># - Argument +string+ should be a \String object;</span>
  <span class="ruby-comment">#   it will be put into a new StringIO object positioned at the beginning.</span>
  <span class="ruby-comment"># - Argument +options+: see {Options for Parsing}[#class-CSV-label-Options+for+Parsing]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ====== Without Option +headers+</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Without option +headers+, returns the first row as a new \Array.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># These examples assume prior execution of:</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse the first line from a \String object:</span>
  <span class="ruby-comment">#   CSV.parse_line(string) # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse the first line from a File object:</span>
  <span class="ruby-comment">#   File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse_line(file) # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#   end # =&gt; [&quot;foo&quot;, &quot;0&quot;]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns +nil+ if the argument is an empty \String:</span>
  <span class="ruby-comment">#   CSV.parse_line(&#39;&#39;) # =&gt; nil</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ====== With Option +headers+</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With {option +headers+}[#class-CSV-label-Option+headers],</span>
  <span class="ruby-comment"># returns the first row as a CSV::Row object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># These examples assume prior execution of:</span>
  <span class="ruby-comment">#   string = &quot;Name,Count\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse the first line from a \String object:</span>
  <span class="ruby-comment">#   CSV.parse_line(string, headers: true) # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Count&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Parse the first line from a File object:</span>
  <span class="ruby-comment">#   File.open(path) do |file|</span>
  <span class="ruby-comment">#     CSV.parse_line(file, headers: true)</span>
  <span class="ruby-comment">#   end # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Count&quot;:&quot;0&quot;&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># ---</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Raises an exception if the argument is +nil+:</span>
  <span class="ruby-comment">#   # Raises ArgumentError (Cannot parse nil as CSV):</span>
  <span class="ruby-comment">#   CSV.parse_line(nil)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1898</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_line</span>(<span class="ruby-identifier">line</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   read(source, **options) -&gt; array_of_arrays</span>
  <span class="ruby-comment">#   read(source, headers: true, **options) -&gt; csv_table</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Opens the given +source+ with the given +options+ (see CSV.open),</span>
  <span class="ruby-comment"># reads the source (see CSV#read), and returns the result,</span>
  <span class="ruby-comment"># which will be either an \Array of Arrays or a CSV::Table.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Without headers:</span>
  <span class="ruby-comment">#   string = &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   CSV.read(path) # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># With headers:</span>
  <span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   CSV.read(path, headers: true) # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1922</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   CSV.readlines(source, **options)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Alias for CSV.read.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1930</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">readlines</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># :call-seq:</span>
  <span class="ruby-comment">#   CSV.table(source, **options)</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Calls CSV.read with +source+, +options+, and certain default options:</span>
  <span class="ruby-comment"># - +headers+: +true+</span>
  <span class="ruby-comment"># - +converters+: +:numeric+</span>
  <span class="ruby-comment"># - +header_converters+: +:symbol+</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Returns a CSV::Table object.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Example:</span>
  <span class="ruby-comment">#   string = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
  <span class="ruby-comment">#   path = &#39;t.csv&#39;</span>
  <span class="ruby-comment">#   File.write(path, string)</span>
  <span class="ruby-comment">#   CSV.table(path) # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#1949</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">table</span>(<span class="ruby-identifier">path</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#1990</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_stringio</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">opts</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#1963</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_enable_bom_detection_automatically</span>(<span class="ruby-identifier">filename_or_io</span>, <span class="ruby-identifier">mode</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">file_opts</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The encoding used by all converters. # # source://csv//lib/csv.rb#895 CSV::ConverterEncoding = T.let(T.unsafe(nil), Encoding)</p>

<p># A Regexp used to find and convert some common Date formats. # # source://csv//lib/csv.rb#884 CSV::DateMatcher = T.let(T.unsafe(nil), Regexp)</p>

<p># A Regexp used to find and convert some common (Date)Time formats. # # source://csv//lib/csv.rb#887 CSV::DateTimeMatcher = T.let(T.unsafe(nil), Regexp)</p>

<p># A FieldInfo Struct contains details about a field’s position in the data # source it was read from.  CSV will pass this Struct to some blocks that make # decisions based on field structure.  See CSV.convert_fields() for an # example. #</p>
<dl class="rdoc-list note-list"><dt># <strong><code>index</code></strong></dt>
<dd>
<p>The zero-based index of the field in its row.</p>
</dd><dt># <strong><code>line</code></strong></dt>
<dd>
<p>The line of the data source this row is from.</p>
</dd><dt># <strong><code>header</code></strong></dt>
<dd>
<p>The header for the column, when available.</p>
</dd><dt># <strong><code>quoted?</code></strong></dt>
<dd>
<p>True or false, whether the original value is quoted or not.</p>
</dd></dl>

<p># # source://csv//lib/csv.rb#881 class CSV::FieldInfo &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute header</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of header</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute header</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute header to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute index</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of index</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute index</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute index to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute line to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute quoted?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of quoted?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quoted?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://csv//lib/csv.rb#881</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Note: Don’t use this class directly. This is an internal class. # # source://csv//lib/csv/fields_converter.rb#5 class CSV::FieldsConverter</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>

<span class="ruby-comment"># A CSV::FieldsConverter is a data structure for storing the</span>
<span class="ruby-comment"># fields converter properties to be passed as a parameter</span>
<span class="ruby-comment"># when parsing a new file (e.g. CSV::Parser.new(@io, parser_options))</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [FieldsConverter] a new instance of FieldsConverter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_converter</span>(<span class="ruby-identifier">name</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">converter</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">convert</span>(<span class="ruby-identifier">fields</span>, <span class="ruby-identifier">headers</span>, <span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">quoted_fields</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">builtin_converters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">need_convert?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/fields_converter.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">need_static_convert?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://csv//lib/csv/fields_converter.rb#8 CSV::FieldsConverter::NO_QUOTED_FIELDS = T.let(T.unsafe(nil), Array)</p>

<p># A Hash containing the names and Procs for the built-in header converters. # See <a href="#class-CSV-label-Built-In+Header+Converters">Built-In Header Converters</a>. # # This Hash is intentionally left unfrozen, and may be extended with # custom field converters. # See <a href="#class-CSV-label-Custom+Header+Converters">Custom Header Converters</a>. # # source://csv//lib/csv.rb#944 CSV::HeaderConverters = T.let(T.unsafe(nil), Hash)</p>

<p># source://csv//lib/csv/input_record_separator.rb#5 module CSV::InputRecordSeparator</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://csv//lib/csv/input_record_separator.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The error thrown when the parser encounters invalid encoding in CSV. # # source://csv//lib/csv.rb#862 class CSV::InvalidEncodingError &lt; ::CSV::MalformedCSVError</p>

<pre class="ruby"><span class="ruby-comment"># @return [InvalidEncodingError] a new instance of InvalidEncodingError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#864</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">encoding</span>, <span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute encoding.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#863</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encoding</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The error thrown when the parser encounters illegal CSV formatting. # # source://csv//lib/csv.rb#852 class CSV::MalformedCSVError &lt; ::RuntimeError</p>

<pre class="ruby"><span class="ruby-comment"># @return [MalformedCSVError] a new instance of MalformedCSVError</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#855</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">message</span>, <span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line_number.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#853</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute line_number.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#854</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lineno</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Note: Don’t use this class directly. This is an internal class. # # source://csv//lib/csv/parser.rb#11 class CSV::Parser</p>

<pre class="ruby"><span class="ruby-comment"># @return [Parser] a new instance of Parser</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#348</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">input</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#356</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column_separator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#368</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">field_size_limit</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#388</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_row?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#384</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">liberal_parsing?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#404</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lineno</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#372</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_field_size</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#412</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quote_character</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_headers?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">row_separator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#396</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_blanks?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#376</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#380</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unconverted_fields?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#447</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_headers?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># This method injects an instance variable &lt;tt&gt;unconverted_fields&lt;/tt&gt; into</span>
<span class="ruby-comment"># +row+ and an accessor method for +row+ called unconverted_fields().  The</span>
<span class="ruby-comment"># variable is set to the contents of +fields+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1294</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_unconverted_fields</span>(<span class="ruby-identifier">row</span>, <span class="ruby-identifier">fields</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#806</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust_headers</span>(<span class="ruby-identifier">headers</span>, <span class="ruby-identifier">quoted_fields</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#881</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">build_scanner</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#728</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect_row_separator</span>(<span class="ruby-identifier">sample</span>, <span class="ruby-identifier">cr</span>, <span class="ruby-identifier">lf</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [row]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_row</span>(<span class="ruby-identifier">row</span>, <span class="ruby-identifier">quoted_fields</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_broken_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#758</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#823</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">may_quoted?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_column_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_column_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#792</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_headers</span>(<span class="ruby-identifier">row</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#945</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_no_quote</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#974</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_quotable_loose</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1035</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_quotable_robust</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1163</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_quoted_column_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1219</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_row_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_unquoted_column_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A set of tasks to prepare the file in order to parse it</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#453</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#508</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_backslash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#766</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_header</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#752</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#812</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_parser</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#492</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_quote_character</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#648</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_quoted</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#580</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_separators</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#523</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_skip_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#540</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_strip</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#675</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_unquoted</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#468</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_variable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#688</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resolve_row_separator</span>(<span class="ruby-identifier">separator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#925</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_line?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#908</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">skip_needless_lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_row</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#1232</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">strip_value</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @raise [MalformedCSVError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#937</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_field_size</span>(<span class="ruby-identifier">field</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This method verifies that there are no (obvious) ambiguities with the</span>
<span class="ruby-comment"># provided +col_sep+ and +strip+ parsing options. For example, if +col_sep+</span>
<span class="ruby-comment"># and +strip+ were both equal to +\t+, then there would be no clear way to</span>
<span class="ruby-comment"># parse the input.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#630</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">validate_strip_and_col_sep_options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Convenient method to check whether the give input reached EOF</span>
  <span class="ruby-comment"># or not.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @return [Boolean]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://csv//lib/csv/parser.rb#25</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof?</span>(<span class="ruby-identifier">input</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># CSV::InputsScanner receives IO inputs, encoding and the chunk_size. # It also controls the life cycle of the object with its methods <code>keep_start</code>, # <code>keep_end</code>, <code>keep_back</code>, <code>keep_drop</code>. # # CSV::InputsScanner.scan() tries to match with pattern at the current position. # If there’s a match, the scanner advances the “scan pointer” and returns the matched string. # Otherwise, the scanner returns nil. # # CSV::InputsScanner.rest() returns the “rest” of the string (i.e. everything after the scan pointer). # If there is no more data (eos? = true), it returns “”. # # source://csv//lib/csv/parser.rb#99 class CSV::Parser::InputsScanner</p>

<pre class="ruby"><span class="ruby-comment"># @return [InputsScanner] a new instance of InputsScanner</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">inputs</span>, <span class="ruby-identifier">encoding</span>, <span class="ruby-identifier">row_separator</span>, <span class="ruby-value">chunk_size:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">check</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @yield [buffer]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_line</span>(<span class="ruby-identifier">row_separator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eos?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_back</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_drop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_start</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#156</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan_all</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjust_last_keep</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_chunk</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#275</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trace</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when encoding is invalid. # # source://csv//lib/csv/parser.rb#35 class CSV::Parser::InvalidEncoding &lt; ::StandardError; end</p>

<p># source://csv//lib/csv/parser.rb#855 CSV::Parser::SCANNER_TEST = T.let(T.unsafe(nil), FalseClass)</p>

<p># source://csv//lib/csv/parser.rb#577 CSV::Parser::STRING_SCANNER_SCAN_ACCEPT_STRING = T.let(T.unsafe(nil), TrueClass)</p>

<p># CSV::Scanner receives a CSV output, scans it and return the content. # It also controls the life cycle of the object with its methods <code>keep_start</code>, # <code>keep_end</code>, <code>keep_back</code>, <code>keep_drop</code>. # # Uses StringScanner (the official strscan gem). Strscan provides lexical # scanning operations on a String. We inherit its object and take advantage # on the methods. For more information, please visit: # <a href="https://docs.ruby-lang.org/en/master/StringScanner.html">docs.ruby-lang.org/en/master/StringScanner.html</a> # # source://csv//lib/csv/parser.rb#52 class CSV::Parser::Scanner &lt; ::StringScanner</p>

<pre class="ruby"><span class="ruby-comment"># @return [Scanner] a new instance of Scanner</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_line</span>(<span class="ruby-identifier">row_separator</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_back</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_drop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_start</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scan_all</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Raised when unexpected case is happen. # # source://csv//lib/csv/parser.rb#39 class CSV::Parser::UnexpectedError &lt; ::StandardError; end</p>

<p># source://csv//lib/csv/parser.rb#837 class CSV::Parser::UnoptimizedStringIO</p>

<pre class="ruby"><span class="ruby-comment"># @return [UnoptimizedStringIO] a new instance of UnoptimizedStringIO</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#838</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#846</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_line</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/parser.rb#850</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eof?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/parser.rb#842</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gets</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># = CSV::Row # A CSV::Row instance represents a CSV table row. # (see <a href="../CSV.html">class CSV</a>). # # The instance may have: # - Fields: each is an object, not necessarily a String. # - Headers: each serves a key, and also need not be a String. # # === Instance Methods # # CSV::Row has three groups of instance methods: # - Its own internally defined instance methods. # - Methods included by module Enumerable. # - Methods delegated to class Array.: #   * Array#empty? #   * Array#length #   * Array#size # # == Creating a CSV::Row Instance # # Commonly, a new CSV::Row instance is created by parsing CSV source # that has headers: #   source = “Name,Valuenfoo,0nbar,1nbaz,2n” #   table = CSV.parse(source, headers: true) #   table.each {|row| p row } # Output: #   #<CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt; #   #<CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt; #   #<CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt; # # You can also create a row directly. See ::new. # # == Headers # # Like a \CSV::Table, a \CSV::Row has headers. # # A \CSV::Row that was created by parsing \CSV source # inherits its headers from the table: #   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot; #   table = CSV.parse(source, headers: true) #   row = table.first #   row.headers # =&gt; [&quot;Name&quot;, &quot;Value&quot;] # # You can also create a new row with headers; # like the keys in a \Hash, the headers need not be Strings: #   row = CSV::Row.new([:name, :value], [&#39;foo&#39;, 0]) #   row.headers # =&gt; [:name, :value] # # The new row retains its headers even if added to a table # that has headers: #   table &lt;&lt; row # =&gt; #<CSV::Table mode:col_or_row row_count:5&gt; #   row.headers # =&gt; [:name, :value] #   <a href=":name">row</a> # =&gt; “foo” #   <a href="&#39;Name&#39;">row</a> # =&gt; nil # # # # == Accessing Fields # # You may access a field in a CSV::Row with either its Integer index # (Array-style) or its header (Hash-style). # # Fetch a field using method #[]: #   row = CSV::Row.new([‘Name’, ‘Value’], [‘foo’, 0]) #   <a href="1">row</a> # =&gt; 0 #   <a href="&#39;Value&#39;">row</a> # =&gt; 0 # # Set a field using method #[]=: #   row = CSV::Row.new([‘Name’, ‘Value’], [‘foo’, 0]) #   row # =&gt; #<CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:0&gt; #   <a href="0">row</a> = ‘bar’ #   <a href="&#39;Value&#39;">row</a> = 1 #   row # =&gt; #<CSV::Row “Name”:“bar” “Value”:1&gt; # # source://csv//lib/csv/row.rb#80 class CSV::Row</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Forwardable</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   CSV::Row.new(headers, fields, header_row = false) -&gt; csv_row</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \CSV::Row instance constructed from</span>
<span class="ruby-comment"># arguments +headers+ and +fields+; both should be Arrays;</span>
<span class="ruby-comment"># note that the fields need not be Strings:</span>
<span class="ruby-comment">#   row = CSV::Row.new([&#39;Name&#39;, &#39;Value&#39;], [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:0&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the \Array lengths are different, the shorter is +nil+-filled:</span>
<span class="ruby-comment">#   row = CSV::Row.new([&#39;Name&#39;, &#39;Value&#39;, &#39;Date&#39;, &#39;Size&#39;], [&#39;foo&#39;, 0])</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:0 &quot;Date&quot;:nil &quot;Size&quot;:nil&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Each \CSV::Row object is either a &lt;i&gt;field row&lt;/i&gt; or a &lt;i&gt;header row&lt;/i&gt;;</span>
<span class="ruby-comment"># by default, a new row is a field row;  for the row created above:</span>
<span class="ruby-comment">#   row.field_row? # =&gt; true</span>
<span class="ruby-comment">#   row.header_row? # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the optional argument +header_row+ is given as +true+,</span>
<span class="ruby-comment"># the created row is a header row:</span>
<span class="ruby-comment">#   row = CSV::Row.new([&#39;Name&#39;, &#39;Value&#39;], [&#39;foo&#39;, 0], header_row = true)</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:0&gt;</span>
<span class="ruby-comment">#   row.field_row? # =&gt; false</span>
<span class="ruby-comment">#   row.header_row? # =&gt; true</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Row] a new instance of Row</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">headers</span>, <span class="ruby-identifier">fields</span>, <span class="ruby-identifier">header_row</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row &lt;&lt; [header, value] -&gt; self</span>
<span class="ruby-comment">#   row &lt;&lt; hash -&gt; self</span>
<span class="ruby-comment">#   row &lt;&lt; value -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Adds a field to +self+; returns +self+:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the argument is a 2-element \Array &lt;tt&gt;[header, value]&lt;/tt&gt;,</span>
<span class="ruby-comment"># a field is added with the given +header+ and +value+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row &lt;&lt; [&#39;NAME&#39;, &#39;Bat&#39;]</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot; &quot;NAME&quot;:&quot;Bat&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the argument is a \Hash, each &lt;tt&gt;key-value&lt;/tt&gt; pair is added</span>
<span class="ruby-comment"># as a field with header +key+ and value +value+.</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row &lt;&lt; {NAME: &#39;Bat&#39;, name: &#39;Bam&#39;}</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot; NAME:&quot;Bat&quot; name:&quot;Bam&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Otherwise, the given +value+ is added as a field with no header.</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row &lt;&lt; &#39;Bag&#39;</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot; nil:&quot;Bag&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">arg</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row == other -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if +other+ is a /CSV::Row that has the same</span>
<span class="ruby-comment"># fields (headers and values) in the same order as +self+;</span>
<span class="ruby-comment"># otherwise returns +false+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   other_row = table[0]</span>
<span class="ruby-comment">#   row == other_row # =&gt; true</span>
<span class="ruby-comment">#   other_row = table[1]</span>
<span class="ruby-comment">#   row == other_row # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#633</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   field(index) -&gt; value</span>
<span class="ruby-comment">#   field(header) -&gt; value</span>
<span class="ruby-comment">#   field(header, offset) -&gt; value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the field value for the given +index+ or +header+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by \Integer index:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(0) # =&gt; &quot;foo&quot;</span>
<span class="ruby-comment">#   row.field(1) # =&gt; &quot;bar&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Counts backward from the last column if +index+ is negative:</span>
<span class="ruby-comment">#   row.field(-1) # =&gt; &quot;0&quot;</span>
<span class="ruby-comment">#   row.field(-2) # =&gt; &quot;foo&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +nil+ if +index+ is out of range:</span>
<span class="ruby-comment">#   row.field(2) # =&gt; nil</span>
<span class="ruby-comment">#   row.field(-3) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by header (first found):</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(&#39;Name&#39;) # =&gt; &quot;Foo&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by header, ignoring +offset+ leading fields:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(&#39;Name&#39;, 2) # =&gt; &quot;Baz&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +nil+ if the header does not exist.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">header_or_index</span>, <span class="ruby-identifier">minimum_index</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row[index] = value -&gt; value</span>
<span class="ruby-comment">#   row[header, offset] = value -&gt; value</span>
<span class="ruby-comment">#   row[header] = value -&gt; value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Assigns the field value for the given +index+ or +header+;</span>
<span class="ruby-comment"># returns +value+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Assign field value by \Integer index:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row[0] = &#39;Bat&#39;</span>
<span class="ruby-comment">#   row[1] = 3</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Bat&quot; &quot;Value&quot;:3&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Counts backward from the last column if +index+ is negative:</span>
<span class="ruby-comment">#   row[-1] = 4</span>
<span class="ruby-comment">#   row[-2] = &#39;Bam&#39;</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Bam&quot; &quot;Value&quot;:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Extends the row with &lt;tt&gt;nil:nil&lt;/tt&gt; if positive +index+ is not in the row:</span>
<span class="ruby-comment">#   row[4] = 5</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bad&quot; &quot;Value&quot;:4 nil:nil nil:nil nil:5&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises IndexError if negative +index+ is too small (too far from zero).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Assign field value by header (first found):</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row[&#39;Name&#39;] = &#39;Bat&#39;</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Bat&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Assign field value by header, ignoring +offset+ leading fields:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row[&#39;Name&#39;, 2] = 4</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Append new field by (new) header:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row[&#39;New&#39;] = 6</span>
<span class="ruby-comment">#   row# =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot; &quot;New&quot;:6&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#339</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.deconstruct -&gt; array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \Array suitable for pattern matching containing the values</span>
<span class="ruby-comment"># of the row.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#682</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deconstruct</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.deconstruct_keys(keys) -&gt; hash</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \Hash suitable for pattern matching containing only the</span>
<span class="ruby-comment"># keys specified as an argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#667</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deconstruct_keys</span>(<span class="ruby-identifier">keys</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   delete(index) -&gt; [header, value] or nil</span>
<span class="ruby-comment">#   delete(header) -&gt; [header, value] or empty_array</span>
<span class="ruby-comment">#   delete(header, offset) -&gt; [header, value] or empty_array</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes a specified field from +self+; returns the 2-element \Array</span>
<span class="ruby-comment"># &lt;tt&gt;[header, value]&lt;/tt&gt; if the field exists.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If an \Integer argument +index+ is given,</span>
<span class="ruby-comment"># removes and returns the field at offset +index+,</span>
<span class="ruby-comment"># or returns +nil+ if the field does not exist:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.delete(1) # =&gt; [&quot;Name&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#   row.delete(50) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Otherwise, if the single argument +header+ is given,</span>
<span class="ruby-comment"># removes and returns the first-found field with the given header,</span>
<span class="ruby-comment"># of returns a new empty \Array if the field does not exist:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.delete(&#39;Name&#39;) # =&gt; [&quot;Name&quot;, &quot;Foo&quot;]</span>
<span class="ruby-comment">#   row.delete(&#39;NAME&#39;) # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If argument +header+ and \Integer argument +offset+ are given,</span>
<span class="ruby-comment"># removes and returns the first-found field with the given header</span>
<span class="ruby-comment"># whose +index+ is at least as large as +offset+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.delete(&#39;Name&#39;, 1) # =&gt; [&quot;Name&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#   row.delete(&#39;NAME&#39;, 1) # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#451</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">header_or_index</span>, <span class="ruby-identifier">minimum_index</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.delete_if {|header, value| ... } -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes fields from +self+ as selected by the block; returns +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes each field for which the block returns a truthy value:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.delete_if {|header, value| value.start_with?(&#39;B&#39;) } # =&gt; true</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot;&gt;</span>
<span class="ruby-comment">#   row.delete_if {|header, value| header.start_with?(&#39;B&#39;) } # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If no block is given, returns a new Enumerator:</span>
<span class="ruby-comment">#   row.delete_if # =&gt; #&lt;Enumerator: #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot;&gt;:delete_if&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#476</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_if</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.dig(index_or_header, *identifiers) -&gt; object</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Finds and returns the object in nested object that is specified</span>
<span class="ruby-comment"># by +index_or_header+ and +specifiers+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The nested objects may be instances of various classes.</span>
<span class="ruby-comment"># See {Dig Methods}[rdoc-ref:dig_methods.rdoc].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Examples:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.dig(1) # =&gt; &quot;0&quot;</span>
<span class="ruby-comment">#   row.dig(&#39;Value&#39;) # =&gt; &quot;0&quot;</span>
<span class="ruby-comment">#   row.dig(5) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#715</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig</span>(<span class="ruby-identifier">index_or_header</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">indexes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.each {|header, value| ... } -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calls the block with each header-value pair; returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.each {|header, value| p [header, value] }</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Foo&quot;]</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If no block is given, returns a new Enumerator:</span>
<span class="ruby-comment">#   row.each # =&gt; #&lt;Enumerator: #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot;&gt;:each&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#610</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.each {|header, value| ... } -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calls the block with each header-value pair; returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.each {|header, value| p [header, value] }</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Foo&quot;]</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#   [&quot;Name&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If no block is given, returns a new Enumerator:</span>
<span class="ruby-comment">#   row.each # =&gt; #&lt;Enumerator: #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot;&gt;:each&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#618</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/row.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   fetch(header) -&gt; value</span>
<span class="ruby-comment">#   fetch(header, default) -&gt; value</span>
<span class="ruby-comment">#   fetch(header) {|row| ... } -&gt; value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the field value as specified by +header+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With the single argument +header+, returns the field value</span>
<span class="ruby-comment"># for that header (first found):</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fetch(&#39;Name&#39;) # =&gt; &quot;Foo&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises exception +KeyError+ if the header does not exist.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With arguments +header+ and +default+ given,</span>
<span class="ruby-comment"># returns the field value for the header (first found)</span>
<span class="ruby-comment"># if the header exists, otherwise returns +default+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fetch(&#39;Name&#39;, &#39;&#39;) # =&gt; &quot;Foo&quot;</span>
<span class="ruby-comment">#   row.fetch(:nosuch, &#39;&#39;) # =&gt; &quot;&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With argument +header+ and a block given,</span>
<span class="ruby-comment"># returns the field value for the header (first found)</span>
<span class="ruby-comment"># if the header exists; otherwise calls the block</span>
<span class="ruby-comment"># and returns its return value:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fetch(&#39;Name&#39;) {|header| fail &#39;Cannot happen&#39; } # =&gt; &quot;Foo&quot;</span>
<span class="ruby-comment">#   row.fetch(:nosuch) {|header| &quot;Header &#39;#{header} not found&#39;&quot; } # =&gt; &quot;Header &#39;nosuch not found&#39;&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#258</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch</span>(<span class="ruby-identifier">header</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">varargs</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   field(index) -&gt; value</span>
<span class="ruby-comment">#   field(header) -&gt; value</span>
<span class="ruby-comment">#   field(header, offset) -&gt; value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the field value for the given +index+ or +header+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by \Integer index:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(0) # =&gt; &quot;foo&quot;</span>
<span class="ruby-comment">#   row.field(1) # =&gt; &quot;bar&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Counts backward from the last column if +index+ is negative:</span>
<span class="ruby-comment">#   row.field(-1) # =&gt; &quot;0&quot;</span>
<span class="ruby-comment">#   row.field(-2) # =&gt; &quot;foo&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +nil+ if +index+ is out of range:</span>
<span class="ruby-comment">#   row.field(2) # =&gt; nil</span>
<span class="ruby-comment">#   row.field(-3) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by header (first found):</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(&#39;Name&#39;) # =&gt; &quot;Foo&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch field value by header, ignoring +offset+ leading fields:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field(&#39;Name&#39;, 2) # =&gt; &quot;Baz&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +nil+ if the header does not exist.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#203</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">field</span>(<span class="ruby-identifier">header_or_index</span>, <span class="ruby-identifier">minimum_index</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.field?(value) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if +value+ is a field in this row, +false+ otherwise:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.field?(&#39;Bar&#39;) # =&gt; true</span>
<span class="ruby-comment">#   row.field?(&#39;BAR&#39;) # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#589</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">field?</span>(<span class="ruby-identifier">data</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.field_row? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if this is a field row, +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">field_row?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   self.fields(*specifiers) -&gt; array_of_fields</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns field values per the given +specifiers+, which may be any mixture of:</span>
<span class="ruby-comment"># - \Integer index.</span>
<span class="ruby-comment"># - \Range of \Integer indexes.</span>
<span class="ruby-comment"># - 2-element \Array containing a header and offset.</span>
<span class="ruby-comment"># - Header.</span>
<span class="ruby-comment"># - \Range of headers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># For +specifier+ in one of the first four cases above,</span>
<span class="ruby-comment"># returns the result of &lt;tt&gt;self.field(specifier)&lt;/tt&gt;;  see #field.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Although there may be any number of +specifiers+,</span>
<span class="ruby-comment"># the examples here will illustrate one at a time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is an \Integer +index+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(index)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fields(1) # =&gt; [&quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a \Range of \Integers +range+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(range)&lt;/tt&gt;:</span>
<span class="ruby-comment">#   row.fields(1..2) # =&gt; [&quot;Bar&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a 2-element \Array +array+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(array)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;, 1) # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a header +header+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(header)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;) # =&gt; [&quot;Foo&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a \Range of headers +range+,</span>
<span class="ruby-comment"># forms a new \Range +new_range+ from the indexes of</span>
<span class="ruby-comment"># &lt;tt&gt;range.start&lt;/tt&gt; and &lt;tt&gt;range.end&lt;/tt&gt;,</span>
<span class="ruby-comment"># and returns &lt;tt&gt;self.field(new_range)&lt;/tt&gt;:</span>
<span class="ruby-comment">#   source = &quot;Name,NAME,name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;..&#39;NAME&#39;) # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns all fields if no argument given:</span>
<span class="ruby-comment">#   row.fields # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#530</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fields</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">headers_and_or_indices</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.has_key?(header) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if there is a field with the given +header+,</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">has_key?</span>(<span class="ruby-identifier">header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.has_key?(header) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if there is a field with the given +header+,</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header?</span>(<span class="ruby-identifier">header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.header_row? -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if this is a header row, +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">header_row?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#    row.headers -&gt; array_of_headers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the headers for this row:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table.first</span>
<span class="ruby-comment">#   row.headers # =&gt; [&quot;Name&quot;, &quot;Value&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.has_key?(header) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if there is a field with the given +header+,</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include?</span>(<span class="ruby-identifier">header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   index(header) -&gt; index</span>
<span class="ruby-comment">#   index(header, offset) -&gt; index</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the index for the given header, if it exists;</span>
<span class="ruby-comment"># otherwise returns +nil+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With the single argument +header+, returns the index</span>
<span class="ruby-comment"># of the first-found field with the given +header+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.index(&#39;Name&#39;) # =&gt; 0</span>
<span class="ruby-comment">#   row.index(&#39;NAME&#39;) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With arguments +header+ and +offset+,</span>
<span class="ruby-comment"># returns the index of the first-found field with given +header+,</span>
<span class="ruby-comment"># but ignoring the first +offset+ fields:</span>
<span class="ruby-comment">#   row.index(&#39;Name&#39;, 1) # =&gt; 1</span>
<span class="ruby-comment">#   row.index(&#39;Name&#39;, 3) # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#573</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index</span>(<span class="ruby-identifier">header</span>, <span class="ruby-identifier">minimum_index</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.inspect -&gt; string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns an ASCII-compatible \String showing:</span>
<span class="ruby-comment"># - Class \CSV::Row.</span>
<span class="ruby-comment"># - Header-value pairs.</span>
<span class="ruby-comment"># Example:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.inspect # =&gt; &quot;#&lt;CSV::Row \&quot;Name\&quot;:\&quot;foo\&quot; \&quot;Value\&quot;:\&quot;0\&quot;&gt;&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#740</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.has_key?(header) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if there is a field with the given +header+,</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key?</span>(<span class="ruby-identifier">header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/row.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.has_key?(header) -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if there is a field with the given +header+,</span>
<span class="ruby-comment"># +false+ otherwise.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">member?</span>(<span class="ruby-identifier">header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.push(*values) -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Appends each of the given +values+ to +self+ as a field; returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.push(&#39;Bat&#39;, &#39;Bam&#39;)</span>
<span class="ruby-comment">#   row # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;Foo&quot; &quot;Name&quot;:&quot;Bar&quot; &quot;Name&quot;:&quot;Baz&quot; nil:&quot;Bat&quot; nil:&quot;Bam&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#410</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/row.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/row.rb#675</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_ary</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.to_csv -&gt; csv_string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the row as a \CSV String. Headers are not included:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_csv # =&gt; &quot;foo,0\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#694</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_csv</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.to_h -&gt; hash</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \Hash formed by adding each header-value pair in +self+</span>
<span class="ruby-comment"># as a key-value pair in the \Hash.</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_h # =&gt; {&quot;Name&quot;=&gt;&quot;foo&quot;, &quot;Value&quot;=&gt;&quot;0&quot;}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Header order is preserved, but repeated headers are ignored:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_h # =&gt; {&quot;Name&quot;=&gt;&quot;Foo&quot;}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#653</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.to_h -&gt; hash</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the new \Hash formed by adding each header-value pair in +self+</span>
<span class="ruby-comment"># as a key-value pair in the \Hash.</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_h # =&gt; {&quot;Name&quot;=&gt;&quot;foo&quot;, &quot;Value&quot;=&gt;&quot;0&quot;}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Header order is preserved, but repeated headers are ignored:</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_h # =&gt; {&quot;Name&quot;=&gt;&quot;Foo&quot;}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#660</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_hash</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.to_csv -&gt; csv_string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the row as a \CSV String. Headers are not included:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.to_csv # =&gt; &quot;foo,0\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#697</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   self.fields(*specifiers) -&gt; array_of_fields</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns field values per the given +specifiers+, which may be any mixture of:</span>
<span class="ruby-comment"># - \Integer index.</span>
<span class="ruby-comment"># - \Range of \Integer indexes.</span>
<span class="ruby-comment"># - 2-element \Array containing a header and offset.</span>
<span class="ruby-comment"># - Header.</span>
<span class="ruby-comment"># - \Range of headers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># For +specifier+ in one of the first four cases above,</span>
<span class="ruby-comment"># returns the result of &lt;tt&gt;self.field(specifier)&lt;/tt&gt;;  see #field.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Although there may be any number of +specifiers+,</span>
<span class="ruby-comment"># the examples here will illustrate one at a time.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is an \Integer +index+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(index)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   source = &quot;Name,Name,Name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fields(1) # =&gt; [&quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a \Range of \Integers +range+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(range)&lt;/tt&gt;:</span>
<span class="ruby-comment">#   row.fields(1..2) # =&gt; [&quot;Bar&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a 2-element \Array +array+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(array)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;, 1) # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a header +header+,</span>
<span class="ruby-comment"># returns &lt;tt&gt;self.field(header)&lt;/tt&gt;L</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;) # =&gt; [&quot;Foo&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the specifier is a \Range of headers +range+,</span>
<span class="ruby-comment"># forms a new \Range +new_range+ from the indexes of</span>
<span class="ruby-comment"># &lt;tt&gt;range.start&lt;/tt&gt; and &lt;tt&gt;range.end&lt;/tt&gt;,</span>
<span class="ruby-comment"># and returns &lt;tt&gt;self.field(new_range)&lt;/tt&gt;:</span>
<span class="ruby-comment">#   source = &quot;Name,NAME,name\nFoo,Bar,Baz\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   row = table[0]</span>
<span class="ruby-comment">#   row.fields(&#39;Name&#39;..&#39;NAME&#39;) # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns all fields if no argument given:</span>
<span class="ruby-comment">#   row.fields # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#551</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">headers_and_or_indices</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Internal data format used to compare equality.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">row</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   row.initialize_copy(other_row) -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calls superclass method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/row.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize_copy</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://csv//lib/csv.rb#2132 class CSV::TSV &lt; ::CSV</p>

<pre class="ruby"><span class="ruby-comment"># @return [TSV] a new instance of TSV</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv.rb#2133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">data</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># = CSV::Table # A CSV::Table instance represents CSV data. # (see <a href="../CSV.html">class CSV</a>). # # The instance may have: # - Rows: each is a Table::Row object. # - Headers: names for the columns. # # === Instance Methods # # CSV::Table has three groups of instance methods: # - Its own internally defined instance methods. # - Methods included by module Enumerable. # - Methods delegated to class Array.: #   * Array#empty? #   * Array#length #   * Array#size # # == Creating a CSV::Table Instance # # Commonly, a new CSV::Table instance is created by parsing CSV source # using headers: #   source = “Name,Valuenfoo,0nbar,1nbaz,2n” #   table = CSV.parse(source, headers: true) #   table.class # =&gt; CSV::Table # # You can also create an instance directly. See ::new. # # == Headers # # If a table has headers, the headers serve as labels for the columns of data. # Each header serves as the label for its column. # # The headers for a CSV::Table object are stored as an Array of Strings. # # Commonly, headers are defined in the first row of CSV source: #   source = “Name,Valuenfoo,0nbar,1nbaz,2n” #   table = CSV.parse(source, headers: true) #   table.headers # =&gt; [“Name”, “Value”] # # If no headers are defined, the Array is empty: #   table = CSV::Table.new([]) #   table.headers # =&gt; [] # # == Access Modes # # CSV::Table provides three modes for accessing table data: # - Row mode. # - Column mode. # - Mixed mode (the default for a new table). # # The access mode for aCSV::Table instance affects the behavior # of some of its instance methods: # - #[] # - #[]= # - #delete # - #delete_if # - #each # - #values_at # # === Row Mode # # Set a table to row mode with method #by_row!: #   source = “Name,Valuenfoo,0nbar,1nbaz,2n” #   table = CSV.parse(source, headers: true) #   table.by_row! # =&gt; #<CSV::Table mode:row row_count:4&gt; # # Specify a single row by an \Integer index: #   # Get a row. #   <a href="1">table</a> # =&gt; #<CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt; #   # Set a row, then get it. #   <a href="1">table</a> = CSV::Row.new([‘Name’, ‘Value’], [‘bam’, 3]) #   <a href="1">table</a> # =&gt; #<CSV::Row &quot;Name&quot;:&quot;bam&quot; &quot;Value&quot;:3&gt; # # Specify a sequence of rows by a \Range: #   # Get rows. #   <a href="1..2">table</a> # =&gt; [#&lt;CSV::Row “Name”:“bam” “Value”:3&gt;, #<CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;] #   # Set rows, then get them. #   <a href="1..2">table</a> = [ #     CSV::Row.new([‘Name’, ‘Value’], [‘bat’, 4]), #     CSV::Row.new([‘Name’, ‘Value’], [‘bad’, 5]), #   ] #   <a href="1..2">table</a> # =&gt; [[“Name”, #<CSV::Row &quot;Name&quot;:&quot;bat&quot; &quot;Value&quot;:4&gt;], [&quot;Value&quot;, #<CSV::Row &quot;Name&quot;:&quot;bad&quot; &quot;Value&quot;:5&gt;]] # # === Column Mode # # Set a table to column mode with method #by_col!: #   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot; #   table = CSV.parse(source, headers: true) #   table.by_col! # =&gt; #<CSV::Table mode:col row_count:4&gt; # # Specify a column by an \Integer index: #   # Get a column. #   <a href="0">table</a> #   # Set a column, then get it. #   <a href="0">table</a> = [‘FOO’, ‘BAR’, ‘BAZ’] #   <a href="0">table</a> # =&gt; [“FOO”, “BAR”, “BAZ”] # # Specify a column by its String header: #   # Get a column. #   <a href="&#39;Name&#39;">table</a> # =&gt; [“FOO”, “BAR”, “BAZ”] #   # Set a column, then get it. #   <a href="&#39;Name&#39;">table</a> = [‘Foo’, ‘Bar’, ‘Baz’] #   <a href="&#39;Name&#39;">table</a> # =&gt; [“Foo”, “Bar”, “Baz”] # # === Mixed Mode # # In mixed mode, you can refer to either rows or columns: # - An Integer index refers to a row. # - A Range index refers to multiple rows. # - A String index refers to a column. # # Set a table to mixed mode with method #by_col_or_row!: #   source = “Name,Valuenfoo,0nbar,1nbaz,2n” #   table = CSV.parse(source, headers: true) #   table.by_col_or_row! # =&gt; #<CSV::Table mode:col_or_row row_count:4&gt; # # Specify a single row by an \Integer index: #   # Get a row. #   <a href="1">table</a> # =&gt; #<CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt; #   # Set a row, then get it. #   <a href="1">table</a> = CSV::Row.new([‘Name’, ‘Value’], [‘bam’, 3]) #   <a href="1">table</a> # =&gt; #<CSV::Row &quot;Name&quot;:&quot;bam&quot; &quot;Value&quot;:3&gt; # # Specify a sequence of rows by a \Range: #   # Get rows. #   <a href="1..2">table</a> # =&gt; [#&lt;CSV::Row “Name”:“bam” “Value”:3&gt;, #<CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;] #   # Set rows, then get them. #   <a href="1">table</a> = CSV::Row.new([‘Name’, ‘Value’], [‘bat’, 4]) #   <a href="2">table</a> = CSV::Row.new([‘Name’, ‘Value’], [‘bad’, 5]) #   <a href="1..2">table</a> # =&gt; [[“Name”, #<CSV::Row &quot;Name&quot;:&quot;bat&quot; &quot;Value&quot;:4&gt;], [&quot;Value&quot;, #<CSV::Row &quot;Name&quot;:&quot;bad&quot; &quot;Value&quot;:5&gt;]] # # Specify a column by its \String header: #   # Get a column. #   <a href="&#39;Name&#39;">table</a> # =&gt; [“foo”, “bat”, “bad”] #   # Set a column, then get it. #   <a href="&#39;Name&#39;">table</a> = [‘Foo’, ‘Bar’, ‘Baz’] #   <a href="&#39;Name&#39;">table</a> # =&gt; [“Foo”, “Bar”, “Baz”] # # source://csv//lib/csv/table.rb#144 class CSV::Table</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Enumerable</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">Forwardable</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   CSV::Table.new(array_of_rows, headers = nil) -&gt; csv_table</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a new \CSV::Table object.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># - Argument +array_of_rows+ must be an \Array of CSV::Row objects.</span>
<span class="ruby-comment"># - Argument +headers+, if given, may be an \Array of Strings.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Create an empty \CSV::Table object:</span>
<span class="ruby-comment">#   table = CSV::Table.new([])</span>
<span class="ruby-comment">#   table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:1&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Create a non-empty \CSV::Table object:</span>
<span class="ruby-comment">#   rows = [</span>
<span class="ruby-comment">#     CSV::Row.new([], []),</span>
<span class="ruby-comment">#     CSV::Row.new([], []),</span>
<span class="ruby-comment">#     CSV::Row.new([], []),</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#   table  = CSV::Table.new(rows)</span>
<span class="ruby-comment">#   table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If argument +headers+ is an \Array of Strings,</span>
<span class="ruby-comment"># those Strings become the table&#39;s headers:</span>
<span class="ruby-comment">#   table = CSV::Table.new([], headers: [&#39;Name&#39;, &#39;Age&#39;])</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;Name&quot;, &quot;Age&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If argument +headers+ is not given and the table has rows,</span>
<span class="ruby-comment"># the headers are taken from the first row:</span>
<span class="ruby-comment">#   rows = [</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;Foo&#39;, &#39;Bar&#39;], []),</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;foo&#39;, &#39;bar&#39;], []),</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;FOO&#39;, &#39;BAR&#39;], []),</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#   table  = CSV::Table.new(rows)</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If argument +headers+ is not given and the table is empty (has no rows),</span>
<span class="ruby-comment"># the headers are also empty:</span>
<span class="ruby-comment">#   table  = CSV::Table.new([])</span>
<span class="ruby-comment">#   table.headers # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if argument +array_of_rows+ is not an \Array object:</span>
<span class="ruby-comment">#   # Raises NoMethodError (undefined method `first&#39; for :foo:Symbol):</span>
<span class="ruby-comment">#   CSV::Table.new(:foo)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if an element of +array_of_rows+ is not a \CSV::Table object:</span>
<span class="ruby-comment">#   # Raises NoMethodError (undefined method `headers&#39; for :foo:Symbol):</span>
<span class="ruby-comment">#   CSV::Table.new([:foo])</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Table] a new instance of Table</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">array_of_rows</span>, <span class="ruby-value">headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table &lt;&lt; row_or_array -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If +row_or_array+ is a \CSV::Row object,</span>
<span class="ruby-comment"># it is appended to the table:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table &lt;&lt; CSV::Row.new(table.headers, [&#39;bat&#39;, 3])</span>
<span class="ruby-comment">#   table[3] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bat&quot; &quot;Value&quot;:3&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If +row_or_array+ is an \Array, it is used to create a new</span>
<span class="ruby-comment"># \CSV::Row object which is then appended to the table:</span>
<span class="ruby-comment">#   table &lt;&lt; [&#39;bam&#39;, 4]</span>
<span class="ruby-comment">#   table[4] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bam&quot; &quot;Value&quot;:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#762</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">row_or_array</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table == other_table -&gt; true or false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +true+ if all each row of +self+ &lt;tt&gt;==&lt;/tt&gt;</span>
<span class="ruby-comment"># the corresponding row of +other_table+, otherwise, +false+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The access mode does no affect the result.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Equal tables:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   other_table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table == other_table # =&gt; true</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Different row count:</span>
<span class="ruby-comment">#   other_table.delete(2)</span>
<span class="ruby-comment">#   table == other_table # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Different last row:</span>
<span class="ruby-comment">#   other_table &lt;&lt; [&#39;bat&#39;, 3]</span>
<span class="ruby-comment">#   table == other_table # =&gt; false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#965</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table[n] -&gt; row or column_data</span>
<span class="ruby-comment">#   table[range] -&gt; array_of_rows or array_of_column_data</span>
<span class="ruby-comment">#   table[header] -&gt; array_of_column_data</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns data from the table;  does not modify the table.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch a \Row by Its \Integer Index::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[n]&lt;/tt&gt;, +n+ an integer.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: _nth_ row of the table, if that row exists;</span>
<span class="ruby-comment">#   otherwise +nil+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the _nth_ row of the table if that row exists:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   table[1] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#   table[1] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Counts backward from the last row if +n+ is negative:</span>
<span class="ruby-comment">#   table[-1] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns +nil+ if +n+ is too large or too small:</span>
<span class="ruby-comment">#   table[4] # =&gt; nil</span>
<span class="ruby-comment">#   table[-4] # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Raises an exception if the access mode is &lt;tt&gt;:row&lt;/tt&gt;</span>
<span class="ruby-comment"># and +n+ is not an \Integer:</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   # Raises TypeError (no implicit conversion of String into Integer):</span>
<span class="ruby-comment">#   table[&#39;Name&#39;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch a Column by Its \Integer Index::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[n]&lt;/tt&gt;, +n+ an \Integer.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:col&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: _nth_ column of the table, if that column exists;</span>
<span class="ruby-comment">#   otherwise an \Array of +nil+ fields of length &lt;tt&gt;self.size&lt;/tt&gt;.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the _nth_ column of the table if that column exists:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   table[1] # =&gt; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Counts backward from the last column if +n+ is negative:</span>
<span class="ruby-comment">#   table[-2] # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns an \Array of +nil+ fields if +n+ is too large or too small:</span>
<span class="ruby-comment">#   table[4] # =&gt; [nil, nil, nil]</span>
<span class="ruby-comment">#   table[-4] # =&gt; [nil, nil, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch Rows by \Range::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[range]&lt;/tt&gt;, +range+ a \Range object.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: rows from the table, beginning at row &lt;tt&gt;range.start&lt;/tt&gt;,</span>
<span class="ruby-comment">#   if those rows exists.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns rows from the table, beginning at row &lt;tt&gt;range.first&lt;/tt&gt;,</span>
<span class="ruby-comment"># if those rows exist:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   rows = table[1..2] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   rows # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#   table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#   rows = table[1..2] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   rows # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If there are too few rows, returns all from &lt;tt&gt;range.start&lt;/tt&gt; to the end:</span>
<span class="ruby-comment">#   rows = table[1..50] # =&gt; #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   rows # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Special case: if &lt;tt&gt;range.start == table.size&lt;/tt&gt;, returns an empty \Array:</span>
<span class="ruby-comment">#   table[table.size..50] # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.end&lt;/tt&gt; is negative, calculates the ending index from the end:</span>
<span class="ruby-comment">#   rows = table[0..-1]</span>
<span class="ruby-comment">#   rows # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.start&lt;/tt&gt; is negative, calculates the starting index from the end:</span>
<span class="ruby-comment">#   rows = table[-1..2]</span>
<span class="ruby-comment">#   rows # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.start&lt;/tt&gt; is larger than &lt;tt&gt;table.size&lt;/tt&gt;, returns +nil+:</span>
<span class="ruby-comment">#   table[4..4] # =&gt; nil</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch Columns by \Range::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[range]&lt;/tt&gt;, +range+ a \Range object.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:col&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: column data from the table, beginning at column &lt;tt&gt;range.start&lt;/tt&gt;,</span>
<span class="ruby-comment">#   if those columns exist.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns column values from the table, if the column exists;</span>
<span class="ruby-comment"># the values are arranged by row:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_col!</span>
<span class="ruby-comment">#   table[0..1] # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Special case: if &lt;tt&gt;range.start == headers.size&lt;/tt&gt;,</span>
<span class="ruby-comment"># returns an \Array (size: &lt;tt&gt;table.size&lt;/tt&gt;) of empty \Arrays:</span>
<span class="ruby-comment">#   table[table.headers.size..50] # =&gt; [[], [], []]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.end&lt;/tt&gt; is negative, calculates the ending index from the end:</span>
<span class="ruby-comment">#   table[0..-1] # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.start&lt;/tt&gt; is negative, calculates the starting index from the end:</span>
<span class="ruby-comment">#   table[-2..2] # =&gt; [[&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If &lt;tt&gt;range.start&lt;/tt&gt; is larger than &lt;tt&gt;table.size&lt;/tt&gt;,</span>
<span class="ruby-comment"># returns an \Array of +nil+ values:</span>
<span class="ruby-comment">#   table[4..4] # =&gt; [nil, nil, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Fetch a Column by Its \String Header::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[header]&lt;/tt&gt;, +header+ a \String header.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:col&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;</span>
<span class="ruby-comment"># - Return value: column data from the table, if that +header+ exists.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns column values from the table, if the column exists:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   table[&#39;Name&#39;] # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#   table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#   col = table[&#39;Name&#39;]</span>
<span class="ruby-comment">#   col # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Modifying the returned column values does not modify the table:</span>
<span class="ruby-comment">#   col[0] = &#39;bat&#39;</span>
<span class="ruby-comment">#   col # =&gt; [&quot;bat&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#   table[&#39;Name&#39;] # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns an \Array of +nil+ values if there is no such column:</span>
<span class="ruby-comment">#   table[&#39;Nosuch&#39;] # =&gt; [nil, nil, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#514</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">index_or_header</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table[n] = row -&gt; row</span>
<span class="ruby-comment">#   table[n] = field_or_array_of_fields -&gt; field_or_array_of_fields</span>
<span class="ruby-comment">#   table[header] = field_or_array_of_fields -&gt; field_or_array_of_fields</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Puts data onto the table.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Set a \Row by Its \Integer Index::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[n] = row&lt;/tt&gt;, +n+ an \Integer,</span>
<span class="ruby-comment">#   +row+ a \CSV::Row instance or an \Array of fields.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: +row+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the row exists, it is replaced:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   new_row = CSV::Row.new([&#39;Name&#39;, &#39;Value&#39;], [&#39;bat&#39;, 3])</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   return_value = table[0] = new_row</span>
<span class="ruby-comment">#   return_value.equal?(new_row) # =&gt; true # Returned the row</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bat&quot;, &quot;Value&quot;=&gt;3}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With access mode &lt;tt&gt;:col_or_row&lt;/tt&gt;:</span>
<span class="ruby-comment">#   table.by_col_or_row! # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;</span>
<span class="ruby-comment">#   table[0] = CSV::Row.new([&#39;Name&#39;, &#39;Value&#39;], [&#39;bam&#39;, 4])</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bam&quot;, &quot;Value&quot;=&gt;4}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># With an \Array instead of a \CSV::Row, inherits headers from the table:</span>
<span class="ruby-comment">#   array = [&#39;bad&#39;, 5]</span>
<span class="ruby-comment">#   return_value = table[0] = array</span>
<span class="ruby-comment">#   return_value.equal?(array) # =&gt; true # Returned the array</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bad&quot;, &quot;Value&quot;=&gt;5}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the row does not exist, extends the table by adding rows:</span>
<span class="ruby-comment"># assigns rows with +nil+ as needed:</span>
<span class="ruby-comment">#   table.size # =&gt; 3</span>
<span class="ruby-comment">#   table[5] = [&#39;bag&#39;, 6]</span>
<span class="ruby-comment">#   table.size # =&gt; 6</span>
<span class="ruby-comment">#   table[3] # =&gt; nil</span>
<span class="ruby-comment">#   table[4]# =&gt; nil</span>
<span class="ruby-comment">#   table[5].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bag&quot;, &quot;Value&quot;=&gt;6}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note that the +nil+ rows are actually +nil+, not a row of +nil+ fields.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Set a Column by Its \Integer Index::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[n] = array_of_fields&lt;/tt&gt;, +n+ an \Integer,</span>
<span class="ruby-comment">#   +array_of_fields+ an \Array of \String fields.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:col&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: +array_of_fields+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the column exists, it is replaced:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   new_col = [3, 4, 5]</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   return_value = table[1] = new_col</span>
<span class="ruby-comment">#   return_value.equal?(new_col) # =&gt; true # Returned the column</span>
<span class="ruby-comment">#   table[1] # =&gt; [3, 4, 5]</span>
<span class="ruby-comment">#   # The rows, as revised:</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;foo&quot;, &quot;Value&quot;=&gt;3}</span>
<span class="ruby-comment">#   table[1].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bar&quot;, &quot;Value&quot;=&gt;4}</span>
<span class="ruby-comment">#   table[2].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;baz&quot;, &quot;Value&quot;=&gt;5}</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If there are too few values, fills with +nil+ values:</span>
<span class="ruby-comment">#   table[1] = [0]</span>
<span class="ruby-comment">#   table[1] # =&gt; [0, nil, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If there are too many values, ignores the extra values:</span>
<span class="ruby-comment">#   table[1] = [0, 1, 2, 3, 4]</span>
<span class="ruby-comment">#   table[1] # =&gt; [0, 1, 2]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If a single value is given, replaces all fields in the column with that value:</span>
<span class="ruby-comment">#   table[1] = &#39;bat&#39;</span>
<span class="ruby-comment">#   table[1] # =&gt; [&quot;bat&quot;, &quot;bat&quot;, &quot;bat&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Set a Column by Its \String Header::</span>
<span class="ruby-comment"># - Form: &lt;tt&gt;table[header] = field_or_array_of_fields&lt;/tt&gt;,</span>
<span class="ruby-comment">#   +header+ a \String header, +field_or_array_of_fields+ a field value</span>
<span class="ruby-comment">#   or an \Array of \String fields.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:col&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Return value: +field_or_array_of_fields+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the column exists, it is replaced:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   new_col = [3, 4, 5]</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   return_value = table[&#39;Value&#39;] = new_col</span>
<span class="ruby-comment">#   return_value.equal?(new_col) # =&gt; true # Returned the column</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] # =&gt; [3, 4, 5]</span>
<span class="ruby-comment">#   # The rows, as revised:</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;foo&quot;, &quot;Value&quot;=&gt;3}</span>
<span class="ruby-comment">#   table[1].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bar&quot;, &quot;Value&quot;=&gt;4}</span>
<span class="ruby-comment">#   table[2].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;baz&quot;, &quot;Value&quot;=&gt;5}</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If there are too few values, fills with +nil+ values:</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] = [0]</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] # =&gt; [0, nil, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If there are too many values, ignores the extra values:</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] = [0, 1, 2, 3, 4]</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] # =&gt; [0, 1, 2]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the column does not exist, extends the table by adding columns:</span>
<span class="ruby-comment">#   table[&#39;Note&#39;] = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</span>
<span class="ruby-comment">#   table[&#39;Note&#39;] # =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="ruby-comment">#   # The rows, as revised:</span>
<span class="ruby-comment">#   table.by_row!</span>
<span class="ruby-comment">#   table[0].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;foo&quot;, &quot;Value&quot;=&gt;0, &quot;Note&quot;=&gt;&quot;x&quot;}</span>
<span class="ruby-comment">#   table[1].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;bar&quot;, &quot;Value&quot;=&gt;1, &quot;Note&quot;=&gt;&quot;y&quot;}</span>
<span class="ruby-comment">#   table[2].to_h # =&gt; {&quot;Name&quot;=&gt;&quot;baz&quot;, &quot;Value&quot;=&gt;2, &quot;Note&quot;=&gt;&quot;z&quot;}</span>
<span class="ruby-comment">#   table.by_col!</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If a single value is given, replaces all fields in the column with that value:</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] = &#39;bat&#39;</span>
<span class="ruby-comment">#   table[&#39;Value&#39;] # =&gt; [&quot;bat&quot;, &quot;bat&quot;, &quot;bat&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#649</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">index_or_header</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_col -&gt; table_dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a duplicate of +self+, in column mode</span>
<span class="ruby-comment"># (see {Column Mode}[#class-CSV::Table-label-Column+Mode]):</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   dup_table = table.by_col</span>
<span class="ruby-comment">#   dup_table.mode # =&gt; :col</span>
<span class="ruby-comment">#   dup_table.equal?(table) # =&gt; false # It&#39;s a dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This may be used to chain method calls without changing the mode</span>
<span class="ruby-comment"># (but also will affect performance and memory usage):</span>
<span class="ruby-comment">#   dup_table.by_col[&#39;Name&#39;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Also note that changes to the duplicate table will not affect the original.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_col</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_col! -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Sets the mode for +self+ to column mode</span>
<span class="ruby-comment"># (see {Column Mode}[#class-CSV::Table-label-Column+Mode]); returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   table1 = table.by_col!</span>
<span class="ruby-comment">#   table.mode # =&gt; :col</span>
<span class="ruby-comment">#   table1.equal?(table) # =&gt; true # Returned self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_col!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_col_or_row -&gt; table_dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a duplicate of +self+, in mixed mode</span>
<span class="ruby-comment"># (see {Mixed Mode}[#class-CSV::Table-label-Mixed+Mode]):</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true).by_col!</span>
<span class="ruby-comment">#   table.mode # =&gt; :col</span>
<span class="ruby-comment">#   dup_table = table.by_col_or_row</span>
<span class="ruby-comment">#   dup_table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   dup_table.equal?(table) # =&gt; false # It&#39;s a dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This may be used to chain method calls without changing the mode</span>
<span class="ruby-comment"># (but also will affect performance and memory usage):</span>
<span class="ruby-comment">#   dup_table.by_col_or_row[&#39;Name&#39;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Also note that changes to the duplicate table will not affect the original.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#280</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_col_or_row</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_col_or_row! -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Sets the mode for +self+ to mixed mode</span>
<span class="ruby-comment"># (see {Mixed Mode}[#class-CSV::Table-label-Mixed+Mode]); returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true).by_col!</span>
<span class="ruby-comment">#   table.mode # =&gt; :col</span>
<span class="ruby-comment">#   table1 = table.by_col_or_row!</span>
<span class="ruby-comment">#   table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   table1.equal?(table) # =&gt; true # Returned self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_col_or_row!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_row -&gt; table_dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a duplicate of +self+, in row mode</span>
<span class="ruby-comment"># (see {Row Mode}[#class-CSV::Table-label-Row+Mode]):</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   dup_table = table.by_row</span>
<span class="ruby-comment">#   dup_table.mode # =&gt; :row</span>
<span class="ruby-comment">#   dup_table.equal?(table) # =&gt; false # It&#39;s a dup</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This may be used to chain method calls without changing the mode</span>
<span class="ruby-comment"># (but also will affect performance and memory usage):</span>
<span class="ruby-comment">#   dup_table.by_row[1]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Also note that changes to the duplicate table will not affect the original.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_row</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.by_row! -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Sets the mode for +self+ to row mode</span>
<span class="ruby-comment"># (see {Row Mode}[#class-CSV::Table-label-Row+Mode]); returns +self+:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.mode # =&gt; :col_or_row</span>
<span class="ruby-comment">#   table1 = table.by_row!</span>
<span class="ruby-comment">#   table.mode # =&gt; :row</span>
<span class="ruby-comment">#   table1.equal?(table) # =&gt; true # Returned self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#333</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">by_row!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.delete(*indexes) -&gt; deleted_values</span>
<span class="ruby-comment">#   table.delete(*headers) -&gt; deleted_values</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the access mode is &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;,</span>
<span class="ruby-comment"># and each argument is either an \Integer or a \Range,</span>
<span class="ruby-comment"># returns deleted rows.</span>
<span class="ruby-comment"># Otherwise, returns deleted columns data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In either case, the returned values are in the order</span>
<span class="ruby-comment"># specified by the arguments.  Arguments may be repeated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns rows as an \Array of \CSV::Row objects.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># One index:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   deleted_values = table.delete(0)</span>
<span class="ruby-comment">#   deleted_values # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Two indexes:</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   deleted_values = table.delete(2, 0)</span>
<span class="ruby-comment">#   deleted_values # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns columns data as column Arrays.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># One header:</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   deleted_values = table.delete(&#39;Name&#39;)</span>
<span class="ruby-comment">#   deleted_values # =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Two headers:</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   deleted_values = table.delete(&#39;Value&#39;, &#39;Name&#39;)</span>
<span class="ruby-comment">#   deleted_values # =&gt; [[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;], [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#834</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indexes_or_headers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.delete_if {|row_or_column| ... } -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes rows or columns for which the block returns a truthy value;</span>
<span class="ruby-comment"># returns +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes rows when the access mode is &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;;</span>
<span class="ruby-comment"># calls the block with each \CSV::Row object:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   table.size # =&gt; 3</span>
<span class="ruby-comment">#   table.delete_if {|row| row[&#39;Name&#39;].start_with?(&#39;b&#39;) }</span>
<span class="ruby-comment">#   table.size # =&gt; 1</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Removes columns when the access mode is &lt;tt&gt;:col&lt;/tt&gt;;</span>
<span class="ruby-comment"># calls the block with each column as a 2-element array</span>
<span class="ruby-comment"># containing the header and an \Array of column fields:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   table.headers.size # =&gt; 2</span>
<span class="ruby-comment">#   table.delete_if {|column_data| column_data[1].include?(&#39;2&#39;) }</span>
<span class="ruby-comment">#   table.headers.size # =&gt; 1</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a new \Enumerator if no block is given:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.delete_if # =&gt; #&lt;Enumerator: #&lt;CSV::Table mode:col_or_row row_count:4&gt;:delete_if&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#887</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_if</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Extracts the nested value specified by the sequence of +index+ or +header+ objects by calling dig at each step,</span>
<span class="ruby-comment"># returning nil if any intermediate step is nil.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#1021</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig</span>(<span class="ruby-identifier">index_or_header</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">index_or_headers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#  table.each {|row_or_column| ... ) -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Calls the block with each row or column; returns +self+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the access mode is &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;,</span>
<span class="ruby-comment"># calls the block with each \CSV::Row object:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.by_row! # =&gt; #&lt;CSV::Table mode:row row_count:4&gt;</span>
<span class="ruby-comment">#   table.each {|row| p row }</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;</span>
<span class="ruby-comment">#   #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;</span>
<span class="ruby-comment">#   #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># When the access mode is &lt;tt&gt;:col&lt;/tt&gt;,</span>
<span class="ruby-comment"># calls the block with each column as a 2-element array</span>
<span class="ruby-comment"># containing the header and an \Array of column fields:</span>
<span class="ruby-comment">#   table.by_col! # =&gt; #&lt;CSV::Table mode:col row_count:4&gt;</span>
<span class="ruby-comment">#   table.each {|column_data| p column_data }</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [&quot;Name&quot;, [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]]</span>
<span class="ruby-comment">#   [&quot;Value&quot;, [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a new \Enumerator if no block is given:</span>
<span class="ruby-comment">#   table.each # =&gt; #&lt;Enumerator: #&lt;CSV::Table mode:col row_count:4&gt;:each&gt;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#930</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/table.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.headers -&gt; array_of_headers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a new \Array containing the \String headers for the table.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the table is not empty, returns the headers from the first row:</span>
<span class="ruby-comment">#   rows = [</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;Foo&#39;, &#39;Bar&#39;], []),</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;FOO&#39;, &#39;BAR&#39;], []),</span>
<span class="ruby-comment">#     CSV::Row.new([&#39;foo&#39;, &#39;bar&#39;], []),</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#   table  = CSV::Table.new(rows)</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#   table.delete(0)</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;FOO&quot;, &quot;BAR&quot;]</span>
<span class="ruby-comment">#   table.delete(0)</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the table is empty, returns a copy of the headers in the table itself:</span>
<span class="ruby-comment">#   table.delete(0)</span>
<span class="ruby-comment">#   table.headers # =&gt; [&quot;Foo&quot;, &quot;Bar&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.inspect =&gt; string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns a &lt;tt&gt;US-ASCII&lt;/tt&gt;-encoded \String showing table:</span>
<span class="ruby-comment"># - Class: &lt;tt&gt;CSV::Table&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Access mode: &lt;tt&gt;:row&lt;/tt&gt;, &lt;tt&gt;:col&lt;/tt&gt;, or &lt;tt&gt;:col_or_row&lt;/tt&gt;.</span>
<span class="ruby-comment"># - Size:  Row count, including the header row.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Example:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.inspect # =&gt; &quot;#&lt;CSV::Table mode:col_or_row row_count:4&gt;\nName,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#1048</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/table.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current access mode for indexing and iteration.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mode</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.push(*rows_or_arrays) -&gt; self</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># A shortcut for appending multiple rows. Equivalent to:</span>
<span class="ruby-comment">#   rows.each {|row| self &lt;&lt; row }</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Each argument may be either a \CSV::Row object or an \Array:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   rows = [</span>
<span class="ruby-comment">#     CSV::Row.new(table.headers, [&#39;bat&#39;, 3]),</span>
<span class="ruby-comment">#     [&#39;bam&#39;, 4]</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#   table.push(*rows)</span>
<span class="ruby-comment">#   table[3..4] # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;bat&quot; &quot;Value&quot;:3&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;bam&quot; &quot;Value&quot;:4&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#788</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">rows</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/table.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.to_a -&gt; array_of_arrays</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the table as an \Array of \Arrays;</span>
<span class="ruby-comment"># the headers are in the first row:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.to_a # =&gt; [[&quot;Name&quot;, &quot;Value&quot;], [&quot;foo&quot;, &quot;0&quot;], [&quot;bar&quot;, &quot;1&quot;], [&quot;baz&quot;, &quot;2&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#978</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.to_csv(**options) -&gt; csv_string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the table as \CSV string.</span>
<span class="ruby-comment"># See {Options for Generating}[../CSV.html#class-CSV-label-Options+for+Generating].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Defaults option +write_headers+ to +true+:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.to_csv # =&gt; &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Omits the headers if option +write_headers+ is given as +false+</span>
<span class="ruby-comment"># (see {Option +write_headers+}[../CSV.html#class-CSV-label-Option+write_headers]):</span>
<span class="ruby-comment">#   table.to_csv(write_headers: false) # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Limit rows if option +limit+ is given like +2+:</span>
<span class="ruby-comment">#   table.to_csv(limit: 2) # =&gt; &quot;Name,Value\nfoo,0\nbar,1\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#1004</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_csv</span>(<span class="ruby-value">write_headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">limit:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.to_csv(**options) -&gt; csv_string</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns the table as \CSV string.</span>
<span class="ruby-comment"># See {Options for Generating}[../CSV.html#class-CSV-label-Options+for+Generating].</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Defaults option +write_headers+ to +true+:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.to_csv # =&gt; &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Omits the headers if option +write_headers+ is given as +false+</span>
<span class="ruby-comment"># (see {Option +write_headers+}[../CSV.html#class-CSV-label-Option+write_headers]):</span>
<span class="ruby-comment">#   table.to_csv(write_headers: false) # =&gt; &quot;foo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Limit rows if option +limit+ is given like +2+:</span>
<span class="ruby-comment">#   table.to_csv(limit: 2) # =&gt; &quot;Name,Value\nfoo,0\nbar,1\n&quot;</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#1015</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>(<span class="ruby-value">write_headers:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">limit:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># :call-seq:</span>
<span class="ruby-comment">#   table.values_at(*indexes) -&gt; array_of_rows</span>
<span class="ruby-comment">#   table.values_at(*headers) -&gt; array_of_columns_data</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the access mode is &lt;tt&gt;:row&lt;/tt&gt; or &lt;tt&gt;:col_or_row&lt;/tt&gt;,</span>
<span class="ruby-comment"># and each argument is either an \Integer or a \Range,</span>
<span class="ruby-comment"># returns rows.</span>
<span class="ruby-comment"># Otherwise, returns columns data.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># In either case, the returned values are in the order</span>
<span class="ruby-comment"># specified by the arguments.  Arguments may be repeated.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns rows as an \Array of \CSV::Row objects.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># No argument:</span>
<span class="ruby-comment">#   source = &quot;Name,Value\nfoo,0\nbar,1\nbaz,2\n&quot;</span>
<span class="ruby-comment">#   table = CSV.parse(source, headers: true)</span>
<span class="ruby-comment">#   table.values_at # =&gt; []</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># One index:</span>
<span class="ruby-comment">#   values = table.values_at(0)</span>
<span class="ruby-comment">#   values # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Two indexes:</span>
<span class="ruby-comment">#   values = table.values_at(2, 0)</span>
<span class="ruby-comment">#   values # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># One \Range:</span>
<span class="ruby-comment">#   values = table.values_at(1..2)</span>
<span class="ruby-comment">#   values # =&gt; [#&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;, #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># \Ranges and indexes:</span>
<span class="ruby-comment">#   values = table.values_at(0..1, 1..2, 0, 2)</span>
<span class="ruby-comment">#   pp values</span>
<span class="ruby-comment"># Output:</span>
<span class="ruby-comment">#   [#&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;,</span>
<span class="ruby-comment">#    #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;,</span>
<span class="ruby-comment">#    #&lt;CSV::Row &quot;Name&quot;:&quot;bar&quot; &quot;Value&quot;:&quot;1&quot;&gt;,</span>
<span class="ruby-comment">#    #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;,</span>
<span class="ruby-comment">#    #&lt;CSV::Row &quot;Name&quot;:&quot;foo&quot; &quot;Value&quot;:&quot;0&quot;&gt;,</span>
<span class="ruby-comment">#    #&lt;CSV::Row &quot;Name&quot;:&quot;baz&quot; &quot;Value&quot;:&quot;2&quot;&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ---</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Returns columns data as row Arrays,</span>
<span class="ruby-comment"># each consisting of the specified columns data for that row:</span>
<span class="ruby-comment">#   values = table.values_at(&#39;Name&#39;)</span>
<span class="ruby-comment">#   values # =&gt; [[&quot;foo&quot;], [&quot;bar&quot;], [&quot;baz&quot;]]</span>
<span class="ruby-comment">#   values = table.values_at(&#39;Value&#39;, &#39;Name&#39;)</span>
<span class="ruby-comment">#   values # =&gt; [[&quot;0&quot;, &quot;foo&quot;], [&quot;1&quot;, &quot;bar&quot;], [&quot;2&quot;, &quot;baz&quot;]]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#734</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">indices_or_headers</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># Internal data format used to compare equality.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/table.rb#217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">table</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Note: Don’t use this class directly. This is an internal class. # # source://csv//lib/csv/writer.rb#8 class CSV::Writer</p>

<pre class="ruby"><span class="ruby-comment"># @return [Writer] a new instance of Writer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/writer.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">output</span>, <span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Adds a new row</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/writer.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">row</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute headers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/writer.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">headers</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A CSV::Writer receives an output, prepares the header, format and output.</span>
<span class="ruby-comment"># It allows us to write new rows in the object and rewind it.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/writer.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lineno</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Winds back to the beginning</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/writer.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rewind</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_force_quotes_fields</span>(<span class="ruby-identifier">force_quotes</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_format</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_header</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepare_output</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quote</span>(<span class="ruby-identifier">field</span>, <span class="ruby-identifier">i</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://csv//lib/csv/writer.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">quote_field</span>(<span class="ruby-identifier">field</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p>class <a href="../../../Object.html"><code>Object</code></a> &lt; ::BasicObject</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Kernel</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">PP</span><span class="ruby-operator">::</span><span class="ruby-constant">ObjectMixin</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://csv//lib/csv.rb#3011</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">CSV</span>(<span class="ruby-operator">*</span><span class="ruby-identifier ruby-title">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://csv//lib/csv/core_ext/string.rb#1 class String</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">Comparable</span>

<span class="ruby-comment"># Equivalent to CSV::parse_line(self, options)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   &quot;CSV,data&quot;.parse_csv</span>
<span class="ruby-comment">#     #=&gt; [&quot;CSV&quot;, &quot;data&quot;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://csv//lib/csv/core_ext/string.rb#6</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_csv</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

</main>

