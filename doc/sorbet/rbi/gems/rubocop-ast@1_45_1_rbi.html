<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>rubocop-ast@1.45.1.rbi - RDoc Documentation</title>

  <meta name="keywords" content="ruby,documentation,rubocop-ast@1.45.1.rbi">
  <meta name="description" content="rubocop-ast@1.45.1.rbi: true # DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the `rubocop-ast` gem. tapioca gem rubocop-ast`.">


<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<div id="navigation-toggle" role="button" tabindex="0" aria-label="Toggle sidebar" aria-expanded="true" aria-controls="navigation">
  <span aria-hidden="true">&#9776;</span>
</div>


<nav id="navigation" role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
  
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../Dockerfile.html">Dockerfile</a>
    <li><a href="../../../Gemfile.html">Gemfile</a>
    <li><a href="../../../Gemfile_lock.html">Gemfile.lock</a>
    <li><a href="../../../README_md.html">README</a>
    <li><a href="../../../Rakefile.html">Rakefile</a>
    <li><details><summary>app</summary>
    <ul class="link-list">
      <li><a href="../../../app/assets/stylesheets/application_css.html">application.css</a>
      <li><a href="../../../app/views/pwa/service-worker_js.html">service-worker.js</a>
    </ul></details>
    <li><a href="../../../bin/docker-entrypoint.html">docker-entrypoint</a>
    <li><a href="../../../config_ru.html">config.ru</a>
    <li><details><summary>config</summary>
    <ul class="link-list">
      <li><a href="../../../config/credentials_yml_enc.html">credentials.yml.enc</a>
      <li><a href="../../../config/master_key.html">master.key</a>
    </ul></details>
    <li><details><summary>log</summary>
    <ul class="link-list">
      <li><a href="../../../log/development_log.html">development.log</a>
      <li><a href="../../../log/test_log.html">test.log</a>
    </ul></details>
    <li><details><summary>public</summary>
    <ul class="link-list">
      <li><a href="../../../public/400_html.html">400.html</a>
      <li><a href="../../../public/404_html.html">404.html</a>
      <li><a href="../../../public/406-unsupported-browser_html.html">406-unsupported-browser.html</a>
      <li><a href="../../../public/422_html.html">422.html</a>
      <li><a href="../../../public/500_html.html">500.html</a>
      <li><a href="../../../public/robots_txt.html">robots</a>
    </ul></details>
    <li><details open><summary>sorbet</summary>
    <ul class="link-list">
      <li><a href="../../../sorbet/config.html">config</a>
      <li><a href="../../../sorbet/rbi/annotations/actionmailer_rbi.html">actionmailer.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionpack_rbi.html">actionpack.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/actionview_rbi.html">actionview.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activejob_rbi.html">activejob.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activemodel_rbi.html">activemodel.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activerecord_rbi.html">activerecord.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/activesupport_rbi.html">activesupport.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/globalid_rbi.html">globalid.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/minitest_rbi.html">minitest.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/railties_rbi.html">railties.rbi</a>
      <li><a href="../../../sorbet/rbi/annotations/rainbow_rbi.html">rainbow.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/caching/fragments_rbi.html">fragments.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/abstract_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/caching_rbi.html">caching.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/conditional_get_rbi.html">conditional_get.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/content_security_policy_rbi.html">content_security_policy.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/data_streaming_rbi.html">data_streaming.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_flash_rbi.html">etag_with_flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/etag_with_template_digest_rbi.html">etag_with_template_digest.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/flash_rbi.html">flash.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/form_builder_rbi.html">form_builder.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/params_wrapper_rbi.html">params_wrapper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/redirecting_rbi.html">redirecting.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers_rbi.html">renderers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/renderers/all_rbi.html">all.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/request_forgery_protection_rbi.html">request_forgery_protection.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/rescue_rbi.html">rescue.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/test_case/behavior_rbi.html">behavior.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_controller/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/assertions_rbi.html">assertions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/integration_test_rbi.html">integration_test.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/route_set/mounted_helpers_rbi.html">mounted_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_dispatch/routing/url_for_rbi.html">url_for.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers_rbi.html">helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_helper_rbi.html">form_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/form_tag_helper_rbi.html">form_tag_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/helpers/text_helper_rbi.html">text_helper.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/layouts_rbi.html">layouts.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/action_view/rendering_rbi.html">rendering.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/enqueuing_rbi.html">enqueuing.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/exceptions_rbi.html">exceptions.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/execution_rbi.html">execution.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/logging_rbi.html">logging.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_adapter_rbi.html">queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_name_rbi.html">queue_name.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/queue_priority_rbi.html">queue_priority.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_job/test_helper/test_queue_adapter_rbi.html">test_queue_adapter.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attribute_methods_rbi.html">attribute_methods.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/attributes_rbi.html">attributes.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/serializers/json_rbi.html">json.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations_rbi.html">validations.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_model/validations/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/actionable_error_rbi.html">actionable_error.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/callbacks_rbi.html">callbacks.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/rescuable_rbi.html">rescuable.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/active_support/testing/file_fixtures_rbi.html">file_fixtures.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/application_controller_rbi.html">application_controller.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/base_generator_rbi.html">base_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/form_generator_rbi.html">form_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_path_helpers_module_rbi.html">generated_path_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_rbi.html">generated_url_helpers.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/generated_url_helpers_module_rbi.html">generated_url_helpers_module.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/policy_generator_rbi.html">policy_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/poro_generator_rbi.html">poro_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/service_generator_rbi.html">service_generator.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/time_rbi.html">time.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/action_broadcast_job_rbi.html">action_broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_job_rbi.html">broadcast_job.rbi</a>
      <li><a href="../../../sorbet/rbi/dsl/turbo/streams/broadcast_stream_job_rbi.html">broadcast_stream_job.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actioncable@8_0_2_rbi.html">actioncable@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailbox@8_0_2_rbi.html">actionmailbox@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionmailer@8_0_2_rbi.html">actionmailer@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionpack@8_0_2_rbi.html">actionpack@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actiontext@8_0_2_rbi.html">actiontext@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/actionview@8_0_2_rbi.html">actionview@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activejob@8_0_2_rbi.html">activejob@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activemodel@8_0_2_rbi.html">activemodel@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activerecord@8_0_2_rbi.html">activerecord@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activestorage@8_0_2_rbi.html">activestorage@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/activesupport@8_0_2_rbi.html">activesupport@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ast@2_4_3_rbi.html">ast@2.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/backport@1_2_0_rbi.html">backport@1.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/base64@0_3_0_rbi.html">base64@0.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bcrypt_pbkdf@1_1_1_rbi.html">bcrypt_pbkdf@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/benchmark@0_4_1_rbi.html">benchmark@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bigdecimal@3_2_2_rbi.html">bigdecimal@3.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/bindex@0_8_1_rbi.html">bindex@0.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/brakeman@7_0_2_rbi.html">brakeman@7.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/commander@5_0_0_rbi.html">commander@5.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/concurrent-ruby@1_3_5_rbi.html">concurrent-ruby@1.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/connection_pool@2_5_3_rbi.html">connection_pool@2.5.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/crass@1_0_6_rbi.html">crass@1.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/csv@3_3_5_rbi.html">csv@3.3.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/date@3_4_1_rbi.html">date@3.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/diff-lcs@1_6_2_rbi.html">diff-lcs@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/dotenv@3_1_8_rbi.html">dotenv@3.1.8.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/drb@2_2_3_rbi.html">drb@2.2.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/e2mmap@0_1_0_rbi.html">e2mmap@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ed25519@1_4_0_rbi.html">ed25519@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erb@5_0_1_rbi.html">erb@5.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/erubi@1_13_1_rbi.html">erubi@1.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/globalid@1_2_1_rbi.html">globalid@1.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/highline@3_0_1_rbi.html">highline@3.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/httparty@0_23_1_rbi.html">httparty@0.23.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/i18n@1_14_7_rbi.html">i18n@1.14.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/importmap-rails@2_1_0_rbi.html">importmap-rails@2.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/io-console@0_8_0_rbi.html">io-console@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/jaro_winkler@1_6_1_rbi.html">jaro_winkler@1.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/json@2_12_2_rbi.html">json@2.12.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kamal@2_7_0_rbi.html">kamal@2.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown-parser-gfm@1_1_0_rbi.html">kramdown-parser-gfm@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/kramdown@2_5_1_rbi.html">kramdown@2.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/language_server-protocol@3_17_0_5_rbi.html">language_server-protocol@3.17.0.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/lint_roller@1_1_0_rbi.html">lint_roller@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/logger@1_7_0_rbi.html">logger@1.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/loofah@2_24_1_rbi.html">loofah@2.24.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mail@2_8_1_rbi.html">mail@2.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/marcel@1_0_4_rbi.html">marcel@1.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/method_source@1_1_0_rbi.html">method_source@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/mini_mime@1_1_5_rbi.html">mini_mime@1.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/minitest@5_25_5_rbi.html">minitest@5.25.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/multi_xml@0_7_2_rbi.html">multi_xml@0.7.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-imap@0_5_9_rbi.html">net-imap@0.5.9.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-pop@0_1_2_rbi.html">net-pop@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-protocol@0_2_2_rbi.html">net-protocol@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-scp@4_1_0_rbi.html">net-scp@4.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-sftp@4_0_0_rbi.html">net-sftp@4.0.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-smtp@0_5_1_rbi.html">net-smtp@0.5.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/net-ssh@7_3_0_rbi.html">net-ssh@7.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/netrc@0_11_0_rbi.html">netrc@0.11.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/nio4r@2_7_4_rbi.html">nio4r@2.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/observer@0_1_2_rbi.html">observer@0.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ostruct@0_6_2_rbi.html">ostruct@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parallel@1_27_0_rbi.html">parallel@1.27.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parlour@9_1_2_rbi.html">parlour@9.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/parser@3_3_8_0_rbi.html">parser@3.3.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pattern_generator@0_1_0_rbi.html">pattern_generator@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/polyfill@1_9_0_rbi.html">polyfill@1.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/pp@0_6_2_rbi.html">pp@0.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prettyprint@0_2_0_rbi.html">prettyprint@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/prism@1_4_0_rbi.html">prism@1.4.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/propshaft@1_1_0_rbi.html">propshaft@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/psych@5_2_6_rbi.html">psych@5.2.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/puma@6_6_0_rbi.html">puma@6.6.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/racc@1_8_1_rbi.html">racc@1.8.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-session@2_1_1_rbi.html">rack-session@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack-test@2_2_0_rbi.html">rack-test@2.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rack@3_1_16_rbi.html">rack@3.1.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rackup@2_2_1_rbi.html">rackup@2.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-dom-testing@2_3_0_rbi.html">rails-dom-testing@2.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails-html-sanitizer@1_6_2_rbi.html">rails-html-sanitizer@1.6.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rails@8_0_2_rbi.html">rails@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/railties@8_0_2_rbi.html">railties@8.0.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rainbow@3_1_1_rbi.html">rainbow@3.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rake@13_3_0_rbi.html">rake@13.3.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbi@0_3_6_rbi.html">rbi@0.3.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rbs@4_0_0_dev_4_rbi.html">rbs@4.0.0.dev.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rdoc@6_14_2_rbi.html">rdoc@6.14.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/redcarpet@3_6_1_rbi.html">redcarpet@3.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/regexp_parser@2_10_0_rbi.html">regexp_parser@2.10.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reline@0_6_1_rbi.html">reline@0.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/require-hooks@0_2_2_rbi.html">require-hooks@0.2.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/reverse_markdown@2_1_1_rbi.html">reverse_markdown@2.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-core@3_13_5_rbi.html">rspec-core@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-expectations@3_13_5_rbi.html">rspec-expectations@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-mocks@3_13_5_rbi.html">rspec-mocks@3.13.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-rails@8_0_1_rbi.html">rspec-rails@8.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec-support@3_13_4_rbi.html">rspec-support@3.13.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rspec@3_13_1_rbi.html">rspec@3.13.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-ast@1_45_1_rbi.html">rubocop-ast@1.45.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-performance@1_25_0_rbi.html">rubocop-performance@1.25.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails-omakase@1_1_0_rbi.html">rubocop-rails-omakase@1.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop-rails@2_32_0_rbi.html">rubocop-rails@2.32.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/rubocop@1_78_0_rbi.html">rubocop@1.78.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp-rails@0_4_6_rbi.html">ruby-lsp-rails@0.4.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-lsp@0_24_2_rbi.html">ruby-lsp@0.24.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/ruby-progressbar@1_13_0_rbi.html">ruby-progressbar@1.13.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/safe_type@1_1_1_rbi.html">safe_type@1.1.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/securerandom@0_4_1_rbi.html">securerandom@0.4.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph-rails@1_1_2_rbi.html">solargraph-rails@1.1.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/solargraph@0_48_0_rbi.html">solargraph@0.48.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-coerce@0_7_0_rbi.html">sorbet-coerce@0.7.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-rails@0_7_34_rbi.html">sorbet-rails@0.7.34.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sorbet-runtime-stub@0_2_0_rbi.html">sorbet-runtime-stub@0.2.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/spoom@1_7_4_rbi.html">spoom@1.7.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/sshkit@1_24_0_rbi.html">sshkit@1.24.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stimulus-rails@1_3_4_rbi.html">stimulus-rails@1.3.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/stringio@3_1_7_rbi.html">stringio@3.1.7.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tapioca@0_17_6_rbi.html">tapioca@0.17.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thor@1_3_2_rbi.html">thor@1.3.2.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/thruster@0_1_14_rbi.html">thruster@0.1.14.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tilt@2_6_1_rbi.html">tilt@2.6.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/timeout@0_4_3_rbi.html">timeout@0.4.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/turbo-rails@2_0_16_rbi.html">turbo-rails@2.0.16.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/tzinfo@2_0_6_rbi.html">tzinfo@2.0.6.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-display_width@3_1_4_rbi.html">unicode-display_width@3.1.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/unicode-emoji@4_0_4_rbi.html">unicode-emoji@4.0.4.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/uri@1_0_3_rbi.html">uri@1.0.3.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/useragent@0_16_11_rbi.html">useragent@0.16.11.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/web-console@4_2_1_rbi.html">web-console@4.2.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-driver@0_8_0_rbi.html">websocket-driver@0.8.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/websocket-extensions@0_1_5_rbi.html">websocket-extensions@0.1.5.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-kramdown@0_0_1_rbi.html">yard-kramdown@0.0.1.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-solargraph@0_1_0_rbi.html">yard-solargraph@0.1.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard-sorbet@0_9_0_rbi.html">yard-sorbet@0.9.0.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/yard@0_9_37_rbi.html">yard@0.9.37.rbi</a>
      <li><a href="../../../sorbet/rbi/gems/zeitwerk@2_7_3_rbi.html">zeitwerk@2.7.3.rbi</a>
      <li><a href="../../../sorbet/rbi/todo_rbi.html">todo.rbi</a>
    </ul></details>
    <li><a href="../../../tmp/restart_txt.html">restart</a>
  </ul>
</div>


  <footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.14.2.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

</nav>

<main role="main" aria-label="Page sorbet/rbi/gems/rubocop-ast@1.45.1.rbi">

<p># typed: true</p>

<p># DO NOT EDIT MANUALLY # This is an autogenerated file for types exported from the ‘rubocop-ast` gem. # Please instead update this file by running `bin/tapioca gem rubocop-ast`.</p>

<p>class Parser::Source::Range</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Ext</span><span class="ruby-operator">::</span><span class="ruby-constant">Range</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/ext/range.rb#3 module RuboCop; end</p>

<p># … # # source://rubocop-ast//lib/rubocop/ast/ext/range.rb#4 module RuboCop::AST</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">RuboCopCompatibility</span>
</pre>

<p>end</p>

<p># A node extension for ‘alias` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `alias` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/alias_node.rb#8 class RuboCop::AST::AliasNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the new identifier as specified by the `alias`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [SymbolNode] the new identifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/alias_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_identifier</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the old identifier as specified by the `alias`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [SymbolNode] the old identifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/alias_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">old_identifier</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘op_asgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/and_asgn_node.rb#8 class RuboCop::AST::AndAsgnNode &lt; ::RuboCop::AST::OpAsgnNode</p>

<pre class="ruby"><span class="ruby-comment"># The operator being used for assignment as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the assignment operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/and_asgn_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘until` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `until` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/and_node.rb#8 class RuboCop::AST::AndNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BinaryOperatorNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">PredicateOperatorNode</span>

<span class="ruby-comment"># Returns the alternate operator of the `and` as a string.</span>
<span class="ruby-comment"># Returns `and` for `&amp;&amp;` and vice versa.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the alternate of the `and` operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/and_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternate_operator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse keyword of the `and` node as a string.</span>
<span class="ruby-comment"># Returns `||` for `&amp;&amp;` and `or` for `and`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the inverse of the `and` operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/and_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘arg`, `optarg`, `restarg`, `kwarg`, `kwoptarg`, # `kwrestarg`, `blockarg`, `shadowarg` and `forward_arg` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all `arg` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/arg_node.rb#9 class RuboCop::AST::ArgNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether the argument has a default value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the argument has a default value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/arg_node.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the default value of the argument, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the default value of the argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/arg_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the name of an argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol, nil] the name of the argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/arg_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘args` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `args` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/args_node.rb#8 class RuboCop::AST::ArgsNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">CollectionNode</span>

<span class="ruby-comment"># Yield each argument from the collection.</span>
<span class="ruby-comment"># Arguments can be inside `mlhs` nodes in the case of destructuring, so this</span>
<span class="ruby-comment"># flattens the collection to just `arg`, `optarg`, `restarg`, `kwarg`,</span>
<span class="ruby-comment"># `kwoptarg`, `kwrestarg`, `blockarg`, `forward_arg` and `shadowarg`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] array of argument nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/args_node.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_list</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># It returns true if arguments are empty and delimiters do not exist.</span>
<span class="ruby-comment"># @example:</span>
<span class="ruby-comment">#   # true</span>
<span class="ruby-comment">#   def x; end</span>
<span class="ruby-comment">#   x { }</span>
<span class="ruby-comment">#   -&gt; {}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   # false</span>
<span class="ruby-comment">#   def x(); end</span>
<span class="ruby-comment">#   def x a; end</span>
<span class="ruby-comment">#   x { || }</span>
<span class="ruby-comment">#   -&gt; () {}</span>
<span class="ruby-comment">#   -&gt; a {}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/args_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_and_without_delimiters?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘array` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `array` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#8 class RuboCop::AST::ArrayNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether the `array` literal is delimited by either percent or</span>
<span class="ruby-comment"># square brackets</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># brackets</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the array is enclosed in percent or square</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bracketed?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each `value` node in the `array` literal.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_value</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `array` literal is delimited by percent brackets.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload percent_literal?</span>
<span class="ruby-comment"># @overload percent_literal?</span>
<span class="ruby-comment"># @return [Boolean] whether the array is enclosed in percent brackets</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_literal?</span>(<span class="ruby-identifier">type</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `array` literal is delimited by square brackets.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the array is enclosed in square brackets</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">square_brackets?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all value nodes in the `array` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of value nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/array_node.rb#9 RuboCop::AST::ArrayNode::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Hash)</p>

<p># A node extension for ‘lvasgn`, `ivasgn`, `cvasgn`, and `gvasgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/asgn_node.rb#8 class RuboCop::AST::AsgnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/asgn_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the variable being assigned as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the variable being assigned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/asgn_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the variable being assigned as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the variable being assigned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/asgn_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/asgn_node.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for primitive literal nodes: ‘sym`, `str`, # `int`, `float`, `rational`… # # source://rubocop-ast//lib/rubocop/ast/node/mixin/basic_literal_node.rb#7 module RuboCop::AST::BasicLiteralNode</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of the literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [mixed] the value of the literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/basic_literal_node.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that are binary operations: # ‘or`, `and` … # # source://rubocop-ast//lib/rubocop/ast/node/mixin/binary_operator_node.rb#7 module RuboCop::AST::BinaryOperatorNode</p>

<pre class="ruby"><span class="ruby-comment"># Returns all of the conditions, including nested conditions,</span>
<span class="ruby-comment"># of the binary operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># operation and the let and right hand side of any nested binary</span>
<span class="ruby-comment"># operators</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the left and right hand side of the binary</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/binary_operator_node.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the left hand side node of the binary operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the left hand side of the binary operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/binary_operator_node.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the right hand side node of the binary operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the right hand side of the binary operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/binary_operator_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘block` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `send` nodes within RuboCop. # # A `block` node is essentially a method send with a block. Parser nests # the `send` node inside the `block` node. # # source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#11 class RuboCop::AST::BlockNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>

<span class="ruby-comment"># Returns a collection of all descendants of this node that are</span>
<span class="ruby-comment"># argument type nodes. See `ArgsNode#argument_list` for details.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_list</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The arguments of this block.</span>
<span class="ruby-comment"># Note that if the block has destructured arguments, `arguments` will</span>
<span class="ruby-comment"># return a `mlhs` node, whereas `argument_list` will return only</span>
<span class="ruby-comment"># actual argument nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this block takes any arguments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this `block` node takes any arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The body of this block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the `block` node or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `block` literal is delimited by curly braces.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` literal is enclosed in braces</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The closing delimiter for this `block` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the closing delimiter for the `block` literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">closing_delimiter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The delimiters for this `block` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;String&gt;] the delimiters for the `block` literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the first argument of this block.</span>
<span class="ruby-comment"># Equivalent to `arguments.first`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the first argument of this block,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `block` literal is delimited by `do`-`end` keywords.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` literal is enclosed in `do`-`end`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keywords?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this `block` literal belongs to a lambda.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` literal belongs to a lambda</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the last argument of this block.</span>
<span class="ruby-comment"># Equivalent to `arguments.last`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the last argument of this block,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the dispatched method as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the dispatched method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a multiline block. This is overridden here</span>
<span class="ruby-comment"># because the general version in `Node` does not work for `block` nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` literal is on a several lines</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The opening delimiter for this `block` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the opening delimiter for the `block` literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">opening_delimiter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The `send` node associated with this block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [SendNode] the `send` node associated with the `block` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a single line block. This is overridden here</span>
<span class="ruby-comment"># because the general version in `Node` does not work for `block` nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` literal is on a single line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node body is a void context.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `block` node body is a void context</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">void_context?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numbered_arguments</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#14 RuboCop::AST::BlockNode::IT_BLOCK_ARGUMENT = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/block_node.rb#16 RuboCop::AST::BlockNode::VOID_CONTEXT_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># A node extension for ‘break` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `break` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/break_node.rb#8 class RuboCop::AST::BreakNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">WrappedArguments</span>
</pre>

<p>end</p>

<p># ‘RuboCop::AST::Builder` is an AST builder that is utilized to let `Parser` # generate ASTs with {RuboCop::AST::Node}. # # @example #   buffer = Parser::Source::Buffer.new(’(string)‘) #   buffer.source = ’puts :foo’ # #   builder = RuboCop::AST::Builder.new #   require ‘parser/ruby25’ #   parser = Parser::Ruby25.new(builder) #   root_node = parser.parse(buffer) # # source://rubocop-ast//lib/rubocop/ast/builder.rb#128 class RuboCop::AST::Builder &lt; ::Parser::Builders::Default</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BuilderExtensions</span>
</pre>

<p>end</p>

<p># Common functionality between the parser and prism builder # # @api private # # source://rubocop-ast//lib/rubocop/ast/builder.rb#7 module RuboCop::AST::BuilderExtensions</p>

<pre class="ruby"><span class="ruby-comment"># Generates {Node} from the given information.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Node] the generated node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/builder.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">n</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">children</span>, <span class="ruby-identifier">source_map</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Overwrite the base method to allow strings with invalid encoding</span>
<span class="ruby-comment"># More details here https://github.com/whitequark/parser/issues/283</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/builder.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">string_value</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/builder.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_klass</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @api private</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/builder.rb#8</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">included</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/builder.rb#14 RuboCop::AST::BuilderExtensions::NODE_MAP = T.let(T.unsafe(nil), Hash)</p>

<p># A parser builder, based on the one provided by prism, # which is capable of emitting AST for more recent Rubies. # # source://rubocop-ast//lib/rubocop/ast/builder_prism.rb#7 class RuboCop::AST::BuilderPrism &lt; ::Prism::Translation::Parser::Builder</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BuilderExtensions</span>
</pre>

<p>end</p>

<p># A node extension for ‘case_match` nodes. This will be used in place of # a plain node when the builder constructs the AST, making its methods # available to all `case_match` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#8 class RuboCop::AST::CaseMatchNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalNode</span>

<span class="ruby-comment"># Returns an array of all the when branches in the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># and the `else` (if any). Note that these bodies could be nil.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node, nil&gt;] an array of the bodies of the `in` branches</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `in_pattern_branches.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_in_pattern</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this case statement has an `else` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `case` statement has an `else` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the else branch of the `case` statement, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the else branch node of the `case` statement</span>
<span class="ruby-comment"># @return [EmptyElse] the empty else branch node of the `case` statement</span>
<span class="ruby-comment"># @return [nil] if the case statement does not have an else branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the `in` pattern branches in the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;InPatternNode&gt;] an array of `in_pattern` nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_pattern_branches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `case` statement as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `case` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_match_node.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘case` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `case` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#8 class RuboCop::AST::CaseNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalNode</span>

<span class="ruby-comment"># Returns an array of all the when branches in the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># and the else (if any). Note that these bodies could be nil.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node, nil&gt;] an array of the bodies of the when branches</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `when_branches.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_when</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this case statement has an `else` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `case` statement has an `else` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the else branch of the `case` statement, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the else branch node of the `case` statement</span>
<span class="ruby-comment"># @return [nil] if the case statement does not have an else branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `case` statement as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `case` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the when branches in the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;WhenNode&gt;] an array of `when` nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/case_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">when_branches</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘casgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/casgn_node.rb#8 class RuboCop::AST::CasgnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConstantNode</span>

<span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/casgn_node.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/casgn_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/casgn_node.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/casgn_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘class` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `class` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/class_node.rb#8 class RuboCop::AST::ClassNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># The body of this `class` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the class</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/class_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The identifier for this `class` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the identifier of the class</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/class_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identifier</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The parent class for this `class` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the parent class of the class</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/class_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_class</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A mixin that helps give collection nodes array polymorphism. # # source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#6 module RuboCop::AST::CollectionNode</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&amp;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">*</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">+</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">-</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">all?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">append</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assoc</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bsearch</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bsearch_index</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chain</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chunk</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chunk_while</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collect_concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">combination</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_blank</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compact_blank!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">count</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cycle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">deconstruct</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete_if</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">detect</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">difference</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dig</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">drop</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">drop_while</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_cons</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_entry</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_index</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_slice</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_with_index</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_with_object</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">entries</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exclude?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">excluding</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extract_options!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fetch_values</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fifth</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fill</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filter_map</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_all</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_index</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flat_map</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">flatten!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forty_two</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fourth</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grep</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">grep_v</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">group_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_order_of</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">include?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">including</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index_with</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inject</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">insert</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">intersect?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">intersection</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">join</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keep_if</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lazy</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">length</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">many?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">map!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">max_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">maximum</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">member?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">min_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minimum</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minmax</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">minmax_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">none?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">one?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pack</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">partition</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">permutation</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pick</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">place</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pluck</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pop</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepend</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">product</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">push</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rassoc</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reduce</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reject!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">repeated_combination</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">repeated_permutation</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reverse</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reverse!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reverse_each</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rindex</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rotate</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rotate!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sample</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">second</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">second_to_last</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">select!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shelljoin</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shift</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">size</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slice</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slice!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slice_after</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slice_before</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slice_when</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sole</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort_by</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sort_by!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sum</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">take</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">take_while</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tally</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">third</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">third_to_last</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_ary</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_formatted_s</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_fs</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_h</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_sentence</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_set</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_xml</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">transpose</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">union</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uniq</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uniq!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unshift</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">without</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zip</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">|</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/collection_node.rb#9 RuboCop::AST::CollectionNode::ARRAY_METHODS = T.let(T.unsafe(nil), Array)</p>

<p># Common functionality for nodes that have conditions: # ‘if`, `while`, `until`, `case`. # This currently doesn’t include ‘when` nodes, because they have multiple # conditions, and need to be checked for that. # # source://rubocop-ast//lib/rubocop/ast/node/mixin/conditional_node.rb#9 module RuboCop::AST::ConditionalNode</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body associated with the condition. This works together with</span>
<span class="ruby-comment"># each node&#39;s custom destructuring method to select the correct part of</span>
<span class="ruby-comment"># the node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note For `if` nodes, this is the truthy branch.</span>
<span class="ruby-comment"># @return [Node, nil] the body of the node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/conditional_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the condition of the node. This works together with each node&#39;s</span>
<span class="ruby-comment"># custom destructuring method to select the correct part of the node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the condition of the node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/conditional_node.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">condition</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the condition of the node is written on more than</span>
<span class="ruby-comment"># one line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the condition is on more than one line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/conditional_node.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_condition?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the condition of the node is written on a single line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the condition is on a single line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/conditional_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line_condition?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘const` nodes. # # source://rubocop-ast//lib/rubocop/ast/node/const_node.rb#6 class RuboCop::AST::ConstNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConstantNode</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that deal with constants: # ‘const`, `casgn`. # # source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#7 module RuboCop::AST::ConstantNode</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean] if the constant starts with `::` (aka s(:cbase))</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">absolute?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] if the constant is a Module / Class, according to the standard convention.</span>
<span class="ruby-comment">#   Note: some classes might have uppercase in which case this method</span>
<span class="ruby-comment">#   returns false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_name?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yield nodes for the namespace</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   For `::Foo::Bar::BAZ` =&gt; yields:</span>
<span class="ruby-comment">#      s(:cbase), then</span>
<span class="ruby-comment">#      s(:const, :Foo), then</span>
<span class="ruby-comment">#      s(:const, s(:const, :Foo), :Bar)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_path</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] if the constant is a Module / Class, according to the standard convention.</span>
<span class="ruby-comment">#   Note: some classes might have uppercase in which case this method</span>
<span class="ruby-comment">#   returns false</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_name?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Node, nil] the node associated with the scope (e.g. cbase, const, ...)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] if the constant does not start with `::` (aka s(:cbase))</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">relative?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Symbol] the demodulized name of the constant: &quot;::Foo::Bar&quot; =&gt; :Bar</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/constant_node.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">short_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘csend` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `csend` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/csend_node.rb#8 class RuboCop::AST::CsendNode &lt; ::RuboCop::AST::SendNode</p>

<pre class="ruby"><span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/csend_node.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_type?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘def` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `def` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#8 class RuboCop::AST::DefNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>

<span class="ruby-comment"># Checks whether this method definition node forwards its arguments</span>
<span class="ruby-comment"># as per the feature added in Ruby 2.7.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This is written in a way that may support lead arguments</span>
<span class="ruby-comment">#   which are rumored to be added in a later version of Ruby.</span>
<span class="ruby-comment"># @return [Boolean] whether the `def` node uses argument forwarding</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_forwarding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># An array containing the arguments of the method definition.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the arguments of the method definition</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The body of the method definition.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note this can be either a `begin` node, if the method body contains</span>
<span class="ruby-comment">#   multiple expressions, or any other node, if it contains a single</span>
<span class="ruby-comment">#   expression.</span>
<span class="ruby-comment"># @return [Node] the body of the method definition</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] if the definition is without an `end` or not.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">endless?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the defined method as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the defined method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The receiver of the method definition, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the receiver of the method definition, or `nil`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node body is a void context.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `def` node body is a void context</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/def_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">void_context?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘defined?` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `send` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/defined_node.rb#8 class RuboCop::AST::DefinedNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/defined_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/defined_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for primitive literal nodes: ‘sym`, `str`, # `int`, `float`, … # # source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#7 module RuboCop::AST::Descendence</p>

<pre class="ruby"><span class="ruby-comment"># Returns an array of child nodes.</span>
<span class="ruby-comment"># This is a shorthand for `node.each_child_node.to_a`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of child nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">child_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of descendant nodes.</span>
<span class="ruby-comment"># This is a shorthand for `node.each_descendant.to_a`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of descendant nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">descendants</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each child node.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Note that this is different from `node.children.each { |child| ... }`</span>
<span class="ruby-comment"># which yields all children including non-node elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload each_child_node</span>
<span class="ruby-comment"># @overload each_child_node</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment"># @yieldparam node [Node] each child node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_child_node</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each descendant node with depth first order.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload each_descendant</span>
<span class="ruby-comment"># @overload each_descendant</span>
<span class="ruby-comment"># @overload each_descendant</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment"># @yieldparam node [Node] each descendant node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_descendant</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">types</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for the receiver and each descendant node in</span>
<span class="ruby-comment"># depth-first order.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This method would be useful when you treat the receiver node as the root</span>
<span class="ruby-comment"># of a tree and want to iterate over all nodes in the tree.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload each_node</span>
<span class="ruby-comment"># @overload each_node</span>
<span class="ruby-comment"># @overload each_node</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment"># @yieldparam node [Node] each node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_node</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">types</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/descendence.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_descendants</span>(<span class="ruby-identifier">types</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘dstr` nodes. This will be used # in place of a plain node when the builder constructs the AST, making # its methods available to all `dstr` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/dstr_node.rb#8 class RuboCop::AST::DstrNode &lt; ::RuboCop::AST::StrNode</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/dstr_node.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘ensure` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `ensure` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#8 class RuboCop::AST::EnsureNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `ensure` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @deprecated Use `EnsureNode#branch`</span>
<span class="ruby-comment"># @return [Node, nil] The body of the `ensure`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an the ensure branch in the exception handling statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the ensure branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the `rescue` node of the `ensure`, if present.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The `rescue` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node body is a void context.</span>
<span class="ruby-comment"># Always `true` for `ensure`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true] whether the `ensure` node body is a void context</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">void_context?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/ensure_node.rb#9 RuboCop::AST::EnsureNode::DEPRECATION_WARNING_LOCATION_CACHE = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/ext/range.rb#5 module RuboCop::AST::Ext; end</p>

<p># Extensions to Parser::AST::Range # # source://rubocop-ast//lib/rubocop/ast/ext/range.rb#7 module RuboCop::AST::Ext::Range</p>

<pre class="ruby"><span class="ruby-comment"># If `exclude_end` is `true`, then the range will be exclusive.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Assume that `node` corresponds to the following array literal:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   [</span>
<span class="ruby-comment">#     :foo,</span>
<span class="ruby-comment">#     :bar</span>
<span class="ruby-comment">#   ]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   node.loc.begin.line_span                       # =&gt; 1..1</span>
<span class="ruby-comment">#   node.source_range.line_span(exclude_end: true) # =&gt; 1...4</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Range] the range of line numbers for the node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/ext/range.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_span</span>(<span class="ruby-value">exclude_end:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘float` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available to # all `float` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/float_node.rb#8 class RuboCop::AST::FloatNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BasicLiteralNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NumericNode</span>
</pre>

<p>end</p>

<p># A node extension for ‘for` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `for` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#8 class RuboCop::AST::ForNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `for` loop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The body of the `for` loop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the collection the `for` loop is iterating over.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] The collection the `for` loop is iterating over</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">collection</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `for` node has a `do` keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `for` node has a `do` keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `for` statement as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `until` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the iteration variable of the `for` loop.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] The iteration variable of the `for` loop</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node body is a void context.</span>
<span class="ruby-comment"># Always `true` for `for`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true] whether the `for` node body is a void context</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/for_node.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">void_context?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘forward-args` nodes. This will be used in place # of a plain node when the builder constructs the AST, making its methods # available to all `forward-args` nodes within RuboCop. # # Not used with modern emitters: # #   $ ruby-parse -e “def foo(…); end” #   (def :foo #     (args #       (forward-arg)) nil) #   $ ruby-parse –legacy -e “-&gt;(foo) { bar }” #   (def :foo #     (forward-args) nil) # # Note the extra ’s’ with legacy form. # # The main RuboCop runs in legacy mode; this node is only used # if user ‘AST::Builder.modernize` or `AST::Builder.emit_lambda=true` # # source://rubocop-ast//lib/rubocop/ast/node/forward_args_node.rb#23 class RuboCop::AST::ForwardArgsNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">CollectionNode</span>

<span class="ruby-comment"># Node wraps itself in an array to be compatible with other</span>
<span class="ruby-comment"># enumerable argument types.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/forward_args_node.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that can be used as hash elements: # ‘pair`, `kwsplat` # # source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#7 module RuboCop::AST::HashElementNode</p>

<pre class="ruby"><span class="ruby-comment"># Returns the delta between this element&#39;s delimiter and the argument&#39;s.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Pairs with different delimiter styles return a delta of 0</span>
<span class="ruby-comment"># @return [Integer] the delta between the two delimiters</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter_delta</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the key of this `hash` element.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note For keyword splats, this returns the whole node</span>
<span class="ruby-comment"># @return [Node] the key of the hash element</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the delta between this pair&#39;s key and the argument pair&#39;s.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Keys on the same line always return a delta of 0</span>
<span class="ruby-comment"># @note Keyword splats always return a delta of 0 for right alignment</span>
<span class="ruby-comment"># @param alignment [Symbol] whether to check the left or right side</span>
<span class="ruby-comment"># @return [Integer] the delta between the two keys</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_delta</span>(<span class="ruby-identifier">other</span>, <span class="ruby-identifier">alignment</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this `hash` element is on the same line as `other`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note A multiline element is considered to be on the same line if it</span>
<span class="ruby-comment">#   shares any of its lines with `other`</span>
<span class="ruby-comment"># @return [Boolean] whether this element is on the same line as `other`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">same_line?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of this `hash` element.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note For keyword splats, this returns the whole node</span>
<span class="ruby-comment"># @return [Node] the value of the hash element</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the delta between this element&#39;s value and the argument&#39;s.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note Keyword splats always return a delta of 0</span>
<span class="ruby-comment"># @return [Integer] the delta between the two values</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_delta</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A helper class for comparing the positions of different parts of a # ‘pair` node. # # source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#67 class RuboCop::AST::HashElementNode::HashElementDelta</p>

<pre class="ruby"><span class="ruby-comment"># @raise [ArgumentError]</span>
<span class="ruby-comment"># @return [HashElementDelta] a new instance of HashElementDelta</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">first</span>, <span class="ruby-identifier">second</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter_delta</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">key_delta</span>(<span class="ruby-identifier">alignment</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_delta</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delta</span>(<span class="ruby-identifier">first</span>, <span class="ruby-identifier">second</span>, <span class="ruby-identifier">alignment</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute first.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_splat?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute second.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">second</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/hash_element_node.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_argument_types?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘hash` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `hash` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#8 class RuboCop::AST::HashNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether the `hash` literal is delimited by curly braces.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `hash` literal is enclosed in braces</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">braces?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each `key` node in the `hash` literal.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_key</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each `pair` node in the `hash` literal.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_pair</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each `value` node in the `hash` literal.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_value</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `hash` node contains any `pair`- or `kwsplat` nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return[Boolean] whether the `hash` is empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the keys in the `hash` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of keys in the `hash` literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this `hash` uses a mix of hash rocket and colon</span>
<span class="ruby-comment"># delimiters for its pairs.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [Boolean] whether the `hash` uses mixed delimiters</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mixed_delimiters?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the key value pairs in the `hash` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># ignored.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note this may be different from children as `kwsplat` nodes are</span>
<span class="ruby-comment"># @return [Array&lt;PairNode&gt;] an array of `pair` nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pairs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether any of the key value pairs in the `hash` literal are on</span>
<span class="ruby-comment"># the same line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note A multiline `pair` is considered to be on the same line if it</span>
<span class="ruby-comment">#   shares any of its lines with another `pair`</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [Boolean] whether any `pair` nodes are on the same line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pairs_on_same_line?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the values in the `hash` literal.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note `kwsplat` nodes are ignored.</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of values in the `hash` literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/hash_node.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘if` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `if` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#8 class RuboCop::AST::IfNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ModifierNode</span>

<span class="ruby-comment"># Returns an array of all the branches in the conditional statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of branch nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#154</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `branches.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_branch</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node has an `else` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This returns `true` for nodes containing an `elsif` clause.</span>
<span class="ruby-comment">#   This is legacy behavior, and many cops rely on it.</span>
<span class="ruby-comment"># @return [Boolean] whether the node has an `else` clause</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the branch of the `if` node that gets evaluated when its</span>
<span class="ruby-comment"># condition is falsey.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This is normalized for `unless` nodes.</span>
<span class="ruby-comment"># @return [Node] the falsey branch node of the `if` node</span>
<span class="ruby-comment"># @return [nil] when there is no else branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` is an `elsif`. Parser handles these by nesting</span>
<span class="ruby-comment"># `if` nodes in the `else` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is an `elsif`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">elsif?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node has at least one `elsif` branch. Returns</span>
<span class="ruby-comment"># true if this `if` node itself is an `elsif`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `if` node has at least one `elsif` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">elsif_conditional?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node is an `if` statement. (This is not true of</span>
<span class="ruby-comment"># ternary operators and `unless` statements.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is an `if` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the branch of the `if` node that gets evaluated when its</span>
<span class="ruby-comment"># condition is truthy.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This is normalized for `unless` nodes.</span>
<span class="ruby-comment"># @return [Node] the truthy branch node of the `if` node</span>
<span class="ruby-comment"># @return [nil] if the truthy branch is empty</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse keyword of the `if` node as a string. Returns `if`</span>
<span class="ruby-comment"># for `unless` nodes and vice versa. Returns an empty string for ternary</span>
<span class="ruby-comment"># operators.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the inverse keyword of the `if` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `if` statement as a string. Returns an empty</span>
<span class="ruby-comment"># string for ternary operators.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `if` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node is in a modifier form, i.e. a condition</span>
<span class="ruby-comment"># trailing behind an expression. Only `if` and `unless` nodes without</span>
<span class="ruby-comment"># other branches can be modifiers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `if` node is a modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_form?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node has nested `if` nodes in any of its</span>
<span class="ruby-comment"># branches.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This performs a shallow search.</span>
<span class="ruby-comment"># @return [Boolean] whether the `if` node contains nested conditionals</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#97</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nested_conditional?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Custom destructuring method. This is used to normalize the branches</span>
<span class="ruby-comment"># for `if` and `unless` nodes, to aid comparisons and conversions.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the different parts of the `if` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node is a ternary operator.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `if` node is a ternary operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#56</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ternary?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `if` node has an `then` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node has an `then` clause</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node is an `unless` statement. (This is not true</span>
<span class="ruby-comment"># of ternary operators and `if` statements.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is an `unless` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/if_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘in` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `in` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/in_pattern_node.rb#8 class RuboCop::AST::InPatternNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `in` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the `in` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/in_pattern_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the index of the `in` branch within the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] the index of the `in` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/in_pattern_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns a node of the pattern in the `in` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] a pattern node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/in_pattern_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `in` node has a `then` keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `in` node has a `then` keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/in_pattern_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Used for modern support only! # Not as thoroughly tested as legacy equivalent # #   $ ruby-parse -e “<a href=":bar">foo</a>” #   (index #     (send nil :foo) #     (sym :bar)) #   $ ruby-parse –legacy -e “<a href=":bar">foo</a>” #   (send #     (send nil :foo) :[] #     (sym :bar)) # # The main RuboCop runs in legacy mode; this node is only used # if user ‘AST::Builder.modernize` or `AST::Builder.emit_index=true` # # source://rubocop-ast//lib/rubocop/ast/node/index_node.rb#19 class RuboCop::AST::IndexNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">RestArguments</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/index_node.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/index_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_accessor?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/index_node.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># An array containing the arguments of the dispatched method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the arguments of the dispatched method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/index_node.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_index</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Used for modern support only! # Not as thoroughly tested as legacy equivalent # #   $ ruby-parse -e “<a href=":bar">foo</a> = :baz” #   (indexasgn #     (send nil :foo) #     (sym :bar) #     (sym :baz)) #   $ ruby-parse –legacy -e “<a href=":bar">foo</a> = :baz” #   (send #     (send nil :foo) :[]= #     (sym :bar) #     (sym :baz)) # # The main RuboCop runs in legacy mode; this node is only used # if user ‘AST::Builder.modernize` or `AST::Builder.emit_index=true` # # source://rubocop-ast//lib/rubocop/ast/node/indexasgn_node.rb#21 class RuboCop::AST::IndexasgnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">RestArguments</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/indexasgn_node.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/indexasgn_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_accessor?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/indexasgn_node.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># An array containing the arguments of the dispatched method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the arguments of the dispatched method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/indexasgn_node.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_index</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘int` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available to # all `int` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/int_node.rb#8 class RuboCop::AST::IntNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BasicLiteralNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NumericNode</span>
</pre>

<p>end</p>

<p># A node extension for ‘kwbegin` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `kwbegin` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/keyword_begin_node.rb#8 class RuboCop::AST::KeywordBeginNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `kwbegin` block. Returns `self` if the `kwbegin` contains</span>
<span class="ruby-comment"># multiple nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The body of the `kwbegin`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_begin_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the `rescue` node of the `kwbegin` block, if one is present.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The `rescue` node within `kwbegin`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_begin_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the `rescue` node of the `kwbegin` block, if one is present.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The `rescue` node within `kwbegin`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_begin_node.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_node</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘kwsplat` and `forwarded_kwrestarg` nodes. This will be used in # place of a plain node when the builder constructs the AST, making its methods available to # all `kwsplat` and `forwarded_kwrestarg` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#8 class RuboCop::AST::KeywordSplatNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">HashElementNode</span>

<span class="ruby-comment"># This is used for duck typing with `pair` nodes which also appear as</span>
<span class="ruby-comment"># `hash` elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colon?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This is used for duck typing with `pair` nodes which also appear as</span>
<span class="ruby-comment"># `hash` elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [false]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_rocket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This provides `forwarded_kwrestarg` node to return true to be compatible with `kwsplat` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [true]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwsplat_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Custom destructuring method. This is used to normalize the branches</span>
<span class="ruby-comment"># for `pair` and `kwsplat` nodes, to add duck typing to `hash` elements.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;KeywordSplatNode&gt;] the different parts of the `kwsplat`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the operator for the `kwsplat` as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the double splat operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/keyword_splat_node.rb#11 RuboCop::AST::KeywordSplatNode::DOUBLE_SPLAT = T.let(T.unsafe(nil), String)</p>

<p># Used for modern support only: # Not as thoroughly tested as legacy equivalent # #   $ ruby-parse -e “-&gt;(foo) { bar }” #   (block #     (lambda) #     (args #       (arg :foo)) #     (send nil :bar)) #   $ ruby-parse –legacy -e “-&gt;(foo) { bar }” #   (block #     (send nil :lambda) #     (args #       (arg :foo)) #     (send nil :bar)) # # The main RuboCop runs in legacy mode; this node is only used # if user ‘AST::Builder.modernize` or `AST::Builder.emit_lambda=true` # # source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#23 class RuboCop::AST::LambdaNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">RestArguments</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_accessor?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># For similarity with legacy mode</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/lambda_node.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_index</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘masgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#8 class RuboCop::AST::MasgnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># @return [Array&lt;Node&gt;] the assignment nodes of the multiple assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The RHS (right hand side) of the multiple assignment. This returns</span>
<span class="ruby-comment"># the nodes as parsed: either a single node if the RHS has a single value,</span>
<span class="ruby-comment"># or an `array` node containing multiple nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># NOTE: Due to how parsing works, `expression` will return the same for</span>
<span class="ruby-comment"># `a, b = x, y` and `a, b = [x, y]`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the right hand side of a multiple assignment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [MlhsNode] the `mlhs` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;Symbol&gt;] names of all the variables being assigned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">names</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The RHS (right hand side) of the multiple assignment. This returns</span>
<span class="ruby-comment"># the nodes as parsed: either a single node if the RHS has a single value,</span>
<span class="ruby-comment"># or an `array` node containing multiple nodes.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># NOTE: Due to how parsing works, `expression` will return the same for</span>
<span class="ruby-comment"># `a, b = x, y` and `a, b = [x, y]`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the right hand side of a multiple assignment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># In contrast to `expression`, `values` always returns a Ruby array</span>
<span class="ruby-comment"># containing all the nodes being assigned on the RHS.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># Literal arrays are considered a singular value; but unlike `expression`,</span>
<span class="ruby-comment"># implied `array` nodes from assigning multiple values on the RHS are treated</span>
<span class="ruby-comment"># as separate.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] individual values being assigned on the RHS of the multiple assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/masgn_node.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_rhs?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that are a kind of method dispatch: # ‘send`, `csend`, `super`, `zsuper`, `yield`, `defined?`, # and (modern only): `index`, `indexasgn`, `lambda` # # source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#8 module RuboCop::AST::MethodDispatchNode</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># Checks whether the dispatched method is an access modifier.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is an access modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">adjacent_def_modifier?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node is an arithmetic operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is an arithmetic</span>
<span class="ruby-comment">#   operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arithmetic_operation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a setter method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a setter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a bare access modifier that</span>
<span class="ruby-comment"># affects all methods defined after the macro.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a bare</span>
<span class="ruby-comment">#   access modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bare_access_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bare_access_modifier_declaration?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a binary operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   foo + bar</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a binary operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#247</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binary_operation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Whether this method dispatch has an explicit block.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method has a block</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The `block`, `numblock`, or `itblock` node associated with this method dispatch, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [BlockNode, nil] the `block`, `numblock`, or `itblock` node associated with this</span>
<span class="ruby-comment">#   method call or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the name of the dispatched method matches the argument</span>
<span class="ruby-comment"># and has an implicit receiver.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param name [Symbol, String] the method name to check for</span>
<span class="ruby-comment"># @return [Boolean] whether the method name matches the argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">command?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the *explicit* receiver of this method dispatch is a</span>
<span class="ruby-comment"># `const` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the receiver of this method dispatch</span>
<span class="ruby-comment">#   is a `const` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#152</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_receiver?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this node is part of a chain of `def` or `defs` modifiers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># or `nil` if it isn&#39;t a def modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   private def foo; end</span>
<span class="ruby-comment"># @return [Node | nil] returns the `def|defs` node this is a modifier for,</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#199</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_modifier</span>(<span class="ruby-identifier">node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if this node is part of a chain of `def` or `defs` modifiers.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># See also `def_modifier` that returns the node or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   private def foo; end</span>
<span class="ruby-comment"># @return [Boolean] whether the `def|defs` node is a modifier or not.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_modifier?</span>(<span class="ruby-identifier">node</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method uses a dot to connect the</span>
<span class="ruby-comment"># receiver and the method name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># This is useful for comparison operators, which can be called either</span>
<span class="ruby-comment"># with or without a dot, i.e. `foo == bar` or `foo.== bar`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method was called with a connecting dot</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dot?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method uses a double colon to connect the</span>
<span class="ruby-comment"># receiver and the method name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method was called with a connecting dot</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_colon?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method dispatch is the implicit form of `#call`,</span>
<span class="ruby-comment"># e.g. `foo.(bar)`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is the implicit form of `#call`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">implicit_call?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_macro_scope?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a lambda. Some versions of parser parses</span>
<span class="ruby-comment"># non-literal lambdas as a method send.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a lambda</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#212</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a lambda literal (stabby lambda.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   -&gt; (foo) { bar }</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a lambda literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#223</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a macro method. A macro method</span>
<span class="ruby-comment"># is defined as a method that sits in a class, module, or block body and</span>
<span class="ruby-comment"># has an implicit receiver.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @note This does not include DSLs that use nested blocks, like RSpec</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a macro method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">macro?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the dispatched method as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the dispatched method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a non-bare access modifier that</span>
<span class="ruby-comment"># affects only the method it receives.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a non-bare</span>
<span class="ruby-comment">#   access modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_bare_access_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">non_bare_access_modifier_declaration?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The receiving node of the method dispatch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the receiver of the dispatched method or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method uses a safe navigation operator to</span>
<span class="ruby-comment"># connect the receiver and the method name.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method was called with a connecting dot</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">safe_navigation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The source range for the method name or keyword that dispatches this call.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Parser::Source::Range] the source range for the method name or keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">selector</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the *explicit* receiver of this method dispatch is</span>
<span class="ruby-comment"># `self`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the receiver of this method dispatch is `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">self_receiver?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a setter method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a setter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">setter_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the dispatched method is a bare `private` or `protected`</span>
<span class="ruby-comment"># access modifier that affects all methods defined after the macro.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the dispatched method is a bare</span>
<span class="ruby-comment">#   `private` or `protected` access modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a unary operation.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   -foo</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a unary operation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unary_operation?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#12 RuboCop::AST::MethodDispatchNode::ARITHMETIC_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_dispatch_node.rb#14 RuboCop::AST::MethodDispatchNode::SPECIAL_MODIFIERS = T.let(T.unsafe(nil), Array)</p>

<p># Common predicates for nodes that reference method identifiers: # ‘send`, `csend`, `def`, `defs`, `super`, `zsuper` # # @note this mixin expects `#method_name` and `#receiver` to be implemented # # source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#9 module RuboCop::AST::MethodIdentifierPredicates</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether the method is an assignment method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is an assignment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#142</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a bang method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a bang method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bang_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a camel case method,</span>
<span class="ruby-comment"># e.g. `Integer()`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a camel case method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">camel_case_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a comparison method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a comparison</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comparison_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the *explicit* receiver of node is a `const` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the receiver of this node is a `const` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_receiver?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is an Enumerable method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is an Enumerable method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enumerable_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is an enumerator method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is an enumerator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enumerator_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method name matches the argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param name [Symbol, String] the method name to check for</span>
<span class="ruby-comment"># @return [Boolean] whether the method name matches the argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method?</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a negation method, i.e. `!` or keyword `not`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a negation method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">negation_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating Array method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating Array method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_array_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating binary operator method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating binary operator method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_binary_operator_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating Hash method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating Hash method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#121</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_hash_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating operator method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating operator method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_operator_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating String method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating String method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_string_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a nonmutating unary operator method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a nonmutating unary operator method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonmutating_unary_operator_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is an operator method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is an operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the method is a predicate method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the method is a predicate method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">predicate_method?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a prefix bang method, e.g. `!foo`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a prefix bang</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prefix_bang?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a prefix not method, e.g. `not foo`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this method is a prefix not</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prefix_not?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the *explicit* receiver of this node is `self`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the receiver of this node is `self`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">self_receiver?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#16 RuboCop::AST::MethodIdentifierPredicates::ENUMERABLE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#10 RuboCop::AST::MethodIdentifierPredicates::ENUMERATOR_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#32 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_ARRAY_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#24 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_BINARY_OPERATOR_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#48 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_HASH_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#28 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_OPERATOR_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#59 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_STRING_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#26 RuboCop::AST::MethodIdentifierPredicates::NONMUTATING_UNARY_OPERATOR_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># <a href="http://phrogz.net/programmingruby/language.html#table_18.4">phrogz.net/programmingruby/language.html#table_18.4</a> # # source://rubocop-ast//lib/rubocop/ast/node/mixin/method_identifier_predicates.rb#20 RuboCop::AST::MethodIdentifierPredicates::OPERATOR_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># A node extension for ‘mlhs` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/mlhs_node.rb#8 class RuboCop::AST::MlhsNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns all the assignment nodes on the left hand side (LHS) of a multiple assignment.</span>
<span class="ruby-comment"># These are generally assignment nodes (`lvasgn`, `ivasgn`, `cvasgn`, `gvasgn`, `casgn`)</span>
<span class="ruby-comment"># but can also be `send` nodes in case of `foo.bar, ... =` or `foo[:bar], ... =`,</span>
<span class="ruby-comment"># or a `splat` node for `*, ... =`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the assignment nodes of the multiple assignment LHS</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mlhs_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignments</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that can be used as modifiers: # ‘if`, `while`, `until` # # source://rubocop-ast//lib/rubocop/ast/node/mixin/modifier_node.rb#7 module RuboCop::AST::ModifierNode</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether the node is in a modifier form, i.e. a condition</span>
<span class="ruby-comment"># trailing behind an expression.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is a modifier</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/modifier_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">modifier_form?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘module` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `module` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/module_node.rb#8 class RuboCop::AST::ModuleNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># The body of this `module` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the module</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/module_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The identifier for this `module` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the identifier of the module</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/module_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identifier</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘next` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `next` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/next_node.rb#8 class RuboCop::AST::NextNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">WrappedArguments</span>
</pre>

<p>end</p>

<p># ‘RuboCop::AST::Node` is a subclass of `Parser::AST::Node`. It provides # access to parent nodes and an object-oriented way to traverse an AST with # the power of `Enumerable`. # # It has predicate methods for every node type, like this: # # @example #   node.send_type?    # Equivalent to: `node.type == :send` #   node.op_asgn_type? # Equivalent to: `node.type == :op_asgn` # #   # Non-word characters (other than a-zA-Z0-9_) in type names are omitted. #   node.defined_type? # Equivalent to: `node.type == :defined?` # #   # Find the first lvar node under the receiver node. #   lvar_node = node.each_descendant.find(&amp;:lvar_type?) # # source://rubocop-ast//lib/rubocop/ast/node.rb#21 class RuboCop::AST::Node &lt; ::Parser::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Sexp</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Descendence</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Macros</span>

<span class="ruby-comment"># @return [Node] a new instance of Node</span>
<span class="ruby-comment"># @see https://www.rubydoc.info/gems/ast/AST/Node:initialize</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">children</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">properties</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__ENCODING___type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__FILE___type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">__LINE___type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alias_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of ancestor nodes.</span>
<span class="ruby-comment"># This is a shorthand for `node.each_ancestor.to_a`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of ancestor nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ancestors</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_asgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">and_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#542</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_block_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#522</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_def_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#546</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">any_match_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_expr_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">args_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#518</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#526</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">argument_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_pattern_with_tail_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">array_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#470</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Some cops treat the shovel operator as a kind of assignment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_or_similar?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">back_ref_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#474</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">basic_conditional?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#428</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">basic_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_pass_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blockarg_expr_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blockarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#530</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">boolean_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">break_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#510</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">call_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_match_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">casgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cbase_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#514</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">chained?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#594</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#612</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">class_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#210</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete!</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#215</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complete?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#478</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditional?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#359</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">const_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">csend_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cvar_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cvasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#379</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_module</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#384</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_module_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defs_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dstr_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dsym_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Calls the given block for each ancestor node from parent to root.</span>
<span class="ruby-comment"># If no block is given, an `Enumerator` is returned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload each_ancestor</span>
<span class="ruby-comment"># @overload each_ancestor</span>
<span class="ruby-comment"># @overload each_ancestor</span>
<span class="ruby-comment"># @return [self] if a block is given</span>
<span class="ruby-comment"># @return [Enumerator] if no block is given</span>
<span class="ruby-comment"># @yieldparam node [Node] each ancestor node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_ancestor</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">types</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eflipflop_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_else_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#414</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_source?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ensure_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#462</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">equals_asgn?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">erange_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">false_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#436</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">falsey_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">float_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward_arg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forward_args_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_args_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_kwrestarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forwarded_restarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#591</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">global_const?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">param1</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#550</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">guard_clause?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gvar_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">gvasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ident_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_guard_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">if_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iflipflop_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">immutable_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_match_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">index_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">indexasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">int_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">irange_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">itarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">itblock_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ivar_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ivasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#491</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwargs_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwbegin_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwnilarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwoptarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwrestarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwsplat_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#585</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#588</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_or_proc?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lambda_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Use is discouraged, this is a potentially slow method and can lead</span>
<span class="ruby-comment"># to even slower algorithms</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the left (aka previous) sibling</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#253</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_sibling</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Use is discouraged, this is a potentially slow method and can lead</span>
<span class="ruby-comment"># to even slower algorithms</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the left (aka previous) siblings</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#263</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_siblings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut to safely check if a location is present</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#558</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc?</span>(<span class="ruby-identifier">which_loc</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Shortcut to safely test a particular location, even if</span>
<span class="ruby-comment"># this location does not exist or is `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#566</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc_is?</span>(<span class="ruby-identifier">which_loc</span>, <span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># NOTE: `loop { }` is a normal method call and thus not a loop keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#487</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loop_keyword?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lvar_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lvasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">masgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_alt_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_as_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_current_line_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#573</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_guard_clause?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_nil_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_pattern_p_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_pattern_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_rest_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_var_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_with_lvasgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_with_trailing_comma_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mlhs_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#619</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_definition?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">module_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Predicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#406</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#440</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">mutable_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#750</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_class_or_module_block?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nil_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Common destructuring method. This can be used to normalize</span>
<span class="ruby-comment"># destructuring for different variations of the node.</span>
<span class="ruby-comment"># Some node types override this with their own custom</span>
<span class="ruby-comment"># destructuring method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the different parts of the ndde</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#284</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nonempty_line_count</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">not_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nth_ref_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numargs_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numblock_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#534</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">numeric_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">objc_kwarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">objc_restarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">objc_varargs_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">op_asgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#502</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator_keyword?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">optarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">or_asgn_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">or_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pair_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the parent node, or `nil` if the receiver is a root node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the parent node or `nil`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#201</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Searching the AST</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#390</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_module_name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#506</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized_call?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pin_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#482</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">post_condition_loop?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">postexe_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preexe_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#578</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">proc?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">procarg0_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Some expressions are evaluated for their value, some for their side</span>
<span class="ruby-comment"># effects, and some for both.</span>
<span class="ruby-comment"># If we know that expressions are useful only for their return values,</span>
<span class="ruby-comment"># and have no side effects, that means we can reorder them, change the</span>
<span class="ruby-comment"># number of times they are evaluated, or replace them with other</span>
<span class="ruby-comment"># expressions which are equivalent in value.</span>
<span class="ruby-comment"># So, is evaluation of this node free of side effects?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#662</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pure?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#538</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">range_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rational_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#352</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">receiver</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recursive_basic_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">recursive_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">redo_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#458</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">reference?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regopt_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resbody_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restarg_expr_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">restarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">retry_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">return_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Use is discouraged, this is a potentially slow method and can lead</span>
<span class="ruby-comment"># to even slower algorithms</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the right (aka next) sibling</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#244</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_sibling</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Use is discouraged, this is a potentially slow method and can lead</span>
<span class="ruby-comment"># to even slower algorithms</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] the right (aka next) siblings</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#272</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_siblings</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">root?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sclass_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">self_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Most nodes are of &#39;send&#39; type, so this method is defined</span>
<span class="ruby-comment"># separately to make this check as fast as possible.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shadowarg_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#466</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shorthand_asgn?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the index of the receiver node in its siblings. (Sibling index</span>
<span class="ruby-comment"># uses zero based numbering.)</span>
<span class="ruby-comment"># Use is discouraged, this is a potentially slow method.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer, nil] the index of the receiver node in its siblings</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sibling_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#410</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_line?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># NOTE: Some rare nodes may have no source, like `s(:args)` in `foo {}`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_length</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#323</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#498</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">special_keyword?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#357</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_content</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">str_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `:class_constructor?`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">struct_constructor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">super_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sym_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">true_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#432</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">truthy_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Determine if the node is one of several node types in a single query</span>
<span class="ruby-comment"># Allows specific single node types, as well as &quot;grouped&quot; types</span>
<span class="ruby-comment"># (e.g. `:boolean` for `:true` or `:false`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">undef_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unless_guard_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">until_post_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">until_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Override `AST::Node#updated` so that `AST::Processor` does not try to</span>
<span class="ruby-comment"># mutate our ASTs. Since we keep references from children to parents and</span>
<span class="ruby-comment"># not just the other way around, we cannot update an AST and share</span>
<span class="ruby-comment"># identical subtrees. Rather, the entire AST must be copied any time any</span>
<span class="ruby-comment"># part of it is changed.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">updated</span>(<span class="ruby-identifier">type</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">children</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">properties</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Some expressions are evaluated for their value, some for their side</span>
<span class="ruby-comment"># effects, and some for both</span>
<span class="ruby-comment"># If we know that an expression is useful only for its side effects, that</span>
<span class="ruby-comment"># means we can transform it in ways which preserve the side effects, but</span>
<span class="ruby-comment"># change the return value</span>
<span class="ruby-comment"># So, does the return value of this node matter? If we changed it to</span>
<span class="ruby-comment"># `(...; nil)`, might that affect anything?</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#632</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#454</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variable?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">when_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">while_post_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">while_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">xstr_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">yield_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">zsuper_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#196</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent=</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#689</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_value_used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#700</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">case_if_value_used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">defined_module0</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#694</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">for_value_used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#736</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_module_name_for_block</span>(<span class="ruby-identifier">ancestor</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#724</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_module_name_for_sclass</span>(<span class="ruby-identifier">sclass_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#711</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent_module_name_part</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#680</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_ancestors</span>(<span class="ruby-identifier">types</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#706</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">while_until_value_used?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-identifier">private</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node.rb#127</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_recursive_literal_predicate</span>(<span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#55 RuboCop::AST::Node::ASSIGNMENTS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#58 RuboCop::AST::Node::BASIC_CONDITIONALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#42 RuboCop::AST::Node::BASIC_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># &lt;=&gt; isn’t included here, because it doesn’t return a boolean. # # @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#28 RuboCop::AST::Node::COMPARISON_OPERATORS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#39 RuboCop::AST::Node::COMPOSITE_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#60 RuboCop::AST::Node::CONDITIONALS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node.rb#84 RuboCop::AST::Node::EMPTY_CHILDREN = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node.rb#85 RuboCop::AST::Node::EMPTY_PROPERTIES = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#50 RuboCop::AST::Node::EQUALS_ASSIGNMENTS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#35 RuboCop::AST::Node::FALSEY_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#89 RuboCop::AST::Node::GROUP_FOR_TYPE = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#47 RuboCop::AST::Node::IMMUTABLE_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#70 RuboCop::AST::Node::KEYWORDS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#37 RuboCop::AST::Node::LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node.rb#80 RuboCop::AST::Node::LITERAL_RECURSIVE_METHODS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node.rb#81 RuboCop::AST::Node::LITERAL_RECURSIVE_TYPES = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#64 RuboCop::AST::Node::LOOP_TYPES = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#44 RuboCop::AST::Node::MUTABLE_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#76 RuboCop::AST::Node::OPERATOR_KEYWORDS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#62 RuboCop::AST::Node::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#68 RuboCop::AST::Node::REFERENCES = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#53 RuboCop::AST::Node::SHORTHAND_ASSIGNMENTS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#78 RuboCop::AST::Node::SPECIAL_KEYWORDS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#31 RuboCop::AST::Node::TRUTHY_LITERALS = T.let(T.unsafe(nil), Set)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node.rb#66 RuboCop::AST::Node::VARIABLES = T.let(T.unsafe(nil), Set)</p>

<p># This class performs a pattern-matching operation on an AST node. # # Detailed syntax: /docs/modules/ROOT/pages/node_pattern.adoc # # Initialize a new ‘NodePattern` with `NodePattern.new(pattern_string)`, then # pass an AST node to `NodePattern#match`. Alternatively, use one of the class # macros in `NodePattern::Macros` to define your own pattern-matching method. # # If the match fails, `nil` will be returned. If the match succeeds, the # return value depends on whether a block was provided to `#match`, and # whether the pattern contained any “captures” (values which are extracted # from a matching AST.) # # - With block: #match yields the captures (if any) and passes the return #               value of the block through. # - With no block, but one capture: the capture is returned. # - With no block, but multiple captures: captures are returned as an array. # - With no block and no captures: #match returns `true`. # # source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#5 class RuboCop::AST::NodePattern</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDefiner</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [NodePattern] a new instance of NodePattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">str</span>, <span class="ruby-value">compiler:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_json</span>(<span class="ruby-identifier">_options</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute ast.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">captures</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encode_with</span>(<span class="ruby-identifier">coder</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eql?</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">freeze</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">init_with</span>(<span class="ruby-identifier">coder</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marshal_dump</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">marshal_load</span>(<span class="ruby-identifier">pattern</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">rest</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute match_code.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_code</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_parameters</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute pattern.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">positional_parameters</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># Yields its argument and any descendants, depth-first.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># @yield [element]</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#59</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">descend</span>(<span class="ruby-identifier">element</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Responsible to build the AST nodes for ‘NodePattern` # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#10 class RuboCop::AST::NodePattern::Builder</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_atom</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_call</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">selector</span>, <span class="ruby-identifier">args</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_capture</span>(<span class="ruby-identifier">capture_token</span>, <span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_list</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">_begin</span>, <span class="ruby-identifier">children</span>, <span class="ruby-identifier">_end</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_subsequence</span>(<span class="ruby-identifier">node_list</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_unary_op</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">_operator</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">*</span><span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_union</span>(<span class="ruby-identifier">begin_t</span>, <span class="ruby-identifier">pattern_lists</span>, <span class="ruby-identifier">end_t</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">n</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">optimizable_as_set?</span>(<span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/builder.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">union_children</span>(<span class="ruby-identifier">pattern_lists</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A NodePattern comment, simplified version of ::Parser::Source::Comment # # source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#7 class RuboCop::AST::NodePattern::Comment</p>

<pre class="ruby"><span class="ruby-comment"># @param range [Parser::Source::Range]</span>
<span class="ruby-comment"># @return [Comment] a new instance of Comment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compares comments. Two comments are equal if they</span>
<span class="ruby-comment"># correspond to the same source range.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param other [Object]</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] a human-readable representation of this comment</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute location.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute location.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/comment.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># The top-level compiler holding the global state # Defers work to its subcompilers # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#11 class RuboCop::AST::NodePattern::Compiler</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [Compiler] a new instance of Compiler</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bind</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute binding.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">binding</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute captures.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">captures</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_as_atom</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_as_node_pattern</span>(<span class="ruby-identifier">node</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_sequence</span>(<span class="ruby-identifier">sequence</span>, <span class="ruby-value">var:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enumerates `enum` while keeping track of state across</span>
<span class="ruby-comment"># union branches (captures and unification).</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_union</span>(<span class="ruby-identifier">enum</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">freeze</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_parameter</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute named_parameters.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_capture</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">positional_parameter</span>(<span class="ruby-identifier">number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute positional_parameters.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">positional_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Utilities</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with_temp_variables</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">names</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_same_captures</span>(<span class="ruby-identifier">enum</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_capture</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Generates code that evaluates to a value (Ruby object) # This value responds to ‘===`. # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#12 class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler &lt; ::RuboCop::AST::NodePattern::Compiler::Subcompiler</p>

<pre class="ruby"><span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_const</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_named_parameter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_number</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Assumes other types are node patterns.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_other_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_positional_parameter</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_regexp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_set</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_string</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_symbol</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/atom_subcompiler.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_unify</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Holds the list of bound variable names # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/binding.rb#8 class RuboCop::AST::NodePattern::Compiler::Binding</p>

<pre class="ruby"><span class="ruby-comment"># @return [Binding] a new instance of Binding</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/binding.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields the first time a given name is bound</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] bound variable name</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/binding.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">bind</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Yields for each branch of the given union, forbidding unification of</span>
<span class="ruby-comment"># bindings which only appear in a subset of the union.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/binding.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">union_bind</span>(<span class="ruby-identifier">enum</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/binding.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">forbid</span>(<span class="ruby-identifier">names</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Variant of the Compiler with tracing information for nodes # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#10 class RuboCop::AST::NodePattern::Compiler::Debug &lt; ::RuboCop::AST::NodePattern::Compiler</p>

<pre class="ruby"><span class="ruby-comment"># @return [Debug] a new instance of Debug</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">named_parameters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node_ids.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_ids</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#38 class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Colorizer] a new instance of Colorizer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-value">compiler:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compiler</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#96</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pattern</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Node] the Ruby AST</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">test</span>(<span class="ruby-identifier">ruby</span>, <span class="ruby-value">trace:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_ast</span>(<span class="ruby-identifier">ruby</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#39 RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::COLOR_SCHEME = T.let(T.unsafe(nil), Hash)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#94 RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Compiler = RuboCop::AST::NodePattern::Compiler::Debug</p>

<p># Result of a NodePattern run against a particular AST # Consider constructor is private # # @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48 class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result &lt; ::Struct</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Hash] a map for {character_position =&gt; color}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">color_map</span>(<span class="ruby-identifier">color_scheme</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [String] a Rainbow colorized version of ruby</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colorize</span>(<span class="ruby-identifier">color_scheme</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute colorizer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of colorizer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colorizer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute colorizer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute colorizer to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colorizer=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Hash] a map for {node =&gt; matched?}, depth-first</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match_map</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment"># @return [Boolean] a value of `Trace#matched?` or `:not_visitable`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matched?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute returned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of returned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">returned</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute returned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute returned to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">returned=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute ruby_ast</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of ruby_ast</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_ast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute ruby_ast</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute ruby_ast to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_ast=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute trace</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Object] the current value of trace</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trace</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Sets the attribute trace</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param value [Object] the value to set the attribute trace to.</span>
<span class="ruby-comment"># @return [Object] the newly set value</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">trace=</span>(<span class="ruby-identifier">_</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">color_map_for</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">color</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword_init?</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">members</span>; <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#48</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#134 module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_compile</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_id</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tracer</span>(<span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#151 class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler &lt; ::RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Compiler</span><span class="ruby-operator">::</span><span class="ruby-constant">Debug</span><span class="ruby-operator">::</span><span class="ruby-constant">InstrumentationSubcompiler</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#156 class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler &lt; ::RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Compiler</span><span class="ruby-operator">::</span><span class="ruby-constant">Debug</span><span class="ruby-operator">::</span><span class="ruby-constant">InstrumentationSubcompiler</span>
</pre>

<p>end</p>

<p># Compiled node pattern requires a named parameter ‘trace`, # which should be an instance of this class # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#13 class RuboCop::AST::NodePattern::Compiler::Debug::Trace</p>

<pre class="ruby"><span class="ruby-comment"># @return [Trace] a new instance of Trace</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enter</span>(<span class="ruby-identifier">node_id</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># return nil (not visited), false (not matched) or true (matched)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matched?</span>(<span class="ruby-identifier">node_id</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/debug.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">success</span>(<span class="ruby-identifier">node_id</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Compiles code that evalues to true or false # for a given value ‘var` (typically a RuboCop::AST::Node) # or it’s ‘node.type` if `seq_head` is true # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#13 class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler &lt; ::RuboCop::AST::NodePattern::Compiler::Subcompiler</p>

<pre class="ruby"><span class="ruby-comment"># @return [NodePatternSubcompiler] a new instance of NodePatternSubcompiler</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">compiler</span>, <span class="ruby-value">var:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">access:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">seq_head:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute access.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute seq_head.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#14</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">seq_head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_element</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">access_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @param [Array&lt;Node&gt;, nil]</span>
<span class="ruby-comment"># @return [String, nil]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#113</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_args</span>(<span class="ruby-identifier">arg_list</span>, <span class="ruby-value">first:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_guard_clause</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compiling helpers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_value_match</span>(<span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiple_access</span>(<span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_ascend</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_capture</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_descend</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_function_call</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_intersection</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_negation</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_node_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Assumes other types are atoms.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_other_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#80</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_predicate</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_sequence</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_unify</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Lists</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_union</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/node_pattern_subcompiler.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_wildcard</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Compiles terms within a sequence to code that evalues to true or false. # Compilation of the nodes that can match only a single term is deferred to # ‘NodePatternSubcompiler`; only nodes that can match multiple terms are # compiled here. # Assumes the given `var` is a `::RuboCop::AST::Node` # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#17 class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler &lt; ::RuboCop::AST::NodePattern::Compiler::Subcompiler</p>

<pre class="ruby"><span class="ruby-comment"># Calls `compile_sequence`; the actual `compile` method</span>
<span class="ruby-comment"># will be used for the different terms of the sequence.</span>
<span class="ruby-comment"># The only case of re-entrant call to `compile` is `visit_capture`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [SequenceSubcompiler] a new instance of SequenceSubcompiler</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">compiler</span>, <span class="ruby-value">sequence:</span>, <span class="ruby-value">var:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_sequence</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sync</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">protected</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_terms</span>(<span class="ruby-identifier">children</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">last_arity</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#251</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cur_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># yield `sync_code` iff not already in sync</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @yield [code]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sync</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Compilation helpers</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_and_advance</span>(<span class="ruby-identifier">term</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_any_order_branches</span>(<span class="ruby-identifier">matched_var</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;String&gt;] Else code, and init code (if any)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_any_order_else</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#180</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_captured_repetition</span>(<span class="ruby-identifier">child_code</span>, <span class="ruby-identifier">child_captures</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_case</span>(<span class="ruby-identifier">when_branches</span>, <span class="ruby-identifier">else_code</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#361</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_child_nb_guard</span>(<span class="ruby-identifier">arity_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_cur_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#325</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_index</span>(<span class="ruby-identifier">cur</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_loop</span>(<span class="ruby-identifier">term</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#347</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_loop_advance</span>(<span class="ruby-identifier">to</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Assumes `@cur_index` is already updated</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_matched</span>(<span class="ruby-identifier">kind</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#304</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_max_matched</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] code that evaluates to `false` if the matched arity is too small</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_min_check</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_remaining</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Hash] of {subcompiler =&gt; code}</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#373</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_union_forks</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">empty_loop</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#214</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_prev</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Modifies in place `forks`</span>
<span class="ruby-comment"># Syncs our state</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">merge_forks!</span>(<span class="ruby-identifier">forks</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Modifies in place `forks` to insure that `cur_{child|index}_var` are ok</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#384</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preserve_union_start</span>(<span class="ruby-identifier">forks</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># E.g. For sequence `(_  _? &lt;_ _&gt;)`, arities are: 1, 0..1, 2</span>
<span class="ruby-comment"># and remaining arities are: 3..4, 2..3, 2..2, 0..0</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Range&gt;] total arities (as Ranges) of remaining children nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#259</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remaining_arities</span>(<span class="ruby-identifier">children</span>, <span class="ruby-identifier">last_arity</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># returns truthy iff `@cur_index` switched to relative from end mode (i.e. &lt; 0)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#341</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">use_index_from_end</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_any_order</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_capture</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Single node patterns are all handled here</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_other_type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_repetition</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_rest</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_union</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># NOTE: assumes `@cur_index != :seq_head`. Node types using `within_loop` must</span>
<span class="ruby-comment"># have `def in_sequence_head; :raise; end`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#333</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">within_loop</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Shift of 1 from standard Ruby indices # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#18 RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler::DELTA = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/sequence_subcompiler.rb#19 RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler::POSITIVE = T.let(T.unsafe(nil), Proc)</p>

<p># Base class for subcompilers # Implements visitor pattern # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#12 class RuboCop::AST::NodePattern::Compiler::Subcompiler</p>

<pre class="ruby"><span class="ruby-comment"># @return [Subcompiler] a new instance of Subcompiler</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">compiler</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute compiler.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compiler</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#34</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_compile</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#47</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inherited</span>(<span class="ruby-identifier">base</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># @private</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#42</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_added</span>(<span class="ruby-identifier">method</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Returns the value of attribute registry.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/compiler/subcompiler.rb#40</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">registry</span>; <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#53 class RuboCop::AST::NodePattern::Invalid &lt; ::StandardError; end</p>

<p># Lexer class for ‘NodePattern` # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#18 class RuboCop::AST::NodePattern::Lexer &lt; ::RuboCop::AST::NodePattern::LexerRex</p>

<pre class="ruby"><span class="ruby-comment"># @return [Lexer] a new instance of Lexer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute comments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute source_buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute tokens.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_parse</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [token]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit</span>(<span class="ruby-identifier">type</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_regexp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">token</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#19 RuboCop::AST::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rb#21 RuboCop::AST::NodePattern::Lexer::REGEXP_OPTIONS = T.let(T.unsafe(nil), Hash)</p>

<p># The generated lexer RuboCop::AST::NodePattern::LexerRex # # source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#23 class RuboCop::AST::NodePattern::LexerRex</p>

<pre class="ruby"><span class="ruby-comment"># Yields on the current action.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">action</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The file name / path</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filename</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The file name / path</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">filename=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current location in the parse.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">location</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The StringScanner for this lexer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">match</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The match groups for the current scan.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Lex the next token.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_token</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Parse the given string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#83</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">str</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Read in and parse the file at +path+.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_file</span>(<span class="ruby-identifier">path</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current scanner class. Must be overridden in subclasses.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#76</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">scanner_class</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The StringScanner for this lexer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ss</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The StringScanner for this lexer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ss=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current lexical state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The current lexical state.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">state=</span>(<span class="ruby-identifier">_arg0</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#31 RuboCop::AST::NodePattern::LexerRex::CALL = T.let(T.unsafe(nil), Regexp)</p>

<p># # # source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#27 RuboCop::AST::NodePattern::LexerRex::CONST_NAME = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#29 RuboCop::AST::NodePattern::LexerRex::IDENTIFIER = T.let(T.unsafe(nil), Regexp)</p>

<p># # # # source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#36 class RuboCop::AST::NodePattern::LexerRex::LexerError &lt; ::StandardError; end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#30 RuboCop::AST::NodePattern::LexerRex::NODE_TYPE = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#33 RuboCop::AST::NodePattern::LexerRex::REGEXP = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#32 RuboCop::AST::NodePattern::LexerRex::REGEXP_BODY = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#28 RuboCop::AST::NodePattern::LexerRex::SYMBOL_NAME = T.let(T.unsafe(nil), Regexp)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/lexer.rex.rb#37 class RuboCop::AST::NodePattern::LexerRex::ScanError &lt; ::RuboCop::AST::NodePattern::LexerRex::LexerError; end</p>

<p># Helpers for defining methods based on a pattern string # # source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#28 module RuboCop::AST::NodePattern::Macros</p>

<pre class="ruby"><span class="ruby-comment"># Define a method which applies a pattern to an AST node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># The new method will return nil if the node does not match.</span>
<span class="ruby-comment"># If the node matches, and a block is provided, the new method will</span>
<span class="ruby-comment"># yield to the block (passing any captures as block arguments).</span>
<span class="ruby-comment"># If the node matches, and no block is provided, the new method will</span>
<span class="ruby-comment"># return the captures, or `true` if there were none.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#36</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_node_matcher</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">pattern_str</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">keyword_defaults</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Define a method which recurses over the descendants of an AST node,</span>
<span class="ruby-comment"># checking whether any of them match the provided pattern</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># If the method name ends with &#39;?&#39;, the new method will return `true`</span>
<span class="ruby-comment"># as soon as it finds a descendant which matches. Otherwise, it will</span>
<span class="ruby-comment"># yield all descendants which match.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_node_search</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-identifier">pattern_str</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">keyword_defaults</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Functionality to turn ‘match_code` into methods/lambda # # source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#7 module RuboCop::AST::NodePattern::MethodDefiner</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_lambda</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_as_lambda</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#8</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_node_matcher</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">defaults</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#21</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_node_search</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">defaults</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#139</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">compile_init</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_helper</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">method_name</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">defaults</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_keyword_list</span>(<span class="ruby-value">forwarding:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_lambda_code</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#125</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_method_code</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_node_search</span>(<span class="ruby-identifier">method_name</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_node_search_body</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-value">prelude:</span>, <span class="ruby-value">on_match:</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_param_list</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_params</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">first</span>, <span class="ruby-value">forwarding:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_retval</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_yield_capture</span>(<span class="ruby-identifier">when_no_capture</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">yield_with:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># This method minimizes the closure for our method</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/method_definer.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrapping_block</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">defaults</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Base class for AST Nodes of a ‘NodePattern` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#7 class RuboCop::AST::NodePattern::Node &lt; ::Parser::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Descendence</span>
<span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># Note: `arity.end` may be `Float::INFINITY`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer, Range] An Integer for fixed length terms, otherwise a Range.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Range] arity as a Range</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">capture?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Node] most nodes have only one child</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">child</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;Node&gt;]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children_nodes</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Array&lt;Node&gt;, nil] replace node with result, or `nil` if no change requested.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># that matches within a Set (e.g. `42`, `:sym` but not `/regexp/`)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] returns true for nodes having a Ruby literal equivalent</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#63</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches_within_set?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Integer] nb of captures that this node will emit</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nb_captures</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># To be overridden by subclasses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] returns whether it matches a variable number of elements</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">variadic?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#73</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">with</span>(<span class="ruby-value">type:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">children:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">location:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Node class for ‘&lt;int str …&gt;` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#179 class RuboCop::AST::NodePattern::Node::AnyOrder &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbidInSeqHead</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ends_with_rest?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">term_nodes</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#182 RuboCop::AST::NodePattern::Node::AnyOrder::ARITIES = T.let(T.unsafe(nil), Hash)</p>

<p># Node class for ‘$something` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#96 class RuboCop::AST::NodePattern::Node::Capture &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">capture?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#108</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nb_captures</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest?</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#85 module RuboCop::AST::NodePattern::Node::ForbidInSeqHead</p>

<pre class="ruby"><span class="ruby-comment"># @raise [NodePattern::Invalid]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#139 RuboCop::AST::NodePattern::Node::FunctionCall = RuboCop::AST::NodePattern::Node::Predicate</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#81 RuboCop::AST::NodePattern::Node::INT_TO_RANGE = T.let(T.unsafe(nil), Hash)</p>

<p># Registry # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#255 RuboCop::AST::NodePattern::Node::MAP = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#11 RuboCop::AST::NodePattern::Node::MATCHES_WITHIN_SET = T.let(T.unsafe(nil), Set)</p>

<p># Node class for ‘predicate?(:arg, :list)` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#130 class RuboCop::AST::NodePattern::Node::Predicate &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arg_list</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">method_name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Node class for ‘int+` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#142 class RuboCop::AST::NodePattern::Node::Repetition &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbidInSeqHead</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#149 RuboCop::AST::NodePattern::Node::Repetition::ARITIES = T.let(T.unsafe(nil), Hash)</p>

<p># Node class for ‘…` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#161 class RuboCop::AST::NodePattern::Node::Rest &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#173</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#162 RuboCop::AST::NodePattern::Node::Rest::ARITY = T.let(T.unsafe(nil), Range)</p>

<p># Node class for ‘(type first second …)` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#117 class RuboCop::AST::NodePattern::Node::Sequence &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbidInSeqHead</span>

<span class="ruby-comment"># @return [Sequence] a new instance of Sequence</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">children</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-identifier">properties</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A list (potentially empty) of nodes; part of a Union # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#205 class RuboCop::AST::NodePattern::Node::Subsequence &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NodePattern</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span><span class="ruby-operator">::</span><span class="ruby-constant">ForbidInSeqHead</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Node class for ‘{ … }` # # source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#223 class RuboCop::AST::NodePattern::Node::Union &lt; ::RuboCop::AST::NodePattern::Node</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arity</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#231</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">in_sequence_head</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Each child in a union must contain the same number</span>
<span class="ruby-comment"># of captures. Only one branch ends up capturing.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/node.rb#249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nb_captures</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Parser for NodePattern # Note: class reopened in ‘parser.racc` # # Doc on how this fits in the compiling process: #   /docs/modules/ROOT/pages/node_pattern.adoc # # source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#12 class RuboCop::AST::NodePattern::Parser &lt; ::Racc::Parser</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">SimpleForwardable</span>

<span class="ruby-comment"># @return [Parser] a new instance of Parser</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">builder</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_10</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#339</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_11</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># reduce 12 omitted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_13</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#349</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_14</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_15</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#357</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_16</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#361</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_17</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#365</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_18</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#369</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_19</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># reduce 1 omitted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#303</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_2</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#373</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_20</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_21</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_22</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># reduce 24 omitted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#389</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_25</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#395</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_26</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#307</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_3</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># reduce 32 omitted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#415</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_33</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># reduce 36 omitted</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#425</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_37</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#429</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_38</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#433</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_39</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#311</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_4</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#437</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_40</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#441</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_41</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#445</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_42</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_43</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#453</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_44</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#457</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_45</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#461</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_46</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#315</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_5</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#319</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_6</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#323</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_7</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#327</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_8</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_9</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#465</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">_reduce_none</span>(<span class="ruby-identifier">val</span>, <span class="ruby-identifier">_values</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_atom</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_call</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_capture</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_list</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_unary_op</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_union</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inspect</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">next_token</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">_arg0</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_arg1</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">_arg2</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># (Similar API to `parser` gem)</span>
<span class="ruby-comment"># Parses a source and returns the AST.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param source_buffer [Parser::Source::Buffer, String] The source buffer to parse.</span>
<span class="ruby-comment"># @return [NodePattern::Node]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">source</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @raise [NodePattern::Invalid]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">enforce_unary</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Overrides Racc::Parser&#39;s method:</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @raise [NodePattern::Invalid]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#59</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_error</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">_vstack</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#16 RuboCop::AST::NodePattern::Parser::Builder = RuboCop::AST::NodePattern::Builder</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.rb#17 RuboCop::AST::NodePattern::Parser::Lexer = RuboCop::AST::NodePattern::Lexer</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#227 RuboCop::AST::NodePattern::Parser::Racc_arg = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#295 RuboCop::AST::NodePattern::Parser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/parser.racc.rb#244 RuboCop::AST::NodePattern::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)</p>

<p># Overrides Parser to use ‘WithMeta` variants and provide additional methods # # source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#8 class RuboCop::AST::NodePattern::Parser::WithMeta &lt; ::RuboCop::AST::NodePattern::Parser</p>

<pre class="ruby"><span class="ruby-comment"># Returns the value of attribute comments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_parse</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute tokens.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Overrides Builder to emit nodes with locations # # source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#39 class RuboCop::AST::NodePattern::Parser::WithMeta::Builder &lt; ::RuboCop::AST::NodePattern::Builder</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_atom</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#61</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_call</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">selector_t</span>, <span class="ruby-identifier">args</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#55</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_list</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">begin_t</span>, <span class="ruby-identifier">children</span>, <span class="ruby-identifier">end_t</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_unary_op</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">operator_t</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-operator">*</span><span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#81</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">join_exprs</span>(<span class="ruby-identifier">left_expr</span>, <span class="ruby-identifier">right_expr</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">loc</span>(<span class="ruby-identifier">token_or_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">n</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">children</span>, <span class="ruby-identifier">source_map</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_map</span>(<span class="ruby-identifier">token_or_range</span>, <span class="ruby-value">begin_t:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">end_t:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">operator_t:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">selector_t:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Overrides Lexer to token locations and comments # # source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#10 class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer &lt; ::RuboCop::AST::NodePattern::Lexer</p>

<pre class="ruby"><span class="ruby-comment"># @return [Lexer] a new instance of Lexer</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">str_or_buffer</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">emit_comment</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [::Parser::Source::Range] last match&#39;s position</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute source_buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/with_meta.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">token</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">value</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Utility to assign a set of values to a constant # # source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#7 module RuboCop::AST::NodePattern::Sets</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#31</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">set</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#15</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>(<span class="ruby-identifier">set</span>); <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#22</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">uniq</span>(<span class="ruby-identifier">name</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#14 RuboCop::AST::NodePattern::Sets::MAX = T.let(T.unsafe(nil), Integer)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#8 RuboCop::AST::NodePattern::Sets::REGISTRY = T.let(T.unsafe(nil), Hash)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_0_1 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_10_10 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_1_1 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_AFTER_ACTION_APPEND_AFTER_ACTION_APPEND_AROUND_ACTION_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ANY_EMPTY_NONE_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_AP_P_PP_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ARRAY_HASH = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_BELONGS_TO_HAS_ONE_HAS_MANY_HAS_AND_BELONGS_TO_MANY = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_BINWRITE_SYSWRITE_WRITE_WRITE_NONBLOCK = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_BRANCH_REF_TAG = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CHANGE_COLUMN_EXECUTE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CIPHER_DIGEST = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CLASS_EVAL_INSTANCE_EVAL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CLASS_EVAL_MODULE_EVAL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CLASS_MODULE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CLASS_MODULE_STRUCT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CLONE_DUP_FREEZE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_COUNT_LENGTH_SIZE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CREATED_AT_UPDATED_AT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_CREATED_AT_UPDATED_AT_2 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_EACH_WITH_INDEX_WITH_INDEX = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_EACH_WITH_OBJECT_WITH_OBJECT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ESCAPE_ENCODE_UNESCAPE_DECODE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_EXIST_EXISTS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FILETEST_FILE_DIR_SHELL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FILE_DIR = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FILE_FILETEST = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FILE_TEMPFILE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FILE_TEMPFILE_STRINGIO = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FIRST_LAST__ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FIXNUM_BIGNUM = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_FORMAT_SPRINTF_PRINTF = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_GETHOSTBYADDR_GETHOSTBYNAME = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_GET_POST_PUT_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_GSUB_GSUB = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_HAS_MANY_HAS_ONE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_HAS_MANY_HAS_ONE_BELONGS_TO = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_HEAD_ASSERT_RESPONSE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_HTML_HTML5 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_IF_UNLESS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_INCLUDE_EXTEND_PREPEND = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_INSERT_INSERT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_INTEGER_BIGDECIMAL_COMPLEX_RATIONAL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_IO_FILE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_KEYS_VALUES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_KEYS_VALUES_TO_H_TO_XML = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_KEY_HAS_KEY_FETCH_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_LAST_FIRST = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_LENGTH_SIZE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_LOAD_RESTORE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_MAP_COLLECT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_MAP_FILTER_MAP = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_MESSAGES_DETAILS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_MODULE_FUNCTION_RUBY2_KEYWORDS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_NEW_ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_NEW_COMPILE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_NEW_OPEN = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_NIL_ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_NOTICE_ALERT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ONLY_EXCEPT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_PRIVATE_PROTECTED_PRIVATE_CLASS_METHOD = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_PRIVATE_PROTECTED_PUBLIC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_RAISE_FAIL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_RAISE_FAIL_THROW_ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_READ_BINREAD = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_REDUCE_INJECT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_REFERER_REFERRER = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_REJECT_DELETE_IF = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_REJECT_REJECT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_RENDER_REDIRECT_TO = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_REQUIRE_REQUIRE_RELATIVE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_RETURNING_UNIQUE_BY = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ROOT_PUBLIC_PATH = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SELECT_FILTER_FIND_ALL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SELECT_FILTER_KEEP_IF = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SELECT_SELECT_FILTER_FILTER = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SEND_PUBLIC_SEND___SEND__ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SET_SORTEDSET = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SKIP_AFTER_ACTION_SKIP_AROUND_ACTION_SKIP_BEFORE_ACTION_SKIP_ACTION_CALLBACK = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SORT_BY_SORT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SPAWN_SYSTEM = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SPRINTF_FORMAT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_STDOUT_STDERR = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_STRUCT_CLASS = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_SUCC_PRED_NEXT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TIME_DATETIME = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TO_ENUM_ENUM_FOR = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TO_H_TO_HASH = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TO_I_TO_F_TO_C_TO_R = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TRANSLATE_LOCALIZE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TRANSLATE_T = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TRUE_FALSE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_TRY_TRY = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_T_TRANSLATE_L_LOCALIZE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_WHERE_NOT = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_ZERO_POSITIVE_NEGATIVE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__AT_SLICE = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__EQUAL_EQL = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__FETCH = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__GLOB = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET__PUSH_APPEND = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___2 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___3 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___4 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___5 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___6 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___7 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___8 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET___METHOD__<em>_</em>CALLEE__ = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_<em>_</em> = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET____2 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET____ETC = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET____ETC_2 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET____ETC_3 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET____ETC_4 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern/sets.rb#10 RuboCop::AST::NodePattern::Sets::SET_____2 = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node_pattern.rb#55 RuboCop::AST::NodePattern::VAR = T.let(T.unsafe(nil), String)</p>

<p># Common functionality for primitive numeric nodes: ‘int`, `float`, `rational`… # # source://rubocop-ast//lib/rubocop/ast/node/mixin/numeric_node.rb#6 module RuboCop::AST::NumericNode</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether this is literal has a sign.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @example</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment">#   +42</span>
<span class="ruby-comment"># @return [Boolean] whether this literal has a sign.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/numeric_node.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sign?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/numeric_node.rb#7 RuboCop::AST::NumericNode::SIGN_REGEX = T.let(T.unsafe(nil), Regexp)</p>

<p># A node extension for ‘op_asgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#8 class RuboCop::AST::OpAsgnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># @return [AsgnNode] the assignment node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">assignment_node</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">expression</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [AsgnNode] the assignment node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lhs</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The name of the variable being assigned as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the name of the variable being assigned</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The operator being used for assignment as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the assignment operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The expression being assigned to the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the expression being assigned.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/op_asgn_node.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rhs</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘op_asgn` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/or_asgn_node.rb#8 class RuboCop::AST::OrAsgnNode &lt; ::RuboCop::AST::OpAsgnNode</p>

<pre class="ruby"><span class="ruby-comment"># The operator being used for assignment as a symbol.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol] the assignment operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/or_asgn_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘or` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `or` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/or_node.rb#8 class RuboCop::AST::OrNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BinaryOperatorNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">PredicateOperatorNode</span>

<span class="ruby-comment"># Returns the alternate operator of the `or` as a string.</span>
<span class="ruby-comment"># Returns `or` for `||` and vice versa.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the alternate of the `or` operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/or_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">alternate_operator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse keyword of the `or` node as a string.</span>
<span class="ruby-comment"># Returns `and` for `or` and `&amp;&amp;` for `||`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the inverse of the `or` operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/or_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_operator</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘pair` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `pair` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#8 class RuboCop::AST::PairNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">HashElementNode</span>

<span class="ruby-comment"># Checks whether the `pair` uses a colon delimiter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this `pair` uses a colon delimiter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">colon?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the delimiter of the `pair` as a string. Returns `=&gt;` for a</span>
<span class="ruby-comment"># colon delimited `pair` and `:` for a hash rocket delimited `pair`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param with_spacing [Boolean] whether to include spacing</span>
<span class="ruby-comment"># @return [String] the delimiter of the `pair`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">deprecated</span>, <span class="ruby-value">with_spacing:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `pair` uses a hash rocket delimiter.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this `pair` uses a hash rocket delimiter</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash_rocket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse delimiter of the `pair` as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @param with_spacing [Boolean] whether to include spacing</span>
<span class="ruby-comment"># @return [String] the inverse delimiter of the `pair`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_delimiter</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">deprecated</span>, <span class="ruby-value">with_spacing:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `pair` uses hash value omission.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this `pair` uses hash value omission</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_omission?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the value starts on its own line.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the value in the `pair` starts its own line</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value_on_new_line?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#15 RuboCop::AST::PairNode::COLON = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#11 RuboCop::AST::PairNode::HASH_ROCKET = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#17 RuboCop::AST::PairNode::SPACED_COLON = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/pair_node.rb#13 RuboCop::AST::PairNode::SPACED_HASH_ROCKET = T.let(T.unsafe(nil), String)</p>

<p># Requires implementing ‘arguments`. # # Common functionality for nodes that are parameterized: # `send`, `super`, `zsuper`, `def`, `defs` # and (modern only): `index`, `indexasgn`, `lambda` # # source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#10 module RuboCop::AST::ParameterizedNode</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether this node has any arguments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this node has any arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Whether the last argument of the node is a block pass,</span>
<span class="ruby-comment"># i.e. `&amp;block`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the last argument of the node is a block pass</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">block_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the first argument of the node.</span>
<span class="ruby-comment"># Equivalent to `arguments.first`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the first argument of the node,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the last argument of the node.</span>
<span class="ruby-comment"># Equivalent to `arguments.last`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the last argument of the node,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node&#39;s arguments are wrapped in parentheses.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this node&#39;s arguments are</span>
<span class="ruby-comment">#   wrapped in parentheses</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parenthesized?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether any argument of the node is a splat</span>
<span class="ruby-comment"># argument, i.e. `*splat`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is a splat argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rest_argument?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether any argument of the node is a splat</span>
<span class="ruby-comment"># argument, i.e. `*splat`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the node is a splat argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">splat_argument?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A specialized ‘ParameterizedNode`. # Requires implementing `first_argument_index` # Implements `arguments` as `<a href="first_argument_index..-1">children</a>` # and optimizes other calls # # source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#83 module RuboCop::AST::ParameterizedNode::RestArguments</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>

<span class="ruby-comment"># @return [Array&lt;Node&gt;] arguments, if any</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#89</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this node has any arguments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this node has any arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#119</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the first argument of the node.</span>
<span class="ruby-comment"># Equivalent to `arguments.first`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the first argument of the node,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># A shorthand for getting the last argument of the node.</span>
<span class="ruby-comment"># Equivalent to `arguments.last`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the last argument of the node,</span>
<span class="ruby-comment">#   or `nil` if there are no arguments</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_argument</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#86 RuboCop::AST::ParameterizedNode::RestArguments::EMPTY_ARGUMENTS = T.let(T.unsafe(nil), Array)</p>

<p># A specialized ‘ParameterizedNode` for node that have a single child # containing either `nil`, an argument, or a `begin` node with all the # arguments # # source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#66 module RuboCop::AST::ParameterizedNode::WrappedArguments</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>

<span class="ruby-comment"># @return [Array] The arguments of the node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/parameterized_node.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># Common functionality for nodes that are predicates: # ‘or`, `and` … # # source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#7 module RuboCop::AST::PredicateOperatorNode</p>

<pre class="ruby"><span class="ruby-comment"># Checks whether this is a logical operator.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this is a logical operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">logical_operator?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the operator as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">operator</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this is a semantic operator.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether this is a semantic operator</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#39</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semantic_operator?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#8 RuboCop::AST::PredicateOperatorNode::LOGICAL_AND = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#17 RuboCop::AST::PredicateOperatorNode::LOGICAL_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#12 RuboCop::AST::PredicateOperatorNode::LOGICAL_OR = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#10 RuboCop::AST::PredicateOperatorNode::SEMANTIC_AND = T.let(T.unsafe(nil), String)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#19 RuboCop::AST::PredicateOperatorNode::SEMANTIC_OPERATORS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/mixin/predicate_operator_node.rb#14 RuboCop::AST::PredicateOperatorNode::SEMANTIC_OR = T.let(T.unsafe(nil), String)</p>

<p># A ‘Prism` interface’s class that provides a fixed ‘Prism::ParseLexResult` instead of parsing. # # This class implements the `parse_lex` method to return a preparsed `Prism::ParseLexResult` # rather than parsing the source code.  When the parse result is already available externally, # such as in Ruby LSP, the Prism parsing process can be bypassed. # # source://rubocop-ast//lib/rubocop/ast/processed_source.rb#12 class RuboCop::AST::PrismPreparsed</p>

<pre class="ruby"><span class="ruby-comment"># @return [PrismPreparsed] a new instance of PrismPreparsed</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">prism_result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse_lex</span>(<span class="ruby-identifier">_source</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">_prism_options</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘procarg0` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all `arg` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/procarg0_node.rb#8 class RuboCop::AST::Procarg0Node &lt; ::RuboCop::AST::ArgNode</p>

<pre class="ruby"><span class="ruby-comment"># Returns the name of an argument.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Symbol, nil] the name of the argument</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/procarg0_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># ProcessedSource contains objects which are generated by Parser # and other information such as disabled lines for cops. # It also provides a convenient way to access source lines. # # source://rubocop-ast//lib/rubocop/ast/processed_source.rb#31 class RuboCop::AST::ProcessedSource</p>

<pre class="ruby"><span class="ruby-comment"># @return [ProcessedSource] a new instance of ProcessedSource</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">ruby_version</span>, <span class="ruby-identifier">path</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">parser_engine:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">prism_result:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute ast.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ast</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ast_with_comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">blank?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute buffer.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">buffer</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Raw source checksum for tracking infinite loops.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">checksum</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Comment, nil] the comment at that line, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_at_line</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Consider using `each_comment_in_lines` instead</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @deprecated use contains_comment?</span>
<span class="ruby-comment"># @return [Boolean] if any of the lines in the given `source_range` has a comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">commented?</span>(<span class="ruby-identifier">source_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute comments.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Should have been called `comments_before_or_at_line`. Doubtful it has of any valid use.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @deprecated Use `each_comment_in_lines`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comments_before_line</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Consider using `each_comment_in_lines` instead</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] if any of the lines in the given `source_range` has a comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">contains_comment?</span>(<span class="ruby-identifier">source_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#179</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">current_line</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute diagnostics.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">diagnostics</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `comments.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#107</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_comment</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Enumerates on the comments contained with the given `line_range`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_comment_in_lines</span>(<span class="ruby-identifier">line_range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `tokens.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_token</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">file_path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `comment_at_line`, `each_comment_in_lines`, or `comments.find`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#112</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_comment</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `tokens.find`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">find_token</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#200</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_token_of</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">following_line</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_token_of</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#187</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_indentation</span>(<span class="ruby-identifier">line_number</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean] if the given line number has a comment.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#140</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line_with_comment?</span>(<span class="ruby-identifier">line</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the source lines, line break characters removed, excluding a</span>
<span class="ruby-comment"># possible __END__ and everything that comes after.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lines</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute parser_engine.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_engine</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute parser_error.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_error</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute path.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">path</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">preceding_line</span>(<span class="ruby-identifier">token</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute raw_source.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">raw_source</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute ruby_version.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ruby_version</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The tokens list is always sorted by token position, except for cases when heredoc</span>
<span class="ruby-comment"># is passed as a method argument. In this case tokens are interleaved by</span>
<span class="ruby-comment"># heredoc contents&#39; tokens.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#211</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">sorted_tokens</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">start_with?</span>(<span class="ruby-identifier">string</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute tokens.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokens_within</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#95</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">valid_syntax?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">builder_class</span>(<span class="ruby-identifier">parser_engine</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#339</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">create_parser</span>(<span class="ruby-identifier">ruby_version</span>, <span class="ruby-identifier">parser_engine</span>, <span class="ruby-identifier">prism_result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The Parser gem does not support Ruby 3.5 or later.</span>
<span class="ruby-comment"># It is also not fully compatible with Ruby 3.4 but for</span>
<span class="ruby-comment"># now respects using parser for backwards compatibility.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_parser_engine</span>(<span class="ruby-identifier">ruby_version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#393</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_token_index</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#398</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">last_token_index</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#368</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">normalize_parser_engine</span>(<span class="ruby-identifier">parser_engine</span>, <span class="ruby-identifier">ruby_version</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">ruby_version</span>, <span class="ruby-identifier">parser_engine</span>, <span class="ruby-identifier">prism_result</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#260</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parser_class</span>(<span class="ruby-identifier">ruby_version</span>, <span class="ruby-identifier">parser_engine</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#403</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">source_range</span>(<span class="ruby-identifier">range_or_node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tokenize</span>(<span class="ruby-identifier">parser</span>); <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#44</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_file</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">ruby_version</span>, <span class="ruby-value">parser_engine:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#35 RuboCop::AST::ProcessedSource::INVALID_LEVELS = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/processed_source.rb#38 RuboCop::AST::ProcessedSource::PARSER_ENGINES = T.let(T.unsafe(nil), Array)</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/processed_source.rb#33 RuboCop::AST::ProcessedSource::STRING_SOURCE_NAME = T.let(T.unsafe(nil), String)</p>

<p># A node extension for ‘irange` and `erange` nodes. This will be used in # place of a plain node when the builder constructs the AST, making its # methods available to all `irange` and `erange` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/range_node.rb#8 class RuboCop::AST::RangeNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/range_node.rb#9</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">begin</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/range_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">end</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘rational` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available to # all `rational` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/rational_node.rb#8 class RuboCop::AST::RationalNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BasicLiteralNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">NumericNode</span>
</pre>

<p>end</p>

<p># A node extension for ‘regexp` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `regexp` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#8 class RuboCop::AST::RegexpNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># @return [String] a string of regexp content</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">content</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if char is one of the delimiters</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#57</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiter?</span>(<span class="ruby-identifier">char</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [String] the regexp delimiters (without %r)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#52</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delimiters</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the extended regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">extended?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the fixed-encoding regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fixed_encoding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the ignore-case regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ignore_case?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp contains interpolation</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">interpolation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the multiline regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#67</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">multiline_mode?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the no-encoding regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">no_encoding?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># NOTE: The &#39;o&#39; option is ignored.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] the Regexp option bits as returned by Regexp#options</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">options</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if the regexp is a %r{...} literal (using any delimiters)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_r_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [RuboCop::AST::Node] a regopt node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regopt</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if regexp uses the single-interpolation regopt</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_interpolation?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Bool] if the regexp is a /.../ literal</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">slash_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Regexp] a regexp of this node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_regexp</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regopt_include?</span>(<span class="ruby-identifier">option</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/regexp_node.rb#9 RuboCop::AST::RegexpNode::OPTIONS = T.let(T.unsafe(nil), Hash)</p>

<p># A node extension for ‘resbody` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `resbody` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/resbody_node.rb#8 class RuboCop::AST::ResbodyNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `rescue` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The body of the `resbody`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/resbody_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the index of the `resbody` branch within the exception handling statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] the index of the `resbody` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/resbody_node.rb#40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the exception variable of the `rescue` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The exception variable of the `resbody`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/resbody_node.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exception_variable</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the exceptions in the `rescue` clause.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of exception nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/resbody_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exceptions</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘rescue` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `rescue` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#8 class RuboCop::AST::RescueNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the rescue node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] The body of the rescue node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the rescue branches in the exception handling statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># and the else (if any). Note that these bodies could be nil.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node, nil&gt;] an array of the bodies of the rescue branches</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#27</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branches</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether this exception handling statement has an `else` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the exception handling statement has an `else` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the else branch of the exception handling statement, if any.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the else branch node of the exception handling statement</span>
<span class="ruby-comment"># @return [nil] if the exception handling statement does not have an else branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">else_branch</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the rescue branches in the exception handling statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;ResbodyNode&gt;] an array of `resbody` nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/rescue_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">resbody_branches</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘return` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `return` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/return_node.rb#8 class RuboCop::AST::ReturnNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">WrappedArguments</span>
</pre>

<p>end</p>

<p># Responsible for compatibility with main gem # # @api private # # source://rubocop-ast//lib/rubocop/ast/rubocop_compatibility.rb#8 module RuboCop::AST::RuboCopCompatibility</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/rubocop_compatibility.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rubocop_loaded</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/rubocop_compatibility.rb#9 RuboCop::AST::RuboCopCompatibility::INCOMPATIBLE_COPS = T.let(T.unsafe(nil), Hash)</p>

<p># A node extension for ‘sclass` nodes. This will be used in place of a # plain node when the builder constructs the AST, making its methods # available to all `sclass` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/self_class_node.rb#8 class RuboCop::AST::SelfClassNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># The body of this `sclass` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the class</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/self_class_node.rb#19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># The identifier for this `sclass` node. (Always `self`.)</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node] the identifier of the class</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/self_class_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">identifier</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘send` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `send` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/send_node.rb#8 class RuboCop::AST::SendNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span><span class="ruby-operator">::</span><span class="ruby-constant">RestArguments</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/send_node.rb#13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attribute_accessor?</span>(<span class="ruby-identifier">param0</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/send_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">send_type?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-identifier">private</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/send_node.rb#24</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">first_argument_index</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># This module provides a shorthand method to create a {Node} like # ‘Parser::AST::Sexp`. # # @see <a href="https://www.rubydoc.info/gems/ast/AST/Sexp">www.rubydoc.info/gems/ast/AST/Sexp</a> # # source://rubocop-ast//lib/rubocop/ast/sexp.rb#9 module RuboCop::AST::Sexp</p>

<pre class="ruby"><span class="ruby-comment"># Creates a {Node} with type `type` and children `children`.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/sexp.rb#11</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">s</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">children</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘str`, `dstr`, and `xstr` nodes. This will be used # in place of a plain node when the builder constructs the AST, making # its methods available to all `str` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#8 class RuboCop::AST::StrNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BasicLiteralNode</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#26</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">character_literal?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#22</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">double_quoted?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">heredoc?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the string literal is delimited by percent brackets.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @overload percent_literal?</span>
<span class="ruby-comment"># @overload percent_literal?</span>
<span class="ruby-comment"># @param type [Symbol] an optional percent literal type</span>
<span class="ruby-comment"># @return [Boolean] whether the string is enclosed in percent brackets</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#45</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">percent_literal?</span>(<span class="ruby-identifier">type</span> = <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">single_quoted?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/node/str_node.rb#11 RuboCop::AST::StrNode::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Hash)</p>

<p># A node extension for ‘super`- and `zsuper` nodes. This will be used in # place of a plain node when the builder constructs the AST, making its # methods available to all `super`- and `zsuper` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/super_node.rb#8 class RuboCop::AST::SuperNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/super_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Custom destructuring method. This can be used to normalize</span>
<span class="ruby-comment"># destructuring for different variations of the node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the different parts of the `super` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/super_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘sym` nodes. This will be used in  place of a # plain node when the builder constructs the AST, making its methods # available to all `sym` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/symbol_node.rb#8 class RuboCop::AST::SymbolNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">BasicLiteralNode</span>
</pre>

<p>end</p>

<p># A basic wrapper around Parser’s tokens. # # source://rubocop-ast//lib/rubocop/ast/token.rb#6 class RuboCop::AST::Token</p>

<pre class="ruby"><span class="ruby-comment"># @return [Token] a new instance of Token</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#18</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">pos</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">text</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#33</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">begin_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#29</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">column</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comma?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Type Predicates</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">dot?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#37</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">end_pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#122</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">equal_sign?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_array_bracket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_brace?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#74</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_bracket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#86</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_curly_brace?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#94</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_parens?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">left_ref_bracket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#25</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">line</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">new_line?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute pos.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">pos</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#110</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">regexp_dots?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">rescue_modifier?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_bracket?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#90</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_curly_brace?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#98</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">right_parens?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#62</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">semicolon?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if there is whitespace after token</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_after?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks if there is whitespace before token</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean]</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#51</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">space_before?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute text.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the value of attribute type.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">type</span>; <span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
  <span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/token.rb#12</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">from_parser_token</span>(<span class="ruby-identifier">parser_token</span>); <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/token.rb#8 RuboCop::AST::Token::LEFT_CURLY_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># source://rubocop-ast//lib/rubocop/ast/token.rb#7 RuboCop::AST::Token::LEFT_PAREN_TYPES = T.let(T.unsafe(nil), Array)</p>

<p># Provides methods for traversing an AST. # Does not transform an AST; for that, use Parser::AST::Processor. # Override methods to perform custom processing. Remember to call ‘super` # if you want to recursively process descendant nodes. # # source://rubocop-ast//lib/rubocop/ast/traversal.rb#9 module RuboCop::AST::Traversal</p>

<pre class="ruby"><span class="ruby-identifier">extend</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">Traversal</span><span class="ruby-operator">::</span><span class="ruby-constant">CallbackCompiler</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___ENCODING__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___FILE__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on___LINE__</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_alias</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_and_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_arg_expr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_array_pattern_with_tail</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_back_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_begin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_block_pass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_blockarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_break</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_case_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_casgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cbase</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_class</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_complex</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_const_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_csend</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_cvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_def</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defined?</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_defs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_dsym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_eflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_empty_else</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ensure</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_erange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_false</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_find_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_float</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_for</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forward_arg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forward_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_args</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_kwrestarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_forwarded_restarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_gvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_hash_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_if_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_iflipflop</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_match</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_in_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_index</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_indexasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_int</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_irange</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_itblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_ivasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwargs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwbegin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwnilarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwoptarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwrestarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_kwsplat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lambda</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvar</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_masgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_alt</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_as</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_current_line</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_nil_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_pattern_p</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_rest</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_var</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_with_lvasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_match_with_trailing_comma</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_mlhs</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_module</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_mrasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_next</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nil</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_not</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_nth_ref</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_numblock</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_op_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_optarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_or_asgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pair</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_pin</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_postexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_preexe</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_procarg0</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rasgn</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rational</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_redo</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regexp</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_regopt</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_resbody</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_rescue</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_restarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_retry</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_return</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sclass</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_self</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_send</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_shadowarg</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_splat</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_str</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_super</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_sym</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_true</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_undef</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_unless_guard</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_until_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_when</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#43</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_while_post</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_xstr</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_yield</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#50</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">on_zsuper</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">walk</span>(<span class="ruby-identifier">node</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/traversal.rb#25 module RuboCop::AST::Traversal::CallbackCompiler</p>

<pre class="ruby"><span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>(<span class="ruby-identifier">child_node_types</span>, <span class="ruby-identifier">expected_children_count</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children_count_check_code</span>(<span class="ruby-identifier">range</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @api private</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/traversal.rb#38</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_callback</span>(<span class="ruby-identifier">type</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">child_node_types</span>, <span class="ruby-value">expected_children_count:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>), <span class="ruby-value">body:</span> <span class="ruby-constant">T</span>.<span class="ruby-identifier">unsafe</span>(<span class="ruby-keyword">nil</span>)); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># @api private # # source://rubocop-ast//lib/rubocop/ast/traversal.rb#26 RuboCop::AST::Traversal::CallbackCompiler::SEND = T.let(T.unsafe(nil), String)</p>

<p># How a particular child node should be visited. For example, if a child node # can be nil it should be guarded behind a nil check. Or, if a child node is a literal # (like a symbol) then the literal itself should not be visited. # # @api private # # source://rubocop-ast//lib/rubocop/ast/traversal.rb#32 RuboCop::AST::Traversal::CallbackCompiler::TEMPLATE = T.let(T.unsafe(nil), Hash)</p>

<p># Only for debugging. # # @api private # # source://rubocop-ast//lib/rubocop/ast/traversal.rb#12 class RuboCop::AST::Traversal::DebugError &lt; ::RuntimeError; end</p>

<p># source://rubocop-ast//lib/rubocop/ast/traversal.rb#109 RuboCop::AST::Traversal::NO_CHILD_NODES = T.let(T.unsafe(nil), Set)</p>

<p># source://rubocop-ast//lib/rubocop/ast/traversal.rb#15 RuboCop::AST::Traversal::TYPE_TO_METHOD = T.let(T.unsafe(nil), Hash)</p>

<p># A node extension for ‘until` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `until` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/until_node.rb#8 class RuboCop::AST::UntilNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ModifierNode</span>

<span class="ruby-comment"># Checks whether the `until` node has a `do` keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `until` node has a `do` keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/until_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse keyword of the `until` node as a string.</span>
<span class="ruby-comment"># Returns `while` for `until` nodes and vice versa.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the inverse keyword of the `until` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/until_node.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `until` statement as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `until` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/until_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘lvar`, `ivar`, `cvar` and `gvar` nodes. # This will be used in place of a plain node when the builder constructs # the AST, making its methods available to all assignment nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/var_node.rb#8 class RuboCop::AST::VarNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># @return [Symbol] The name of the variable.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/var_node.rb#10</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">name</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># source://rubocop-ast//lib/rubocop/ast/version.rb#5 module RuboCop::AST::Version; end</p>

<p># source://rubocop-ast//lib/rubocop/ast/version.rb#6 RuboCop::AST::Version::STRING = T.let(T.unsafe(nil), String)</p>

<p># A node extension for ‘when` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `when` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#8 class RuboCop::AST::WhenNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-comment"># Returns the body of the `when` node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Node, nil] the body of the `when` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#42</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">body</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the index of the `when` branch within the `case` statement.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Integer] the index of the `when` branch</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">branch_index</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns an array of all the conditions in the `when` branch.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array&lt;Node&gt;] an array of condition nodes</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#12</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">conditions</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># @deprecated Use `conditions.each`</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#17</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each_condition</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>); <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Checks whether the `when` node has a `then` keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `when` node has a `then` keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/when_node.rb#35</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">then?</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘while` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `while` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/while_node.rb#8 class RuboCop::AST::WhileNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ConditionalNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ModifierNode</span>

<span class="ruby-comment"># Checks whether the `until` node has a `do` keyword.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Boolean] whether the `until` node has a `do` keyword</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/while_node.rb#30</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do?</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the inverse keyword of the `while` node as a string.</span>
<span class="ruby-comment"># Returns `until` for `while` nodes and vice versa.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the inverse keyword of the `while` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/while_node.rb#23</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inverse_keyword</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Returns the keyword of the `while` statement as a string.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [String] the keyword of the `while` statement</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/while_node.rb#15</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keyword</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p># A node extension for ‘yield` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `yield` nodes within RuboCop. # # source://rubocop-ast//lib/rubocop/ast/node/yield_node.rb#8 class RuboCop::AST::YieldNode &lt; ::RuboCop::AST::Node</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">ParameterizedNode</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodIdentifierPredicates</span>
<span class="ruby-identifier">include</span> <span class="ruby-operator">::</span><span class="ruby-constant">RuboCop</span><span class="ruby-operator">::</span><span class="ruby-constant">AST</span><span class="ruby-operator">::</span><span class="ruby-constant">MethodDispatchNode</span>

<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/yield_node.rb#20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">arguments</span>; <span class="ruby-keyword">end</span>

<span class="ruby-comment"># Custom destructuring method. This can be used to normalize</span>
<span class="ruby-comment"># destructuring for different variations of the node.</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># @return [Array] the different parts of the `send` node</span>
<span class="ruby-comment">#</span>
<span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/node/yield_node.rb#16</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">node_parts</span>; <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

<p>class RuboCop::CommentConfig; end class RuboCop::Config; end class RuboCop::ConfigValidator; end</p>

<p># Similar to ‘Forwardable#def_delegators`, but simpler &amp; faster # # source://rubocop-ast//lib/rubocop/ast/utilities/simple_forwardable.rb#5 module RuboCop::SimpleForwardable</p>

<pre class="ruby"><span class="ruby-comment"># source://rubocop-ast//lib/rubocop/ast/utilities/simple_forwardable.rb#6</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">def_delegators</span>(<span class="ruby-identifier">accessor</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">methods</span>); <span class="ruby-keyword">end</span>
</pre>

<p>end</p>

</main>

